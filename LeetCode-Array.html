<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg"><link rel="icon" href="/img/logo.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#01213a"><meta name="author" content="Wei He"><meta name="keywords" content="Computer Science and Technology, Machine Learning, Deep Learning, Computer Vision, Natural Language Processing"><meta name="baidu-site-verification" content="code-J3wrn8WJYJ"><meta name="google-site-verification" content="0p_KJKTfB8EcahVDp0vYRjVRhHFw1SBWHi15OakKHY0"><meta name="description" content="在 LeetCode 等平台上刷题的笔记，循序渐进，一题多解。本文包含「数组」类型题中的：哈希表、前缀和&#x2F;差分、离散化、排序&#x2F;选择、双指针等。持续更新中。"><meta property="og:type" content="article"><meta property="og:title" content="力扣刷题笔记 #01 数组"><meta property="og:url" content="https://hwcoder.top/LeetCode-Array"><meta property="og:site_name" content="Hwcoder - Life Oriented Programming"><meta property="og:description" content="在 LeetCode 等平台上刷题的笔记，循序渐进，一题多解。本文包含「数组」类型题中的：哈希表、前缀和&#x2F;差分、离散化、排序&#x2F;选择、双指针等。持续更新中。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hwcoder.top/img/home/LeetCode.jpg"><meta property="article:published_time" content="2022-10-02T09:07:27.000Z"><meta property="article:modified_time" content="2023-03-03T14:13:00.000Z"><meta property="article:author" content="Wei He"><meta property="article:tag" content="Algorithm"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://hwcoder.top/img/home/LeetCode.jpg"><title>力扣刷题笔记 #01 数组 | Hwcoder - Life Oriented Programming</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/mac.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"hwcoder.top",root:"/",version:"1.9.0",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h2, h3",placement:"left",visible:"always",icon:"§"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4",collapseDepth:3},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"XGNf4GEnaFLiUijMUvz8HSBF-gzGzoHsz",app_key:"JPeVLcug6EcWdBTpGrDJSdKi",server_url:"https://xgnf4gen.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Hwcoder</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/bg/other.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="力扣刷题笔记 #01 数组"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-10-02 17:07" pubdate>2022年10月2日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 11k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 62 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="算法笔记" id="heading-6caacb5aaee15525d7a2b4768aa79852" role="tab" data-toggle="collapse" href="#collapse-6caacb5aaee15525d7a2b4768aa79852" aria-expanded="true">算法笔记 <span class="list-group-count">(17)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-6caacb5aaee15525d7a2b4768aa79852" role="tabpanel" aria-labelledby="heading-6caacb5aaee15525d7a2b4768aa79852"><div class="category-post-list"></div><div class="category-sub row nomargin-x"><a class="category-subitem list-group-item category-item-action col-10 col-md-11 col-xm-11" title="力扣刷题" id="heading-9ca088cdf0fdc34dd48290c9d13c88b1" role="tab" data-toggle="collapse" href="#collapse-9ca088cdf0fdc34dd48290c9d13c88b1" aria-expanded="true">力扣刷题 <span class="list-group-count">(15)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-9ca088cdf0fdc34dd48290c9d13c88b1" role="tabpanel" aria-labelledby="heading-9ca088cdf0fdc34dd48290c9d13c88b1"><div class="category-post-list"><a href="/LeetCode-Array" title="力扣刷题笔记 #01 数组" class="list-group-item list-group-item-action active"><span class="category-post">力扣刷题笔记 #01 数组</span> </a><a href="/LeetCode-Bitwise" title="力扣刷题笔记 #02 数位&amp;二进制" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #02 数位&amp;二进制</span> </a><a href="/LeetCode-Data-Structure" title="力扣刷题笔记 #03 数据结构" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #03 数据结构</span> </a><a href="/LeetCode-Divide-Conquer" title="力扣刷题笔记 #04 二分&amp;分治" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #04 二分&amp;分治</span> </a><a href="/LeetCode-DP-1" title="力扣刷题笔记 #05-1 一维动态规划" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #05-1 一维动态规划</span> </a><a href="/LeetCode-DP-2" title="力扣刷题笔记 #05-2 二维动态规划" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #05-2 二维动态规划</span> </a><a href="/LeetCode-DP-3" title="力扣刷题笔记 #05-3 复杂动态规划" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #05-3 复杂动态规划</span> </a><a href="/LeetCode-Graph" title="力扣刷题笔记 #06 图论" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #06 图论</span> </a><a href="/LeetCode-Greedy" title="力扣刷题笔记 #07 贪心算法" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #07 贪心算法</span> </a><a href="/LeetCode-LinkList" title="力扣刷题笔记 #08 链表" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #08 链表</span> </a><a href="/LeetCode-Math" title="力扣刷题笔记 #09 数学" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #09 数学</span> </a><a href="/LeetCode-Search" title="力扣刷题笔记 #10 搜索&amp;剪枝" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #10 搜索&amp;剪枝</span> </a><a href="/LeetCode-Stack-Queue" title="力扣刷题笔记 #11 栈&amp;队列" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #11 栈&amp;队列</span> </a><a href="/LeetCode-String" title="力扣刷题笔记 #12 字符串" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #12 字符串</span> </a><a href="/LeetCode-Tree" title="力扣刷题笔记 #13 树" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #13 树</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="算法入门" id="heading-cbb23c60a3cdd7188054b6ba4efbf423" role="tab" data-toggle="collapse" href="#collapse-cbb23c60a3cdd7188054b6ba4efbf423" aria-expanded="false">算法入门 <span class="list-group-count">(2)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-cbb23c60a3cdd7188054b6ba4efbf423" role="tabpanel" aria-labelledby="heading-cbb23c60a3cdd7188054b6ba4efbf423"><div class="category-post-list"><a href="/Algo-Note-1" title="算法入门笔记 #1 杂记" class="list-group-item list-group-item-action"><span class="category-post">算法入门笔记 #1 杂记</span> </a><a href="/Algo-Note-2" title="算法入门笔记 #2 STL标准库" class="list-group-item list-group-item-action"><span class="category-post">算法入门笔记 #2 STL标准库</span></a></div></div></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">力扣刷题笔记 #01 数组</h1><p class="note note-info">本文最后更新于：2023年3月3日 晚上</p><div class="markdown-body"><p>本文包含「数组」类型题中的：哈希表、前缀和/差分、离散化、排序/选择、双指针等技巧。持续更新中。</p><blockquote><p><a href="">题目描述</a>：</p><p><strong>方法1</strong>：</p><p><strong>方法2</strong>：</p><p><strong>方法3</strong>：</p><p><strong>坑点</strong>：</p></blockquote><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="1-两数之和-E"><a href="#1-两数之和-E" class="headerlink" title="1. 两数之和 (E+)"></a>1. 两数之和 (E+)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">题目描述</a>：给定一个数组，在数组中找出两个整数，使两数之和为指定值，并返回<strong>两数下标</strong>。</p><p><strong>方法1</strong>：暴力枚举，两层循环顺序遍历，复杂度 $O(n^2)$。</p><p><strong>方法2</strong>：哈希表，注意到内层循环本质是「<strong>快速查找目标值的索引</strong>」，用哈希表可 $O(1)$ 查找，总复杂度 $O(n)$。</p><p><strong>坑点</strong>：当数组中有两个 key 相同时，如果先建哈希表，则会发生覆盖，然而由于每种输入只会对应一个答案，因此此时这两个 key 就必定是结果。解决方法是<strong>边建表边遍历，每次查找的都是遍历过的值</strong>。</p><h3 id="128-最长连续序列-M"><a href="#128-最长连续序列-M" class="headerlink" title="128. 最长连续序列 (M)"></a>128. 最长连续序列 (M)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence/">题目描述</a>：给定一个无序数组 <code>nums</code>，找出其中<strong>可以组成的最长连续序列</strong>（不要求序列元素在原数组中连续）的长度。</p><p><strong>方法1</strong>：排序，先进行快速排序，再用一个指针扫描数组即可。时间复杂度 $O(n\log n)$。</p><p><strong>方法2</strong>：哈希集合，先将原数组存入哈希集合，既能<strong>去重</strong>又能<strong>快速定位元素</strong>。遍历哈希集合，对每个 $x$ 寻找 $x+1$，直到找到最长序列。为了<strong>防止同一个序列重复判断</strong>，每次先检查 $x-1$ 是否存在，如果<strong>存在则跳过</strong>。时间复杂度 $O(n)$。</p><p><strong>方法3</strong>：哈希表 + 并查集，<strong>维护每个集合的大小</strong>，对于元素 $x$ 合并 $x +1$，并更新最大集合，时间复杂度 $O(n)$。</p><h3 id="169-多数元素-E"><a href="#169-多数元素-E" class="headerlink" title="169. 多数元素 (E)"></a>169. 多数元素 (E)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/majority-element/">题目描述</a>：给定一个大小为 $n$ 的数组，返回其中的<strong>多数元素</strong>，即数组中出现次数<strong>大于</strong> $\lfloor n/2 \rfloor $ 的元素。</p><p><strong>方法1</strong>：哈希表，直接统计每个元素出现的次数，<strong>同时维护</strong>最大值，时间复杂度 $O(n)$，空间复杂度 $O(n)$。</p><p><strong>方法2</strong>：排序，由于众数次数超过了一半，下标为 $\lfloor n/2 \rfloor $ 的元素<strong>一定是众数</strong>。时间复杂度 $O(n\log n)$。</p><p><strong>方法3</strong>：随机选取一个数，遍历检查，如果不是再重新选。期望次数为 $2$，时间复杂度 $O(n)$，空间复杂度 $O(1)$。</p><p><strong>方法4</strong>：<strong>半数投票法</strong>，顺序扫描，假设有一个擂台，$cnt$ 为擂台上的人数。当擂台没人时直接上台；如果有人且是同伙则上台，$cnt+1$；如果不是同伙则打败一个，$cnt-1$。由于<strong>众数超过了一半，最终一定能打败非众数</strong>，最后剩余的就是多数元素。时间复杂度 $O(n)$，空间复杂度 $O(1)$。</p><h3 id="1124-表现良好的最长时间段-M"><a href="#1124-表现良好的最长时间段-M" class="headerlink" title="1124. 表现良好的最长时间段 (M)"></a>1124. 表现良好的最长时间段 (M)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-well-performing-interval/">题目描述</a>：给定一个仅包含 $\pm 1$ 的数组，求解<strong>区间分数和</strong>大于 $0$ 的<strong>最长区间长度</strong>。</p><p><strong>方法1</strong>：前缀和，预处理得到前缀和之后，暴力枚举区间左右端点，时间复杂度 $O(n^2)$，超时。</p><p><strong>方法2</strong>：前缀和<strong>连续性</strong> + 哈希表，<strong>只枚举区间右端点</strong>，此时我们希望找到<strong>最小</strong>的 $l&lt;r$ 满足 $pre[l]&lt;pre[r]$，使用哈希表记录<strong>每一个前缀和第一次出现</strong>的位置，可以优化寻找过程，时间复杂度 $O(n)$。</p><blockquote><p>由于 $pre[0]=0$，所以要根据 $pre[r]$ 是否大于零来讨论：</p><ul><li>如果 $pre[r]&gt;0$，则左端点最小就是 $l=0$，此时的最长长度为 $r+1$。</li><li>如果 $pre[r] \leq 0$，则要在其左边找到满足 $pre[l] = pre[r]-1$ 的位置。为什么是 $-1$ 而<strong>不是更小的数</strong>？因为 $pre[0]=0$，而前缀数组每次只能 $\pm 1$，所以 $pre[r]-1$ 一定比 $pre[r]-2$ <strong>更靠左</strong>！</li></ul></blockquote><p><strong>方法3</strong>：贪心 + 单调队列 + 栈，能成为<strong>最长子数组的左端点</strong>的元素必然构成一个<strong>递减序列</strong>，因为如果来了一个<strong>大于等于栈顶</strong>的元素，则栈顶元素一定能比新元素构成更长的区间。这里单调队列<strong>用栈实现</strong>。因此先<strong>正向遍历</strong>获得单调递减栈，再<strong>反向遍历</strong>枚举<strong>右端点</strong>，每遇到比栈顶更大的元素就更新答案并弹出元素。时间复杂度 $O(n)$。</p><h2 id="前缀和-差分"><a href="#前缀和-差分" class="headerlink" title="前缀和/差分"></a>前缀和/差分</h2><p>前缀和需要 $O(n)$ 构建，此后可以多次 $O(1)$ 查询<strong>区间和</strong>，但不支持单点或区间的快速修改，每次修改需要 $O(n)$。</p><ul><li>这类题目通常要求「<strong>访问、找到、计数</strong>」一个<strong>连续子数组</strong>，并且统计量具有<strong>前缀性质</strong>。</li><li>此外，前缀和还有其他变式：前缀和的模、前缀积、前缀出现次数等。</li></ul><p>差分数组也需要 $O(n)$ 构建，此后可以多次 $O(1)$ 加减<strong>更新区间值</strong>，但最后需要进行一次前缀和才能恢复原始数组。</p><ul><li>这类题目通常要求「<strong>改变、划分</strong>」多个<strong>连续子数组</strong>，并且每次对多个连续元素执行操作。</li><li>如果要求除了加减外的其他操作，则应该考虑单次操作 $O(\log n)$ 的线段树维护。</li></ul><p>有时候需要二维数组的前缀和、差分，用于<strong>求二维数组中给定矩阵区间和</strong>，或者<strong>给矩阵区间的每个值都加上常数</strong>，下面给出常用代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 原始数组 nums 转前缀和数组 pre，pre[i][j] 表示 (i,j) 以外的左上角的矩阵之和</span><br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">pre</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        pre[i][j] = nums[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + pre[i<span class="hljs-number">-1</span>][j] + pre[i][j<span class="hljs-number">-1</span>] - pre[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br><span class="hljs-comment">// 查询左上角为 (x1,y1)，右下角为 (x2,y2) 的矩阵和</span><br>res = pre[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>] - pre[x1][y2+<span class="hljs-number">1</span>] - pre[x2+<span class="hljs-number">1</span>][y1] + pre[x1][y1];<br><br><span class="hljs-comment">// 原始数组 nums 转差分数组 diff, 没有实际意义</span><br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">diff</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        diff[i][j] = nums[i][j] - nums[i<span class="hljs-number">-1</span>][j] - nums[i][j<span class="hljs-number">-1</span>] + nums[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br><span class="hljs-comment">// 对左上角为 (x1,y1)，右下角为 (x2,y2) 的矩阵加上常数 c</span><br>diff[x1][y1] += c;<br>diff[x1][y2+<span class="hljs-number">1</span>] -= c;<br>diff[x2+<span class="hljs-number">1</span>][y1] -= c;<br>diff[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>] += c;<br><br><span class="hljs-comment">// diff 恢复为原始数组，此时 diff 可以迭代更新，再去除首行和首列</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        diff[i][j] += diff[i<span class="hljs-number">-1</span>][j] + diff[i][j<span class="hljs-number">-1</span>] - diff[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br><span class="hljs-comment">// diff 恢复为原始数组，采用另一种方式，得到 n*n 的数组</span><br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(n));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) ans[i][j] = diff[i][j];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) ans[i][j] += ans[i][j - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) ans[i][j] += ans[i - <span class="hljs-number">1</span>][j];<br></code></pre></td></tr></table></figure><h3 id="2406-将区间分为最少组数-M"><a href="#2406-将区间分为最少组数-M" class="headerlink" title="2406. 将区间分为最少组数 (M)"></a>2406. 将区间分为最少组数 (M)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/">题目描述</a>：给定一些整数区间，将其划分为若干区间<strong>组</strong>，使得每组区间都不相交（<strong>区间端点也不能重叠</strong>）。返回最少需要划分的组数。</p><p><strong>方法1</strong>：贪心 + multiset，先按区间起始值排序，在集合中记录<strong>已有区间组的末尾值</strong>，每次新区间加入时在集合中找到<strong>可以插入的最大值</strong>，并更新该值为新区间的末尾值。时间复杂度为 $O(n\log n)$。</p><p><strong>方法2</strong>：优先队列，由于排过序，每次新区间加入时可以直接插入<strong>任意一个可插入的区间</strong>，因为无论选哪个，下一个新区间<strong>面临的选择还是那些</strong>。因此选择已有的<strong>最小末尾值</strong>（最容易插入的），维护最小堆，时间复杂度为 $O(n\log n)$。</p><p><strong>方法3</strong>：差分 + 前缀和，如果有重叠数字则必须分到不同区间组，<strong>最高的重叠次数就是答案</strong>。从前往后枚举，用<strong>差分数组</strong>记录对应每个区间的计数，最后通过<strong>前缀和</strong>还原数组取最值即可。时间复杂度为 $O(N)$，$N$ 为<strong>整数范围</strong>。</p><p><strong>拓展</strong>：本题的另一个问法 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/meeting-rooms-ii">253. 会议室 II</a>，给定 $n$ 个会议的起止时间，计算<strong>至少分配多少间</strong>会议室才能避免会议冲突。</p><h3 id="238-除自身以外数组的乘积-M"><a href="#238-除自身以外数组的乘积-M" class="headerlink" title="238. 除自身以外数组的乘积 (M)"></a>238. 除自身以外数组的乘积 (M)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/product-of-array-except-self/">题目描述</a>：给定一个整数数组 <code>nums</code>，返回另一个答案数组，要求每个位置为 <code>nums</code> 中除 <code>nums[i]</code> 外<strong>其余各元素</strong>的乘积。保证不会溢出，<strong>禁止使用除法</strong>。</p><p><strong>方法1</strong>：尝试使用除法，直接计算所有元素的乘积再除以对应位置的值，但在数组中有<strong>零元素</strong>时会出错，需要特判。</p><p><strong>方法2</strong>：前后缀乘积，预处理出两个前后缀数组，每个位置直接算出答案。时空复杂度均为 $O(n)$。</p><p><strong>方法3</strong>：前后缀 + 在线计算，正向遍历时用 $L$ 维护下标 $[0,i]$ 的<strong>前缀乘积</strong>并放入答案数组，反向遍历时用 $R$ 维护 $[n-1-i,n-1]$ 的<strong>后缀乘积</strong>更新答案数组。空间复杂度优化到 $O(1)$，也可以只用一次遍历完成。</p><hr><p>以下为「<strong>前缀和 + 哈希表计数</strong>」类型题，这类题目通常要求统计一类<strong>连续子数组的个数</strong>，需要<strong>枚举一侧端点</strong>。</p><h3 id="560-和为-K-的子数组-M"><a href="#560-和为-K-的子数组-M" class="headerlink" title="560. 和为 K 的子数组 (M)"></a>560. 和为 K 的子数组 (M)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/">题目描述</a>：给定整数数组 <code>nums</code> 和整数 <code>k</code>，统计并返回该数组中和为 <code>k</code> 的<strong>连续子数组</strong>的个数 。</p><p><strong>方法1</strong>：暴力，本题不能用滑动窗口的原因是数组<strong>有正有负</strong>，不能提前移动左指针，因此使用两层循环。外层枚举左端点，内层枚举右端点，区间和<strong>累加</strong>计算，复杂度 $O(n^2)$，超时。</p><p><strong>方法2</strong>：前缀和 + 哈希表，枚举左端点 $i$，则 $i$ 到<strong>右端点之和</strong>为 $k$，<strong>左侧之和</strong>为 $pre[i]$，两边相加就是右端点的前缀和，因此需要用<strong>哈希表计数前缀和</strong>为 $k+pre[i]$ 的个数，时空复杂度均为 $O(n)$。</p><blockquote><p>注意，由于数组有正有负，前缀和为 $k+pre[i]$ 的数组可能在 $i$ 的左侧，记得要<strong>扣除</strong>这部分。实际操作中只需要在枚举完一个左端点 $i$ ，将其前缀和 $pre[i+1]$ 的次数减去即可。</p></blockquote><p><strong>方法3</strong>：空间优化，<strong>先枚举右端点</strong>，在枚举 $pre[i] - k$ 的前缀和次数，则枚举的过程可以和前缀和一起处理，且不需要再扣除（因为后面的还没遍历到）。前缀和的空间也可以用一个变量存放，空间优化。</p><h3 id="523-连续的子数组和-M"><a href="#523-连续的子数组和-M" class="headerlink" title="523. 连续的子数组和 (M)"></a>523. 连续的子数组和 (M)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/continuous-subarray-sum/">题目描述</a>：给定整数数组 <code>nums</code> 和整数 <code>k</code>，判断是否含有总和为 <code>k</code> 的倍数、长度至少为 $2$ 的<strong>连续子数组</strong>。</p><p><strong>方法1</strong>：暴力，两层循环枚举左端点和右端点，区间和累加，时间复杂度 $O(n^2)$，超时。</p><p><strong>方法2</strong>：前缀和 + 哈希表，由<strong>同余定理</strong>，哈希表只要存储 $sum\%k$ 的结果。而本题只要判断不需要计数，因此存储每个值<strong>第一次出现的下标</strong>。同时枚举右端点 $i$，只需看哈希表中 $pre[i]$ 的下标<strong>距离是否超过</strong> $2$，复杂度 $O(n)$。</p><p><strong>方法3</strong>：前缀和 + 哈希集合，由于本题距离下限固定为 $2$，在枚举右端点时，<strong>依次进行</strong>「哈希查询、哈希插入、前缀和更新」，就能避免找到长度 $&lt;2$ 的连续子数组。更容易实现，复杂度 $O(n)$。</p><p><strong>坑点</strong>：方法 2 中要初始化 $hash[0]=-1$，即没有元素时的前缀和为 $0$。</p><h3 id="1248-统计「优美子数组」-M"><a href="#1248-统计「优美子数组」-M" class="headerlink" title="1248. 统计「优美子数组」(M)"></a>1248. 统计「优美子数组」(M)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/continuous-subarray-sum/">题目描述</a>：给定整数数组 <code>nums</code> 和整数 <code>k</code>，如果某个<strong>连续子数组</strong>中恰好有 <code>k</code> 个奇数数字，则称为「优美子数组」。</p><p><strong>方法1</strong>：暴力，两层循环枚举左端点和右端点，区间和累计，时间复杂度 $O(n^2)$，超时。</p><p><strong>方法2</strong>：乘法原理，建立一个纯奇数的 $odd$ 数组，存储奇数 $i$ 出现的位置，枚举每个奇数 $i$，其对答案的贡献是其<strong>左右边界的范围乘积</strong>，时间复杂度 $O(n)$。</p><p><strong>方法3</strong>：前缀次数 + 哈希表，哈希表记录前缀次数为 $k$ 的个数，当统计到 $i$ 时，在哈希表中查找 $pre[i]-k$ 的个数即可，复杂度 $O(n)$。</p><p><strong>坑点</strong>：方法 3 中要初始化 $hash[0]=1$，即一开始有 $0$ 个奇数数字。</p><h3 id="437-路径总和-III-H"><a href="#437-路径总和-III-H" class="headerlink" title="437. 路径总和 III (H)"></a>437. 路径总和 III (H)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii/">题目描述</a>：给定一个二叉树的根节点和一个目标整数，求二叉树中<strong>节点之和</strong>为目标值的<strong>路径数目</strong>。这里的路径不需要从根节点开始，也不需要在叶子节点结束，但是<strong>路径方向必须是向下的</strong>。</p><p><strong>方法1</strong>：暴力 DFS，DFS <strong>枚举每个节点</strong>作为路径头时的情况，再向下 DFS 到叶节点，总共有两层 DFS，时间复杂度 $O(n^2)$，空间复杂度 $O(n)$。</p><p><strong>方法2</strong>：前缀和 + 哈希表，DFS 遍历时记录<strong>根节点到当前节点</strong>的和 $cur$，并用哈希表计数，每次查询 $cur-target$ 的个数。为了<strong>防止不同分支影响计数</strong>，DFS 回溯时需要删去哈希表中的记录。注意初始化 <code>hash[0]=1</code>，如果从根节点到当前节点<strong>恰好</strong>等于目标，差值就是 $0$。时间复杂度 $O(n)$。</p><p><strong>坑点</strong>：本题的方法 1 中，<strong>记忆化</strong>数组并不能优化时间复杂度，因为需要存储的关键字有两个，必须用 pair，且只能用 map 映射，<strong>常数较大</strong>。而且两个关键字组成的<strong>目标域太过稀疏，重复访问的概率很小</strong>。</p><h3 id="2488-统计中位数为-K-的子数组-H"><a href="#2488-统计中位数为-K-的子数组-H" class="headerlink" title="2488. 统计中位数为 K 的子数组 (H)"></a>2488. 统计中位数为 K 的子数组 (H)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-subarrays-with-median-k/">题目描述</a>：给定一个 $[1,n]$ 的排列数组，统计其<strong>中位数</strong>为整数 $k$ 的<strong>连续子数组</strong>数目，长度为偶数时中位数算靠前者。</p><p><strong>方法1</strong>：暴力，找出中位数，从中间开始向两边遍历，同时<strong>累计</strong>大于、小于 $k$ 的个数，复杂度 $O(n^2)$，超时。</p><p><strong>方法2</strong>：前缀次数 + 哈希表，$k$ 为中位数意味着「左侧小于 + 右侧小于 (+1) = 左侧大于 + 右侧大于」，因此需要<strong>计数两侧</strong>大于、小于 $k$ 的数的个数。利用<strong>前缀次数处理</strong>，再将两侧「大于 - 小于」的值出现次数存入<strong>两个哈希表</strong>，遍历哈希表，用乘法原理算出结果，时间复杂度 $O(n)$。</p><p><strong>方法3</strong>：<strong>正负性转换</strong> + 哈希表，大于 $k$ 的数可视为 $+1$，小于 $k$ 的数视为 $-1$。从 $k$ 所在位置开始，先向左扫描同时累计 $lsum$，并用<strong>哈希表</strong>记录 $lsum$ 的出现次数；再向右扫描累计 $rsum$，看哈希表中有多少个 $lsum$ 可以配对。时间复杂度 $O(n)$。</p><h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><p>解决数据范围大但样本点少的情况，将大范围的样本（连续取值）映射到小范围（离散取值）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>nums.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()), nums.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">int</span> m = nums.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 去重后的长度</span><br></code></pre></td></tr></table></figure><h3 id="850-矩形面积-II-H"><a href="#850-矩形面积-II-H" class="headerlink" title="850. 矩形面积 II (H)"></a>850. 矩形面积 II (H)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rectangle-area-ii/">题目描述</a>：给定一组 X-Y 轴对齐的矩形（左上角和右下角坐标），计算平面中<strong>所有矩形</strong>覆盖的<strong>总面积</strong>，重叠部分只算一次。</p><p><strong>方法1</strong>：离散化 + 扫描线，对所有矩形的左右边界排序，横坐标离散化成 $2n$ 个点，纵坐标去重成 $\leqslant2 n-1$ 个线段。遍历横坐标，每次对<strong>一批横坐标相同的左右边界</strong>遍历纵坐标线段，复杂度 $O(n^2)$。</p><blockquote><p>扫描线算法：用一条竖直的直线从平面的<strong>最左端扫到最右端</strong>，扫描过程中直线会被给定的矩形覆盖，对覆盖的线段进行积分。每次扫到矩形的<strong>左边界</strong>时，覆盖的长度<strong>可能会增加</strong>；扫到矩形的<strong>右边界</strong>时，覆盖的长度<strong>可能会减少</strong>。</p><p>离散化，分别对横纵坐标处理：</p><ul><li><p>由于矩形的横坐标是连续值（$1e9$），而矩形的个数 $n \leqslant 200$，可以将其转化为 $2n$ 个离散的横坐标。</p></li><li><p>纵坐标将扫描线划分作 $2n-1$ 个线段（共有 $2n$ 个离散的坐标，去掉两端的射线），因此可以用两个长度为 $2n-1$ 的数组维护。 $seg[i]$ 表示第 $i$ 个线段被覆盖的次数，$length[i]$ 表示第 $i$ 个线段的长度。遇到一个左边界时，我们就将左边界覆盖到的线段对应的 $seg[i]$ 全部加 $1$；遇到一个右边界时，我们就将右边界覆盖到的线段对应的 $seg[i]$ 全部减 $1$。处理完一批后，$seg[i]$ 如果大于 $0$，说明它被覆盖，将 $length[i]$ 累加，即可得到「覆盖的线段长度」。</p></li></ul></blockquote><p><strong>方法2</strong>：离散化 + 扫描线 + 线段树，维护 $seg$ 数组的覆盖次数，以及离散化后的 $length$。需要区间加、减操作，对于所有非 $0$ 的位置，按照 $length$ 求和。复杂度 $O(n \log n)$。</p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>常见的有<strong>分段双指针、并行双指针、快慢双指针、对撞双指针、滑动窗口双指针</strong>：</p><ul><li>分段双指针：两个指针将序列分为三段，最右边是未访问的，左边和中间的序列往往具有特定属性。</li><li>并行双指针：两个指针分别遍历两个序列，遍历到的值进行某种操作，并使其中一个指针前进。</li><li>快慢双指针：常用于链表中，解决需要「计数」的问题。</li><li>对撞双指针：两个指针从两端开始向中间靠拢，通常使用 <code>while(left &lt; right)</code>。</li><li>滑动窗口双指针：关注窗口内的值，题目中通常会有「<strong>最长连续子</strong> XX」，关键在于「连续」。</li></ul><h3 id="283-移动零-E"><a href="#283-移动零-E" class="headerlink" title="283. 移动零 (E)"></a>283. 移动零 (E)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/">题目描述</a>：将数组 <code>nums</code> 中的所有 <code>0</code> 移动到数组的末尾，同时<strong>保持非零元素的相对顺序</strong>，要求原地操作。</p><p><strong>方法1</strong>：冒泡，不改变相对顺序，将所有 <code>0</code> 冒泡移动末尾，复杂度 $O(n^2)$。</p><p><strong>方法2</strong>：分段双指针，左指针左边均为处理过的非零数，<strong>右指针左边直到左指针本身均为零</strong>，右指针右边是未处理的序列。右指针向右移动，每次遇到非零数，就和左指针指向的零交换，同时左指针右移。复杂度 $O(n)$，交换的次数是<strong>非零数的个数</strong>。</p><p><strong>方法3</strong>：直接遍历，遍历时计数 <code>0</code> 的个数，每次遇到非零数直接往前填充，最后再填充所有零。复杂度 $O(n)$，覆盖次数是非零数的个数 + 零的个数，也就是<strong>数组的长度</strong>。</p><h3 id="11-盛最多水的容器-M"><a href="#11-盛最多水的容器-M" class="headerlink" title="11. 盛最多水的容器 (M)"></a>11. 盛最多水的容器 (M)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/">题目描述</a>：给定一个长度为 <code>n</code> 的数组表示 <code>n</code> 条垂线的高，找出其中两条线，使它们构成的容器能装最多的水。</p><p><strong>方法1</strong>：暴力，两层循环，先选中左边界，再遍历右边界，时间复杂度 $O(n^2)$。</p><p><strong>方法2</strong>：贪心 + 对撞双指针，双指针从两端开始遍历，选定<strong>两个边界中的短板</strong>，向中间收窄一格。时间复杂度 $O(n)$。</p><blockquote><p>如果长板向内收窄则不可能得到更优解，因为短板只可能更短，而横轴也变短了。</p></blockquote><h3 id="15-三数之和-M"><a href="#15-三数之和-M" class="headerlink" title="15. 三数之和 (M)"></a>15. 三数之和 (M)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">题目描述</a>：给定一个整数数组，返回其中所有<strong>不重复的三元组</strong>，使其和为零。三元组中可以有相同数。</p><p><strong>方法1</strong>：排序 + 暴力，将数组从小到大排序后，三层循环遍历，且<strong>每层循环都大于上一层循环枚举的元素</strong>，可以保证三元组 <code>a&lt;=b&lt;=c</code>，不会有其他顺序。同时对<strong>每一层循环跳过相同的数</strong>，否则也会重复。时间复杂度 $O(n^3)$。</p><p><strong>方法2</strong>：排序 + 对撞双指针，方法 1 的第三层遍历中，如果 <code>b</code> 匹配到了一个元素 <code>c</code>，则下一次 <code>b&lt;=b&#39;</code> 时一定有 <code>c&#39;&lt;=c</code>，因此无需完整遍历，只需用双指针从两端向中靠拢。时间复杂度 $O(n^2)$。</p><p><strong>拓展</strong>：这题的解法也可以照搬到 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/">四数之和</a>，只是多了一层循环。</p><h3 id="16-最接近的三数之和-M"><a href="#16-最接近的三数之和-M" class="headerlink" title="16. 最接近的三数之和 (M)"></a>16. 最接近的三数之和 (M)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum-closest/">题目描述</a>：给定一个整数数组和一个<strong>目标值</strong> <code>target</code> ，从数组中选出选出三个整数，使它们的和与 <code>target</code> 最接近。</p><p><strong>方法1</strong>：暴力，三层循环遍历，时间复杂度 $O(n^3)$，可以通过排序进行一定的剪枝。</p><p><strong>方法2</strong>：排序 + 对撞双指针，外层循环不变，内层循环改用对撞双指针，同时维护一个变量 $diff$ 表示和目标<strong>差值的绝对值</strong>。内层循环时会被 $sum \pm diff$ 划分为<strong>五种情况</strong>，时间复杂度 $O(n^2)$。</p><h3 id="75-颜色分类-M"><a href="#75-颜色分类-M" class="headerlink" title="75. 颜色分类 (M)"></a>75. 颜色分类 (M)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/">题目描述</a>：给定一个由数字 <code>0 1 2</code> 组成的数组，代表三种颜色（<strong>荷兰国旗问题</strong>），按照 <code>0&lt;1&lt;2</code> 的顺序<strong>原地排序</strong>。</p><p><strong>方法1</strong>：单指针两次遍历，用指针维护「<strong>已归位</strong>」元素下标，第一次遍历找出数字 $0$ 放到指针处，并将指针后移；第二次遍历找出数字 $1$ 放到指针处。两次遍历完 $2$ 都出现在尾部。时间复杂度 $O(n)$。</p><p><strong>方法2</strong>：并行双指针，用指针 $p_0$ 维护下一个 $0$ 的位置，指针 $p_1$ 维护下一个 $1$ 的位置。每次遇到 $1$ 则将其交换到 $p_1$，并<strong>将 $p_1$ 增一</strong>；每次遇到 $0$ 则将其交换到 $p_0$，由于 $p_0$ 处<strong>可能放着</strong> $1$，所以还要将其放到 $p_1$ 位置，最后<strong>将两个指针增一</strong>。</p><p><strong>方法3</strong>：对撞双指针，左指针 $p_0$ 维护下一个 $0$ 的位置，右指针 $p_2$ 维护下一个 $2$ 的位置。<strong>从左往右遍历</strong>，遇到 $0$ 直接换，遇到 $2$ 交换后，当前位置换来的数可能还是 $0$ 或 $2$，需要<strong>一直重复交换直到当前位置为</strong> $1$。</p><blockquote><p>此时遍历用的迭代变量可以理解为 $p_1$，因为本题的目的就是划分三个区间，用三个指针是最符合直觉的。</p></blockquote><h3 id="42-接雨水-H"><a href="#42-接雨水-H" class="headerlink" title="42. 接雨水 (H)"></a>42. 接雨水 (H)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">题目描述</a>：给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>方法1</strong>：暴力，对于每个坐标，其能接的水量取决于<strong>左右两边最高的柱子中较矮者</strong>，两层循环遍历，复杂度 $O(n^2)$。</p><p><strong>方法2</strong>：DP 预处理最大值，两次扫描，记录<strong>每个柱子</strong>的<strong>左右两边最大值</strong>，再扫描累计，时空复杂度均为 $O(n)$。该方法可以简单优化：从左到右的预处理可以和第三次扫描<strong>合并</strong>，<strong>用一个变量存储</strong>左边最大值，节省一个数组。</p><p><strong>方法3</strong>：单调栈 + 模拟，每遍历到一个柱子，如果比栈顶元素<strong>更小则入栈</strong>，如果更大则说明前面的柱子<strong>可以形成水洼</strong>，则依次将所有较小数弹出，并计算<strong>和新柱子的距离差值</strong>，再把新柱子入栈。时空复杂度均为 $O(n)$。</p><p><strong>方法4</strong>：贪心 + 对撞双指针，双指针从两端开始遍历，再用两个变量存储左右两边最大值，每次<strong>较小者向中间收窄一格</strong>，同时计算出当前柱子能接的水量。时间复杂度 $O(n)$，空间复杂度 $O(1)$。</p><blockquote><p>较小者可以先计算的原因是：较小者可能会被更新为较大者，而较大者不可能会被更新为较小者。因此较小者此刻的解具有<strong>无后效性</strong>。</p></blockquote><p><strong>方法5</strong>：分治 + 面积法，<strong>最高柱子将全局分为两边</strong>，两边各有各自的次高柱子，<strong>次高柱子与最高柱子中间的区域</strong>显然取值就是「次高柱子 - 当前柱子」，同理以此类推到两端。时间复杂度 $O(n)$，空间复杂度 $O(1)$。</p><blockquote><p>因此<strong>只需遍历一次</strong>，从左往右取左边最大值，从右往左取右边最大值，答案增加「<strong>左高 + 右高</strong> - 当前柱子」。这里的减去的「当前柱子」只是为了减去所有柱子的面积（合并在一次遍历中完成）。</p><p>最后减去「最高柱子 $\times$ 总长度」，因为两次扫描都会<strong>经过最高柱子</strong>，经过后再接着扫描的面积无意义，形成了一个大矩形的面积，需要扣除。</p></blockquote><p><strong>坑点</strong>：最左边、最右边两个柱子<strong>不可能接到水</strong>，要跳过，可以直接从 <code>1</code> 遍历到 <code>n-2</code>。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>双指针中较为困难的一类题：关注窗口内的值，题目中通常会有「<strong>连续子</strong> XX」，关键在于「连续」。</p><ul><li><p>要求「<strong>最长连续子</strong> XX」的<strong>长度</strong>，此时应该尽量滑动右指针，在窗口不满足要求时滑动左指针。同时优化判断「<strong>窗口是否满足要求</strong>」的复杂度。此时维护的窗口类型：</p><ul><li><strong>哈希集合</strong>：维护窗口内有哪些元素；</li><li><strong>哈希表</strong>：维护窗口内元素出现的次数、最后出现的位置；</li><li><strong>双哈希表</strong>：对子串乱序匹配问题，需要一个 <code>need</code> 存储目标次数、一个 <code>window</code> 维护窗口内出现的次数；</li><li><strong>单个变量</strong>：利用位运算进行存储、或者压位操作。</li></ul></li><li><p>要求「<strong>连续子</strong> XX」的<strong>个数</strong>，此时应该<strong>枚举右指针并固定</strong>（定界法），然后再枚举左指针，计数左指针的枚举次数。左指针不需要复位，防止退化为 $O(n^2)$。此时需要维护的变量：</p><ul><li><strong>不该出现</strong>的元素的最后出现的位置，代表窗口左指针的<strong>最左取值</strong>；</li><li><strong>必须出现</strong>的元素的最后出现的位置，代表窗口左指针的<strong>最右取值</strong>。</li></ul></li></ul><h3 id="3-无重复字符的最长子串-M"><a href="#3-无重复字符的最长子串-M" class="headerlink" title="3. 无重复字符的最长子串 (M)"></a>3. 无重复字符的最长子串 (M)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">题目描述</a>：给定一个字符串 <code>s</code>，找出其中不含有重复字符的<strong>最长连续子串</strong>的长度。</p><p><strong>方法1</strong>：双指针滑动窗口，右指针每前进一格，在窗口内进行 <code>s.find</code>，如果找到重复字符，则左指针快速前移，复杂度 $O(n^2)$。左右指针移动的方式也可以交换。</p><p><strong>方法2</strong>：滑动窗口 + <strong>哈希集合</strong>，左指针多次 <code>erase()</code> 直到 <code>hash.count() == 0</code> 代替 <code>find</code>，复杂度 $O(n)$。</p><p><strong>方法3</strong>：滑动窗口 + <strong>哈希表</strong>，比上一个方法多用一个数来存储字符在数组中的下标，左指针快速前移时不需要一直多次 <code>count()</code>，复杂度 $O(n)$。</p><h3 id="438-找到字符串中所有字母异位词-M"><a href="#438-找到字符串中所有字母异位词-M" class="headerlink" title="438. 找到字符串中所有字母异位词 (M)"></a>438. 找到字符串中所有字母异位词 (M)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">题目描述</a>：给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的<strong>字母异位词子串</strong>（相同字母重排列形成）。</p><p><strong>方法1</strong>：<strong>定长</strong>滑动窗口，窗口长度限定为 <code>p</code> 的长度，枚举窗口的每个位置，用哈希表 + 计数来判断窗口内是否匹配所有字母，<strong>每次只考虑一进一出的两个字母</strong>，时间复杂度 $O(n+m)$。</p><p><strong>方法2</strong>：滑动窗口 + <strong>双哈希表</strong>，哈希表 <code>need</code> 记录<strong>目标字符次数</strong>，用双指针扫描母串并记录<strong>窗口内字符次数</strong> <code>window</code>，左指针只在 $window[s[l]]&gt;need[s[l]]$ 时<strong>前移</strong>。用 $cnt$ 维护已匹配字符数，当窗口长度恰好是 <code>p</code> 的长度时更新。时间复杂度 $O(n+m)$。</p><h3 id="76-最小覆盖子串-H"><a href="#76-最小覆盖子串-H" class="headerlink" title="76. 最小覆盖子串 (H)"></a>76. 最小覆盖子串 (H)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">题目描述</a>：给定字符串 <code>s</code> 和 <code>t</code>，找出 <code>s</code> 中涵盖 <code>t</code> 所有字符的<strong>最小子串</strong>，顺序可以打乱。</p><p><strong>方法1</strong>：滑动窗口 + <strong>双哈希表</strong>，哈希表 <code>need</code> 记录<strong>目标字符次数</strong>，用双指针扫描母串并记录<strong>窗口内字符次数</strong> <code>window</code>，左指针只在 $window[s[l]]&gt;need[s[l]]$ 时<strong>前移</strong>。用 $cnt$ 维护已匹配字符数，及时更新答案。复杂度 $O(n+m)$。</p><p><strong>方法2</strong>：滑动窗口 + 单哈希表，哈希表 <code>need</code> 记录<strong>距离目标字符剩余次数</strong>，只有遇到 <code>t</code> 中存在的字符时才更新窗口，用 $cnt$ 维护剩余字符数，及时更新答案。复杂度 $O(n+m)$。</p><h3 id="2401-最长优雅子数组-M"><a href="#2401-最长优雅子数组-M" class="headerlink" title="2401. 最长优雅子数组 (M)"></a>2401. 最长优雅子数组 (M)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-nice-subarray/">题目描述</a>：<strong>正</strong>整数组成的数组 <code>nums</code> 中找出<strong>最长连续子数组</strong>，使其满足子数组中所有元素 <code>&amp;</code> 结果等于 0。</p><p><strong>方法</strong>：滑动窗口 + 位运算，窗口内所有元素取 <code>|</code> 使二进制 1 位合并，右侧元素只需和整体进行 <code>&amp;</code> 就能判断是否加入窗口，如果不能加入，则左侧元素需要弹出，使用 <code>^</code> 运算<strong>去除</strong>二进制 1 位。</p><hr><h3 id="795-区间子数组个数-M"><a href="#795-区间子数组个数-M" class="headerlink" title="795. 区间子数组个数 (M)"></a>795. 区间子数组个数 (M)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/">题目描述</a>：给定一个整数数组 <code>nums</code> 和两个整数：<code>left</code> 及 <code>right</code>。找出连续、非空且<strong>最大值</strong>在 <code>[left,right]</code> 内的子数组，统计个数。</p><p><strong>方法1</strong>：乘法原理，单调栈预处理每个数作为最大值时的两边边界，计算出个数贡献，时空复杂度均为 $O(n)$。</p><p><strong>方法2</strong>：定界法，显然 <code>&gt;right</code> 的数不能包含，记上一个出现的位置为 $i_0$；区间内的数<strong>至少包含一个</strong>，记上一个出现的位置为 $i_1$。<strong>枚举右端点</strong>，则当 $i_0&lt;i_1$ 时，两者的差就是个数。时间复杂度 $O(n)$，空间复杂度 $O(1)$。</p><h3 id="2817-统计定界子数组的数目-H"><a href="#2817-统计定界子数组的数目-H" class="headerlink" title="2817. 统计定界子数组的数目 (H)"></a>2817. 统计定界子数组的数目 (H)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/">题目描述</a>：给定一个整数数组 <code>nums</code> 和两个整数 <code>minK</code> 以及 <code>maxK</code>，若一个<strong>连续子数组</strong>中的<strong>最小值</strong>等于 <code>minK</code>，<strong>最大值</strong>等于 <code>maxK</code>，则称为定界子数组。返回定界子数组的数目。</p><p><strong>方法1</strong>：分治 + 滑动窗口双指针，首先去掉范围之外的数，将原数组<strong>分为若干个子数组</strong>，再对每个子数组讨论。每个子数组采用双指针扫描，时间复杂度 $O(n)$。</p><blockquote><p>对每个子数组，先枚举右端点，右指针滑动并计数 <code>miCnt</code> 和 <code>mxCnt</code>，当 <code>miCnt &gt; 0 &amp;&amp; mxCnt &gt; 0</code> 时，说明右端点已经满足，此时左端点有多种取值。</p><p>枚举左端点，左指针滑动并减少 <code>miCnt</code> 和 <code>mxCnt</code>，当不满足条件时，<strong>左端点枚举过的距离</strong>就是该右端点对应的定界子数组个数。继续枚举下一个右端点。</p><p>对于下一个右端点，即使滑动窗口之间不满足 <code>miCnt &gt; 0 &amp;&amp; mxCnt &gt; 0</code>，也可以增加<strong>左端点枚举过的距离</strong>，因为这段距离中任何一个左端点都可以和当前右端点构成定界子数组。</p></blockquote><p><strong>方法2</strong>：定界法，记录<strong>上一个范围之外的数</strong>的下标 $i_0$，代表了<strong>左端点的最左取值</strong>。枚举右端点，同时记录遍历过的<strong>距离右端点最近</strong>的 $minK$ 和 $maxK$ 的<strong>下标</strong>，二者中的靠左者就是<strong>左端点的最右取值</strong>。时间复杂度 $O(n)$。</p><p><strong>坑点</strong>：不要试图将两边端点的取值范围找出来后相乘，因为这题每个点有两种角色，需要都满足时才能产生贡献。</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" class="category-chain-item">算法笔记</a> <span>></span> <a href="/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/" class="category-chain-item">力扣刷题</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Algorithm/">#Algorithm</a></div></div><div class="license-box my-3"><div class="license-title"><div>力扣刷题笔记 #01 数组</div><div>https://hwcoder.top/LeetCode-Array</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Wei He</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年10月2日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/LeetCode-Bitwise" title="力扣刷题笔记 #02 数位&amp;二进制"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">力扣刷题笔记 #02 数位&amp;二进制</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/BaoYan-Memoir" title="2022年保研回忆录"><span class="hidden-mobile">2022年保研回忆录</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.16/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"jdbBr3BddTiqSCPnXw6sXFv7-gzGzoHsz","appKey":"2bjgwDr2opjVCwhgjDMpk53c","path":"window.location.pathname","placeholder":"说点什么吧( •̀ ω •́ )✧","avatar":"retro","meta":["nick","mail","link"],"requiredFields":["nick"],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-t}),0<o.find(".toc-list-item").length&&o.css("visibility","visible"))})</script><script>!function(){var i,t=CONFIG.code_language.enable&&CONFIG.code_language.default,c=CONFIG.copy_btn;(t||c)&&(i="",i+='<div class="code-widget">',i+="LANG",i+="</div>",jQuery(".markdown-body pre").each(function(){var e,a,n=jQuery(this);0<n.find("code.mermaid").length||0<n.find("span.line").length||(e="",t&&(e=CONFIG.code_language.default,0<n[0].children.length&&2<=n[0].children[0].classList.length&&n.children().hasClass("hljs")?e=n[0].children[0].classList[1]:n[0].getAttribute("data-language")?e=n[0].getAttribute("data-language"):n.parent().hasClass("sourceCode")&&0<n[0].children.length&&2<=n[0].children[0].classList.length?(e=n[0].children[0].classList[1],n.parent().addClass("code-wrapper")):n.parent().hasClass("markdown-body")&&0===n[0].classList.length&&n.wrap('<div class="code-wrapper"></div>'),e=e.toUpperCase().replace("NONE",CONFIG.code_language.default)),n.append(i.replace("LANG",e).replace('code-widget">',(a=n[0],(0<=Fluid.utils.getBackgroundLightness(a)?"code-widget-light":"code-widget-dark")+(c?' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>':' code-widget">')))),c&&Fluid.utils.createScript("https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js",function(){new window.ClipboardJS(".copy-btn",{target:function(e){for(var a=e.parentNode.childNodes,n=0;n<a.length;n++)if("CODE"===a[n].tagName)return a[n]}}).on("success",function(e){e.clearSelection(),e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-copy","icon-success"),setTimeout(function(){e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-success","icon-copy")},2e3)})}))}))}()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script>MathJax = {
          tex    : {
            inlineMath: { '[+]': [['$', '$']] }
          },
          loader : {
            load: ['ui/lazy']
          },
          options: {
            renderActions: {
              findScript    : [10, doc => {
                document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                  const display = !!node.type.match(/; *mode=display/);
                  const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                  const text = document.createTextNode('');
                  node.parentNode.replaceChild(text, node);
                  math.start = { node: text, delim: '', n: 0 };
                  math.end = { node: text, delim: '', n: 0 };
                  doc.math.push(math);
                });
              }, '', false],
              insertedScript: [200, () => {
                document.querySelectorAll('mjx-container').forEach(node => {
                  let target = node.parentNode;
                  if (target.nodeName.toLowerCase() === 'li') {
                    target.parentNode.classList.add('has-jax');
                  }
                });
              }, '', false]
            }
          }
        };</script><script src="https://lib.baomitu.com/mathjax/3.2.0/es5/tex-svg-full.js"></script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>