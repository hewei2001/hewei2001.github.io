<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg"><link rel="icon" href="/img/logo.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#01213a"><meta name="author" content="He Wei"><meta name="keywords" content="Computer Science and Technology, Machine Learning, Deep Learning, Computer Vision, Natural Language Processing"><meta name="baidu-site-verification" content="code-J3wrn8WJYJ"><meta name="google-site-verification" content="0p_KJKTfB8EcahVDp0vYRjVRhHFw1SBWHi15OakKHY0"><meta name="description" content="算法入门学习过程中的笔记，本文简述了 C++ STL 标准模板库的基础用法，包括 Algorithm 算法库、字符串 string 库、常用容器库：vector、pair、tuple、map、set、stack、queue、deque。"><meta property="og:type" content="article"><meta property="og:title" content="算法入门笔记 #2 STL标准库"><meta property="og:url" content="https://hwcoder.top/Algo-Note-2"><meta property="og:site_name" content="Hwcoder - Life Oriented Programming"><meta property="og:description" content="算法入门学习过程中的笔记，本文简述了 C++ STL 标准模板库的基础用法，包括 Algorithm 算法库、字符串 string 库、常用容器库：vector、pair、tuple、map、set、stack、queue、deque。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hwcoder.top/img/home/coding.png"><meta property="article:published_time" content="2022-08-27T08:23:09.000Z"><meta property="article:modified_time" content="2022-10-08T08:35:09.171Z"><meta property="article:author" content="He Wei"><meta property="article:tag" content="Algorithm"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://hwcoder.top/img/home/coding.png"><title>算法入门笔记 #2 STL标准库 | Hwcoder - Life Oriented Programming</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/mac.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"hwcoder.top",root:"/",version:"1.9.0",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h2, h3",placement:"left",visible:"always",icon:"§"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4",collapseDepth:3},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"XGNf4GEnaFLiUijMUvz8HSBF-gzGzoHsz",app_key:"JPeVLcug6EcWdBTpGrDJSdKi",server_url:"https://xgnf4gen.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Hwcoder</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于我</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/bg/other.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="算法入门笔记 #2 STL标准库"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-08-27 16:23" pubdate>2022年8月27日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 14k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 80 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="算法笔记" id="heading-6caacb5aaee15525d7a2b4768aa79852" role="tab" data-toggle="collapse" href="#collapse-6caacb5aaee15525d7a2b4768aa79852" aria-expanded="true">算法笔记 <span class="list-group-count">(14)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-6caacb5aaee15525d7a2b4768aa79852" role="tabpanel" aria-labelledby="heading-6caacb5aaee15525d7a2b4768aa79852"><div class="category-post-list"></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="力扣刷题" id="heading-9ca088cdf0fdc34dd48290c9d13c88b1" role="tab" data-toggle="collapse" href="#collapse-9ca088cdf0fdc34dd48290c9d13c88b1" aria-expanded="false">力扣刷题 <span class="list-group-count">(12)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-9ca088cdf0fdc34dd48290c9d13c88b1" role="tabpanel" aria-labelledby="heading-9ca088cdf0fdc34dd48290c9d13c88b1"><div class="category-post-list"><a href="/LeetCode-Array-LinkList" title="力扣刷题笔记 #1 数组&amp;链表" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #1 数组&amp;链表</span> </a><a href="/LeetCode-Stack-Queue" title="力扣刷题笔记 #10 栈&amp;队列" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #10 栈&amp;队列</span> </a><a href="/LeetCode-String" title="力扣刷题笔记 #11 字符串" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #11 字符串</span> </a><a href="/LeetCode-Tree" title="力扣刷题笔记 #12 树" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #12 树</span> </a><a href="/LeetCode-Bitwise" title="力扣刷题笔记 #2 数位&amp;二进制" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #2 数位&amp;二进制</span> </a><a href="/LeetCode-Data-Structure" title="力扣刷题笔记 #3 数据结构" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #3 数据结构</span> </a><a href="/LeetCode-Divide-Conquer" title="力扣刷题笔记 #4 二分&amp;分治" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #4 二分&amp;分治</span> </a><a href="/LeetCode-DP" title="力扣刷题笔记 #5 动态规划" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #5 动态规划</span> </a><a href="/LeetCode-Graph" title="力扣刷题笔记 #6 图论" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #6 图论</span> </a><a href="/LeetCode-Greedy" title="力扣刷题笔记 #7 贪心算法" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #7 贪心算法</span> </a><a href="/LeetCode-Math" title="力扣刷题笔记 #8 数学" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #8 数学</span> </a><a href="/LeetCode-Search" title="力扣刷题笔记 #9 搜索&amp;剪枝" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #9 搜索&amp;剪枝</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem list-group-item category-item-action col-10 col-md-11 col-xm-11" title="算法入门" id="heading-cbb23c60a3cdd7188054b6ba4efbf423" role="tab" data-toggle="collapse" href="#collapse-cbb23c60a3cdd7188054b6ba4efbf423" aria-expanded="true">算法入门 <span class="list-group-count">(2)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-cbb23c60a3cdd7188054b6ba4efbf423" role="tabpanel" aria-labelledby="heading-cbb23c60a3cdd7188054b6ba4efbf423"><div class="category-post-list"><a href="/Algo-Note-1" title="算法入门笔记 #1 杂记" class="list-group-item list-group-item-action"><span class="category-post">算法入门笔记 #1 杂记</span> </a><a href="/Algo-Note-2" title="算法入门笔记 #2 STL标准库" class="list-group-item list-group-item-action active"><span class="category-post">算法入门笔记 #2 STL标准库</span></a></div></div></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">算法入门笔记 #2 STL标准库</h1><p class="note note-info">本文最后更新于：2022年10月8日 下午</p><div class="markdown-body"><p>STL (Standard Template Library) 标准模板库，是一个具有工业强度的，高效的 C++ 程序库。文章开头先附上一个 STL 常用模板，方便取用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span> <span class="hljs-comment">// 万能头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; 	<span class="hljs-comment">// 大部分的 STL 保留字位于 std 命名空间</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> y second  		<span class="hljs-comment">// 结合 pair 用</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> db;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-keyword">int</span>&gt; vi;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii; <span class="hljs-comment">// 常用于坐标系</span><br><br>vector&lt;<span class="hljs-keyword">int</span>&gt; a;<br>a.<span class="hljs-built_in">pb</span>(<span class="hljs-number">1</span>);<br><br>vector&lt;pii&gt; p;<br>p.<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">mp</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)); <span class="hljs-comment">// 支持 C++ 11 及以上的平台 mp 可以用 &#123;&#125; 代替</span><br></code></pre></td></tr></table></figure><h2 id="Algorithm-算法库"><a href="#Algorithm-算法库" class="headerlink" title="Algorithm 算法库"></a>Algorithm 算法库</h2><p>头文件 <code>#include&lt;algorithm&gt;</code> 定义了 STL 中基础的算法，大部分方法可以在容器中找到对应函数，例如不修改内容的 <code>find</code>、<code>count</code> 等操作，修改内容的 <code>remove</code>、<code>replace</code>、<code>swap</code> 等操作，以及排序、二分查找、两数取最大最小、交换两数等算法。</p><p>这里列出常用的几个操作：</p><ul><li><code>__gcd(1024, 256);</code>：求最大公约数。</li><li><code>min(&#123;a, b, c, d&#125;)</code>：返回多个数的最值，需要用<strong>大括号</strong>包围（C++11 以上）。</li><li><code>sort(a,a+n)</code>、<code>stable_sort(a,a+n)</code>：前者采用快速排序，后者采用归并排序，<strong>不改变相等元素的相对位置</strong>，除了数组指针也支持迭代器 <code>sort(v.begin(), v.end())</code>。<ul><li>如果要自定义比较函数 cmp，遵循以下模板：<code>bool cmp(T &amp;a,T &amp;b)&#123;return a&lt;b;&#125;</code>，在力扣刷题时要在函数前加上 <code>static</code>。</li><li>默认是升序排列，如果要降序排列则用 <code>sort(v.begin(), v.end(), greater&lt;int&gt;());</code></li></ul></li><li><code>reverse(v.begin(),v.end())</code>：翻转 vector 容器，也可以用于 string 字符串的翻转。</li><li><code>lower_bound(a,a+n,x)</code>：返回<strong>升序数组</strong>中可以插入元素 x 的<strong>最低位置</strong>，也就是<strong>大于等于</strong> x 的第一个数的地址；</li><li><code>upper_bound(a,a+n,x)</code>：返回<strong>升序数组</strong>中可以插入元素 x 的<strong>最高位置</strong>，也就是<strong>大于</strong> x 的第一个数的地址；<ul><li>简记：假设有一个数组 <code>1 1 2 2 2 3 3</code>，如果 x 选 2，则可以插在第一个 2 的位置，也可以插在第一个 3 的位置，此时其他元素后移，不会改变升序。</li><li>将得到地址减<strong>去数组的起始地址</strong>就可以得到下标：<code>pos = lower_bound(a,a+n,x) - a;</code></li><li>此方法在前两个参数构成的<strong>前闭后开</strong>区间内查找，如果不存在满足的元素则返回 <code>end()</code>，如果数组是降序的，则需要加上参数 <code>greater&lt;int&gt;()</code>。</li></ul></li><li><code>nth_element(first，kth，end)</code>：将<strong>第 k 小</strong>元素放到它该放的位置上，左边元素都小于等于它，右边元素都大于等于它。这是一个<strong>原地算法</strong>，会改变原数组，复杂度 $O(n)$。<ul><li>除了数组指针也支持迭代器 <code>nth_element(v.begin(), v.begin() + k, v.end())</code>，如果要选择<strong>第 k 大</strong>元素，可以使用 <code>nth_element(v.begin(), v.begin() + k, v.end(), greater&lt;int&gt;())</code>。</li></ul></li><li><code>next_permutation(a,a+n)</code>、<code>next_permutation(v.begin(), v.end())</code>：原地算法，改变原数组、向量、字符串为按字典序的全排列中的下一排列，返回 bool 值为 0 时表示结束。</li><li><code>accumulate(a,a+n,0)</code>、<code>accumulate(v.begin(), v.end(), 0)</code>：用加法运算符求出元素序列的和，第三个参数是和的初值。该方法也可以自定义加法运算符，作为第四个参数输入。</li><li><code>unique(a,a+n)</code>：去除数组中<strong>相邻的重复</strong>元素（配合排序使用），返回去重后的尾地址。这里的去除并非真正意义的 erase，而是将重复的元素放到容器的末尾。<ul><li>将尾地址<strong>减去数组的起始地址</strong>就能得到去重后的个数：<code>n = unique(a,a+n) - a;</code>，然后遍历。</li><li>结合向量的批量删除操作<strong>真正去掉重复</strong>：<code>v.erase(unique(v.begin(), v.end()), v.end());</code>，之后用 <code>n = v.size()</code> 就能得到去重后的个数。</li></ul></li></ul><h2 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串 | string"></a>字符串 | string</h2><p>string 是 C++ 特有的字符串变量类型。</p><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li>头文件 <code>#include&lt;string&gt;</code></li><li>声明 string 变量：<ul><li>直接声明并等号赋值：<code>string str=&quot;12345678&quot;;</code></li><li>声明一个副本：<code>string s(str);</code></li><li>声明一个字符串数组的复制品：<code>char ch[]=&quot;12345678&quot;; string s(ch);</code></li><li>利用迭代器复制区间：<code>string s(str.begin(),str.end()-2);</code></li><li>将 int 变量转 string：<code>string strNum=to_string(intNum);</code></li></ul></li><li>运算符（重载后）：<ul><li>比较运算符 <code>== &gt; &lt; &gt;= &lt;= !=</code> 用法参考 <code>strcmp</code></li><li>加法运算符 <code>+ +=</code> 用于连接两个字符串</li><li>下标运算符 <code>[]</code> 用于获取特定位置</li></ul></li><li>特性函数：<ul><li>返回当前容量，即不必挪动就能存放的字符数：<code>s.capacity();</code></li><li>返回经过挪动后能存放的最大容量：<code>s.max_size();</code></li><li>返回当前在内存空间中的大小（字节数），不计终止符：<code>s.size();</code> 或 <code>s.length();</code></li><li>判断当前字符串是否为空：<code>s.empty();</code></li><li>返回当前 string 对应的<strong>字符数组</strong>的头指针：<code>printf(&quot;%s&quot;, s.c_str());</code></li></ul></li><li>查找运算：<ul><li>返回 str 在 s 中第一次出现的位置，没找到就返回 -1：<code>s.find(str);</code></li><li>同上，从下标为 index 处开始查找：<code>s.find(str,idx);</code></li><li>同上，查找对象换成字符：<code>s.find(&#39;x&#39;);</code></li><li>返回 str 在 s 中最后一次出现的位置：<code>s.find_last_of(str);</code></li></ul></li><li>其他运算：<ul><li>在下标 p 位置插入，原有的后移，但不能插在结束符后的空间：<code>s.insert(p, &quot;hello&quot;);</code></li><li>在末尾插入一个字符：<code>s.push_back(&#39;a&#39;);</code>（和 vector 很相似）</li><li>删除 p 开始的所有字符：<code>s.erase(p);</code></li><li>交换当前字符串与 str 的值：<code>s.swap(str);</code></li><li>返回从下标 i 开始的子串：<code>s.substr(0)</code></li><li>返回从下标 i 到下标 j 的子串：<code>s.substr(0,3)</code>，如果超过总长度则输出原字符串</li><li>将 string 变量转 int：<code>int num = stoi(s);</code></li></ul></li></ul><h3 id="特殊性质"><a href="#特殊性质" class="headerlink" title="特殊性质"></a>特殊性质</h3><ul><li>string 拥有一个特殊的输入输出流库：<code>#include&lt;sstream&gt;</code>，可以将任意类型的变量输出到流中，再以字符串的形式读出。如 int 转 string 操作：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#inlcude<span class="hljs-meta-string">&lt;sstream&gt;</span></span><br>stringstream ss;<br>ss &lt;&lt; intNum;<br>string strNum = ss.<span class="hljs-built_in">str</span>(); <span class="hljs-comment">//.str()是&lt;sstream&gt;库中的函数</span><br></code></pre></td></tr></table></figure><ul><li>由于 string 也是容器，因此支持迭代器和下标两种访问操作，通常用下标方便处理更复杂的输出。</li></ul><h3 id="易混淆的库"><a href="#易混淆的库" class="headerlink" title="易混淆的库"></a>易混淆的库</h3><ul><li>cstring：与 C 兼容的字符串处理库，使用字符串数组、指针操作<ul><li><code>strcpy(a,b)</code>：将 b 字符串拷贝到 a 处，遇到 <code>&#39;\0&#39;</code> 停止，可能溢出</li><li><code>strcat(a,b)</code>： 将 b 字符串连接到 a 处，可能溢出</li><li><code>strcmp(a,b)</code>：比较 a,b 字符串，直到遇到不相同的字符或者 <code>&#39;\0&#39;</code>，都相同返回 0，首个不同字符 a&lt;b 则返回负数，否则返回正数</li><li><code>strlen(a)</code>：返回 a 字符串的长度，不含 <code>&#39;\0&#39;</code></li><li><code>strstr(a,b)</code>：在 a 中查找 b 字符串，返回第一次出现位置的指针</li><li><code>memset(a,&#39;x&#39;,n)</code>：将 a 指向的内存空间，逐字节地赋值为字符 x，此处也可替换成 0-255 的十进制或十六进制数字</li><li><code>memcpy(a,b,n)</code>：将 b 指向的内存空间拷贝 n 个字节到 a，可能溢出</li><li><code>memcmp(a,b,n)</code>：比较两个内存空间的前 n 个字节</li></ul></li><li>cctype：用于字符类型的判别与处理<ul><li><code>isalnum()</code>：如果参数是字母数字，即字母或者数字，函数返回 true</li><li><code>isalpha()</code>：如果参数是字母，函数返回 true</li><li><code>isdigit()</code>：如果参数是数字（0－9），函数返回 true</li><li><code>isgraph()</code>：如果参数是除空格之外的打印字符，函数返回 true</li><li><code>islower()</code>：如果参数是小写字母，函数返回 true</li><li><code>isprint()</code>：如果参数是打印字符（包括空格），函数返回 true</li><li><code>isupper()</code>：如果参数是大写字母，函数返回 true</li><li><code>isxdigit()</code>：如果参数是十六进制数字，即 0－9、a－f、A－F，函数返回 true</li><li><code>tolower()</code>：如果参数是大写字符，返回其小写，否则返回该参数</li><li><code>toupper()</code>：如果参数是小写字符，返回其大写，否则返回该参数</li></ul></li></ul><h2 id="向量-vector"><a href="#向量-vector" class="headerlink" title="向量 | vector"></a>向量 | vector</h2><p>vector 是一个能够存放任意类型的<strong>动态数组</strong>，能够增加和压缩数据，是<strong>同一种类型</strong>的对象的集合，每个对象都有一个对应的整数索引值。</p><p>向量中的元素按照<strong>严格的线性顺序排序</strong>，可以通过元素在序列中的位置访问对应的元素。使用一个内存分配器对象来动态地处理它的存储需求。</p><h3 id="基础操作-1"><a href="#基础操作-1" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li><p>头文件 <code>#include&lt;vector&gt;</code></p></li><li><p>创建 vector 对象：</p><ul><li>直接创建：<code>vector&lt;int&gt; v;</code>（实际中通常会 <code>typedef vector&lt;int&gt; vi;</code>）</li><li>直接创建并初始化（类似数组）：<code>vector&lt;int&gt; v=&#123;1,2,3&#125;;</code></li><li>创建一个副本：<code>vector&lt;int&gt; v_b(v_a);</code></li><li>创建含有 <code>n</code> 个元素 <code>a</code> 的对象：<code>vector&lt;int&gt; v(n,a);</code></li><li>创建含有 <code>n</code> 个元素且全 0 的对象：<code>vector&lt;int&gt; v(n);</code></li><li>创建二维对象：<code>vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n));</code></li></ul></li><li><p>插入、删除元素：</p><ul><li>尾部插入元素：<code>v.push_back(a);</code></li><li>尾部删除元素：<code>int a = v.pop_back();</code></li><li>任意位置插入元素：<code>v.insert(v.begin()+i, a)</code>，在下标 i 的元素前面插入 a。</li></ul></li><li><p>删除元素：<code>v.erase(v.begin()+2)</code>，删除下标 2 的元素。</p><ul><li>批量删除：<code>v.erase(v.begin()+i, v.begin()+j)</code>，删除左闭右开区间。</li></ul></li><li><p>特性函数：</p><ul><li>向量大小：<code>v.size()</code></li><li>内存中向量能包含的最大元素个数：<code>v.max_size()</code></li><li>清空：<code>v.clear();</code></li><li>判断空：<code>v.empty()</code></li></ul></li><li><p>访问元素：</p><ul><li><p>随机访问成员：<code>v.at(i)</code>，返回元素的引用</p></li><li><p>数组运算符：<code>v[i]</code>，返回元素的引用</p></li><li><p>特定元素访问：<code>v.front()</code> 和 <code>v.back()</code> 返回第一个和最后一个元素的引用</p></li><li><p>迭代访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 声明迭代器，此时的 it 类似指针</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator it; 	<span class="hljs-comment">// 这里可以换成 auto</span><br><span class="hljs-keyword">for</span>(it=vec.<span class="hljs-built_in">begin</span>(); it!=vec.<span class="hljs-built_in">end</span>(); it++)<br>    cout&lt;&lt;*it&lt;&lt;endl;  		<span class="hljs-comment">// 访问指针指向的元素，有 *</span><br><br><span class="hljs-comment">// C++11 新语法，此时的 item 为元素本身</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item:vec)<br>    cout&lt;&lt;item&lt;&lt;endl;  	<span class="hljs-comment">// 不需要 *，且此时修改不会影响原数组（深拷贝）</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;item:vec)<br>    item++;	 		   	<span class="hljs-comment">// 如果带有 &amp; 就可以修改元素（浅拷贝）</span><br><br><span class="hljs-comment">// 不用迭代器直接用下标索引遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++)<br>    cout&lt;&lt;vec[i]&lt;&lt;endl;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="特殊性质-1"><a href="#特殊性质-1" class="headerlink" title="特殊性质"></a>特殊性质</h3><ul><li><code>v.begin()</code> 与 <code>v.end()</code> 返回的是<strong>指针</strong>，指向第一个元素和最后一个元素的<strong>下一个位置</strong>（无意义），只能赋值给迭代器。<ul><li>与普通指针相同，<code>*(v.begin()+i)</code> 可以访问下标 i 的元素。</li><li>与普通数组相同，使用 sort 排序时，必须要用 <code>sort(v.begin(),v.end());</code></li></ul></li><li><code>v.front()</code> 与 <code>v.back()</code> 返回的是元素的<strong>引用</strong>，可以赋值给<strong>别名变量</strong>（浅拷贝）或普通变量（深拷贝）。<ul><li>引用是 C++ 特有的语法，声明引用变量 <code>int &amp;a=v.front();</code> 时，共享同一内存单元。</li><li>类似的还有随机访问 <code>v.at(i)</code> 和数组运算符 <code>v[i]</code>，也可以赋值给别名变量或普通变量。</li></ul></li><li>vector 作为函数的参数或者返回值时，必须用 <code>&amp;</code> <strong>传引用调用</strong>：<ul><li><code>double Distance(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b)</code></li><li>注意<strong>普通数组传引用</strong>调用时需要<strong>带个数</strong>：<code>(int (&amp;a)[10])</code>，传指针不需要：<code>(int *a)</code> 或 <code>(int a[])</code></li></ul></li><li>能够存放任意类型，意味着可以嵌套其他数据结构：<ul><li>定义二维动态数组：<code>vector&lt;vector&lt;int&gt;&gt; v;</code></li><li>定义静态数组内一维动态数组：<code>vector&lt;int&gt; a[100];</code>，可用于邻接表。</li><li>定义结构体数组：<code>vector&lt;Student&gt; v;</code>，结构体需要全局定义。</li><li>两个存放相同类型元素的向量可以使用<strong>比较运算符</strong>，依据字典序逐个比较。</li></ul></li><li>vector 的 push_back() 代价虽然是均摊的 O(1)，但是当数据量大的时候会很慢。所以如果需要使用的话，可以用 <code>vector&lt;int&gt; v(n);</code> 初始化再赋值。</li><li>批量赋<strong>递增值</strong>：<code>iota(v.begin(), v.end(), 0);</code>，其中 <code>0</code> 代表首个元素值，赋值后的向量元素为 $\{0, 1, 2,\cdots\}$。常用于<strong>不改变原数组顺序的伪排序</strong>。</li></ul><h2 id="配对-pair"><a href="#配对-pair" class="headerlink" title="配对 | pair"></a>配对 | pair</h2><p>pair 可以将<strong>两个任意类型</strong>的元素绑定成一组元素，其内部实现就是一个 <code>template&lt;class T1,class T2&gt;</code> 的结构体。可以用来组成更高级的映射 map，也可以用来表示<strong>坐标</strong>等双元素的结构体。当一个函数需要返回两个数据的时候，可以选择 pair。</p><h3 id="基础操作-2"><a href="#基础操作-2" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li>头文件 <code>#include&lt;utility&gt;</code></li><li>创建 pair 对象：<ul><li>直接创建：<code>pair&lt;int,int&gt; p;</code>（实际中通常会 <code>typedef pair&lt;int,int&gt; pii;</code>）</li><li>创建并赋值：<code>pair&lt;int,int&gt; p(3,4);</code></li><li>使用 C++ 括号运算符赋值：<code>pair&lt;int,int&gt; p = &#123;3，4&#125;;</code></li><li>先创建后赋值：<code>p = make_pair(3,4);</code></li></ul></li><li>访问对象：<ul><li>等价于结构体变量：<code>cout &lt;&lt; p.first &lt;&lt; &#39; &#39; &lt;&lt; p.second;</code>（注意不是指针）</li></ul></li><li>嵌套：<ul><li>三元 pair：<code>pair&lt;int, pair&lt;int, int&gt;&gt; p(1,&#123;2,3&#125;);</code></li><li>其他容器：<code>vector&lt;pair&lt;int, int&gt;&gt;</code>（实际中通常会 <code>vector&lt;pii&gt; v</code>）</li></ul></li></ul><h3 id="特殊性质-2"><a href="#特殊性质-2" class="headerlink" title="特殊性质"></a>特殊性质</h3><ul><li><p>在某些情况函数想要返回两个数据时，可以将 pair 对象作为返回值，此时函数外接收的对象可以是 pair，也可以直接通过 std::tie 进行接收：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">pair&lt;string, <span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getPreson</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Steve&quot;</span>, <span class="hljs-number">25</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	string name; <span class="hljs-keyword">int</span> ages;<br>	<span class="hljs-built_in">tie</span>(name, ages) = <span class="hljs-built_in">getPreson</span>(); <span class="hljs-comment">// 类似 Python 中的元组解包</span><br>	cout &lt;&lt; <span class="hljs-string">&quot;name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;, ages: &quot;</span> &lt;&lt; ages &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组 | tuple"></a>元组 | tuple</h2><p>C++11 引入的 tuple 可以将<strong>多个任意类型</strong>的元素绑定成一组元素，是泛化的 pair。通常将其当作一个简易的结构体使用，避免复杂的声明，用法与 pair 非常类似。</p><h3 id="基础操作-3"><a href="#基础操作-3" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li>头文件 <code>#include&lt;tuple&gt;</code></li><li>创建 tuple 对象：<ul><li>直接创建：<code>tuple&lt;int,int,int&gt; tup;</code></li><li>创建并赋值：<code>tuple&lt;int,int,int&gt; tup(1, 2, 3);</code></li><li>创建并使用函数赋值：<code>tuple&lt;int,int,int&gt;tup = make_tuple(1, 2, 3);</code> 和 pair 不同，这里的<strong>创建步骤不能省略</strong>！</li></ul></li><li>访问对象（注意<strong>不要漏掉括号</strong>）：<ul><li>get 函数：<code>cout &lt;&lt; get&lt;0&gt;(tup) &lt;&lt; &#39; &#39;&lt;&lt; get&lt;1&gt;(tup);</code>，返回的是元素的引用，因此可以修改</li></ul></li><li>元组解包：<ul><li>主动声明变量：<code>tie(a, b, c) = tup;</code></li><li>自动声明变量：<code>auto&amp; [a, b, c] = tup;</code> 如果某个元素不需要用到，可以用 <code>_</code> 代替</li></ul></li><li>嵌套到其他容器（以向量为例）：<ul><li>声明：<code>vector&lt;tuple&lt;int, int, int&gt;&gt; tups;</code></li><li>插入：<code>tups.push_back(make_tuple(1, 2, 3))</code> 或 <code>tups.emplace_back(1, 2, 3);</code></li></ul></li></ul><h2 id="映射-map"><a href="#映射-map" class="headerlink" title="映射 | map"></a>映射 | map</h2><p>map 是一个存放<strong>一对一映射</strong>（pair）的关联容器，存储的<strong>关键字和值</strong>可以定义为任意类型，各个键值对的<strong>键互不相同且不允许被修改</strong>，但值可以相同。</p><p>map 的内部实现为<strong>红黑树</strong>（弱平衡二叉树），是二叉搜索树的升级版，具有对数据进行<strong>排序</strong>的功能。因此我们可以认为 map 内部所有键值对都是按 key 排序的，key 必须为<strong>可排序的类型</strong>（包括自定义类型）。</p><p>需要强调的是，map 中对元素增删改查的时间复杂度都是 $O(\log n)$，但使用迭代器遍历 map 的复杂度是 $O(n)$。</p><h3 id="基础操作-4"><a href="#基础操作-4" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li><p>头文件 <code>#include&lt;map&gt;</code></p></li><li><p>创建 map 对象：</p><ul><li>直接创建：<code>map&lt;string,int&gt; mp;</code></li><li>创建并初始化：<code>map&lt;string,int&gt; mp=&#123;&#123;"A", 10&#125;, &#123;"B", 20&#125;, &#123;"C", 30&#125;&#125;;</code></li></ul></li><li><p>插入元素：</p><ul><li>用 insert 函数插入 pair：<code>mp.insert(pair&lt;string, int&gt;(&quot;hw&quot;, 2001));</code> 通常会结合 typedef 简化；</li><li>前者也可以用 make_pair 替换：<code>mp.insert(make_pair(&quot;hw&quot;, 2001));</code></li><li>C++ 11 标准支持<strong>花括号初始化</strong>：<code>mp.insert(&#123;&quot;hw&quot;, 2001&#125;);</code></li><li>用 insert 函数插入 value_type 数据：<code>mp.insert(map&lt;string, int&gt;::value_type(&quot;hw&quot;, 2001));</code></li><li>用数组运算符<strong>访问并插入</strong>（最常用）：<code>mp[“hw”]=2001;</code>，此时<strong>不受唯一性限制</strong>，可以覆盖已有的键值对；</li></ul></li><li><p>删除元素（erase 函数）：</p><ul><li>删除迭代器指向元素：<code>auto it=mp.find(&quot;hw&quot;); mp.erase(it);</code></li><li>删除关键字：<code>bool flag = mp.erase(&quot;hw&quot;);</code> 如果找到并删除则返回 1，否则返回 0</li><li>删除迭代器指向区间元素：<code>mp.erase(++mp.begin(), mp.end());</code></li></ul></li><li><p>特性函数：</p><ul><li>键值对数目：<code>mp.size()</code></li><li>清空：<code>mp.clear();</code></li><li>判断空：<code>mp.empty()</code></li></ul></li><li><p>访问元素：</p><ul><li><p>随机访问成员：<code>mp.at(&quot;hw&quot;)</code>，返回元素的引用，如果访问到<strong>未知元素会抛出异常</strong>。</p></li><li><p>数组运算符访问：<code>cout &lt;&lt; mp[&quot;hw”];</code>，返回元素的引用，如果访问到未知元素会返回一个<strong>全零的空值</strong>！</p></li><li><p>查找元素：<code>auto it=mp.find(&quot;hw&quot;);</code> 返回指向元素的迭代器，如果没找到，则返回 <code>mp.end()</code>；此外，如果想<strong>判断一个元素是否存在</strong>，可以直接 <code>mp.count(&quot;hw&quot;) != 0</code>，该值在 map 和 set 中只能为 0 或 1。</p></li><li><p>迭代访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 声明迭代器，此时的 it 类似结构体指针</span><br>map&lt;string,<span class="hljs-keyword">int</span>&gt;::iterator it; 				<span class="hljs-comment">// 这里可以换成 auto</span><br><span class="hljs-keyword">for</span>(it=mp.<span class="hljs-built_in">begin</span>(); it!=mp.<span class="hljs-built_in">end</span>(); it++)<br>    cout&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;it-&gt;second&lt;&lt;endl; <span class="hljs-comment">// 不能直接 * 访问</span><br><br><span class="hljs-comment">// C++11 新语法，此时的 item 类似结构体</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;item: mp)<br>    cout&lt;&lt;item.first&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;item.second&lt;&lt;endl; <span class="hljs-comment">// 结构体直接用 . 访问属性</span><br><br><span class="hljs-comment">// 反向迭代访问</span><br>map&lt;string,<span class="hljs-keyword">int</span>&gt;::reverse_iterator it;<br><span class="hljs-keyword">for</span>(it = mp.<span class="hljs-built_in">rbegin</span>(); it != mp.<span class="hljs-built_in">rend</span>(); it++)<br>    cout&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="特殊性质-3"><a href="#特殊性质-3" class="headerlink" title="特殊性质"></a>特殊性质</h3><ul><li>map、set、multimap、multiset 的迭代器是没有加减法的，仅支持自增 <code>it++</code>、自减 <code>it--</code> 的操作，不支持 <code>it+1</code>、<code>mp.begin()+1</code> 操作。这是因为这些容器采用了特殊的数据结构，没有「<strong>两个元素之距离</strong>」的概念。</li><li>采用迭代器遍历 map、set 的复杂度是 $O(n)$，这是因为二叉树的遍历是 $O(E)$，每一条边只会被自上而下、自下而上各访问一次。</li><li>由于内部有序，map 和 set 支持 <code>mp.lower_bound(key)</code> 、<code>mp.upper_bound(key)</code>、<code>equal_range(key)</code> 运算，返回指向特定结构体的迭代器指针。但是考虑到 map 和 set 中都不会有重复的 key，此方法在 multimap、multiset 更常用。</li><li>map 和 set 的插入删除，并不会使已经赋值的 iterator 失效，这是因为插入删除<strong>不会改变内部的树结构</strong>，不需要进行内存拷贝和移动；但是对于 vector 而言，每次插入删除<strong>都可能使其失效</strong>，即使是调用 push_back 的尾部插入，除了因为连续存放导致的内存平移，还可能涉及到容量倍增等操作。牢记一个原则：<strong>不要使用过期的迭代器</strong>。</li></ul><h3 id="哈希表-unordered-map"><a href="#哈希表-unordered-map" class="headerlink" title="哈希表 | unordered_map"></a>哈希表 | unordered_map</h3><p>如果只是需要一个映射关系，而不需要其有序，可以用 unordered_map。和 map 容器相似，unordered_map 同样以<strong>键值对</strong>（pair）的形式存储数据，存储的各个键值对的<strong>键互不相同且不允许被修改</strong>。</p><p>无序映射的底层采用<strong>哈希表</strong>存储结构，根据键的 hash 值来判断元素是否相同，不具有对数据的排序功能，但可以实现 $O(1)$ 查找、插入。由于无序，不支持 <code>lower_bound()</code> 和 <code>upper_bound()</code> 等方法。</p><p>常用的操作与 map 类似：</p><ul><li><p>头文件 <code>#include &lt;unordered_map&gt;</code></p></li><li><p>创建 unordered_map 对象：<code>unordered_map&lt;string,int&gt; hash;</code></p></li><li><p>$O(1)$ 插入元素（最常用）：<code>hash[&quot;ABC&quot;]=5;</code></p></li><li><p>$O(1)$ 查询元素（最常用）：<code>int n=hash[&quot;ABC&quot;];</code></p></li><li><p>判断关键字是否存在：<code>hash.count(&quot;ABC&quot;) != 0</code> 或 <code>hash.find(&quot;ABC&quot;) != hash.end()</code>，前者更为常用。</p></li><li><p>迭代访问（较少用）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 声明迭代器，此时的 it 为结构体指针</span><br>unordered_map&lt;string,<span class="hljs-keyword">int</span>&gt;::iterator it;<br><span class="hljs-keyword">for</span>(it=hash.<span class="hljs-built_in">begin</span>(); it!=hash.<span class="hljs-built_in">end</span>(); it++)<br>    cout&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;<br><br><span class="hljs-comment">// C++11 新语法，此时的 item 为结构体</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item: hash)<br>    cout&lt;&lt;item.first&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;item.second&lt;&lt;endl;<br></code></pre></td></tr></table></figure></li></ul><p>如果想让自定义的 class 作为 key 来使用 unordered_map，则还自行需要实现：重载<strong>哈希函数</strong>、判断两个 class 变量是否相等的函数（重载<strong>等价运算符</strong>）。</p><blockquote><p>哈希集合 unordered_set 有时也会用到，方法类似，不再单独介绍。</p></blockquote><h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><p>具有和 map 相同的诸多特性，最主要的区别在于，multimap 容器中可以同时存储<strong>多个键相同的键值对</strong>。</p><p>和 map 相比，multimap 未提供 <code>at()</code> 成员方法，也没有重载 <code>[]</code> 运算符。这意味着，map 容器中通过指定键获取键值对的方式，将不再适用于 multimap 容器。其实这很好理解，因为 multimap 容器中指定的键可能对应多个键值对，而不再是 1 个。</p><p>值的一提的是，由于 multimap 可存储多个具有相同键的键值对，因此 <code>lower_bound()</code>、<code>upper_bound()</code>、<code>equal_range()</code> 以及 <code>count()</code> 方法会经常用到。</p><h2 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 | set"></a>集合 | set</h2><p>set 是一个存放同一类型元素的<strong>集合</strong>容器，满足数学定义上集合的<strong>互异性</strong>——即 set 中每个元素只能出现一次。其内部实现也为红黑树，因此能根据元素的值自动进行排序。</p><p>set 中对元素增删改查的时间复杂度都是 $O(\log n)$，但使用迭代器遍历 set 的复杂度是 $O(n)$。</p><h3 id="基础操作-5"><a href="#基础操作-5" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li><p>头文件 <code>#include&lt;set&gt;</code></p></li><li><p>创建 set 对象：</p><ul><li>直接创建：<code>set&lt;int&gt; st;</code></li><li>创建并初始化：<code>set&lt;int&gt; st=&#123;1, 2, 3, 4&#125;;</code></li><li>创建并拷贝：<code>set&lt;int&gt; new_st(st);</code></li></ul></li><li><p>插入、删除元素：</p><ul><li>插入一个元素：<code>st.insert(3);</code></li><li>删除一个元素：<code>st.erase(3);</code></li><li>删除迭代器指向元素：<code>auto it=st.find(3); st.erase(it);</code></li><li>删除区间内的元素：<code>st.erase(++st.begin(), st.end());</code></li></ul></li><li><p>特性函数：</p><ul><li>元素个数：<code>st.size();</code></li><li>清空集合：<code>st.clear();</code></li><li>判断空：<code>st.empty();</code></li></ul></li><li><p>访问元素：</p><ul><li><p>查找元素：<code>auto it=st.find(&quot;hw&quot;);</code> 返回指向元素的迭代器，如果没找到，则返回 <code>st.end()</code>；此外，如果想<strong>判断一个元素是否存在</strong>，可以直接 <code>st.count(&quot;hw&quot;) != 0</code>，该值在 map 和 set 中只能为 0 或 1。</p></li><li><p>有序性：<code>st.lower_bound(2)</code>、<code>st.upper_bound(2)</code>，返回指向特定结构体的迭代器指针。</p></li><li><p>迭代访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 声明迭代器，此时的 it 类似指针</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=st.<span class="hljs-built_in">begin</span>(); it!=st.<span class="hljs-built_in">end</span>(); it++)<br>    cout&lt;&lt;*it&lt;&lt;endl; 	<span class="hljs-comment">// 访问指针指向的元素，有 *</span><br><br><span class="hljs-comment">// C++11 新语法，此时的 item 为元素本身</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;item: st)<br>    cout&lt;&lt;item&lt;&lt;endl; 	<span class="hljs-comment">// 不需要 *</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="特殊性质-4"><a href="#特殊性质-4" class="headerlink" title="特殊性质"></a>特殊性质</h3><ul><li><p>map 和 set 本身都是以升序排列，但是对于 set 而言有时候会改变其排序的方式，也可能引入结构体，因此需要用到自定义比较函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 元素不是结构体，重载 () 运算符</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span>&#123;</span><br>	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp;a, <span class="hljs-keyword">const</span> T &amp;b)</span></span>&#123;<br>		<span class="hljs-keyword">return</span> a.data &gt; b.data;<br>    &#125;<br>&#125;<br>set&lt;T, cmp&gt; st;<br><br><span class="hljs-comment">// 元素是结构体，直接将比较函数写在结构体内</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Info</span>&#123;</span><br>	string name;<br>	<span class="hljs-keyword">float</span> score;<br>	<span class="hljs-comment">// 重载 &lt; 操作符，自定义排序规则	</span><br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> Info &amp;a) <span class="hljs-keyword">const</span>&#123;<br>		<span class="hljs-comment">// 按 score 从大到小排列</span><br>        <span class="hljs-keyword">return</span> a.score &lt; score;<br>    &#125;<br>&#125;<br>set&lt;Info&gt; s;<br></code></pre></td></tr></table></figure></li></ul><h3 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h3><p>multiset 使用频率相对较低，其和 set 的区别在于，multiset 容器中可以同时存储<strong>多个相同的元素</strong>，不再有互异性。</p><p>但是由于 set 结构的有序性，当我们需要一个「<strong>时刻有序的数组</strong>」时，支持 $O(\log n)$ 地插入、删除、修改数组元素后<strong>依然保持有序</strong>，multiset 就会派上用场。经常结合 <code>lower_bound()</code>、<code>upper_bound()</code> 使用。</p><h2 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 | stack"></a>栈 | stack</h2><p>从一段进栈，从同一端出栈，满足后进先出（LIFO）。</p><h3 id="基础操作-6"><a href="#基础操作-6" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li>头文件 <code>include&lt;stack&gt;</code></li><li>创建 stack 对象：<code>stack&lt;int&gt; s;</code></li><li>操作元素：<ul><li>栈顶压入元素：<code>s.push(x);</code></li><li>栈顶弹出元素：<code>s.pop();</code>，注意此时<strong>没有返回值</strong>；</li><li>返回栈顶元素：<code>s.top()</code>，返回<strong>元素的引用，因此可以直接修改</strong>。</li></ul></li><li>特性函数：<ul><li>栈长度：<code>s.size()</code></li><li>判断栈空：<code>s.empty()</code></li></ul></li></ul><h3 id="特殊性质-5"><a href="#特殊性质-5" class="headerlink" title="特殊性质"></a>特殊性质</h3><ul><li>当栈为空的时候，如果调用 <code>s.top()</code> 则出现<strong>数组越界</strong>报错，解决办法是在使用该方法前加一个栈空判断：<code>!s.empty() &amp;&amp; s.top()</code>。该方法同样适用于队列、向量等容器。</li><li>C++11 新增 <code>s.emplace(x)</code> 操作，用于在栈顶压入元素，参数为<strong>直接对象</strong>时相当于 <code>s.push(x)</code>，区别在于当参数为<strong>构造函数对象</strong>时，例如 <code>s.push(data(x,y))</code> 和 <code>s.emplace(data(x,y))</code> 时，此时后者可以简化为 <code>s.emplace(x,y)</code>。</li></ul><h2 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列 | queue"></a>队列 | queue</h2><p>从一端入队，从另一端出队，满足先进先出（FIFO）的结构。普通的队列基于链表结构实现，而优先队列基于堆结构实现。</p><h3 id="基础操作-7"><a href="#基础操作-7" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li>头文件 <code>#include&lt;queue&gt;</code></li><li>创建 queue 对象：<code>queue&lt;int&gt; q;</code></li><li>操作元素：<ul><li>队尾插入元素：<code>q.push();</code></li><li>队首弹出元素：<code>q.pop();</code>，注意此时<strong>没有返回值</strong>；</li><li>返回队首元素：<code>q.front()</code>，返回<strong>元素的引用，因此可以直接修改</strong>；</li><li>返回队尾元素：<code>q.back()</code>，返回元素的引用，因此可以直接修改。</li></ul></li><li>特性函数：<ul><li>队列长度：<code>q.size();</code></li><li>判断队空：<code>q.empty();</code></li><li>注意队列和栈都没有 clear 函数，想要清空只能重新初始化：<code>q = queue&lt;int&gt; ();</code></li></ul></li></ul><h3 id="优先队列-priority-queue"><a href="#优先队列-priority-queue" class="headerlink" title="优先队列 | priority_queue"></a>优先队列 | priority_queue</h3><p>利用自带的优先队列可以实现最大堆和最小堆，其<strong>头文件和队列相同</strong>，特性函数也相同。此时优先级最高的先出队，默认情况下优先级就是「整数的大小」。出入队的复杂度为 $O(\log n)$，$n$ 为队列的大小。下面介绍基础的用法：</p><ul><li>创建 priority_queue 对象：<ul><li>优先队列有<strong>三个参数</strong>，其声明形式为：<code>priority_queue&lt;类型, vector&lt;类型&gt;, less&lt;类型&gt;&gt;</code>，后两个参数可以省略，第一个参数不能省略，三个 <code>类型</code> 保持一致。</li><li>构建最大堆（大顶堆）：<code>priority_queue&lt;int&gt; max_heap;</code> 或 <code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; max_heap;</code></li><li>构建最小堆（小顶堆）：<code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; min_heap;</code></li></ul></li></ul><ul><li>操作元素：<ul><li>在完全二叉树的底部插入元素，并上浮到相应位置：<code>heap.push();</code></li><li>从堆顶弹出元素，并填充二叉树底部元素，然后下滤到相应位置：<code>heap.pop();</code></li><li>返回堆顶元素：<code>heap.top()</code>，注意和普通队列的区别！</li></ul></li></ul><p>如果想自定义其他优先级，则需要在<strong>自定义结构体</strong> cmp 中重载括号运算符 <code>()</code>，使其变成<strong>仿函数</strong>（Functor），并替换 <code>less&lt;类型&gt;</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span>&#123;</span><br>	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp;a, <span class="hljs-keyword">const</span> T &amp;b)</span></span>&#123;<br>		<span class="hljs-keyword">return</span> a.data &lt; b.data;<br>    &#125;<br>&#125;;<br>priority_queue&lt;T, vector&lt;T&gt;, cmp&gt; heap; <br></code></pre></td></tr></table></figure><p>或者在主函数外<strong>自定义比较函数</strong> cmp（类似 sort 的写法），再用 <code>decltype</code> 进行<strong>类型自动推断</strong>（转为仿函数）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">comp</span><span class="hljs-params">(T &amp;a, T &amp;b)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> a.data &gt; b.data;<br>&#125;<br>priority_queue&lt;T ,vector&lt;T&gt;, <span class="hljs-keyword">decltype</span>(&amp;cmp)&gt; <span class="hljs-built_in">heap</span>(cmp);<br></code></pre></td></tr></table></figure><h2 id="双端队列-deque"><a href="#双端队列-deque" class="headerlink" title="双端队列 | deque"></a>双端队列 | deque</h2><p>具备栈和队列的功能，但是操作要慢一点（常数级）。在实际使用中可以和 vector 类比，vector 的优势是对<strong>中间</strong>的操作速度快（例如索引遍历、迭代器遍历），deque 优势是对<strong>首端</strong>的操作速度快（例如删除头部）。在对尾端操作上（例如尾端插入），二者速度相仿。</p><p>在实际应用中，常用于实现单调队列、滑动窗口等算法。</p><h3 id="基础操作-8"><a href="#基础操作-8" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li>头文件 <code>#include &lt;deque&gt;</code></li><li>创建 deque 对象：<code>deque&lt;int&gt; dq;</code></li><li><p>操作元素：</p><ul><li>返回队首元素：<code>dq.front();</code></li><li>返回队尾元素：<code>dq.back();</code></li><li>队首插入一个元素：<code>dq.push_front();</code></li><li>队尾插入一个元素：<code>dq.push_back();</code></li><li>队首弹出一个元素：<code>dq.pop_front();</code></li><li>队尾弹出一个元素：<code>dq.pop_back();</code></li></ul></li><li><p>特性函数：</p><ul><li>双端队列长度：<code>dq.size();</code></li><li>判断队空：<code>dq.empty();</code></li><li>清空队列：<code>dq.clear();</code></li><li>返回指向第一个元素和最后一个元素的指针（只能赋值给迭代器）：<code>v.begin()</code>、 <code>v.end()</code></li></ul></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" class="category-chain-item">算法笔记</a> <span>></span> <a href="/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/" class="category-chain-item">算法入门</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Algorithm/">#Algorithm</a></div></div><div class="license-box my-3"><div class="license-title"><div>算法入门笔记 #2 STL标准库</div><div>https://hwcoder.top/Algo-Note-2</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>He Wei</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年8月27日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/BaoYan-Memoir" title="2022年保研回忆录"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">2022年保研回忆录</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/Algo-Note-1" title="算法入门笔记 #1 杂记"><span class="hidden-mobile">算法入门笔记 #1 杂记</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.16/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"jdbBr3BddTiqSCPnXw6sXFv7-gzGzoHsz","appKey":"2bjgwDr2opjVCwhgjDMpk53c","path":"window.location.pathname","placeholder":"说点什么吧( •̀ ω •́ )✧","avatar":"retro","meta":["nick","mail","link"],"requiredFields":["nick"],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-t}),0<o.find(".toc-list-item").length&&o.css("visibility","visible"))})</script><script>!function(){var i,t=CONFIG.code_language.enable&&CONFIG.code_language.default,c=CONFIG.copy_btn;(t||c)&&(i="",i+='<div class="code-widget">',i+="LANG",i+="</div>",jQuery(".markdown-body pre").each(function(){var e,a,n=jQuery(this);0<n.find("code.mermaid").length||0<n.find("span.line").length||(e="",t&&(e=CONFIG.code_language.default,0<n[0].children.length&&2<=n[0].children[0].classList.length&&n.children().hasClass("hljs")?e=n[0].children[0].classList[1]:n[0].getAttribute("data-language")?e=n[0].getAttribute("data-language"):n.parent().hasClass("sourceCode")&&0<n[0].children.length&&2<=n[0].children[0].classList.length?(e=n[0].children[0].classList[1],n.parent().addClass("code-wrapper")):n.parent().hasClass("markdown-body")&&0===n[0].classList.length&&n.wrap('<div class="code-wrapper"></div>'),e=e.toUpperCase().replace("NONE",CONFIG.code_language.default)),n.append(i.replace("LANG",e).replace('code-widget">',(a=n[0],(0<=Fluid.utils.getBackgroundLightness(a)?"code-widget-light":"code-widget-dark")+(c?' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>':' code-widget">')))),c&&Fluid.utils.createScript("https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js",function(){new window.ClipboardJS(".copy-btn",{target:function(e){for(var a=e.parentNode.childNodes,n=0;n<a.length;n++)if("CODE"===a[n].tagName)return a[n]}}).on("success",function(e){e.clearSelection(),e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-copy","icon-success"),setTimeout(function(){e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-success","icon-copy")},2e3)})}))}))}()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script>MathJax = {
          tex    : {
            inlineMath: { '[+]': [['$', '$']] }
          },
          loader : {
            load: ['ui/lazy']
          },
          options: {
            renderActions: {
              findScript    : [10, doc => {
                document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                  const display = !!node.type.match(/; *mode=display/);
                  const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                  const text = document.createTextNode('');
                  node.parentNode.replaceChild(text, node);
                  math.start = { node: text, delim: '', n: 0 };
                  math.end = { node: text, delim: '', n: 0 };
                  doc.math.push(math);
                });
              }, '', false],
              insertedScript: [200, () => {
                document.querySelectorAll('mjx-container').forEach(node => {
                  let target = node.parentNode;
                  if (target.nodeName.toLowerCase() === 'li') {
                    target.parentNode.classList.add('has-jax');
                  }
                });
              }, '', false]
            }
          }
        };</script><script src="https://lib.baomitu.com/mathjax/3.2.0/es5/tex-svg-full.js"></script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>