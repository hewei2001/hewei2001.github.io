<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg"><link rel="icon" href="/img/logo.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#01213a"><meta name="author" content="Wei He"><meta name="keywords" content="Computer Science and Technology, Machine Learning, Deep Learning, Computer Vision, Natural Language Processing"><meta name="description" content="「数理逻辑」课程笔记，内容偏应试风格，主要包括：命题逻辑、三大系统中定理的证明、谓词逻辑。"><meta property="og:type" content="article"><meta property="og:title" content="数理逻辑 应试笔记"><meta property="og:url" content="https://hwcoder.top/Mathematical-Logic"><meta property="og:site_name" content="Hwcoder - Life Oriented Programming"><meta property="og:description" content="「数理逻辑」课程笔记，内容偏应试风格，主要包括：命题逻辑、三大系统中定理的证明、谓词逻辑。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hwcoder.top/img/home/Mathematical-Logic.jpg"><meta property="article:published_time" content="2021-08-27T12:23:04.000Z"><meta property="article:modified_time" content="2022-05-19T03:54:34.000Z"><meta property="article:author" content="Wei He"><meta property="article:tag" content="Math"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://hwcoder.top/img/home/Mathematical-Logic.jpg"><title>数理逻辑 应试笔记 | Hwcoder - Life Oriented Programming</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/mac.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"hwcoder.top",root:"/",version:"1.9.5",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h2, h3",placement:"left",visible:"always",icon:"§"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4",collapseDepth:3},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"XGNf4GEnaFLiUijMUvz8HSBF-gzGzoHsz",app_key:"JPeVLcug6EcWdBTpGrDJSdKi",server_url:"https://xgnf4gen.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")})</script><meta name="generator" content="Hexo 5.4.2"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Hwcoder</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/bg/other.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="数理逻辑 应试笔记"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-08-27 20:23" pubdate>2021年8月27日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 11k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 62 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="学习笔记" id="heading-078425eaf316a180b0989442e53f920b" role="tab" data-toggle="collapse" href="#collapse-078425eaf316a180b0989442e53f920b" aria-expanded="true">学习笔记 <span class="list-group-count">(42)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-078425eaf316a180b0989442e53f920b" role="tabpanel" aria-labelledby="heading-078425eaf316a180b0989442e53f920b"><div class="category-post-list"></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="信息检索" id="heading-b10f39c13b5f9af517dfde91c4da0ec4" role="tab" data-toggle="collapse" href="#collapse-b10f39c13b5f9af517dfde91c4da0ec4" aria-expanded="false">信息检索 <span class="list-group-count">(11)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-b10f39c13b5f9af517dfde91c4da0ec4" role="tabpanel" aria-labelledby="heading-b10f39c13b5f9af517dfde91c4da0ec4"><div class="category-post-list"><a href="/IR-Note-1" title="IR学习笔记 #01 概论&amp;布尔模型" class="list-group-item list-group-item-action"><span class="category-post">IR学习笔记 #01 概论&amp;布尔模型</span> </a><a href="/IR-Note-2" title="IR学习笔记 #02 统计语言模型" class="list-group-item list-group-item-action"><span class="category-post">IR学习笔记 #02 统计语言模型</span> </a><a href="/IR-Note-3" title="IR学习笔记 #03 向量空间模型" class="list-group-item list-group-item-action"><span class="category-post">IR学习笔记 #03 向量空间模型</span> </a><a href="/IR-Note-4" title="IR学习笔记 #04 概率模型" class="list-group-item list-group-item-action"><span class="category-post">IR学习笔记 #04 概率模型</span> </a><a href="/IR-Note-5" title="IR学习笔记 #05 检索系统评价" class="list-group-item list-group-item-action"><span class="category-post">IR学习笔记 #05 检索系统评价</span> </a><a href="/IR-Note-6" title="IR学习笔记 #06 网络信息检索" class="list-group-item list-group-item-action"><span class="category-post">IR学习笔记 #06 网络信息检索</span> </a><a href="/IR-Note-7" title="IR学习笔记 #07 IRLbot" class="list-group-item list-group-item-action"><span class="category-post">IR学习笔记 #07 IRLbot</span> </a><a href="/IR-Note-8" title="IR学习笔记 #08 倒排索引模型" class="list-group-item list-group-item-action"><span class="category-post">IR学习笔记 #08 倒排索引模型</span> </a><a href="/IR-Note-9" title="IR学习笔记 #09 网页排序" class="list-group-item list-group-item-action"><span class="category-post">IR学习笔记 #09 网页排序</span> </a><a href="/IR-Note-10" title="IR学习笔记 #10 查询相关反馈" class="list-group-item list-group-item-action"><span class="category-post">IR学习笔记 #10 查询相关反馈</span> </a><a href="/IR-Note-11" title="IR学习笔记 #11 问答系统" class="list-group-item list-group-item-action"><span class="category-post">IR学习笔记 #11 问答系统</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="强化学习" id="heading-6964a39570837d485ed73b611a392391" role="tab" data-toggle="collapse" href="#collapse-6964a39570837d485ed73b611a392391" aria-expanded="false">强化学习 <span class="list-group-count">(9)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-6964a39570837d485ed73b611a392391" role="tabpanel" aria-labelledby="heading-6964a39570837d485ed73b611a392391"><div class="category-post-list"><a href="/RL-Note-1" title="RL 学习笔记 #1 基本概念" class="list-group-item list-group-item-action"><span class="category-post">RL 学习笔记 #1 基本概念</span> </a><a href="/RL-Note-2" title="RL 学习笔记 #2 贝尔曼公式" class="list-group-item list-group-item-action"><span class="category-post">RL 学习笔记 #2 贝尔曼公式</span> </a><a href="/RL-Note-3" title="RL 学习笔记 #3 值迭代和策略迭代" class="list-group-item list-group-item-action"><span class="category-post">RL 学习笔记 #3 值迭代和策略迭代</span> </a><a href="/RL-Note-4" title="RL 学习笔记 #4 蒙特卡洛学习算法" class="list-group-item list-group-item-action"><span class="category-post">RL 学习笔记 #4 蒙特卡洛学习算法</span> </a><a href="/RL-Note-5" title="RL 学习笔记 #5 随机近似与随机梯度下降" class="list-group-item list-group-item-action"><span class="category-post">RL 学习笔记 #5 随机近似与随机梯度下降</span> </a><a href="/RL-Note-6" title="RL 学习笔记 #6 时序差分学习算法" class="list-group-item list-group-item-action"><span class="category-post">RL 学习笔记 #6 时序差分学习算法</span> </a><a href="/RL-Note-7" title="RL 学习笔记 #7 值函数近似和 DQN 算法" class="list-group-item list-group-item-action"><span class="category-post">RL 学习笔记 #7 值函数近似和 DQN 算法</span> </a><a href="/RL-Note-8" title="RL 学习笔记 #8 策略梯度方法" class="list-group-item list-group-item-action"><span class="category-post">RL 学习笔记 #8 策略梯度方法</span> </a><a href="/RL-Note-9" title="RL 学习笔记 #9 Actor-Critic 方法" class="list-group-item list-group-item-action"><span class="category-post">RL 学习笔记 #9 Actor-Critic 方法</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem list-group-item category-item-action col-10 col-md-11 col-xm-11" title="本科课程" id="heading-d577b913fa605a2342ab24bd1b0bea8b" role="tab" data-toggle="collapse" href="#collapse-d577b913fa605a2342ab24bd1b0bea8b" aria-expanded="true">本科课程 <span class="list-group-count">(4)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-d577b913fa605a2342ab24bd1b0bea8b" role="tabpanel" aria-labelledby="heading-d577b913fa605a2342ab24bd1b0bea8b"><div class="category-post-list"><a href="/Database-System" title="数据库系统 应试笔记" class="list-group-item list-group-item-action"><span class="category-post">数据库系统 应试笔记</span> </a><a href="/Mathematical-Logic" title="数理逻辑 应试笔记" class="list-group-item list-group-item-action active"><span class="category-post">数理逻辑 应试笔记</span> </a><a href="/Software-Engineering-1" title="软件工程 应试笔记 #1" class="list-group-item list-group-item-action"><span class="category-post">软件工程 应试笔记 #1</span> </a><a href="/Software-Engineering-2" title="软件工程 应试笔记 #2" class="list-group-item list-group-item-action"><span class="category-post">软件工程 应试笔记 #2</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="机器学习" id="heading-61bb1751fd355596e307767d1927c855" role="tab" data-toggle="collapse" href="#collapse-61bb1751fd355596e307767d1927c855" aria-expanded="false">机器学习 <span class="list-group-count">(13)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-61bb1751fd355596e307767d1927c855" role="tabpanel" aria-labelledby="heading-61bb1751fd355596e307767d1927c855"><div class="category-post-list"><a href="/ML-Note-1" title="ML学习笔记 #01 梯度下降：一元线性回归" class="list-group-item list-group-item-action"><span class="category-post">ML学习笔记 #01 梯度下降：一元线性回归</span> </a><a href="/ML-Note-2" title="ML学习笔记 #02 梯度下降：多元线性回归" class="list-group-item list-group-item-action"><span class="category-post">ML学习笔记 #02 梯度下降：多元线性回归</span> </a><a href="/ML-Note-3" title="ML学习笔记 #03 正规方程：多元线性回归" class="list-group-item list-group-item-action"><span class="category-post">ML学习笔记 #03 正规方程：多元线性回归</span> </a><a href="/ML-Note-4" title="ML学习笔记 #04 逻辑回归：二分类到多分类" class="list-group-item list-group-item-action"><span class="category-post">ML学习笔记 #04 逻辑回归：二分类到多分类</span> </a><a href="/ML-Note-5" title="ML学习笔记 #05 过拟合与正则化" class="list-group-item list-group-item-action"><span class="category-post">ML学习笔记 #05 过拟合与正则化</span> </a><a href="/ML-Note-6" title="ML学习笔记 #06 神经网络基础" class="list-group-item list-group-item-action"><span class="category-post">ML学习笔记 #06 神经网络基础</span> </a><a href="/ML-Note-7" title="ML学习笔记 #07 神经网络：反向传播" class="list-group-item list-group-item-action"><span class="category-post">ML学习笔记 #07 神经网络：反向传播</span> </a><a href="/ML-Note-8" title="ML学习笔记 #08 数据集划分与误差分析" class="list-group-item list-group-item-action"><span class="category-post">ML学习笔记 #08 数据集划分与误差分析</span> </a><a href="/ML-Note-9" title="ML学习笔记 #09 支持向量机" class="list-group-item list-group-item-action"><span class="category-post">ML学习笔记 #09 支持向量机</span> </a><a href="/ML-Note-10" title="ML学习笔记 #10 K-Means 聚类" class="list-group-item list-group-item-action"><span class="category-post">ML学习笔记 #10 K-Means 聚类</span> </a><a href="/ML-Note-11" title="ML学习笔记 #11 主成分分析" class="list-group-item list-group-item-action"><span class="category-post">ML学习笔记 #11 主成分分析</span> </a><a href="/ML-Note-12" title="ML学习笔记 #12 异常检测" class="list-group-item list-group-item-action"><span class="category-post">ML学习笔记 #12 异常检测</span> </a><a href="/ML-Note-13" title="ML学习笔记 #13 协同过滤推荐算法" class="list-group-item list-group-item-action"><span class="category-post">ML学习笔记 #13 协同过滤推荐算法</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="模式识别" id="heading-03b289aaa6b21d8730ca1e736a2796eb" role="tab" data-toggle="collapse" href="#collapse-03b289aaa6b21d8730ca1e736a2796eb" aria-expanded="false">模式识别 <span class="list-group-count">(5)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-03b289aaa6b21d8730ca1e736a2796eb" role="tabpanel" aria-labelledby="heading-03b289aaa6b21d8730ca1e736a2796eb"><div class="category-post-list"><a href="/PR-Note-1" title="PR学习笔记 #1 KNN 分类器" class="list-group-item list-group-item-action"><span class="category-post">PR学习笔记 #1 KNN 分类器</span> </a><a href="/PR-Note-2" title="PR学习笔记 #2 贝叶斯分类器" class="list-group-item list-group-item-action"><span class="category-post">PR学习笔记 #2 贝叶斯分类器</span> </a><a href="/PR-Note-3" title="PR学习笔记 #3 概率密度：参数估计" class="list-group-item list-group-item-action"><span class="category-post">PR学习笔记 #3 概率密度：参数估计</span> </a><a href="/PR-Note-4" title="PR学习笔记 #4 概率密度：非参数估计" class="list-group-item list-group-item-action"><span class="category-post">PR学习笔记 #4 概率密度：非参数估计</span> </a><a href="/PR-Note-5" title="PR学习笔记 #5 判别式 vs. 生成式" class="list-group-item list-group-item-action"><span class="category-post">PR学习笔记 #5 判别式 vs. 生成式</span></a></div></div></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">数理逻辑 应试笔记</h1><p class="note note-info">本文最后更新于：2022年5月19日 中午</p><div class="markdown-body"><p>该笔记是本人于哈尔滨工业大学（深圳）2021 年春季学期「数理逻辑」课程的笔记，最终课程成绩是满分。授课教师为任世军，是本部经验丰富的老教师。</p><p>由于笔记是在考前复习时才逐渐整理的，笔记内容偏<strong>应试风格</strong>，标题顺序也是按照哈工大「数理逻辑」课程一贯的出题模板来的，涵盖了课程所学，主要包括：命题逻辑、三大系统中定理的证明、谓词逻辑。</p><h2 id="命题逻辑部分">命题逻辑部分</h2><h3 id="求主析取合取范式">求(主)析取/合取范式</h3><p>一般会涉及到三个原子命题，唯一方法——列真值表。</p><p>列真值表的顺序可以依照语法分析树。</p><p>主合取看 0，主析取看 1，直接写。列真值表一定要<strong>反复检查细节</strong>。蕴含的前后件不要看反了。</p><h3 id="用完备联结词组表示公式">用完备联结词组表示公式</h3><p>通常最终结果要化为与非式、或非式。</p><p>先把原式子中的「蕴含、等价」全换成「与、或、非」。（<strong>可以用等价式化简，但没必要，除非很明显的吸收律</strong>）</p><ul><li><strong>与非</strong>：</li></ul><p>用德摩根律把 <span class="math inline">\(\lor\)</span> 全消掉，再把 <span class="math inline">\(\land\)</span> 用</p><p><span class="math display">\[ p\land q\Leftrightarrow \lnot \left( p\uparrow q \right) \]</span></p><p>替换，再把所有的 <span class="math inline">\(\lnot\)</span> 用下式替换，注意此时 p 可能是个很长的式子。 <span class="math display">\[ \lnot p\Leftrightarrow p\uparrow p \]</span></p><ul><li><strong>或非</strong>：</li></ul><p>同理，也是消掉另一个符号，再把或替换了，再替换非。</p><h3 id="判断逻辑蕴含逻辑等价的正确性">判断逻辑蕴含/逻辑等价的正确性</h3><ol type="1"><li><strong>逻辑蕴含</strong>，一般前提会有多个</li></ol><p>通常做法是，给前提均指派为真，利用公式法，推出一系列公式，然后推得右边的公式的值恒为 1，则<strong>成立</strong>。</p><p>如果推不到右边，可以先假设右边为 0（反证法），推出左边的值可以均为 1，则<strong>不成立</strong>。</p><p><strong>注意</strong>：假设右边为 1 没用，不充分。</p><ol start="2" type="1"><li><strong>逻辑等价</strong>，一般是一对一，两边都比较长</li></ol><p>理论上可以用<strong>真值表</strong>，但是语法分析树太长了。</p><p>如果可以一眼判断出<strong>不成立</strong>，那么枚举一个反例也行。</p><p>通常做法是，两边利用公式法化简，最后推出的赋值式相等，则对于任意的指派 <span class="math inline">\(v\)</span>，都有 <span class="math inline">\(A^v = B^v\)</span>，故成立。</p><p>化简过程中，有一些较长的非、蕴含符号可以替换成与非，如： <span class="math display">\[ \begin{aligned} \lnot p\rightarrow q\,\,&amp;\text{换成 } p\lor q \\ \lnot \left( p\rightarrow \lnot q \right) \,\,&amp;\text{换成 } p\land q \end{aligned} \]</span> 避免列赋值式太长。</p><p>注意：化简到最后可能形式上不相等，这时候可以两个式子<strong>联立消项</strong>，看最后是不是<strong>永真式</strong>，如果不是，同样可以举反例（举反例不好直接想到，因此还是要推理，可以先用 PC 的方法变形看看）。</p><h2 id="pc-中定理的证明">PC 中定理的证明</h2><p>依次使用以下方法。</p><h3 id="逆向推理法直接法">1 逆向推理法（直接法）</h3><p>对待证明定理进行等价转化，转变成熟悉的形式。常用工具：</p><ul><li><p>加前件定理3：去相同前件</p></li><li><p>加后件定理4：去相同后件</p></li><li><p>逆否转换：四种情况</p></li><li><p>前件互换定理2：前件移到里面后</p></li><li><p>公理2：提出前件</p></li><li><p>补前件定理：去单个前件，只需证出后件就可以</p></li><li><p>三段论定理8：需要多次加前件、后件时</p></li></ul><p>例题：</p><ol type="1"><li><strong>二难推理</strong>（后面发现用定理18更好做）</li></ol><p><span class="math display">\[ \vdash \left( A\rightarrow C \right) \rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( A\lor B \right) \rightarrow C \right) \right) \]</span></p><p>观察形式，发现三项都有共同后件 <span class="math inline">\(C\)</span>，则三项全取逆否 <span class="math display">\[ \left( \lnot C\rightarrow \lnot A \right) \rightarrow \left( \left( \lnot C\rightarrow \lnot B \right) \rightarrow \left( \lnot C\rightarrow \lnot \left( \left( A\lor B \right) \right) \right) \right) \]</span> 利用公理 2 及 加前件定理可以去掉前件 <span class="math inline">\(\lnot C\)</span> <span class="math display">\[ \lnot A\rightarrow \left( \lnot B\rightarrow \lnot \left( A\lor B \right) \right) \]</span> 再用逆否转换，前件互换等定理即可逆向</p><p><strong>类似题</strong>： <span class="math display">\[ \vdash \left( A\rightarrow C \right) \rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( \left( A\rightarrow B \right) \rightarrow B \right) \rightarrow C \right) \right) \]</span></p><p>也必须用逆否来做。</p><ol start="2" type="1"><li><strong>作业题5</strong>（常规做法是演绎定理，其他都很麻烦）</li></ol><p><span class="math display">\[ \vdash \left( A\rightarrow \left( B\rightarrow C \right) \right) \rightarrow \left( \left( C\rightarrow D \right) \rightarrow \left( A\rightarrow \left( B\rightarrow D \right) \right) \right) \]</span></p><p>先前件互换可使得后件两项都含 <span class="math inline">\(A\)</span> <span class="math display">\[ \left( C\rightarrow D \right) \rightarrow \left( \left( A\rightarrow \left( B\rightarrow C \right) \right) \rightarrow \left( A\rightarrow \left( B\rightarrow D \right) \right) \right) \,\, \]</span> 发现去掉前件 <span class="math inline">\(A\)</span> 后还可以去掉前件 <span class="math inline">\(B\)</span></p><p>但是再用一次前件互换即可得到定理4的形式 <span class="math display">\[ \left( C\rightarrow D \right) \rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( B\rightarrow D \right) \right) \]</span></p><ol start="3" type="1"><li><strong>砍头操作</strong></li></ol><p>砍头操作有两种办法：将 <span class="math display">\[ \left( \lnot A\rightarrow B \right) \rightarrow \left( \left( \lnot A\rightarrow \lnot B \right) \rightarrow A \right) \]</span> 变成 <span class="math display">\[ B\rightarrow \left( \left( \lnot A\rightarrow \lnot B \right) \rightarrow A \right) \]</span> <strong>方法一</strong>：先添前件（用公理1再分离）变成 <span class="math display">\[ B\rightarrow \left( \left( \lnot A\rightarrow B \right) \rightarrow \left( \left( \lnot A\rightarrow \lnot B \right) \rightarrow A \right) \right) \]</span> 再用公理2分离，前件是公理1的形式，后件自然成立，总计要4行</p><p><strong>方法二</strong>：直接用三段论定理8，因为 <span class="math display">\[ B\rightarrow \left( \lnot A\rightarrow B \right) \]</span> 显然成立，用三段论定理8接上，只需要2行，但是要分条件（有可能不允许使用定理8，如作业题PC1）</p><ol start="4" type="1"><li><strong>反公理2</strong>（19 年试卷的答案，思路清奇，没用定理18）</li></ol><p><span class="math display">\[ \vdash \left( \left( A\rightarrow B \right) \rightarrow \left( A\rightarrow C \right) \right) \rightarrow \left( A\rightarrow \left( B\rightarrow C \right) \right) \]</span></p><p>一开始观察三项前件都有 <span class="math inline">\(A\)</span>，以为可以用类似二难推理的办法做。</p><p>但是！注意到整体的形式是「两项推一项」，与二难推理不同，因此不能用公理2来提出前件，再去掉前件。</p><p>观察发现，后件 <span class="math inline">\(A\to(B\to C)\)</span> 可以用一次前件互换定理，得到 <span class="math display">\[ \vdash \left( \left( A\rightarrow B \right) \rightarrow \left( A\rightarrow C \right) \right) \rightarrow \left( B\rightarrow \left( A\rightarrow C \right) \right) \]</span> 此时有共同的后件，可以用加后件定理快速解决。</p><h3 id="利用定理18">2 利用定理18</h3><p>定理18证明的简便性和方法1相近，尝试方法1失败后，若形式符合<span class="math inline">\((A \to B)\to C\)</span>，可以考虑定理18</p><p>将原式子拆成 <span class="math inline">\(\lnot A \to C\)</span> 和 <span class="math inline">\(B \to C\)</span> ，再用方法1</p><p>例题：</p><ol type="1"><li><strong>反公理2</strong>（书上用演绎定理证明，很简短）</li></ol><p><span class="math display">\[ \vdash \left( \left( A\rightarrow B \right) \rightarrow \left( A\rightarrow C \right) \right) \rightarrow \left( A\rightarrow \left( B\rightarrow C \right) \right) \]</span></p><p>如果看前两项，想用逆推的方法解决，但是发现加前件定理用不了，因为接不上。直接考虑定理18。</p><ul><li>拆成</li></ul><p><span class="math display">\[ \left( A\rightarrow C \right) \rightarrow \left( A\rightarrow \left( B\rightarrow C \right) \right) \]</span> 只需前件互换，去掉后件即可证明。</p><ul><li>拆成</li></ul><p><span class="math display">\[ \lnot \left( A\rightarrow B \right) \rightarrow \left( A\rightarrow \left( B\rightarrow C \right) \right) \]</span> 比较复杂，需要前件互换，<strong>再摘掉 A</strong></p><p>（<strong>注意：这一步可以不需要前件互换，只需用公理1+三段论，直接砍后件头</strong>）</p><p>（<strong>附注</strong>：砍后件头，倒过来书写时其实是加后件头，与前面的砍头操作不同） <span class="math display">\[ \lnot \left( A\rightarrow B \right) \rightarrow \left( B\rightarrow C \right) \]</span> 然后再换前件，因为前面的 <strong><span class="math inline">\(\lnot\)</span> 是在整体上的，必须要和单体进行一次逆否转换</strong> <span class="math display">\[ B\rightarrow \left( \lnot \left( A\rightarrow B \right) \rightarrow C \right) \]</span> 再对里面做逆否，此时 <span class="math inline">\(\lnot\)</span> 已经转移到单独的 <span class="math inline">\(C\)</span> 上了 <span class="math display">\[ B\rightarrow \left( \lnot C\rightarrow \left( A\rightarrow B \right) \right) \]</span> 需要前件互换，<strong>再摘掉 <span class="math inline">\(\lnot C\)</span></strong></p><p>（<strong>注意：这一步可以不需要前件互换，只需用公理1+三段论，直接砍后件头</strong>）</p><ul><li>补充</li></ul><p><span class="math display">\[ \lnot \left( A\rightarrow B \right) \rightarrow \left( B\rightarrow C \right) \]</span></p><p>前面的 <strong><span class="math inline">\(\lnot\)</span> 是在整体上的，还有另一种办法可以消去</strong></p><p>因为 <span class="math inline">\(\lnot (A \to B)\)</span> 可以推出 <span class="math inline">\(A\)</span> 或 <span class="math inline">\(\lnot B\)</span> ，利用<strong>三段论</strong>定理可以接上去。</p><p>此题可以用 <span class="math inline">\(\lnot B\)</span>，转化后的形式是定理6。</p><ol start="2" type="1"><li><strong>二难推理</strong></li></ol><p><span class="math display">\[ \vdash \left( A\rightarrow C \right) \rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( A\lor B \right) \rightarrow C \right) \right) \]</span></p><p>二难推理系列的题目，比思维流更好的办法其实是定理18，并且套路十分明显。</p><ul><li>拆成</li></ul><p><span class="math display">\[ \lnot A\rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( A\lor B \right) \rightarrow C \right) \right) \]</span></p><p>首先第一部分，由于 <span class="math inline">\(C\)</span> 在后件的两个后件，此时用加后件定理可以轻松消去 <span class="math inline">\(C\)</span>。 <span class="math display">\[ \lnot A\rightarrow \left( \left( A\lor B \right) \rightarrow B \right) \]</span> 再用一次前件互换定理，发现就是定理1。</p><ul><li>（<strong>这一步纯套路，每题都是一样</strong>）拆成</li></ul><p><span class="math display">\[ C\rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( A\lor B \right) \rightarrow C \right) \right) \]</span></p><p>此时不能直接用加后件了，否则最前面的 <span class="math inline">\(C\)</span> 消不掉。直接前件互换， <span class="math display">\[ \left( B\rightarrow C \right) \rightarrow \left( C\rightarrow \left( \left( A\lor B \right) \rightarrow C \right) \right) \]</span> 发现后件是公理1，于是摘掉前件，成立。</p><p><strong>类似题</strong>： <span class="math display">\[ \vdash \left( A\rightarrow C \right) \rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( \left( A\rightarrow B \right) \rightarrow B \right) \rightarrow C \right) \right) \]</span></p><p>也可以用同样的套路秒做。</p><h3 id="反证法">3 反证法</h3><p>前两种方法都想不出来的情况下考虑，书写过程会相对繁琐。</p><ol type="1"><li>基本方法</li></ol><p>假定原定理为0，按照依次将式子标上0和1，直到推出矛盾（一般会有多处，找容易的）。</p><p>证明时显而易见的（前几条）可以不用加注释，可以理解成真值表的体现。</p><p>后面的推理过程可以按标0和1的顺序来，通常都是由大后件的结论往前件找矛盾。</p><p><strong>最常使用：三段论定理</strong>，用于把 <span class="math inline">\(\lnot P\)</span> 接上去，最后才能转到矛盾。</p><ol start="2" type="1"><li>推演技巧</li></ol><p>最无脑的方法是把所有单项都用 <span class="math inline">\(\lnot P\)</span> 推出来，再进行排列组合出矛盾。</p><p>高级的方法是抓住「<strong>矛盾块</strong>」（通常是原式的一端），再把「<strong>另一个矛盾块</strong>」通过逆向推理法（直接法）证到原式的另一端，即可。</p><h3 id="演绎定理">4 演绎定理</h3><p>没啥好说的，一般不给用，对三个以上变量比较友好，提取出所有前件后就可以用直接法证明。</p><h2 id="nd-中定理的证明">ND 中定理的证明</h2><h3 id="思维流">思维流</h3><p>本质是<strong>逆向推理法</strong>，逆推的同时可以注意左端项的逻辑规律（赋1，看矛盾）</p><p>结合常见形式及解决套路可以更快解决。</p><ol type="1"><li><strong>当右端项包含 <span class="math inline">\(\lnot\)</span> 时：</strong></li></ol><p><span class="math display">\[ \lnot A\land \lnot B\vdash \lnot \left( A\lor B \right) \]</span></p><p>用 <span class="math inline">\(\lnot +\)</span> 规则把右端项挪到左边时，要导出矛盾，往往这个矛盾是右端项的<strong>部分</strong>，如析取、合取的部分。</p><p>此时的惯常做法是将这两个矛盾合取，如 <span class="math inline">\(A\land \lnot A\)</span> ，这个式子必定为0，事实上左边此时的两个式子已经自相矛盾。</p><p>当然不一定要用 <span class="math inline">\(A\land \lnot A\)</span>，因为左边矛盾的情况下，赋1可以推出很多对矛盾，只是这个最常见。</p><ol start="2" type="1"><li><strong>当左端项有 <span class="math inline">\(\lor\)</span> 时：</strong></li></ol><p><span class="math display">\[ \lnot A\lor \lnot B\vdash \lnot \left( A\land B \right) \]</span></p><p>充分利用析取，将其两项分别放到左端，用 <span class="math inline">\(\in\)</span> 规则把两项先推出来。</p><p>左端多出来的两项最终也需要消去。</p><ul><li>这就需要 <span class="math inline">\(\lor-\)</span> 规则，因此上面推出来的两式要最后导出到同一个目标，通常是<span class="math inline">\(A\land \lnot A\)</span>，这类式子。</li><li>也有可能是需要 <span class="math inline">\(\to +\)</span> 规则，把小项拿到右边当前件。</li></ul><p><strong>注意</strong>：如果 <span class="math inline">\(\lor\)</span> 是含在某个大的式子里，也可以将小项直接拿到外面来推。</p><ol start="3" type="1"><li><strong>当右端项有 <span class="math inline">\(\lor\)</span> 时：</strong></li></ol><p><span class="math display">\[ \lnot \left( A\land B \right) \vdash \lnot A\lor \lnot B \]</span></p><p>一般可以用 <span class="math inline">\(\lor -\)</span> 简化，只需证一半，但是保留哪一半要根据左边的情况推理，即思维流。</p><p>但有时也不能上来就简化，因为左边的条件可能太宽泛了（太少了），因此可能要加上一些小项再看。</p><p>这时候常用的是 <span class="math inline">\(-\)</span> 规则。这也是最难用的一个规则。</p><ol start="4" type="1"><li><strong>当左端项有 <span class="math inline">\(\land\)</span> 时：</strong></li></ol><p><span class="math display">\[ A\land \left( {B}\lor {C} \right) \vdash \left( {A}\land {B} \right) \lor \left( {A}\land {C} \right) \]</span></p><p>利用 <span class="math inline">\(\land -\)</span> 规则，将两个子命题拆出来。</p><p>当然不能白拆，要和前几条综合起来用，往往时加入了很多项后，用这个来助攻。</p><ol start="5" type="1"><li><strong>当右端项有 <span class="math inline">\(\land\)</span> 时：</strong></li></ol><p>可能是要把两个细分都推出来。 <span class="math display">\[ \lnot \left( {A}\lor {B} \right) \vdash \lnot {A}\land \lnot {B} \]</span> 也可能是要整个推出，即生成未出现过的项，常用 <span class="math inline">\(\lor-\)</span> 规则。 <span class="math display">\[ \left( A\land {B} \right) \lor \left( {A}\land {C} \right) \vdash {A}\land \left( {B}\lor {C} \right) \]</span></p><ol start="6" type="1"><li><strong>在右端生成从未出现过的项：</strong></li></ol><p>常用 <span class="math inline">\(\lor-\)</span> 规则，但是这种必须有理有据的推出，而且左端要含 <span class="math inline">\(\lor\)</span>。</p><p>另一个方法是 <span class="math inline">\(\lnot -\)</span>，矛盾可以推任意。</p><ul><li>通常的用法是：</li></ul><p><span class="math display">\[ \begin{aligned} XXX, A, \lnot A&amp;\vdash A \\ XXX, A, \lnot A&amp;\vdash \lnot A \\ XXX, A, \lnot A&amp;\vdash B \end{aligned} \]</span></p><ul><li>然后再想办法消掉多出来的单项，如</li></ul><p><span class="math display">\[ XXX, \lnot A\vdash A\rightarrow B \]</span></p><ul><li>或者再利用 <span class="math inline">\(\lor-\)</span> ，二者结合，如</li></ul><p><span class="math display">\[ \begin{aligned} XXX, A, \lnot A&amp;\vdash B \\ XXX, A, B&amp;\vdash B \\ XXX, A&amp;\vdash \lnot A\lor B \\ XXX, A&amp;\vdash B \end{aligned} \]</span></p><p>例：（需要用到两种引入方法） <span class="math display">\[ \left( A\lor B \right) \land \left( \lnot B\lor C \right) \vdash A\lor C \]</span> 按照思维流推断，发现最开始可以引入 <span class="math inline">\(B\)</span>，<span class="math inline">\(\lnot B\)</span> 的矛盾推任意。</p><p>而右端项的析取，一次只能推一半。</p><p>推一半的时候，还是需要引入新项，此时用 <span class="math inline">\(\lor-\)</span> ，因为左端项还有个析取（隐藏在合取中）可以用，将两个子项单独拿出来放到左边，即可推出。</p><ol start="7" type="1"><li><strong>当左端项有 <span class="math inline">\(\to\)</span> 时：</strong></li></ol><p>由于ND中没有分离规则，所以要利用好这个 <span class="math inline">\(\to\)</span> 需要先在左端加上前件，用两次 <span class="math inline">\(\in\)</span> 规则。</p><p>最后再用 <span class="math inline">\(\to -\)</span> 规则把后件推到右端。</p><ol start="8" type="1"><li><strong>当左端项包含 <span class="math inline">\(\lnot\)</span> 时：</strong></li></ol><p><span class="math display">\[ \lnot ( A\to B ) \vdash A\land \lnot B \]</span></p><p>想按照逻辑推出东西基本不可能，最好的办法是利用已有的一个 <span class="math inline">\(\lnot\)</span> ，制造矛盾，使得矛盾可以推任意，或者 <span class="math inline">\(\lnot +\)</span>。</p><p>但是如果要制造矛盾，必须引入新的变量，这样左边就会多一个元素，即使 <span class="math inline">\(\lnot -\)</span> 推出了任意，但左边也不符合。</p><p>因此可以用 <span class="math inline">\(\lnot +\)</span> 规则，在左边引入一个<strong>待求右端项</strong>的 <span class="math inline">\(\lnot\)</span> ，推出矛盾后再用反证法把<strong>待求变量</strong>移到右边，此时可能要用 <span class="math inline">\(\lnot \lnot-\)</span> 规则。</p><h2 id="fc-中定理的证明">FC 中定理的证明</h2><h3 id="两种书写格式">两种书写格式</h3><ol type="1"><li><p>用 PC 中的公式序列，最后再补上 <span class="math inline">\(\Gamma\)</span> ，不用序号，用「<strong>从而</strong>...」连接结论。</p><p>常用于 <strong>FC 反证法定理8</strong>、<strong>双向证明</strong>（先证后证）</p></li><li><p>用 ND 中的演绎序列，直接证出结果（书写内容多），如果此时<strong>要用 PC 或者 FC 的定理</strong>，需要在公式前面写 <span class="math inline">\(\vdash\)</span>，并在下一条用分离规则导出（<strong>注意</strong>：不用写用若干次 <span class="math inline">\(+\)</span> 规则）。</p><p>常用于 <strong>FC 存在消除定理10</strong></p></li></ol><p>具体证明过程依次使用以下方法。</p><h3 id="存在消除定理">存在消除定理</h3><p>当式子左端有 <span class="math inline">\(\exists xA\)</span> 或 <span class="math inline">\(\exists x(A\to B)\)</span> 的量词时，优先考虑用存在消除定理10。</p><p>在左端补上 <span class="math inline">\(A\)</span> 或 <span class="math inline">\((A\to B)\)</span> ，并用 ND 中的规则推出想要的右端项。</p><p>接着就可以用存在消除定理把左端补上的东西消除了。 <span class="math display">\[ \begin{aligned} &amp;\left( 1 \right) \exists v\left( B\rightarrow A \right) , B\rightarrow A, B\vdash A \\ &amp;\left( 2 \right) \exists v\left( B\rightarrow A \right) , B\vdash \exists v\left( B\rightarrow A \right) \\ &amp;\left( 3 \right) \exists v\left( B\rightarrow A \right) , B\vdash A\,\, \end{aligned} \]</span> <strong>注意</strong>：虽说「存在」消除定理，但是最后消掉的是 <span class="math inline">\(\exists x\)</span> 里面的东西。</p><p><strong>警告</strong>：使用该方法时，(3) 式中左右端项都不能有 <span class="math inline">\(v\)</span> 的自由出现！</p><h3 id="反证法定理">反证法定理</h3><p>反证法不一定是最优解，但是是最 FC 的做法，一般标准答案会用。当右端的整体上有个 <span class="math inline">\(\lnot\)</span> 打头，或者右端有个 <span class="math inline">\(\exists x\)</span> 时，建议使用。</p><p><span class="math display">\[ \begin{aligned} &amp;\text{从而}\varGamma \vdash A\,\,\text{且} \varGamma \vdash \lnot A \\ &amp;\text{从而公式集}\varGamma \text{不一致，由}FC\text{反证法定理}8 \\ &amp;\text{得}\forall vB\rightarrow A\vdash \lnot \forall v\lnot \left( B\rightarrow A \right) \end{aligned} \]</span></p><p>注意：如果左右都有 <span class="math inline">\(\exists x\)</span>，优先用存在消除定理。</p><h3 id="思维流-1">思维流</h3><p>前两种方法都不可以使用的时候考虑，跟 ND 中的证明没啥区别。可能会用到一些 PC 中的定理，如三段论定理8、逆否定理、以及一些小套件（定理6，定理9）。</p><h3 id="其他小技巧">其他小技巧</h3><ol type="1"><li>FC 定理 9 平时用的少，但是有时有妙用。</li></ol><p><span class="math display">\[ \begin{aligned} &amp;\left( 1 \right) \exists v\left( B\rightarrow A \right) , B\vdash A \\ &amp;\left( 2 \right) \exists v\left( B\rightarrow A \right) , \forall vB\vdash A \end{aligned} \]</span></p><ol start="2" type="1"><li><p>FC 也有<strong>演绎定理</strong>，并且考试中可以<strong>直接使用</strong>。（省步骤，不然就得用 ND 中复杂的规则来代替）</p><p>比如往左放就要用 <span class="math inline">\((+)\)</span> 再用 <span class="math inline">\((\to-)\)</span> 规则，往右放就要用 <span class="math inline">\((\to +)\)</span> 规则。</p></li><li><p>全称推广定理 和 定理1 是互逆的关系，是 PC/ND 系统与 FC 联系的关键。常用于导出待证明式子右端项。</p></li><li><p>补充：使用 FC 定理时，有的定理有限制。</p></li></ol><ul><li>公理4 （项 t 对 v 可代入）</li><li>公理6 （v 在 A 中无自由出现）</li><li><strong>全称推广定理5</strong> （v 在 <span class="math inline">\(\Gamma\)</span> 中无自由出现）</li><li>定理9 （v 在 <span class="math inline">\(\Gamma\)</span> 中无自由出现）</li><li><strong>存在消除定理10</strong> （v 在 <span class="math inline">\(\Gamma\)</span> 和 B 中无自由出现）（在最后一行前后都无自由出现）</li></ul><h2 id="谓词演算部分">谓词演算部分</h2><h3 id="构造语义和指派">构造语义和指派</h3><p>语义就是 <span class="math inline">\(U=&lt;D,I&gt;\)</span> 即论域和解释，其中论域部分令 <span class="math inline">\(D=\{1, 2\}\)</span>。</p><p>解释部分 <span class="math inline">\(I\)</span> 要加横杠，分别对常元、函词、谓词做一个映射。<strong>构造时根据要求，巧妙选择</strong>。 <span class="math display">\[ \begin{aligned} &amp;\bar{a}=1 \\ &amp;\bar{f}\left( 1,1 \right) =1,\bar{f}\left( 1,2 \right) =1,\bar{f}\left( 2,1 \right) =1,\bar{f}\left( 2,2 \right) =1 \\ &amp;\bar{R}=\left\{ 1,2 \right\} ,\bar{P}=\left\{ \left( 1,1 \right) \right\} ,\bar{Q}=\oslash \end{aligned} \]</span> <strong>注意</strong>：函词是<strong>个体</strong>映射到<strong>个体</strong>，谓词是取这些<strong>个体</strong>时值为 <strong>True</strong>。<strong>一元谓词跟函词很容易混淆</strong>。</p><p>指派 <span class="math inline">\(s\)</span> 就是给变元取值。 <span class="math display">\[ \bar{x}=2,\bar{y}=1 \]</span> 注意：书写时展开函词的时候，<strong>横杠</strong>都要加上。特别是多层函词时。 <span class="math display">\[ \overline{f\left( x,y \right) }=\bar{f}\left( \bar{x},\bar{y} \right) \]</span> 判断真假的时候，简单的直接写 T 或 F 就可以（需要横杠），表示映射。</p><p>但是含有<strong>任意、存在量词</strong>的必须用标准写法（不用横杠）<strong>拆去</strong>。 <span class="math display">\[ \begin{aligned} &amp;\models _U\left( \forall x \right) P\left( x \right) \left[ s \right] \,\, iff.\models _UP\left( x \right) \left[ s\left( x|1 \right) \right] \,\,\text{且} \models _UP\left( x \right) \left[ s\left( x|2 \right) \right] \\ &amp;\models _U\left( \exists x \right) P\left( x \right) \left[ s \right] \,\, iff.\models _UP\left( x \right) \left[ s\left( x|1 \right) \right] \,\,\text{或} \models _UP\left( x \right) \left[ s\left( x|2 \right) \right] \end{aligned} \]</span></p><h3 id="构造自然语句的形式化">构造自然语句的形式化</h3><p>格式要注意，在开头要令出谓词、函词，一般不需要论域（除非真的只有一种个体词）。</p><p><strong>每个出现的个体词</strong>都应该有对应的谓词，如「作家」「作品」「小说」「学生」「实数」。</p><p>一个基本原则：$$</p><p>常用短语：</p><ul><li>并非所有：<span class="math inline">\(\lnot \forall x\)</span></li><li>有且仅有、唯一：$x( R( x ) u( R( u ) E( x, u ) ) ) $</li><li>不是就是、要么要么：$x( R( x ) P( x ) Q( x ) ) $</li></ul><p>例题：形式化表示第二数学归纳法。 <span class="math display">\[ \begin{aligned} &amp; \text{令谓词：} \\&amp; F\left( x \right) \text{表示当}n=x\text{时，命题成立；} \\&amp; L\left( x,k \right) \text{表示}x&lt;k\text{；} \\&amp; P\left( x \right) \text{表示}x\text{是正整数。} \\&amp; \left( 1 \right) F\left( 1 \right) \\&amp; \left( 2 \right) \forall k\left( \left( P\left( k \right) \land \forall x\left( P\left( x \right) \land L\left( x,k \right) \rightarrow F\left( x \right) \right) \right) \rightarrow F\left( k \right) \right) \\&amp; \left( 3 \right) \forall x\left( P\left( x \right) \rightarrow F\left( x \right) \right) \end{aligned} \]</span></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="category-chain-item">学习笔记</a> <span>></span> <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/" class="category-chain-item">本科课程</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Math/" class="print-no-link">#Math</a></div></div><div class="license-box my-3"><div class="license-title"><div>数理逻辑 应试笔记</div><div>https://hwcoder.top/Mathematical-Logic</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Wei He</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2021年8月27日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/Git-Note-1" title="Git学习笔记 #1 基础知识介绍"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Git学习笔记 #1 基础知识介绍</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/IR-Project" title="IR课程项目-文学检索-开发文档"><span class="hidden-mobile">IR课程项目-文学检索-开发文档</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"jdbBr3BddTiqSCPnXw6sXFv7-gzGzoHsz","appKey":"2bjgwDr2opjVCwhgjDMpk53c","path":"window.location.pathname","placeholder":"说点什么吧( •̀ ω •́ )✧","avatar":"retro","meta":["nick","mail","link"],"requiredFields":["nick"],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script>if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-svg-full.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>