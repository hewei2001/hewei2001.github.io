<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg"><link rel="icon" href="/img/logo.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#01213a"><meta name="description" content="「数理逻辑」课程笔记，内容偏应试风格，主要包括：命题逻辑、三大系统中定理的证明、谓词逻辑。"><meta name="author" content="He Wei"><meta name="keywords" content="Computer Science and Technology, Machine Learning, Deep Learning, Computer Vision, Natural Language Processing"><meta name="baidu-site-verification" content="code-J3wrn8WJYJ"><meta name="google-site-verification" content="0p_KJKTfB8EcahVDp0vYRjVRhHFw1SBWHi15OakKHY0"><meta name="description" content="「数理逻辑」课程笔记，内容偏应试风格，主要包括：命题逻辑、三大系统中定理的证明、谓词逻辑。"><meta property="og:type" content="article"><meta property="og:title" content="数理逻辑应试笔记"><meta property="og:url" content="https://hwcoder.top/Mathematical-Logic"><meta property="og:site_name" content="Hwcoder - Life Oriented Programming"><meta property="og:description" content="「数理逻辑」课程笔记，内容偏应试风格，主要包括：命题逻辑、三大系统中定理的证明、谓词逻辑。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-08-27T12:23:04.000Z"><meta property="article:modified_time" content="2021-08-31T12:53:43.935Z"><meta property="article:author" content="He Wei"><meta property="article:tag" content="Math"><meta name="twitter:card" content="summary_large_image"><title>数理逻辑应试笔记 | Hwcoder - Life Oriented Programming</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/night-owl.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/css/mac.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"hwcoder.top",root:"/",version:"1.8.12",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h2, h3",placement:"left",visible:"always",icon:"§"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4",collapseDepth:3},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"XGNf4GEnaFLiUijMUvz8HSBF-gzGzoHsz",app_key:"JPeVLcug6EcWdBTpGrDJSdKi",server_url:"https://xgnf4gen.lc-cn-n1-shared.com",path:"window.location.pathname"}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Hwcoder</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于我</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/img/bg/other.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="数理逻辑应试笔记"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-08-27 20:23" pubdate>2021年8月27日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 10k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 43 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">数理逻辑应试笔记</h1><p class="note note-info">本文最后更新于：2021年8月31日 晚上</p><div class="markdown-body"><p>该笔记是本人于哈尔滨工业大学（深圳）2021 年春季学期「数理逻辑」课程的笔记，最终课程成绩是满分。授课教师为任世军，是本部经验丰富的老教师。</p><p>由于笔记是在考前复习时才逐渐整理的，笔记内容偏<strong>应试风格</strong>，标题顺序也是按照哈工大「数理逻辑」课程一贯的出题模板来的，涵盖了课程所学，主要包括：命题逻辑、三大系统中定理的证明、谓词逻辑。</p><h2 id="命题逻辑部分"><a href="#命题逻辑部分" class="headerlink" title="命题逻辑部分"></a>命题逻辑部分</h2><h3 id="求-主-析取-合取范式"><a href="#求-主-析取-合取范式" class="headerlink" title="求(主)析取/合取范式"></a>求(主)析取/合取范式</h3><p>一般会涉及到三个原子命题，唯一方法——列真值表。</p><p>列真值表的顺序可以依照语法分析树。</p><p>主合取看 0，主析取看 1，直接写。列真值表一定要<strong>反复检查细节</strong>。蕴含的前后件不要看反了。</p><h3 id="用完备联结词组表示公式"><a href="#用完备联结词组表示公式" class="headerlink" title="用完备联结词组表示公式"></a>用完备联结词组表示公式</h3><p>通常最终结果要化为与非式、或非式。</p><p>先把原式子中的「蕴含、等价」全换成「与、或、非」。（<strong>可以用等价式化简，但没必要，除非很明显的吸收律</strong>）</p><ul><li><strong>与非</strong>：</li></ul><p>用德摩根律把 $\lor$ 全消掉，再把 $\land$ 用</p><script type="math/tex;mode=display">p\land q\Leftrightarrow \lnot \left( p\uparrow q \right)</script><p>替换，再把所有的 $\lnot$ 用下式替换，注意此时 p 可能是个很长的式子。</p><script type="math/tex;mode=display">\lnot p\Leftrightarrow p\uparrow p</script><ul><li><strong>或非</strong>：</li></ul><p>同理，也是消掉另一个符号，再把或替换了，再替换非。</p><h3 id="判断逻辑蕴含-逻辑等价的正确性"><a href="#判断逻辑蕴含-逻辑等价的正确性" class="headerlink" title="判断逻辑蕴含/逻辑等价的正确性"></a>判断逻辑蕴含/逻辑等价的正确性</h3><ol><li><strong>逻辑蕴含</strong>，一般前提会有多个</li></ol><p>通常做法是，给前提均指派为真，利用公式法，推出一系列公式，然后推得右边的公式的值恒为 1，则<strong>成立</strong>。</p><p>如果推不到右边，可以先假设右边为 0（反证法），推出左边的值可以均为 1，则<strong>不成立</strong>。</p><p><strong>注意</strong>：假设右边为 1 没用，不充分。</p><ol><li><strong>逻辑等价</strong>，一般是一对一，两边都比较长</li></ol><p>理论上可以用<strong>真值表</strong>，但是语法分析树太长了。</p><p>如果可以一眼判断出<strong>不成立</strong>，那么枚举一个反例也行。</p><p>通常做法是，两边利用公式法化简，最后推出的赋值式相等，则对于任意的指派 $v$，都有 $A^v = B^v$，故成立。</p><p>化简过程中，有一些较长的非、蕴含符号可以替换成与非，如：</p><script type="math/tex;mode=display">\begin{aligned}
\lnot p\rightarrow q\,\,&\text{换成 } p\lor q
\\
\lnot \left( p\rightarrow \lnot q \right) \,\,&\text{换成 } p\land q
\end{aligned}</script><p>避免列赋值式太长。</p><p>注意：化简到最后可能形式上不相等，这时候可以两个式子<strong>联立消项</strong>，看最后是不是<strong>永真式</strong>，如果不是，同样可以举反例（举反例不好直接想到，因此还是要推理，可以先用 PC 的方法变形看看）。</p><h2 id="PC-中定理的证明"><a href="#PC-中定理的证明" class="headerlink" title="PC 中定理的证明"></a>PC 中定理的证明</h2><p>依次使用以下方法。</p><h3 id="1-逆向推理法（直接法）"><a href="#1-逆向推理法（直接法）" class="headerlink" title="1 逆向推理法（直接法）"></a>1 逆向推理法（直接法）</h3><p>对待证明定理进行等价转化，转变成熟悉的形式。常用工具：</p><ul><li>加前件定理3：去相同前件</li><li>加后件定理4：去相同后件</li><li>逆否转换：四种情况</li><li><p>前件互换定理2：前件移到里面后</p></li><li><p>公理2：提出前件</p></li><li>补前件定理：去单个前件，只需证出后件就可以</li><li>三段论定理8：需要多次加前件、后件时</li></ul><p>例题：</p><ol><li><strong>二难推理</strong>（后面发现用定理18更好做）</li></ol><script type="math/tex;mode=display">\vdash \left( A\rightarrow C \right) \rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( A\lor B \right) \rightarrow C \right) \right)</script><p>观察形式，发现三项都有共同后件 $C$，则三项全取逆否</p><script type="math/tex;mode=display">\left( \lnot C\rightarrow \lnot A \right) \rightarrow \left( \left( \lnot C\rightarrow \lnot B \right) \rightarrow \left( \lnot C\rightarrow \lnot \left( \left( A\lor B \right) \right) \right) \right)</script><p>利用公理 2 及 加前件定理可以去掉前件 $\lnot C$</p><script type="math/tex;mode=display">\lnot A\rightarrow \left( \lnot B\rightarrow \lnot \left( A\lor B \right) \right)</script><p>再用逆否转换，前件互换等定理即可逆向</p><p><strong>类似题</strong>：</p><script type="math/tex;mode=display">\vdash \left( A\rightarrow C \right) \rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( \left( A\rightarrow B \right) \rightarrow B \right) \rightarrow C \right) \right)</script><p>也必须用逆否来做。</p><ol><li><strong>作业题5</strong>（常规做法是演绎定理，其他都很麻烦）</li></ol><script type="math/tex;mode=display">\vdash \left( A\rightarrow \left( B\rightarrow C \right) \right) \rightarrow \left( \left( C\rightarrow D \right) \rightarrow \left( A\rightarrow \left( B\rightarrow D \right) \right) \right)</script><p>先前件互换可使得后件两项都含 $A$</p><script type="math/tex;mode=display">\left( C\rightarrow D \right) \rightarrow \left( \left( A\rightarrow \left( B\rightarrow C \right) \right) \rightarrow \left( A\rightarrow \left( B\rightarrow D \right) \right) \right) \,\,</script><p>发现去掉前件 $A$ 后还可以去掉前件 $B$</p><p>但是再用一次前件互换即可得到定理4的形式</p><script type="math/tex;mode=display">\left( C\rightarrow D \right) \rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( B\rightarrow D \right) \right)</script><ol><li><strong>砍头操作</strong></li></ol><p>砍头操作有两种办法：将</p><script type="math/tex;mode=display">\left( \lnot A\rightarrow B \right) \rightarrow \left( \left( \lnot A\rightarrow \lnot B \right) \rightarrow A \right)</script><p>变成</p><script type="math/tex;mode=display">B\rightarrow \left( \left( \lnot A\rightarrow \lnot B \right) \rightarrow A \right)</script><p><strong>方法一</strong>：先添前件（用公理1再分离）变成</p><script type="math/tex;mode=display">B\rightarrow \left( \left( \lnot A\rightarrow B \right) \rightarrow \left( \left( \lnot A\rightarrow \lnot B \right) \rightarrow A \right) \right)</script><p>再用公理2分离，前件是公理1的形式，后件自然成立，总计要4行</p><p><strong>方法二</strong>：直接用三段论定理8，因为</p><script type="math/tex;mode=display">B\rightarrow \left( \lnot A\rightarrow B \right)</script><p>显然成立，用三段论定理8接上，只需要2行，但是要分条件（有可能不允许使用定理8，如作业题PC1）</p><ol><li><strong>反公理2</strong>（19 年试卷的答案，思路清奇，没用定理18）</li></ol><script type="math/tex;mode=display">\vdash \left( \left( A\rightarrow B \right) \rightarrow \left( A\rightarrow C \right) \right) \rightarrow \left( A\rightarrow \left( B\rightarrow C \right) \right)</script><p>一开始观察三项前件都有 $A$，以为可以用类似二难推理的办法做。</p><p>但是！注意到整体的形式是「两项推一项」，与二难推理不同，因此不能用公理2来提出前件，再去掉前件。</p><p>观察发现，后件 $A\to(B\to C)$ 可以用一次前件互换定理，得到</p><script type="math/tex;mode=display">\vdash \left( \left( A\rightarrow B \right) \rightarrow \left( A\rightarrow C \right) \right) \rightarrow \left( B\rightarrow \left( A\rightarrow C \right) \right)</script><p>此时有共同的后件，可以用加后件定理快速解决。</p><h3 id="2-利用定理18"><a href="#2-利用定理18" class="headerlink" title="2 利用定理18"></a>2 利用定理18</h3><p>定理18证明的简便性和方法1相近，尝试方法1失败后，若形式符合$(A \to B)\to C$，可以考虑定理18</p><p>将原式子拆成 $\lnot A \to C$ 和 $B \to C$ ，再用方法1</p><p>例题：</p><ol><li><strong>反公理2</strong>（书上用演绎定理证明，很简短）</li></ol><script type="math/tex;mode=display">\vdash \left( \left( A\rightarrow B \right) \rightarrow \left( A\rightarrow C \right) \right) \rightarrow \left( A\rightarrow \left( B\rightarrow C \right) \right)</script><p>如果看前两项，想用逆推的方法解决，但是发现加前件定理用不了，因为接不上。直接考虑定理18。</p><ul><li>拆成</li></ul><script type="math/tex;mode=display">\left( A\rightarrow C \right) \rightarrow \left( A\rightarrow \left( B\rightarrow C \right) \right)</script><p>只需前件互换，去掉后件即可证明。</p><ul><li>拆成</li></ul><script type="math/tex;mode=display">\lnot \left( A\rightarrow B \right) \rightarrow \left( A\rightarrow \left( B\rightarrow C \right) \right)</script><p>比较复杂，需要前件互换，<strong>再摘掉 A</strong></p><p>（<strong>注意：这一步可以不需要前件互换，只需用公理1+三段论，直接砍后件头</strong>）</p><p>（<strong>附注</strong>：砍后件头，倒过来书写时其实是加后件头，与前面的砍头操作不同）</p><script type="math/tex;mode=display">\lnot \left( A\rightarrow B \right) \rightarrow \left( B\rightarrow C \right)</script><p>然后再换前件，因为前面的 <strong>$\lnot$ 是在整体上的，必须要和单体进行一次逆否转换</strong></p><script type="math/tex;mode=display">B\rightarrow \left( \lnot \left( A\rightarrow B \right) \rightarrow C \right)</script><p>再对里面做逆否，此时 $\lnot$ 已经转移到单独的 $C$ 上了</p><script type="math/tex;mode=display">B\rightarrow \left( \lnot C\rightarrow \left( A\rightarrow B \right) \right)</script><p>需要前件互换，<strong>再摘掉 $\lnot C$</strong></p><p>（<strong>注意：这一步可以不需要前件互换，只需用公理1+三段论，直接砍后件头</strong>）</p><ul><li>补充</li></ul><script type="math/tex;mode=display">\lnot \left( A\rightarrow B \right) \rightarrow \left( B\rightarrow C \right)</script><p>前面的 <strong>$\lnot$ 是在整体上的，还有另一种办法可以消去</strong></p><p>因为 $\lnot (A \to B)$ 可以推出 $A$ 或 $\lnot B$ ，利用<strong>三段论</strong>定理可以接上去。</p><p>此题可以用 $\lnot B$，转化后的形式是定理6。</p><ol><li><strong>二难推理</strong></li></ol><script type="math/tex;mode=display">\vdash \left( A\rightarrow C \right) \rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( A\lor B \right) \rightarrow C \right) \right)</script><p>二难推理系列的题目，比思维流更好的办法其实是定理18，并且套路十分明显。</p><ul><li>拆成</li></ul><script type="math/tex;mode=display">\lnot A\rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( A\lor B \right) \rightarrow C \right) \right)</script><p>首先第一部分，由于 $C$ 在后件的两个后件，此时用加后件定理可以轻松消去 $C$。</p><script type="math/tex;mode=display">\lnot A\rightarrow \left( \left( A\lor B \right) \rightarrow B \right)</script><p>再用一次前件互换定理，发现就是定理1。</p><ul><li>（<strong>这一步纯套路，每题都是一样</strong>）拆成</li></ul><script type="math/tex;mode=display">C\rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( A\lor B \right) \rightarrow C \right) \right)</script><p>此时不能直接用加后件了，否则最前面的 $C$ 消不掉。直接前件互换，</p><script type="math/tex;mode=display">\left( B\rightarrow C \right) \rightarrow \left( C\rightarrow \left( \left( A\lor B \right) \rightarrow C \right) \right)</script><p>发现后件是公理1，于是摘掉前件，成立。</p><p><strong>类似题</strong>：</p><script type="math/tex;mode=display">\vdash \left( A\rightarrow C \right) \rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( \left( A\rightarrow B \right) \rightarrow B \right) \rightarrow C \right) \right)</script><p>也可以用同样的套路秒做。</p><h3 id="3-反证法"><a href="#3-反证法" class="headerlink" title="3 反证法"></a>3 反证法</h3><p>前两种方法都想不出来的情况下考虑，书写过程会相对繁琐。</p><ol><li>基本方法</li></ol><p>假定原定理为0，按照依次将式子标上0和1，直到推出矛盾（一般会有多处，找容易的）。</p><p>证明时显而易见的（前几条）可以不用加注释，可以理解成真值表的体现。</p><p>后面的推理过程可以按标0和1的顺序来，通常都是由大后件的结论往前件找矛盾。</p><p><strong>最常使用：三段论定理</strong>，用于把 $\lnot P$ 接上去，最后才能转到矛盾。</p><ol><li>推演技巧</li></ol><p>最无脑的方法是把所有单项都用 $\lnot P$ 推出来，再进行排列组合出矛盾。</p><p>高级的方法是抓住「<strong>矛盾块</strong>」（通常是原式的一端），再把「<strong>另一个矛盾块</strong>」通过逆向推理法（直接法）证到原式的另一端，即可。</p><h3 id="4-演绎定理"><a href="#4-演绎定理" class="headerlink" title="4 演绎定理"></a>4 演绎定理</h3><p>没啥好说的，一般不给用，对三个以上变量比较友好，提取出所有前件后就可以用直接法证明。</p><h2 id="ND-中定理的证明"><a href="#ND-中定理的证明" class="headerlink" title="ND 中定理的证明"></a>ND 中定理的证明</h2><h3 id="思维流"><a href="#思维流" class="headerlink" title="思维流"></a>思维流</h3><p>本质是<strong>逆向推理法</strong>，逆推的同时可以注意左端项的逻辑规律（赋1，看矛盾）</p><p>结合常见形式及解决套路可以更快解决。</p><ol><li><strong>当右端项包含 $\lnot$ 时：</strong></li></ol><script type="math/tex;mode=display">\lnot A\land \lnot B\vdash \lnot \left( A\lor B \right)</script><p>用 $\lnot +$ 规则把右端项挪到左边时，要导出矛盾，往往这个矛盾是右端项的<strong>部分</strong>，如析取、合取的部分。</p><p>此时的惯常做法是将这两个矛盾合取，如 $A\land \lnot A$ ，这个式子必定为0，事实上左边此时的两个式子已经自相矛盾。</p><p>当然不一定要用 $A\land \lnot A$，因为左边矛盾的情况下，赋1可以推出很多对矛盾，只是这个最常见。</p><ol><li><strong>当左端项有 $\lor$ 时：</strong></li></ol><script type="math/tex;mode=display">\lnot A\lor \lnot B\vdash \lnot \left( A\land B \right)</script><p>充分利用析取，将其两项分别放到左端，用 $\in$ 规则把两项先推出来。</p><p>左端多出来的两项最终也需要消去。</p><ul><li>这就需要 $\lor-$ 规则，因此上面推出来的两式要最后导出到同一个目标，通常是$A\land \lnot A$，这类式子。</li><li>也有可能是需要 $\to +$ 规则，把小项拿到右边当前件。</li></ul><p><strong>注意</strong>：如果 $\lor$ 是含在某个大的式子里，也可以将小项直接拿到外面来推。</p><ol><li><strong>当右端项有 $\lor$ 时：</strong></li></ol><script type="math/tex;mode=display">\lnot \left( A\land B \right) \vdash \lnot A\lor \lnot B</script><p>一般可以用 $\lor -$ 简化，只需证一半，但是保留哪一半要根据左边的情况推理，即思维流。</p><p>但有时也不能上来就简化，因为左边的条件可能太宽泛了（太少了），因此可能要加上一些小项再看。</p><p>这时候常用的是 $-$ 规则。这也是最难用的一个规则。</p><ol><li><strong>当左端项有 $\land$ 时：</strong></li></ol><script type="math/tex;mode=display">A\land \left( {B}\lor {C} \right) \vdash \left( {A}\land {B} \right) \lor \left( {A}\land {C} \right)</script><p>利用 $\land -$ 规则，将两个子命题拆出来。</p><p>当然不能白拆，要和前几条综合起来用，往往时加入了很多项后，用这个来助攻。</p><ol><li><strong>当右端项有 $\land$ 时：</strong></li></ol><p>可能是要把两个细分都推出来。</p><script type="math/tex;mode=display">\lnot \left( {A}\lor {B} \right) \vdash \lnot {A}\land \lnot {B}</script><p>也可能是要整个推出，即生成未出现过的项，常用 $\lor-$ 规则。</p><script type="math/tex;mode=display">\left( A\land {B} \right) \lor \left( {A}\land {C} \right) \vdash {A}\land \left( {B}\lor {C} \right)</script><ol><li><strong>在右端生成从未出现过的项：</strong></li></ol><p>常用 $\lor-$ 规则，但是这种必须有理有据的推出，而且左端要含 $\lor$。</p><p>另一个方法是 $\lnot -$，矛盾可以推任意。</p><ul><li>通常的用法是：</li></ul><script type="math/tex;mode=display">\begin{aligned}
XXX, A, \lnot A&\vdash A
\\
XXX, A, \lnot A&\vdash \lnot A
\\
XXX, A, \lnot A&\vdash B
\end{aligned}</script><ul><li>然后再想办法消掉多出来的单项，如</li></ul><script type="math/tex;mode=display">XXX, \lnot A\vdash A\rightarrow B</script><ul><li>或者再利用 $\lor-$ ，二者结合，如</li></ul><script type="math/tex;mode=display">\begin{aligned}
XXX, A, \lnot A&\vdash B
\\
XXX, A, B&\vdash B
\\
XXX, A&\vdash \lnot A\lor B
\\
XXX, A&\vdash B
\end{aligned}</script><p>例：（需要用到两种引入方法）</p><script type="math/tex;mode=display">\left( A\lor B \right) \land \left( \lnot B\lor C \right) \vdash A\lor C</script><p>按照思维流推断，发现最开始可以引入 $B$，$\lnot B$ 的矛盾推任意。</p><p>而右端项的析取，一次只能推一半。</p><p>推一半的时候，还是需要引入新项，此时用 $\lor-$ ，因为左端项还有个析取（隐藏在合取中）可以用，将两个子项单独拿出来放到左边，即可推出。</p><ol><li><strong>当左端项有 $\to$ 时：</strong></li></ol><p>由于ND中没有分离规则，所以要利用好这个 $\to$ 需要先在左端加上前件，用两次 $\in$ 规则。</p><p>最后再用 $\to -$ 规则把后件推到右端。</p><ol><li><strong>当左端项包含 $\lnot$ 时：</strong></li></ol><script type="math/tex;mode=display">\lnot ( A\to B ) \vdash A\land \lnot B</script><p>想按照逻辑推出东西基本不可能，最好的办法是利用已有的一个 $\lnot$ ，制造矛盾，使得矛盾可以推任意，或者 $\lnot +$。</p><p>但是如果要制造矛盾，必须引入新的变量，这样左边就会多一个元素，即使 $\lnot -$ 推出了任意，但左边也不符合。</p><p>因此可以用 $\lnot +$ 规则，在左边引入一个<strong>待求右端项</strong>的 $\lnot$ ，推出矛盾后再用反证法把<strong>待求变量</strong>移到右边，此时可能要用 $\lnot \lnot-$ 规则。</p><h2 id="FC-中定理的证明"><a href="#FC-中定理的证明" class="headerlink" title="FC 中定理的证明"></a>FC 中定理的证明</h2><h3 id="两种书写格式"><a href="#两种书写格式" class="headerlink" title="两种书写格式"></a>两种书写格式</h3><ol><li><p>用 PC 中的公式序列，最后再补上 $\Gamma$ ，不用序号，用「<strong>从而</strong>…」连接结论。</p><p>常用于 <strong>FC 反证法定理8</strong>、<strong>双向证明</strong>（先证后证）</p></li><li><p>用 ND 中的演绎序列，直接证出结果（书写内容多），如果此时<strong>要用 PC 或者 FC 的定理</strong>，需要在公式前面写 $\vdash$，并在下一条用分离规则导出（<strong>注意</strong>：不用写用若干次 $+$ 规则）。</p><p>常用于 <strong>FC 存在消除定理10</strong></p></li></ol><p>具体证明过程依次使用以下方法。</p><h3 id="存在消除定理"><a href="#存在消除定理" class="headerlink" title="存在消除定理"></a>存在消除定理</h3><p>当式子左端有 $\exists xA$ 或 $\exists x(A\to B)$ 的量词时，优先考虑用存在消除定理10。</p><p>在左端补上 $A$ 或 $(A\to B)$ ，并用 ND 中的规则推出想要的右端项。</p><p>接着就可以用存在消除定理把左端补上的东西消除了。</p><script type="math/tex;mode=display">\begin{aligned}
&\left( 1 \right) \exists v\left( B\rightarrow A \right) , B\rightarrow A, B\vdash A
\\
&\left( 2 \right) \exists v\left( B\rightarrow A \right) , B\vdash \exists v\left( B\rightarrow A \right) 
\\
&\left( 3 \right) \exists v\left( B\rightarrow A \right) , B\vdash A\,\,
\end{aligned}</script><p><strong>注意</strong>：虽说「存在」消除定理，但是最后消掉的是 $\exists x$ 里面的东西。</p><p><strong>警告</strong>：使用该方法时，(3) 式中左右端项都不能有 $v$ 的自由出现！</p><h3 id="反证法定理"><a href="#反证法定理" class="headerlink" title="反证法定理"></a>反证法定理</h3><p>反证法不一定是最优解，但是是最 FC 的做法，一般标准答案会用。当右端的整体上有个 $\lnot$ 打头，或者右端有个 $\exists x$ 时，建议使用。</p><script type="math/tex;mode=display">\begin{aligned}
&\text{从而}\varGamma \vdash A\,\,\text{且} \varGamma \vdash \lnot A
\\
&\text{从而公式集}\varGamma \text{不一致，由}FC\text{反证法定理}8
\\
&\text{得}\forall vB\rightarrow A\vdash \lnot \forall v\lnot \left( B\rightarrow A \right)
\end{aligned}</script><p>注意：如果左右都有 $\exists x$，优先用存在消除定理。</p><h3 id="思维流-1"><a href="#思维流-1" class="headerlink" title="思维流"></a>思维流</h3><p>前两种方法都不可以使用的时候考虑，跟 ND 中的证明没啥区别。可能会用到一些 PC 中的定理，如三段论定理8、逆否定理、以及一些小套件（定理6，定理9）。</p><h3 id="其他小技巧"><a href="#其他小技巧" class="headerlink" title="其他小技巧"></a>其他小技巧</h3><ol><li>FC 定理 9 平时用的少，但是有时有妙用。</li></ol><script type="math/tex;mode=display">\begin{aligned}
&\left( 1 \right) \exists v\left( B\rightarrow A \right) , B\vdash A
\\
&\left( 2 \right) \exists v\left( B\rightarrow A \right) , \forall vB\vdash A
\end{aligned}</script><ol><li><p>FC 也有<strong>演绎定理</strong>，并且考试中可以<strong>直接使用</strong>。（省步骤，不然就得用 ND 中复杂的规则来代替）</p><p>比如往左放就要用 $(+)$ 再用 $(\to-)$ 规则，往右放就要用 $(\to +)$ 规则。</p></li><li><p>全称推广定理 和 定理1 是互逆的关系，是 PC/ND 系统与 FC 联系的关键。常用于导出待证明式子右端项。</p></li><li><p>补充：使用 FC 定理时，有的定理有限制。</p></li></ol><ul><li>公理4 （项 t 对 v 可代入）</li><li>公理6 （v 在 A 中无自由出现）</li><li><strong>全称推广定理5</strong> （v 在 $\Gamma$ 中无自由出现）</li><li>定理9 （v 在 $\Gamma$ 中无自由出现）</li><li><strong>存在消除定理10</strong> （v 在 $\Gamma$ 和 B 中无自由出现）（在最后一行前后都无自由出现）</li></ul><h2 id="谓词演算部分"><a href="#谓词演算部分" class="headerlink" title="谓词演算部分"></a>谓词演算部分</h2><h3 id="构造语义和指派"><a href="#构造语义和指派" class="headerlink" title="构造语义和指派"></a>构造语义和指派</h3><p>语义就是 $U=<d ,i>$ 即论域和解释，其中论域部分令 $D=\{1, 2\}$。</d></p><p>解释部分 $I$ 要加横杠，分别对常元、函词、谓词做一个映射。<strong>构造时根据要求，巧妙选择</strong>。</p><script type="math/tex;mode=display">\begin{aligned}
&\bar{a}=1
\\
&\bar{f}\left( 1,1 \right) =1,\bar{f}\left( 1,2 \right) =1,\bar{f}\left( 2,1 \right) =1,\bar{f}\left( 2,2 \right) =1
\\
&\bar{R}=\left\{ 1,2 \right\} ,\bar{P}=\left\{ \left( 1,1 \right) \right\} ,\bar{Q}=\oslash
\end{aligned}</script><p><strong>注意</strong>：函词是<strong>个体</strong>映射到<strong>个体</strong>，谓词是取这些<strong>个体</strong>时值为 <strong>True</strong>。<strong>一元谓词跟函词很容易混淆</strong>。</p><p>指派 $s$ 就是给变元取值。</p><script type="math/tex;mode=display">\bar{x}=2,\bar{y}=1</script><p>注意：书写时展开函词的时候，<strong>横杠</strong>都要加上。特别是多层函词时。</p><script type="math/tex;mode=display">\overline{f\left( x,y \right) }=\bar{f}\left( \bar{x},\bar{y} \right)</script><p>判断真假的时候，简单的直接写 T 或 F 就可以（需要横杠），表示映射。</p><p>但是含有<strong>任意、存在量词</strong>的必须用标准写法（不用横杠）<strong>拆去</strong>。</p><script type="math/tex;mode=display">\begin{aligned}
&\models _U\left( \forall x \right) P\left( x \right) \left[ s \right] \,\, iff.\models _UP\left( x \right) \left[ s\left( x|1 \right) \right] \,\,\text{且} \models _UP\left( x \right) \left[ s\left( x|2 \right) \right] 
\\
&\models _U\left( \exists x \right) P\left( x \right) \left[ s \right] \,\, iff.\models _UP\left( x \right) \left[ s\left( x|1 \right) \right] \,\,\text{或} \models _UP\left( x \right) \left[ s\left( x|2 \right) \right]
\end{aligned}</script><h3 id="构造自然语句的形式化"><a href="#构造自然语句的形式化" class="headerlink" title="构造自然语句的形式化"></a>构造自然语句的形式化</h3><p>格式要注意，在开头要令出谓词、函词，一般不需要论域（除非真的只有一种个体词）。</p><p><strong>每个出现的个体词</strong>都应该有对应的谓词，如「作家」「作品」「小说」「学生」「实数」。</p><p>一个基本原则：$\forall \text{配}\rightarrow \text{，}\exists \text{配}\land $</p><p>常用短语：</p><ul><li>并非所有：$\lnot \forall x$</li><li>有且仅有、唯一：$\exists x\left( R\left( x \right) \land \forall u\left( R\left( u \right) \rightarrow E\left( x, u \right) \right) \right) $</li><li>不是就是、要么要么：$\forall x\left( R\left( x \right) \rightarrow P\left( x \right) \oplus Q\left( x \right) \right) $</li></ul><p>例题：形式化表示第二数学归纳法。</p><script type="math/tex;mode=display">\begin{aligned}
&
\text{令谓词：}
\\&
F\left( x \right) \text{表示当}n=x\text{时，命题成立；}
\\&
L\left( x,k \right) \text{表示}x<k\text{；}
\\&
P\left( x \right) \text{表示}x\text{是正整数。}
\\&
\left( 1 \right) F\left( 1 \right) 
\\&
\left( 2 \right) \forall k\left( \left( P\left( k \right) \land \forall x\left( P\left( x \right) \land L\left( x,k \right) \rightarrow F\left( x \right) \right) \right) \rightarrow F\left( k \right) \right) 
\\&
\left( 3 \right) \forall x\left( P\left( x \right) \rightarrow F\left( x \right) \right)
\end{aligned}</script></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a> <a class="hover-with-bg" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/">本科课程</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/Math/">Math</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="nofollow noopener noopener"><u>CC BY-NC-SA 4.0</u></a> 协议，转载请注明来自 <a href="https://hwcoder.top" rel="noopener"><u>Hwcoder</u></a>！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/Git-Note-1"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Git学习笔记 #1 基础知识介绍</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/IR-Project"><span class="hidden-mobile">IR课程项目-文学检索-开发文档</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"jdbBr3BddTiqSCPnXw6sXFv7-gzGzoHsz","appKey":"2bjgwDr2opjVCwhgjDMpk53c","path":"window.location.pathname","placeholder":"说点什么吧( •̀ ω •́ )✧","avatar":"retro","meta":["nick","mail","link"],"requiredFields":["nick"],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/local-search.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script defer src="/js/leancloud.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js"></script><script>!function(t){(0,Fluid.plugins.typing)(t.getElementById("subtitle").title)}((window,document))</script><script>MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script><script src="/js/boot.js"></script></body></html>