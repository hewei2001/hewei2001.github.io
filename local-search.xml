<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ML学习笔记 #2 梯度下降：多元线性回归</title>
    <link href="/2021/10/04/ML-Note-2/"/>
    <url>/2021/10/04/ML-Note-2/</url>
    
    <content type="html"><![CDATA[<p>在前文的基础上，我们引入多个特征变量，探讨梯度下降对多元线性回归的解法。此外，下一节将介绍正规方程在解多元线性回归中的应用。</p><h2 id="多元线性回归-Multiple-Linear-Regression"><a href="#多元线性回归-Multiple-Linear-Regression" class="headerlink" title="多元线性回归 | Multiple Linear Regression"></a>多元线性回归 | Multiple Linear Regression</h2><p>现在我们的样本点 $\left(x^{(i)}, y^{(i)}\right)$ 有多个特征作为<strong>输入变量</strong>，即给定的训练集为：</p><script type="math/tex; mode=display">\left\{\left(x_1^{(i)},x_2^{(i)},\cdots,x_n^{(i)},y^{(i)}\right),\;i=1,2,\cdots,m\right\}</script><ul><li>$n$ 代表单个样本的特征数量；</li><li>${x}^{(i)}$ 代表第 $i$ 个观察实例的<strong>特征向量</strong>；</li><li>$x^{(i)}_j$ 代表第 $i$ 个观察实例的第 $j$ 个<strong>特征分量</strong>。</li></ul><p>同时，回归方程 $h$ 也具有多个参数 $\theta_0,\theta_1,\cdots,\theta_n$：</p><script type="math/tex; mode=display">h_\theta(x)=\theta_0+\theta_1x_1\cdots+\theta_nx_n</script><p>为简化表达式，这里假定 $x_0 \equiv 1$ ，并以<strong>向量</strong>（vector）表示参数和自变量：$\theta=(\theta_0,\cdots,\theta_n)^T,\;x=(x_0,\cdots,x_n)^T$，得到：</p><script type="math/tex; mode=display">h_\theta(x)=\theta^Tx</script><h3 id="多变量梯度下降"><a href="#多变量梯度下降" class="headerlink" title="多变量梯度下降"></a>多变量梯度下降</h3><p>类似地，我们定义平方误差代价函数：</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}\sum_{i=1}^m\left(\theta^Tx^{(i)}-y^{(i)}\right)^2</script><p>我们的目标和一元线性回归中一样，要找出使得代价函数最小的一系列参数。于是，</p><script type="math/tex; mode=display">\frac{\partial J}{\partial \theta}=\frac{1}{m}\sum_{i=1}^m\left(\theta^Tx^{(i)}-y^{(i)}\right)x^{(i)}</script><p>梯度下降时，不断作迭代：</p><script type="math/tex; mode=display">\theta:=\theta-\alpha\cdot\frac{\partial J}{\partial \theta}</script><p>即可。</p><h3 id="特征缩放与标准化"><a href="#特征缩放与标准化" class="headerlink" title="特征缩放与标准化"></a>特征缩放与标准化</h3><p>当不同自变量取值范围相差较大时，绘制的<strong>等高线图</strong>上的椭圆会变得瘦长，而梯度下降<strong>算法收敛</strong>将会很慢，因为每一步都可能会跨过这个椭圆导致<strong>振荡</strong>。这里略去数学上的证明。</p><p>此时，我们需要把所有<strong>自变量</strong>进行缩放、标准化，使其落在 -1 到 1 之间。最简单的方法是，置：</p><script type="math/tex; mode=display">x_i^{(j)}:=\frac{x_i^{(j)}-\mu_i}{\sigma_i}</script><p>其中，$\mu_i=\frac{1}{m}\sum\limits_{j=1}^m x_i^{(j)}$ 是样本<strong>均值</strong>（Mean Value），$\sigma_i=\sqrt{\frac{\sum\limits_{j=1}^m\left(x_i^{(j)}-\mu_i\right)^2}{m-1}}$ 是样本<strong>无偏标准差</strong>（Unbiased Standerd Deviation），就完成了<strong>归一化</strong>（Normalization）。归一化后样本均值为 0，方差为 1。</p><p>需要注意的是，<strong>因变量</strong>不需要归一化，否则计算的结果将失真。且如果进行了归一化，对所有<strong>待测</strong>样本点也需要进行一样的操作。</p><blockquote><p>此外，线性回归并不适用于所有情形，有时我们需要曲线来适应我们的数据，这时候我们也要对特征进行<strong>构造</strong>，如二次函数、三次函数、幂函数、对数函数等。构造后的新变量就可以当作一个新的特征来使用，这就是<strong>多项式回归</strong>（Polynomial Regression）。新变量的取值范围可能更大，此时，特征缩放就非常有必要！</p></blockquote><h3 id="学习率-alpha"><a href="#学习率-alpha" class="headerlink" title="学习率 $\alpha$"></a>学习率 $\alpha$</h3><p>上一节谈到，学习率（Learnig rate）的选取很重要，过小则梯度下降很慢，过大则有可能不收敛。通过绘制<strong>迭代收敛曲线</strong>（Convergence Graph）可以看出学习率的好坏，也可以看出何时算法能收敛并及时<strong>终止算法</strong>。</p><p><img src="/img/blog/ML-Note-2-images/cost-iter.png" alt="代价函数-迭代次数" width=50% /></p><p>特别地，当 $\alpha$ 取值过大时，曲线可能呈现<strong>上扬</strong>或<strong>波浪线</strong>型，解决办法都是选择更小的 $\alpha$ 值。可以证明，只要 $\alpha$ 足够小，凸函数都会收敛于极点。</p><p>此外，还有一种终止算法的方法：判断在某次或连续 $n$ 次迭代后 $J(\theta)$ 的变化小于某个极小量，如 $\varepsilon =1e^{-3}$，此时就可以认为算法终止。但这种办法则不能用于选择尽量大的 $\alpha$ 值。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># load data, data.shape = (47, 3)</span><br>data = np.genfromtxt(<span class="hljs-string">&quot;ex1data2.txt&quot;</span>, delimiter=<span class="hljs-string">&#x27;,&#x27;</span>)<br>(m, n) = data.shape<br>X = data[:, :-<span class="hljs-number">1</span>]<br>y = data[:, -<span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># normalization</span><br>mu = X.mean(axis=<span class="hljs-number">0</span>)<br>sigma = X.std(axis=<span class="hljs-number">0</span>, ddof=<span class="hljs-number">1</span>)<br>X = (X - mu) / sigma<br>X = np.c_[np.ones(m), X] <span class="hljs-comment"># 增加一列 1</span><br><br><span class="hljs-comment"># parameters</span><br>alpha = <span class="hljs-number">0.01</span><br>num_iters = <span class="hljs-number">1500</span><br>theta = np.zeros(n)<br>J_history = np.zeros(num_iters)<br><br><span class="hljs-comment"># Gradient Descent</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, num_iters):<br>error = (X @ theta).flatten() - y  <span class="hljs-comment"># error.shape = (47, )</span><br>theta -= (alpha / m) * np.<span class="hljs-built_in">sum</span>(X * error[:, np.newaxis], axis=<span class="hljs-number">0</span>)<br>J_history[i] = np.<span class="hljs-built_in">sum</span>(np.power(error, <span class="hljs-number">2</span>)) / (<span class="hljs-number">2</span> * m)<br><br><span class="hljs-comment"># predict</span><br>predict = (np.array([<span class="hljs-number">1650</span>, <span class="hljs-number">3</span>]) - mu) / sigma<br>predict = np.r_[<span class="hljs-number">1</span>, predict]<br><span class="hljs-built_in">print</span>(predict @ theta)<br><br><span class="hljs-comment"># plot the convergence graph</span><br>plt.plot(np.arange(J_history.size), J_history)<br>plt.xlabel(<span class="hljs-string">&#x27;Number of iterations&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Cost J&#x27;</span>)<br>plt.show()<br></code></pre></div></td></tr></table></figure><p>得到的 $\left( \theta_0, \theta_1, \theta_2 \right)$ 结果是：[340412.65957447 110631.04841449  -6649.47240647]，预测在 $\left( x_1=1650,x_2=3 \right) $ 时的房价为 293101.0568574823。</p><p>绘制的迭代收敛曲线如下：</p><p><img src="/img/blog/ML-Note-2-images/Figure_1.png" alt="多元线性回归的迭代收敛曲线" width=50% /></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PR学习笔记 #2 贝叶斯分类器</title>
    <link href="/2021/10/02/PR-Note-2/"/>
    <url>/2021/10/02/PR-Note-2/</url>
    
    <content type="html"><![CDATA[<p>在 <a href="https://hwcoder.top/2021/08/25/IR-Note-4/">IR学习笔记 #4 概率模型</a> 中曾提到朴素贝叶斯（Naive Bayes）的应用，这里正式学到。贝叶斯分类器基于概率论的原理，是最经典的分类算法之一。其解决的核心点在于根据<strong>已有概率信息</strong>，对未知事物发生结果的概率计算。</p><p><img src="/img/blog/PR-Note-2-images/bayes.jpg" alt="贝叶斯分类器" width = 50% /></p><h2 id="朴素贝叶斯-Naive-Bayes"><a href="#朴素贝叶斯-Naive-Bayes" class="headerlink" title="朴素贝叶斯 | Naive Bayes"></a>朴素贝叶斯 | Naive Bayes</h2><p>概率论中有许多易混淆的<strong>数学表述</strong>，这里列举：</p><ul><li>条件概率公式: $P(A \mid B)=\frac{P(A B)}{P(B)}$</li><li>概率乘法公式: $P(A B)=P(A \mid B) P(B)$</li><li>全概率公式： $P(A)=\sum_{i=1}^{n} P\left(A B_{i}\right)=\sum_{i=1}^{n} P\left(A \mid B_{i}\right) P\left(B_{i}\right)$</li><li>贝叶斯公式：$P\left( B_i\mid A \right) =\frac{P\left( AB_i \right)}{P\left( A \right)}=\frac{P\left( A\mid B_i \right) P\left( B_i \right)}{\sum_{i=1}^n{P\left( A\mid B_i \right) P\left( B_i \right)}}$</li></ul><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>下面引入训练集的定义：</p><script type="math/tex; mode=display">D=\left\{ x^{\left( i \right)},i=1,2,\cdots ,m \right\} ,\;C=\left\{ x^{(i)}\in \omega ^{\left( j \right)},\;j=1,2,\cdots ,N \right\}</script><ul><li>$m$ 代表训练集中样本点的数量；</li><li>$x^{(i)}$ 代表第 $i$ 个样本点，是一个 $n$ 维向量，$n$ 代表特征数；</li><li>$N$ 代表类别数，所有训练集中样本点被显式地标注；</li><li>样本向量展开为 $x^{\left( i \right)}=\left\{ A_1=a_{i1},A_2=a_{i2},\cdots ,A_n=a_{in} \right\} $。</li></ul><p>贝叶斯分类器要解决的问题就是，利用上述数据集，将一个新的测试样例 $x=\left\{ A_1=a_{1},A_2=a_{2},\cdots ,A_n=a_{n} \right\} $ 归为 $N$ 中的某一类。在这个基础上，我们有如下定义：</p><ul><li>先验概率：$P\left( \omega ^{\left( j \right)} \right)$，表示对<strong>任意未知</strong>测试样例，将其归为类别 $\omega ^{\left( j \right)}$ 的概率，常用训练集中类别 $\omega ^{\left( j \right)}$ 占 $m$ 的比例估计。</li><li>后验概率：$P\left( \omega ^{\left( j \right)} \mid x \right)$，表示对<strong>已知特征</strong>测试样例，将其归为类别 $\omega ^{\left( j \right)}$ 的概率，就是贝叶斯分类器所要求的。</li><li>似然概率：$P\left( x \mid \omega ^{\left( j \right)} \right)$，表示在类别 $\omega ^{\left( j \right)}$ 中，出现<strong>属性等同于测试样例的训练样例</strong>的概率，可用训练集类别 $\omega ^{\left( j \right)}$ 中含 $x$ 的比例估计。</li></ul><p>于是，利用贝叶斯公式导出：</p><script type="math/tex; mode=display">P\left( \omega ^{\left( j \right)} \mid x \right) =\frac{P\left( x \mid \omega ^{\left( j \right)} \right) P\left( \omega ^{\left( j \right)} \right)}{P\left( x \right)}=\frac{P\left( x \mid \omega ^{\left( j \right)} \right) P\left( \omega ^{\left( j \right)} \right)}{\sum_{i=1}^N{P\left( x \mid \omega ^{\left( i \right)} \right) P\left( \omega ^{\left( i \right)} \right)}}</script><h3 id="似然概率"><a href="#似然概率" class="headerlink" title="似然概率"></a>似然概率</h3><p>前文提到，在计算 $P(x \mid \omega ^{\left( j \right)})$ 时，我们可用训练集类别 $\omega ^{\left( j \right)}$ 中含 $x$ 的比例估计。然而，这样做会遇到一个问题：当类别 $\omega ^{\left( j \right)}$ 中不存在 $x$ 样本点的时候，如果将概率视作 0，那么结果则必为 0，显然不符合要求。</p><p>而上述这种情况经常会发生在<strong>多属性</strong>的样本分类中，因此，我们改用：</p><script type="math/tex; mode=display">P\left(x \mid \omega ^{\left( j \right)}\right)=\prod_{k=1}^n{P\left(A_k=a_k \mid \omega ^{\left( j \right)}\right)}</script><p>其中，$P\left(A_k=a_k \mid \omega ^{\left( j \right)}\right)$ 表示在类别 $\omega ^{\left( j \right)}$ 中，第 $k$ 个属性值时 $a_k$ 的样本出现的概率。</p><blockquote><p>此处采用连乘的形式，是基于<strong>所有属性相互独立</strong>的假设（这正是「<strong>朴素</strong>」的由来），否则应当使用概率乘法公式，即：$P\left( A_1A_2A_3 \right) =P\left( A_1 \right) P\left( A_2 \mid A_1 \right) P\left( A_3 \mid A_1A_2 \right) $。</p></blockquote><p>对于 $P\left(A_k=a_k \mid \omega ^{\left( j \right)}\right)$ 的求法，则须分两种情况来讨论：</p><ol><li><p>$A_k$ 是<strong>离散</strong>属性，直接用 $a_k$ 在类别中的比例估计即可。如果依然发生了零频问题，则需要考虑使用折扣法、插值法、退避法等进行<strong>平滑处理</strong>。</p></li><li><p>$A_k$ 是<strong>连续</strong>属性，通常我们假设 $A_k$ 在类别中是符合均值为 $\mu$，标准差为 $\sigma$ 的正态分布，则用其<strong>概率密度函数</strong>的值估计其概率：</p><script type="math/tex; mode=display">P(A_k=a_k \mid \omega ^{\left( j \right)})=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(a_k-\mu )^2}{2\sigma ^2}}</script></li></ol><h2 id="决策理论"><a href="#决策理论" class="headerlink" title="决策理论"></a>决策理论</h2><p>有了后验概率，现在则需要考虑决策问题。</p><h3 id="最小错误率分类"><a href="#最小错误率分类" class="headerlink" title="最小错误率分类"></a>最小错误率分类</h3><p>在贝叶斯分类器中，在我们计算出所有类别的后验概率之后，若有：</p><script type="math/tex; mode=display">P\left( \omega ^{\left( j \right)} \mid x \right) =\max \left\{ P\left( \omega ^{\left( 1 \right)} \mid x \right) ,P\left( \omega ^{\left( 2 \right)} \mid x \right) ,\cdots ,P\left( \omega ^{\left( N \right)} \mid x \right) \right\}</script><p>则认为 $x\in \omega ^{\left( j \right)}$，这是基于<strong>最小化错误率</strong>的思想。当选择了类别 $\omega ^{\left( j \right)}$，错误分类的概率就是 $x\notin \omega ^{\left( j \right)}$ 的概率：</p><script type="math/tex; mode=display">P(\mathrm{error} \mid x)=1-\underset{j=1,\cdots ,N}{\max}\left\{ P\left( \omega ^{\left( j \right)} \mid x \right) \right\}</script><p>当然，这时在固定测试样本为 $x$ 的情况下，如果要求对所有不同的 $x$ 取值的平均错误率 $P(\mathrm{error})$，则需要对整个特征空间进行加权求和。</p><p>此外，根据最小错误率分类时，我们只需要比较出后验概率最大的一类就行，因此在计算过程中只需比较 $P\left( x \mid \omega ^{\left( j \right)} \right) P\left( \omega ^{\left( j \right)} \right)$ 的大小即可。</p><h3 id="最小风险分类"><a href="#最小风险分类" class="headerlink" title="最小风险分类"></a>最小风险分类</h3><p>但在实际分类情形中，我们还应当考虑每次决策的代价——譬如将患者诊断为阴性的代价要远大于将正常人诊断为阳性。为此，我们补充如下定义：</p><ul><li>决策：$\alpha_i$，表示将测试样例 $x$ 分到类别 $\omega ^{\left(i\right)}$。</li><li>代价：$\lambda _{ij}=\lambda \left( \alpha _i \mid \omega _j \right)$，表示将<strong>真实</strong>类别 $\omega ^{\left(j\right)}$ 中的样本分到<strong>预测</strong>类别 $\omega ^{\left(i\right)}$ 的代价，当 $i=j$ 时，代价可忽略不计。</li></ul><p>则可以得到下面的<strong>条件风险</strong>：</p><script type="math/tex; mode=display">R\left( \alpha _i \mid x \right) =E\left( \lambda _{ij} \mid x \right) =\sum_{j=1}^N{\lambda _{ij}}P\left( \omega _j \mid x \right)</script><p>如果我们致力于<strong>最小化总体风险</strong>，则需要定义<strong>决策函数</strong>（最优分类器）：</p><script type="math/tex; mode=display">\alpha \left( x \right) =\underset{i=1,\cdots ,N}{\mathrm{arg}\min}R\left( \alpha _i\mid x \right)</script><p>此时，在整个特征空间中，对所有不同的 $x$ 取值，采取决策函数带来的<strong>期望风险</strong>为：</p><script type="math/tex; mode=display">R=\int{R\left( \alpha \left( x \right) \mid x \right)}P\left( x \right) \mathrm{d}x</script><h2 id="半朴素贝叶斯分类"><a href="#半朴素贝叶斯分类" class="headerlink" title="半朴素贝叶斯分类"></a>半朴素贝叶斯分类</h2><p>前文提到，朴素贝叶斯分类中采用了<strong>所有属性条件独立</strong>的假设，但在现实任务中这个假设往往很难成立。因此，我们对假设进行一定程度的放松，适当考虑<strong>部分属性</strong>间的相互依赖信息，因此称为「<strong>半朴素</strong>」。</p><p>其中，<strong>独依赖估计</strong>（One-Dependent Estimator，ODE）是半朴素贝叶斯分类器最常用的一种策略，顾名思议，就是假设每个属性<strong>最多仅依赖于一个</strong>其他属性。</p><p>被依赖的属性称为<strong>父属性</strong>，用 $pA_k$ 来表示，则似然概率：</p><script type="math/tex; mode=display">P\left( x\mid \omega ^{\left( j \right)} \right) =\prod_{k=1}^n{P\left( A_k=a_k\mid \omega ^{\left( j \right)},pA_k=pa_k \right)}</script><p>那么，问题的关键就转化为如何确定每个属性的父属性。最直接的做法就是假设所有属性都依赖于同一个父属性，称之为<strong>超父</strong>（Super-Parent），对应的方法称为 <strong>SPODE</strong> (Super-Parent ODE)。</p><p>此外，还有更为复杂的 <strong>TAN</strong> (Tree Augmented Naive Bayes)，通过计算所有属性两两之间的<strong>条件互信息</strong>（Conditional Mutual Information）：</p><script type="math/tex; mode=display">I\left( A_i,A_j\mid C \right) =\sum_{A_i,A_j;\omega ^{\left( j \right)}\in C}{P}\left( A_i,A_j\mid \omega ^{\left( j \right)} \right) \log \frac{P\left( A_i,A_j\mid \omega ^{\left( j \right)} \right)}{P\left( A_i\mid \omega ^{\left( j \right)} \right) P\left( A_j\mid \omega ^{\left( j \right)} \right)}</script><p>绘制出带权无向完全图，任意两个结点之边的权重为 $I\left( A_i,A_j\mid C \right)$。再构建此完全图的<strong>最大带权生成树</strong>，挑选根结点，将边置为有向，就得到了每个属性及其父属性的依赖关系。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>模式识别</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
      <tag>PR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PR学习笔记 #1 KNN分类器</title>
    <link href="/2021/10/01/PR-Note-1/"/>
    <url>/2021/10/01/PR-Note-1/</url>
    
    <content type="html"><![CDATA[<p>该笔记是本人于哈尔滨工业大学（深圳）2021 年秋季学期「模式识别」课程的笔记，授课教师为 <a href="https://scholar.google.com/citations?hl=zh-CN&amp;user=zOVgYQYAAAAJ">徐勇</a> 教授。姑且算是一门 CV 入门课程。</p><h2 id="PR-vs-ML"><a href="#PR-vs-ML" class="headerlink" title="PR vs. ML"></a>PR vs. ML</h2><p>「模式识别」与「机器学习」作为学校开设的<strong>人工智能</strong>领域二选一的先修课程，相比是有其考虑的。作为一个初学者，或许需要对这二者有更系统的认识。</p><p>这里引用一篇知乎回答的内容：</p><p><img src="/img/blog/PR-Note-1-images/content.jpg" alt="参考自相关书籍目录" width = 80% /></p><p>从上面的目录大致看出模式识别跟机器学习之间有很大部分的<strong>重叠</strong>。但是两者之间还是有很明显的区别的：</p><ul><li>在模式识别中，模式即用来描述研究对象的<strong>特征</strong>。一般模式识别中的大部分分类器，都是在假定已经了用来描述对象性质的特征，系统的输入就是这些处理好的特征。因此，<strong>模式识别研究的是怎么样通过输入的特征对样本进行分类</strong>。</li><li>然而，如果特征与所研究的分类问题没有关系或者关系很弱，那么无论采用怎么样的分类器，都很难取得理想的分类效果。相比之下，<strong>机器学习更加关注的是特征抽取、特征分析，进而实现分类</strong>。</li></ul><p>此外，既然上述图中还提到了「深度学习」，那不妨探讨一下经典面试题「深度学习和机器学习有什么不同？」，同样与特征有关：</p><ul><li><strong>深度学习是一种特殊的机器学习</strong>，具有强大的能力和灵活性。它通过学习将世界表示为嵌套的层次结构，每个表示都与<strong>更简单的特征</strong>相关，而抽象的表示则用于计算<strong>更抽象的表示</strong>。</li><li>传统的机器学习侧重人工进行特征抽取、特征分析，而深度学习从数据中先学习简单的特征，并从其逐渐学习到更为复杂抽象的深层特征，<strong>不依赖人工的特征工程</strong>。</li></ul><h2 id="K-近邻算法-K-Nearest-Neighbor"><a href="#K-近邻算法-K-Nearest-Neighbor" class="headerlink" title="K 近邻算法 | K-Nearest Neighbor"></a>K 近邻算法 | K-Nearest Neighbor</h2><p>最近邻算法是解决<strong>分类</strong>问题的一种算法，是一种监督学习算法。它的思想是：如果一个<strong>样本点</strong>在特征空间中<strong>最相似的样本点</strong>中的属于某一个类别，则该样本也属于这个类别。</p><p>关于「<strong>相似</strong>」这个概念，涉及到<strong>样本距离</strong>的度量，常用的度量方式是<strong>二范数</strong>，对向量而言就是<strong>欧式距离</strong>（Euclidean Distance)：</p><script type="math/tex; mode=display">D(x,y)=\sqrt{\sum_{i=1}^n{(}x_i-y_i)^2}=\left\| x-y \right\| _2</script><p>大多数情况下，欧式距离可以满足我们的需求，但有时候也需要了解其他方式：</p><ul><li>闵可夫斯基距离（Minkowski Distance）：$\sqrt[p]{\sum\limits_{i=1}^{n}(|x_i-y_i|)^p}$</li><li>曼哈顿距离（Manhattan Distance）：$\sum\limits_{i=1}^{n}|x_i-y_i|$</li><li>切比雪夫距离（Chebyshev Distance）：$\underset{i=1,\cdots ,n}{\max}\left| x_{\boldsymbol{i}}-y_i \right|$</li><li>汉明距离（Hamming Distance）：仅当特征值为 bool 值时使用</li><li>夹角余弦距离（Cosine Distance）：$\cos \theta =\frac{\sum_{i=1}^n{x_i}\times y_i}{\sqrt{\sum_{i=1}^n{x_{i}^{2}}\sum_{i=1}^n{y_{i}^{2}}}}$</li></ul><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>解决了度量问题，剩下的就很简单了，假设有训练集：</p><script type="math/tex; mode=display">D=\left\{x^{(i)},\;i=1,2,\cdots,m\right\},\;C=\left\{ x^{(i)}\in \omega ^{\left( j \right)},\;j=1,2,\cdots ,N \right\}</script><ul><li>$m$ 代表训练集中样本点的数量；</li><li>$x^{(i)}$ 代表第 $i$ 个样本点，是一个 $n$ 维向量，$n$ 代表特征数；</li><li>$N$ 代表类别数，所有训练集中样本点被显式地标注。</li></ul><p>那么，最近邻算法可以表述为：</p><ol><li>计算测试样本点 $x$ 与所有训练样本点 $x^{(i)}$ 的距离 $\left| x-x^{(i)} \right| _2$；</li><li>找出距离最小的情况 $g_k\left( x \right) =\min \left| x-x^{\left( k \right)} \right| _2$；</li><li>若 $x^{(k)}\in \omega ^{\left( j \right)}$，则测试样本 $x \in \omega ^{\left( j \right)}$。</li></ol><p>然而，上述方法有明显的缺陷：<strong>单个训练样本</strong>对分类的结果有较大的影响。如果在一个样本空间中有反常的样本点，那么它很可能会影响到周围测试样本的判别。</p><p>因此，$\text{KNN}$ 选择了<strong>多数表决法</strong>作为改进，在做决策时选择特征空间中最相似的 $K$ 个样本点，并以其中<strong>大多数样本所属</strong>的类别作为测试样本的类别。故 $\text{KNN}$ 算法可以改进为：</p><ol><li>计算测试样本点 $x$ 与所有训练样本点 $x^{(i)}$ 的距离 $\left| x-x^{(i)} \right| _2$；</li><li>找出距离最小的前 $K$ 个样本点； </li><li>统计其中最多样本点所属的类别 $\omega ^{\left( j \right)}$，则测试样本 $x \in \omega ^{\left( j \right)}$。</li></ol><p>此外，$\text{KNN}$ 算法还可以用于<strong>回归</strong>的决策，即用最近的 $K$ 个样本的平均值作为回归预测值。</p><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>$\text{KNN}$ 算法是一种<strong>懒散学习法</strong>（Lazy Learing），在模型训练的过程中几乎不耗时，主要的计算量则花在预测时的计算，因此会比其他许多算法都要慢。</p><p>通过 Brute-Force 的方法找到最相近的前 $K$ 个样本点，在样本量小、样本特征少的时候或许还能用，但实际运用中我们通常采用更高级的处理方法：</p><ul><li>KDTree (K-Dimension Tree)：根据样本的 $n$ 维特征建树，选取<strong>特征取值方差最大者</strong>作为根结点，将所有结点以该特征值均分为左右子树（将特征空间以<strong>超平面</strong>分割），再以同样方法递归建树。测试时，只需以测试样本点为圆心绘制<strong>超球体</strong>，在所有与球面交割的<strong>超矩形体</strong>中搜索最近邻的点。</li><li>BallTree：KDTree 中利用球面交割矩形体的方法搜索，对于不均匀数据集，空间中的超矩形体会有许多棱角，导致会因为<strong>超球体交割于棱角</strong>导致进行多余的搜索。本方法将分割块改为<strong>超球体</strong>，建立球树以避免问题的发生，搜索回溯的方法与 KDTree 类似。</li></ul><p>当然，上述方法在建模时需要较大的内存，属于「空间换时间」的经典样例。</p><h3 id="超参数-K"><a href="#超参数-K" class="headerlink" title="超参数 K"></a>超参数 K</h3><p>所谓超参数（Hyper-Parameter），就是在开始<strong>模型训练之前</strong>，就<strong>人为设置</strong>好的参数，这时相对其他<strong>模型训练得出</strong>的参数（Parameter）提出的一个概念。</p><p>作为本算法唯一的参数 $K$，就需要根据经验进行优化，以提高学习的性能和效果。下面我们通过<strong>交叉验证</strong>（Cross-Validation）来分析这个问题。</p><blockquote><p>所谓的交叉验证，就是将样本数据按照一定比例，<strong>拆分</strong>出训练用的数据和验证用的数据，其中验证集不参与模型的构建。</p></blockquote><p>选取一个较小的 $K$ 值，不断增加，并计算验证集的错误率，最终可以绘制出如下曲线：</p><p><img src="/img/blog/PR-Note-1-images/KNN-error.png" alt="K值与误差率" width=80%/></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>模式识别</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
      <tag>PR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python笔记 #2 数据分析基础</title>
    <link href="/2021/09/25/Python-Note-2/"/>
    <url>/2021/09/25/Python-Note-2/</url>
    
    <content type="html"><![CDATA[<p>学习 Machine Learning 的时候发现需要用许多矩阵运算和画图的库，本文将以<strong>实用主义</strong>的方式记录每次遇到的新用法。</p><p>2021 年贵系的暑培新增了「科学计算」内容，本文部分内容参考了清华 LZJ 同学的教程。本文将持续更新。</p><h2 id="常用的库"><a href="#常用的库" class="headerlink" title="常用的库"></a>常用的库</h2><p>计算机领域，有用的数据特指<strong>结构化的数据</strong>，即符合一定的语法规范，才能方便计算机处理。这些数据包括表格型的数据，多维数组型的数据，由键位列关联起来的多张表数据等等。针对这些数据，Python 都有相应库去处理。</p><p><strong>数据处理</strong>：</p><ul><li><p><strong>Numpy</strong>：是 Numerical Python 的缩写，用于处理<strong>大规模多维数组</strong>，<strong>矩阵计算</strong>等，有成熟的 C 接口，很多 Python 的第三方库都基于 Numpy 实现（例如 Python 的计算机视觉库 cv2 ）。</p></li><li><p><strong>Pandas</strong>：提供了更高级的数据结构和函数，适用于处理<strong>表格化</strong>、<strong>结构化</strong>的数据。</p></li></ul><p><strong>科学计算</strong>：</p><ul><li><strong>Scipy</strong>：Python 的<strong>科学计算</strong>库，可以处理积分微分、线性代数、最优化问题、信号处理、统计学等问题。</li><li><strong>Scikit-learn</strong>：Python 的<strong>机器学习</strong>工具包，可以处理机器学习的众多计算问题，如支持向量机，聚类，特征选择等问题。</li><li><strong>Statmodels</strong>：处理统计学和经济学问题的库，与 scikit-learn 相比包含更多经典模型。</li></ul><p><strong>数据可视化</strong>：</p><ul><li><strong>Matplotlib</strong>：最经典的<strong>二维数据</strong>可视化库，结合 Numpy 使用可以成为 matlab 的有力替代品。</li></ul><p><strong>自动化办公</strong>：</p><ul><li><strong>docx</strong>：处理 Doc 文档。</li><li><p><strong>pptx</strong>：处理 Powerpoint 幻灯片。</p></li><li><p><strong>openpyxl</strong>：处理 Excel 表格。</p></li></ul><h2 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h2><p>Numpy 底层是用 C 写的，所以可以很方便的操作内存，这点与 Python 的原生数据结构不同。因此，Numpy 在处理大型数据时<strong>速度更快</strong>，内存<strong>开销也更小</strong>（和原生 Python 相比）。</p><h3 id="ndarray-对象"><a href="#ndarray-对象" class="headerlink" title="ndarray 对象"></a>ndarray 对象</h3><p>ndarray 是 Numpy 的核心数据结构，全称是 N-dimensional Array，N 维数组，一个快速、灵活的大型数据集容器，内部储存<strong>同一类型</strong>的数据。</p><p>ndarray 有两个重要属性，<code>dtype</code> 和 <code>shape</code>，分别表示元素的<strong>数据类型</strong>和<strong>形状参数</strong>，此外还有 <code>ndim</code> (维数), <code>size</code> (元素个数), <code>itemsize</code> (每个元素字节数) 等属性。</p><ul><li><code>arr.dtype</code>、<code>dtype(arr)</code>：返回 <code>arr</code> 的数据类型，常见类型如下：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">int16/uint16</td><td style="text-align:center">有符号和无符号 16 位整数</td></tr><tr><td style="text-align:center"><strong>int32</strong>/uint32</td><td style="text-align:center">有符号和无符号 32 位整数</td></tr><tr><td style="text-align:center">int64/uint64</td><td style="text-align:center">有符号和无符号 64 位整数</td></tr><tr><td style="text-align:center">float32</td><td style="text-align:center">标准单精度浮点数，兼容 C 的 float</td></tr><tr><td style="text-align:center"><strong>float64</strong></td><td style="text-align:center">标准双精度浮点数，兼容 C 的 double</td></tr><tr><td style="text-align:center">float128</td><td style="text-align:center">拓展精度浮点数</td></tr><tr><td style="text-align:center">complex128</td><td style="text-align:center">基于 float64 的复数</td></tr><tr><td style="text-align:center">bool</td><td style="text-align:center">布尔值，为 True 或 False</td></tr></tbody></table></div><ul><li><code>arr2 = arr1.astype(np.float64)</code>：改变原数据类型为目标类型。</li><li><code>arr.shape</code>、<code>shape(arr)</code>：返回 <code>arr</code> 的形状参数，通常赋值给变量 <code>(m, n)</code>，不同的参数含义如下：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"><code>arr</code></th><th style="text-align:center"><code>arr.shape</code></th><th style="text-align:center"><code>arr.dtype</code></th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">array(1)</td><td style="text-align:center"><code>()</code></td><td style="text-align:center">int32</td><td style="text-align:center">单个整数</td></tr><tr><td style="text-align:center">array(1.)</td><td style="text-align:center"><code>()</code></td><td style="text-align:center">float64</td><td style="text-align:center">单个浮点数</td></tr><tr><td style="text-align:center">array([1, 2])</td><td style="text-align:center"><code>(2,)</code></td><td style="text-align:center">int32</td><td style="text-align:center">一维数组，2 个元素</td></tr><tr><td style="text-align:center">array([[1],<br/> [2]])</td><td style="text-align:center"><code>(2, 1)</code></td><td style="text-align:center">int32</td><td style="text-align:center">二维数组，2 行 1 列</td></tr><tr><td style="text-align:center">array([[1, 2]])</td><td style="text-align:center"><code>(1, 2)</code></td><td style="text-align:center">int32</td><td style="text-align:center">二维数组，1 行 2 列</td></tr><tr><td style="text-align:center">array([[1, 2],<br/> [3, 4]])</td><td style="text-align:center"><code>(2, 2)</code></td><td style="text-align:center">int32</td><td style="text-align:center">二维数组，2 行 2 列</td></tr><tr><td style="text-align:center">array([[[1, 1],<br/>               [1, 1]],<br/>            [[1, 1],<br/>    [1, 1]]])</td><td style="text-align:center"><code>(2, 2, 2)</code></td><td style="text-align:center">int32</td><td style="text-align:center">三维数组</td></tr></tbody></table></div><ul><li><code>arr.shape[0]</code>、<code>arr.shape[1]</code>：返回 <code>arr</code> 的第 0 维、第 1 维的长度。</li><li><code>arr.size</code>：返回元素个数，通常赋值给变量 <code>m</code>，用于生成等长的数组。</li></ul><h3 id="ndarray-构造"><a href="#ndarray-构造" class="headerlink" title="ndarray 构造"></a>ndarray 构造</h3><p>根据不同的需求，有各种构造 ndarray 的方法。</p><ul><li><strong>已有容器转化数组</strong></li></ul><p>生成 ndarray 的基本函数是 <code>np.array()</code>，其参数可以是 list 、tuple 或 另一个 ndarray，会<strong>自动识别</strong>类型。其函数接口如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    obj: 传入原数组</span><br><span class="hljs-string">    dtype: 指定数据类型，默认根据原数组推断为 int32 或 float64</span><br><span class="hljs-string">    copy: 是否拷贝（不共享内存）</span><br><span class="hljs-string">    order: 数组存储风格，C 按行优先，F 按列优先，K 自适应</span><br><span class="hljs-string">    ndmin: 最小维数</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>np.array(<span class="hljs-built_in">object</span>, dtype = <span class="hljs-literal">None</span>, copy = <span class="hljs-literal">True</span>, order = <span class="hljs-string">&#x27;K&#x27;</span>, subok = <span class="hljs-literal">False</span>, ndmin = <span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><p>样例测试如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># list</span><br>arr1 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<span class="hljs-comment"># arr1.shape = (3,)</span><br>arr2 = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]) <span class="hljs-comment"># arr2.shape = (2, 2)</span><br><span class="hljs-comment"># tuple</span><br>arr3 = np.array((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<span class="hljs-comment"># arr3.shape = (3,)</span><br>arr4 = np.array(((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)))<span class="hljs-comment"># arr4.shape = (2, 2)</span><br><span class="hljs-comment"># float</span><br>arr5 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3.14</span>])<span class="hljs-comment"># arr5.dtype = float64</span><br>arr6 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], dtype = np.float64)<br><span class="hljs-comment"># merge</span><br>arr7 = np.array([arr1, arr5])<span class="hljs-comment"># arr7.shape = (2, 3)</span><br></code></pre></div></td></tr></table></figure><ul><li><strong>生成已初始化数组</strong></li></ul><p>Numpy 自带初始化函数，用来生成默认数组，以下为样例：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">arr1 = np.zeros((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<span class="hljs-comment"># 全 0.  数组，arr1.shape = (2, 3)</span><br>arr2 = np.ones(<span class="hljs-number">10</span>)<span class="hljs-comment"># 全 1.  数组，arr2.shape = (10,)</span><br>arr3 = np.empty((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>))<span class="hljs-comment"># 未初始化数组，arr3.shape = (3, 4, 5)</span><br></code></pre></div></td></tr></table></figure><p>需要注意的是，传入的实参为生成数组的 <code>shape</code>，必须用<strong>元组</strong>表示！且生成的数组默认类型都为 float64。</p><p>若要生成高维数组，除了用 <code>np.array()</code> 拼接两个低维数组，通常都是用 <code>np.empty()</code> 实现。</p><ul><li><strong>基于范围生成数组</strong></li></ul><p>生成方式与 Matlab 类似，这里给出函数接口：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 范围在 [start, stop) 之间，缺省其一则视为 [0, stop)，步长为 step</span><br>np.arange(start, stop, step, dtype)<br><span class="hljs-comment"># 生成等差数列，[start, stop] 之间，限定总数为 num，endpoint 表示是否包含 stop 端点</span><br>np.linspace(start, stop, num=<span class="hljs-number">50</span>, endpoint=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 生成等比数列，注意范围是 [base^start, base^stop] 之间,限定总数为 num</span><br>np.logspace(start, stop, num=<span class="hljs-number">50</span>, endpoint=<span class="hljs-literal">True</span>, base=<span class="hljs-number">10.0</span>)<br></code></pre></div></td></tr></table></figure><ul><li><strong>生成随机数组</strong></li></ul><p>常用的有三种方式，这里给出函数接口：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 生成 0 到 1 之间的浮点数，参数为各个维度</span><br>np.random.rand(d0, d1, ..., dn)<br><span class="hljs-comment"># 生成 [low, high) 之间的整数，缺省其一则视为 [0, high)，size 用元组表示</span><br>np.random.randint(low, high, size=<span class="hljs-literal">None</span>, dtype=<span class="hljs-built_in">int</span>)<br><span class="hljs-comment"># 生成 均值为 0，方差为 1 的正态分布浮点数，参数为各个维度</span><br>np.random.randn(d0, d1, ..., dn)<br></code></pre></div></td></tr></table></figure><ul><li><strong>从外部文件导入</strong></li></ul><p>最常用的方式，从外部文件导入大量数据集，这里列出样例：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 导入 .txt 文件，每行作为数组的一行，分隔符为逗号，选中前 2 列</span><br>data = np.loadtxt(<span class="hljs-string">&#x27;ex1data1.txt&#x27;</span>, delimiter=<span class="hljs-string">&#x27;,&#x27;</span>, usecols=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>x = data[:, <span class="hljs-number">0</span>] <span class="hljs-comment"># 第 0 列作为自变量</span><br>y = data[:, <span class="hljs-number">1</span>]<span class="hljs-comment"># 第 1 列作为因变量</span><br>m = y.size<span class="hljs-comment"># 元素组数定义为 m</span><br></code></pre></div></td></tr></table></figure><p>当 .txt 文件有<strong>空缺数据</strong>时，需要使用复杂度更高的函数：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 导入有空缺的 .txt 文件，每行作为数组的一行，分隔符为逗号，选中前 2 列</span><br>data = np.genfromtxt(<span class="hljs-string">&#x27;ex1data1.txt&#x27;</span>, delimiter=<span class="hljs-string">&#x27;,&#x27;</span>, usecols=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br></code></pre></div></td></tr></table></figure><p>导入其他格式文件或许需要用到其他辅助库：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> scipy.io <span class="hljs-keyword">as</span> scio<br><span class="hljs-comment"># 导入 .mat 文件需要用到 scipy.io 模块，这是一个二进制字典文件</span><br>data = scio.loadmat(<span class="hljs-string">&#x27;ex6data1.mat&#x27;</span>)<br>X = data[<span class="hljs-string">&#x27;X&#x27;</span>]<span class="hljs-comment"># 获取字典键 &#x27;X&#x27;</span><br>y = data[<span class="hljs-string">&#x27;y&#x27;</span>].flatten()<span class="hljs-comment"># 获取字典键 &#x27;y&#x27;，展开成一维</span><br>m = y.size<br></code></pre></div></td></tr></table></figure><h3 id="ndarray-索引"><a href="#ndarray-索引" class="headerlink" title="ndarray 索引"></a>ndarray 索引</h3><p>ndarray 容器的赋值主要用<strong>索引</strong>完成，其基本特性：<strong>浅拷贝</strong>，即多个对象<strong>共用一块内存</strong>。Numpy 官方解释是，Numpy 主要用于处理大量数据，所以不希望用缺省复制的方式，否则会引起各种内存问题。</p><p>索引语法和原生 Python 类似，用<strong>数字和冒号</strong>表示<strong>左闭右开</strong>范围：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 索引 [5,8) 位</span><br>arr1 = np.arange(<span class="hljs-number">6</span>)<span class="hljs-comment"># 内存中 [0, 1, 2, 3, 4, 5]</span><br>arr2 = arr1[<span class="hljs-number">3</span>:<span class="hljs-number">4</span>]<br><span class="hljs-comment"># 缺省，索引全部值</span><br>arr2[:] = <span class="hljs-number">6</span><span class="hljs-comment"># 内存中 [0, 1, 2, 6, 6, 5]</span><br><span class="hljs-comment"># 如果不想索引原数组</span><br>arr3 = arr1[<span class="hljs-number">1</span>:<span class="hljs-number">2</span>].copy()<span class="hljs-comment"># 用 .copy() 可以强制拷贝</span><br></code></pre></div></td></tr></table></figure><p>对于高维数组，如果想通过赋值实现<strong>降维</strong>，可以使用<strong>切片索引</strong>：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">arr1 = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br><span class="hljs-built_in">print</span>(arr1[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], arr1[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<span class="hljs-comment"># 4 4，前者为 Python 列表索引</span><br><span class="hljs-built_in">print</span>(arr1[:<span class="hljs-number">1</span>, <span class="hljs-number">0</span>:])<span class="hljs-comment"># [[1 2 3]]</span><br><span class="hljs-built_in">print</span>(arr1[:, <span class="hljs-number">0</span>])<span class="hljs-comment"># [1 4]</span><br><span class="hljs-built_in">print</span>(arr1[:, :<span class="hljs-number">1</span>])<span class="hljs-comment"># [[1] [4]]</span><br></code></pre></div></td></tr></table></figure><p>由第一个例子注意到，不同于原生 Python，高维数组还可以通过 <code>[x,y,z]</code> 的方式在不同维度之间索引，同时还可以用<strong>冒号加数字</strong>表示<strong>左闭右开</strong>范围。</p><p>特别注意最后两个例子，在第二维上虽然范围都是 0，但前者只用了数字，后者还用了冒号，导致结果的维数并不相同。这说明：<strong>使用冒号不会降维</strong>，哪怕确实范围中只有一列。</p><p>此外，Numpy 中还有一种<strong>布尔索引</strong>的有趣用法，不是本文重点，这里举个例子：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 按 50% 概率，随机抽取序列</span><br>arr = np.arange(<span class="hljs-number">10</span>)<span class="hljs-comment"># 生成 待抽取 的序列</span><br>p = np.random.rand(<span class="hljs-number">10</span>)  <span class="hljs-comment"># 生成 0 - 1 之间的随机小数</span><br><span class="hljs-built_in">print</span>(arr[p &lt; <span class="hljs-number">0.5</span>])<span class="hljs-comment"># 利用标量语法，转化为 bool 数组，再索引 arr</span><br><span class="hljs-comment"># 浓缩成一行</span><br><span class="hljs-built_in">print</span>(np.arange(<span class="hljs-number">10</span>)[np.random.rand(<span class="hljs-number">10</span>) &lt; <span class="hljs-number">0.5</span>])<br></code></pre></div></td></tr></table></figure><h3 id="ndarray-变形"><a href="#ndarray-变形" class="headerlink" title="ndarray 变形"></a>ndarray 变形</h3><p>ndarray 可通过一些自带的函数改变形状（维度），以便完成一些复杂的矩阵运算。</p><ul><li><code>arr.flatten()</code>：返回一份<strong>深拷贝</strong>的展开成<strong>一维</strong>的数组，默认按行优先展开 <code>order=&#39;C&#39;</code>，用于矩阵时默认展开到 <code>(n,1)</code>。</li><li><code>arr[:,np.newaxis]</code>：将一维 <code>arr</code> 增加到二维数组 <code>(m,1)</code>。常用于生成<strong>列向量</strong>，才能<strong>点乘</strong>系数矩阵。</li><li><code>arr[np.newaxis,:]</code>：将一维 <code>arr</code> 增加到二维数组 <code>(1,m)</code>。</li><li><code>np.c_[arr1, arr2]</code>：将<strong>二维数组</strong>按列相连，要求<strong>行数一致</strong>。如果对象是<strong>一维</strong>数组，视作 <code>(m,1)</code> 的二维数组。</li><li><code>np.r_[arr1, arr2]</code>：将<strong>二维数组</strong>按行相连，要求<strong>列数一致</strong>。如果对象是<strong>一维</strong>数组或<strong>常数</strong>，则仍拼成<strong>一维</strong>数组。</li><li><code>np.column_stack((arr1, arr2))</code>：类似 <code>np.c_</code> 的函数形式，要求传入<strong>元组</strong>。</li><li><code>np.row_stack((arr1, arr2))</code>：类似 <code>np.r_</code> 的函数形式，要求传入<strong>元组</strong>。</li><li><code>np.reshape(arr,(5,5))</code>：调整形状，默认<strong>按行展开</strong>后填到新形状，要求<strong>规模匹配</strong>。</li><li><code>np.set_printoptions(formatter=&#123;&#39;float&#39;: &#39;&#123;: 0.6f&#125;&#39;.format&#125;)</code>：设置<strong>全局</strong>精度。</li></ul><h3 id="常用数学函数"><a href="#常用数学函数" class="headerlink" title="常用数学函数"></a>常用数学函数</h3><p>ndarray 的另一特点是支持<strong>类标量语法</strong>的计算，标量会作用在数组的<strong>每一个</strong>元素上，例如：<code>arr + 2</code>、<code>arr * 10</code> 、<code>arr[:] = 2</code> 等。此外，还支持一系列运算函数，以下所有函数同样支持 <code>数组变量.函数名(参数)</code> 形式调用：</p><h4 id="普通运算"><a href="#普通运算" class="headerlink" title="普通运算"></a>普通运算</h4><ul><li><code>np.sum(arr[1,:])</code>：对一维数组 <code>arr[1,:]</code>，求和，得到一个值。</li><li><code>np.sum(arr, 0)</code>：对二维数组 <code>arr</code>，求每一列和，<strong>塌缩</strong>成 <code>(列数,)</code>。</li><li><code>np.sum(arr, 1)</code>：对二维数组 <code>arr</code>，求每一行和，塌缩成 <code>(行数,)</code>。</li><li><code>np.max(arr)</code>：对整个数组，求最大值，得到一个值。</li><li><code>np.max(arr, 0)</code>：对二维数组 <code>arr</code>，求每一列最大值，塌缩成 <code>(列数,)</code>。</li><li><code>np.argmax(arr,0)</code>：对二维数组 <code>arr</code>，求每一列最大值的索引，塌缩成 <code>(列数,)</code>。</li><li><code>np.sin(arr)</code>、<code>np.cos(arr)</code>、<code>np.tan(arr)</code>：作用于每个元素。</li><li><code>np.power(x, n)</code>：求单个数字 <code>x</code> 的 <code>n</code> 次幂，速度更快。</li></ul><h4 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h4><ul><li><code>np.dot(arr1, arr2)</code>：<strong>矩阵点乘</strong>，要求第一个矩阵的列数等于第二个矩阵的行数，一维数组视作二维数组的<strong>行向量或列向量</strong>。</li><li><code>np.matmul(arr1, arr2)</code>：同上，矩阵点乘，支持高维矩阵的 Broadcast。</li><li><code>arr1 @ arr2</code>：同上，矩阵点乘。</li><li><code>np.multiply(arr1, arr2)</code>：<strong>对应位置相乘</strong>，要求两个矩阵<strong>各个维度长度相等</strong>。</li><li><code>arr1 * arr2</code>：同上，对应位置相乘。</li><li><code>arr1.T</code>：求转置，数组没有求共轭、逆的函数。</li></ul><h4 id="统计运算"><a href="#统计运算" class="headerlink" title="统计运算"></a>统计运算</h4><ul><li><code>np.mean(arr)</code>：求<strong>所有</strong>样本平均值。</li><li><code>np.mean(arr, 0)</code>：对二维数组 <code>arr</code>，求每一列样本平均值，<strong>塌缩</strong>成 <code>(列数,)</code>。</li><li><code>np.average(arr, weights=None)</code>：求样本加权平均值。</li><li><code>np.std(arr)</code>：求样本标准差。</li><li><code>np.std(arr, ddof=1)</code>：求样本<strong>无偏</strong>标准差。</li><li><code>np.std(arr, axis=0, ddof=1)</code>：对二维数组 <code>arr</code>，求每一列样本<strong>无偏</strong>标准差，<strong>塌缩</strong>成 <code>(列数,)</code>。</li><li><code>np.var(arr)</code>：求样本方差。</li></ul><h3 id="matrix-对象"><a href="#matrix-对象" class="headerlink" title="matrix 对象"></a>matrix 对象</h3><p>除了 ndarray，Numpy 针对二维数组还专门设置了一个<strong>矩阵</strong>对象。matrix 的大部分性质与 ndarray 无异，但多了一些功能函数：</p><ul><li><code>np.mat([[1,2],[5,7]])</code>：声明矩阵，注意维数必须为 2。</li><li><code>np.mat([1,2,3])</code>：会被强制转化为 <code>(1,3)</code> 的二维矩阵。</li><li><code>np.mat(arr1)</code>、<code>np.asmatricx(arr1)</code>：从数组转到矩阵。</li><li><code>np.asarray(mat1)</code>：从矩阵转到数组。</li><li><code>mat1.T</code>、<code>mat1.H</code>、<code>mat1.I</code>：转置矩阵、共轭矩阵、逆矩阵。</li><li><code>mat1 * mat2</code>：<strong>点乘</strong>，要求第一个矩阵的列数等于第二个矩阵的行数。</li><li><code>np.multiply(mat1, mat2)</code>：<strong>对应位置相乘</strong>，要求两个矩阵<strong>各个维度长度相等</strong>。</li></ul><h3 id="Broadcast-广播机制"><a href="#Broadcast-广播机制" class="headerlink" title="Broadcast 广播机制"></a>Broadcast 广播机制</h3><p>Numpy 中对于两个 ndarray 的<strong>加减乘除</strong>都是标量操作，即对应位置元素之间的操作。并且，当两个数组的形状不同时，Numpy 自带的 Broadcast 机制会<strong>自动扩展数组</strong>进行操作。</p><p>例如，在归一化变量时，我们使用：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 元素减去平均值，除以无偏标准差</span><br>data = (data - data.mean(<span class="hljs-number">0</span>)) / data.std(axis=<span class="hljs-number">0</span>, ddof=<span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure><p>很明显，<code>data</code> 和塌缩后的 <code>np.mean(data, 0)</code> 形状不相同，但仍可以相减。</p><p>广播兼容的条件有两种：</p><ul><li>两个<strong>不同维度</strong>的数组的<strong>后缘维度</strong>（trailing dimension，即从末尾开始算起的维度）的轴长度相符。如：<code>(4,3)</code> 与 <code>(3,)</code>；<code>(5,6,7)</code> 与 <code>(6,7)</code>。</li><li>两个<strong>相同维度</strong>的数组，但其中在<strong>某一维度</strong>上仅为 1。如 <code>(4,5,6)</code> 与 <code>(4,1,6)</code>、<code>(4,5,1)</code>。</li></ul><h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><p>绘图时最常用的模块是 Matplotlib 中的 <strong>pyplot</strong> 模块。绘图时先调用相关绘图函数，设置图像各种细节，最后调用 <code>plt.show()</code> 显示图片。</p><p>这时会出现一个基于 Qt 实现的交互窗口，程序执行到 <code>plt.show()</code> 时阻塞。在交互窗口中可以<strong>进一步调整图片</strong>格式细节或<strong>保存图片</strong>，关闭窗口后程序继续运行。下面以一个例子说明：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br>x = np.linspace(-<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">30</span>)  <span class="hljs-comment"># [-4, 4] 中长度为 30 的等差数列</span><br>y = np.sin(x)<span class="hljs-comment"># 获得 sin 值</span><br>plt.plot(x, y)<span class="hljs-comment"># 以 x 为自变量，y 为因变量，绘制折线图</span><br>plt.show()<span class="hljs-comment"># 显示图像，程序阻塞</span><br></code></pre></div></td></tr></table></figure><h3 id="格式字符串"><a href="#格式字符串" class="headerlink" title="格式字符串"></a>格式字符串</h3><p>与 Matlab 相似，Matplotlib 使用事先约定好的字符串代表<strong>绘图格式</strong>，将其写入 <code>plt.plot()</code> 即可，如  <code>plt.plot(x, y, &#39;bo&#39;)</code> 即蓝色圆圈标记。</p><ul><li><code>color</code>：绘制点的颜色，支持以下缩写，还可以用 <code>c=&#39;#000&#39;</code> 指定。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">颜色</th><th style="text-align:center">字符</th><th style="text-align:center">颜色</th><th style="text-align:center">字符</th><th style="text-align:center">颜色</th><th style="text-align:center">字符</th><th style="text-align:center">颜色</th></tr></thead><tbody><tr><td style="text-align:center"><code>b</code></td><td style="text-align:center">蓝色</td><td style="text-align:center"><code>r</code></td><td style="text-align:center">红色</td><td style="text-align:center"><code>m</code></td><td style="text-align:center">洋红色</td><td style="text-align:center"><code>k</code></td><td style="text-align:center">黑色</td></tr><tr><td style="text-align:center"><code>g</code></td><td style="text-align:center">绿色</td><td style="text-align:center"><code>c</code></td><td style="text-align:center">青色</td><td style="text-align:center"><code>y</code></td><td style="text-align:center">黄色</td><td style="text-align:center"><code>w</code></td><td style="text-align:center">白色</td></tr></tbody></table></div><ul><li><code>marker</code>：绘制点的形状。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">标记</th><th style="text-align:center">字符</th><th style="text-align:center">标记</th><th style="text-align:center">字符</th><th style="text-align:center">标记</th><th style="text-align:center">字符</th><th style="text-align:center">标记</th></tr></thead><tbody><tr><td style="text-align:center"><code>.</code></td><td style="text-align:center">点标记</td><td style="text-align:center"><code>&gt;</code></td><td style="text-align:center">右三角标记</td><td style="text-align:center"><code>p</code></td><td style="text-align:center">五边形标记</td><td style="text-align:center"><code>D</code></td><td style="text-align:center">菱形标记</td></tr><tr><td style="text-align:center"><code>,</code></td><td style="text-align:center">像素标记</td><td style="text-align:center"><code>1</code></td><td style="text-align:center">三叉戟标记</td><td style="text-align:center"><code>*</code></td><td style="text-align:center">星形标记</td><td style="text-align:center"><code>d</code></td><td style="text-align:center">菱形标记</td></tr><tr><td style="text-align:center"><code>o</code></td><td style="text-align:center">圆圈标记</td><td style="text-align:center"><code>2</code></td><td style="text-align:center">三叉戟标记</td><td style="text-align:center"><code>h</code></td><td style="text-align:center">六角形标记</td><td style="text-align:center"><code>丨</code></td><td style="text-align:center">竖线标记</td></tr><tr><td style="text-align:center"><code>v</code></td><td style="text-align:center">倒三角标记</td><td style="text-align:center"><code>3</code></td><td style="text-align:center">三叉戟标记</td><td style="text-align:center"><code>H</code></td><td style="text-align:center">六角形标记</td><td style="text-align:center"><code>_</code></td><td style="text-align:center">横线标记</td></tr><tr><td style="text-align:center"><code>^</code></td><td style="text-align:center">正三角标记</td><td style="text-align:center"><code>4</code></td><td style="text-align:center">三叉戟标记</td><td style="text-align:center"><code>+</code></td><td style="text-align:center">+标记</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>&lt;</code></td><td style="text-align:center">左三角标记</td><td style="text-align:center"><code>s</code></td><td style="text-align:center">正方形标记</td><td style="text-align:center"><code>x</code></td><td style="text-align:center">x标记</td><td style="text-align:center"></td></tr></tbody></table></div><ul><li><code>line</code>：绘制线的形状。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">格式</th><th style="text-align:center">字符</th><th style="text-align:center">格式</th><th style="text-align:center">字符</th><th style="text-align:center">格式</th><th style="text-align:center">字符</th><th style="text-align:center">格式</th></tr></thead><tbody><tr><td style="text-align:center"><code>-</code></td><td style="text-align:center">实线</td><td style="text-align:center"><code>--</code></td><td style="text-align:center">虚线</td><td style="text-align:center"><code>-.</code></td><td style="text-align:center">点划线</td><td style="text-align:center"><code>:</code></td><td style="text-align:center">点线</td></tr></tbody></table></div><h3 id="特定类型图"><a href="#特定类型图" class="headerlink" title="特定类型图"></a>特定类型图</h3><p>下面是一些常用的绘图函数。更多官网案例：<a href="https://matplotlib.org/stable/gallery/index.html。">https://matplotlib.org/stable/gallery/index.html。</a></p><h4 id="折线图-plot"><a href="#折线图-plot" class="headerlink" title="折线图 plot()"></a>折线图 <code>plot()</code></h4><p><code>plt.plot()</code> 用于绘制<strong>折线图</strong>，需要一系列点作为因变量和自变量，函数接口如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">matplotlib.pyplot.plot(*args, scalex=<span class="hljs-literal">True</span>, scaley=<span class="hljs-literal">True</span>, data=<span class="hljs-literal">None</span>, **kwargs)<br></code></pre></div></td></tr></table></figure><p>观察接口，可以发现有以下的用法：</p><ul><li>传入<strong>两个等长</strong>数组或列表，前者是自变量，后者是因变量。</li><li>只传入<strong>一个</strong>数组或列表，自变量默认从 0 开始整数递增。</li><li>传入两个列表，<strong>各包含两个值</strong>，可以绘制一条直线。</li></ul><h4 id="散点图-scatter"><a href="#散点图-scatter" class="headerlink" title="散点图 scatter()"></a>散点图 <code>scatter()</code></h4><p><code>plt.scatter()</code> 用于绘制<strong>散点图</strong>，需要<strong>两个等长</strong>数组或列表，函数接口如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">matplotlib.pyplot.scatter(x, y, s=<span class="hljs-literal">None</span>, c=<span class="hljs-literal">None</span>, marker=<span class="hljs-literal">None</span>, **kwargs)<br></code></pre></div></td></tr></table></figure><p>其中只有 <code>x</code> 和 <code>y</code> 为必填项，<code>s</code> 代表每个点的大小，可以是常数也可以是列表。</p><h3 id="子图-subplot"><a href="#子图-subplot" class="headerlink" title="子图 subplot()"></a>子图 <code>subplot()</code></h3><p><code>plt.subplot()</code> 用于在一张图里绘制<strong>多个子图</strong>，函数接口如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">matplotlib.pyplot.subplot(nrows, ncols, index, **kwargs)<br></code></pre></div></td></tr></table></figure><p>其中只有 <code>nrow</code> 和 <code>ncols</code> 表示总共有多少子图，<code>index</code> 代表其中第几个。如：<code>plt.subplot(2,2,1)</code>，也可以缩写为 <code>plt.subplot(221)</code>。</p><p>紧跟在 <code>plt.subplot()</code> 语句后面的语句绘制的就是 <code>index</code> 所指向的图，绘制完再次使用 <code>plt.subplot()</code> 语句切换到下一张子图。</p><h2 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h2><p>除了上述的数据分析第三方库，还有一些辅助工具库也许有用。</p><h3 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h3><p><code>time</code> 是 Python 中处理时间的标准库，提供系统级精确计时功能（可以用于程序性能分析）。其主要功能分为三块：时间获取、时间格式化、程序计时，这里介绍计时相关内容。</p><ul><li><code>sleep(s)</code>： <code>s</code> 为休眠时间，单位秒，可以是浮点数。</li><li><code>perf_counter()</code>：返回一个 CPU 级别的精确时间计数值，单位为秒。</li></ul><p>后者的使用由于<strong>计数器起点</strong>不确定，<strong>连续调用求差值</strong>才有意义：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>arr = np.arange(<span class="hljs-number">100000000</span>)<br>start = time.perf_counter()<span class="hljs-comment"># 计数器起点</span><br>arr = arr * <span class="hljs-number">2</span><br>end = time.perf_counter()<span class="hljs-comment"># 计数器终点</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;numpy time cost: %.3f s&#x27;</span> % (end - start))<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python笔记 #1 基础语法</title>
    <link href="/2021/09/24/Python-Note-1/"/>
    <url>/2021/09/24/Python-Note-1/</url>
    
    <content type="html"><![CDATA[<p>跟着贵系的暑培过了一遍语法，然而写代码时还是感到乏力，总觉得要打一遍才能记住，于是有了这篇博客。</p><p>本文部分内容参考了清华 AYF 同学的教程，部分参考了 Python 官方的一份 <a href="https://docs.python.org/zh-cn/3/tutorial/index.html">Tutorial</a>，函数用法参考了 <a href="https://xyfjason.top">xyfJASON</a> 的博客。本文将持续更新。</p><h2 id="Python-特性"><a href="#Python-特性" class="headerlink" title="Python 特性"></a>Python 特性</h2><p>相比于 C 的编译型、弱类型、静态类型特点，Python 则是一种解释型、强类型、动态类型的语言。</p><h3 id="交互式-vs-脚本"><a href="#交互式-vs-脚本" class="headerlink" title="交互式 vs 脚本"></a>交互式 vs 脚本</h3><p>作为一种解释型语言，Python 不需要像 C 一样编译运行，它可以<strong>逐行运行</strong>代码，因此又分为<strong>交互式窗口</strong>运行与<strong>脚本</strong>运行两种模式：</p><ul><li>交互式窗口：在 CLI 输入 <code>python</code>，即可进入交互式窗口，输入一行代码即可运行。本文使用的交互式环境是 <strong>IPython</strong>，输入 <code>ipython</code> 即可呼出。</li><li>脚本：在 CLI 输入 <code>python xxx.py</code>，就会依次执行整个脚本文件。本文使用的 IDE 是 <strong>PyCharm</strong>。</li></ul><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>) <span class="hljs-comment"># 打印输出</span><br>Hello, world!<br></code></pre></div></td></tr></table></figure><p>在交互式窗口，<code>&gt;&gt;&gt;</code> 作为提示符，在 IPython 中则是 <code>In [1]:</code>。执行 <code>exit()</code> 或者按下 <code>Ctrl+D</code> 就能退出窗口。</p><p>注意到，这行代码中没有 <code>;</code> 分号，可以直接运行而无需编译，字符串用了单引号，注释用 <code>#</code> 开始【与 C 不同】。</p><h2 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h2><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>【与 C 不同】，Python <strong>不用</strong>声明变量类型，解释器自动解释。</p><ul><li><code>int</code>：变长整数，默认是 4 字节，有需要时自动增长，用于高精度运算，还支持十六进制、八进制和二进制表示。</li><li><code>complex</code>：自带的复数类型，表示为 <code>real + imag*1j</code> 的形式，虚部为 1 的时候不可省略 1，可以用 <code>j</code> 也可以用 <code>J</code>。实虚部分别为一个 <code>float</code>。</li><li><code>float</code>：8 字节浮点数，【相当于 C 的 double】。</li><li><code>bool</code>：True 和 False，注意首字母大写，用作数值计算时与 C 一样视作 0 和 1。</li><li><code>NoneType</code>： None，空值，常用于返回值、特判。</li></ul><blockquote><p>需要单独说明的是，Python 会存储所有的 -5 到 256 的整数，其他任何变量是这些值时，会被指向这个<strong>预先开好</strong>的内存，因此任何两个值为 5 的 int 变量都指向同⼀内存地址。</p></blockquote><p>尽量用小写变量名（<strong>下划线法</strong>），这是 Python3 的主流命名方式。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>这里列出常见的运算符，运算符可以重载，重载需要修改其对应的定义函数。</p><p><strong>算术运算符</strong>：</p><ul><li><code>+</code> <code>-</code> <code>*</code>【与 C 相同】</li><li><code>%</code>：<code>35 % 4 == 3</code>，<code>-35 % 4 == 1</code>，<code>35 % -4 == -1</code>，<code>-35 % -4 == -3</code>，【与 C 不同：负数对正数取模时返回正余数，而非像 C 那样返回负余数】</li><li><code>/</code>： <code>__trudiv__</code>，真除，得到 <code>float</code> 结果</li><li><code>//</code>： <code>__floordiv__</code>，除后向下取整（不是舍弃小数），得到 <code>int</code> 结果</li><li><code>**</code>： <code>__pow__</code>，幂运算</li></ul><p><strong>比较运算符</strong>：</p><ul><li><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code> <code>==</code> <code>!=</code> 【与 C 相同】</li></ul><p><strong>位运算符</strong>:</p><ul><li><code>&amp;</code> <code>|</code> <code>^</code> <code>~</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> 【与 C 相同】</li></ul><p><strong>赋值运算符</strong>：</p><ul><li><code>=</code>：赋值号，不能被重载</li><li><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> 【与 C 相同】</li><li>注意 Python 中没有 <code>++</code> <code>--</code> 的运算符，只能通过 <code>+= 1</code> 实现</li></ul><p><strong>逻辑运算符</strong>：</p><ul><li><code>and</code> <code>or</code> <code>not</code> 【类似 C 中的 <code>&amp;&amp;</code> <code>||</code> <code>！</code>】</li><li>对于 <code>and</code> 和 <code>or</code>，通常用于条件分支 <code>bool</code> 的判断，如果非要连接 <code>int</code> 变量，得到的结果不会直接转换为 <code>bool</code>，而是返回<strong>能够得出结果</strong>的<strong>最后一个变量</strong>【与 C 中的短路类似】</li></ul><p><strong>三目运算符</strong>：</p><ul><li><code>a if cond else b</code>：相当于 C 中的 <code>cond ? a : b</code>，注意其参数顺序【与 C 不同】，但更贴近自然语言</li></ul><p><strong>特殊条件运算符</strong>：</p><ul><li><code>in</code>：被包含于，详见下文「容器」，返回 bool</li><li><code>not in</code>：<code>in</code> 的否定，返回 bool</li><li><code>is</code>：判断两个变量的地址是否相同，不可重载，返回 bool</li><li><code>is not</code>：判断两个变量地址是否不同，不可重载，返回 bool</li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Python 将字符串封装成了<strong>基本类型</strong>并处理了多种运算，带来许多便利，注意基本类型本身是<strong>不可修改</strong>的，所谓修改其实是将<strong>重新生成</strong>另一个字符串，再将其<strong>赋值</strong>给目标。</p><p>此外，Python 中没有单独的字符类型，单个字符将被视为长度为 1 的字符串。【与 C 不同】，可以用 <code>&quot;&quot;</code> 或者 <code>&#39;&#39;</code> 括起字符串。</p><p>下面是一些常用函数，设 <code>str</code> 是一个字符串：</p><ul><li><code>str.title()</code>：返回单词首字母大写，其余字母小写（不管以前是不是大写）的字符串</li><li><code>str.upper()</code>、<code>str.lower()</code>：返回全大/小写的字符串</li><li><code>str1 + str2</code>：返回用加号拼接的字符串【与 C++ 的 <code>string</code> 类似】</li><li><code>str * 3</code>：返回重复三遍拼接的字符串</li><li>制表符 <code>\t</code>，换行符 <code>\n</code>【与 C 相同】</li><li><code>str.lstrip()</code>、<code>str.rstrip()</code>、<code>str.strip()</code>: 返回删除开头/末尾/两端空白的字符串</li><li><code>str.replace(str1, str2)</code>：将字符串中的单词 <code>str1</code> 全部替换成 <code>str2</code> </li><li><code>str.split()</code>：以空格为分隔符把字符串拆成一个个单词，并返回包含这些单词的列表</li></ul><p>此外还有一种跨行字符串，用 <code>’‘’</code> 或 <code>”“”</code> 括起来，由于脚本中顺序执行时不会输出变量值，这类字符串常用于<strong>跨行注释</strong>，特别是函数头注释。</p><h3 id="输入输出与编码"><a href="#输入输出与编码" class="headerlink" title="输入输出与编码"></a>输入输出与编码</h3><p>此处说明几个重要函数：</p><ul><li><code>len(obj)</code>：获取 <code>obj</code> 的长度，常用于获取字符串（注意是 Unicode，因此中文和英文字符都占 1 位）、字节串、容器的长度</li><li><code>str(a)</code>: 把数字（整型或浮点型） <code>a</code> 转换成字符串</li><li><code>chr(0x4f60)</code>：将整型变量 <code>i</code> 转化成单个字符</li><li><code>ord(&#39;你&#39;)</code>：获取单个字符的编码（Unicode），注意在 Unicode 中，英文字母的编码有意设置与 ASCII 码一致</li></ul><p>最常用的输出语句 <code>print</code>，本质上是将变量<strong>转化为字符串</strong>输出，在末尾自动<strong>换行</strong>。该函数可以有多个变量，变量间用 <code>,</code> 分隔，输出时会用空格隔开。</p><p>如果要在一句话中插入许多变量，这条 <code>print</code> 语句可能会很丑陋，因此 Python 中有三种格式化字符串的方法。</p><ul><li><code>%</code>：如 <code>print(&#39;I am %d&#39; % (age))</code>，【与 C 类似】</li><li><code>str.format()</code>：如 <code>print(&#39;hello, &#123;&#125;&#39;.format(name))</code></li><li><code>f-string</code>：如 <code>print(f&#39;hello,&#123;name&#125;.I am &#123;age&#125;&#39;)</code></li></ul><p>其中 <code>f-string</code> 是 Python3.6 的新特性，最为直观便利。</p><p>此外，<code>input(&#39;Press ENTER to continue&#39;)</code> 是常见的一种输入语句，会显示对应的提示内容，读入内容以回车键结尾。</p><h3 id="字节串"><a href="#字节串" class="headerlink" title="字节串"></a>字节串</h3><p><code>bytes</code> 即是 Python 中的字节串，它表示最纯粹的<strong>二进制</strong>数据，【类似 C 的 <code>unsigned char *</code>】，但是在显示上它仅支持 ASCII 显示，因此用肉眼看显得有些不伦不类，通常它只存在于数据的处理过程中。</p><p><code>bytes</code> 的构造与字符串类似，但是要加一个 <code>b</code> 做前导，如 <code>print(b&#39;\x41&#39;)</code>。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>Python 提供了一系列内置容器，它们如同 C++ 的 STL ⼀样，不过比 STL 的用法灵活得多。</p><p>同样先介绍几个重要函数：</p><ul><li><code>type(obj)</code>：可以获取参数 <code>obj</code> 的类型</li><li><code>isinstance(obj, class_or_tuple)</code>：可以判断 <code>obj</code> 是不是类的实例</li><li><code>id(obj)</code>：获取 <code>obj</code> 的地址， <code>a is b</code> 等价于 <code>id(a) == id(b)</code></li></ul><h3 id="列表-List"><a href="#列表-List" class="headerlink" title="列表 | List"></a>列表 | List</h3><p>列表（list）是很常用的容器，常被看作 Python 中的数组，但实际上【与 C++ 的 vector 类似】。设 <code>lst</code> 是一个列表：</p><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><ul><li>定义列表：<code>lst = [a, b, c, d]</code> ，其中 <code>a,b,c,d</code> 等是列表的元素，<strong>类型可以不同</strong></li><li>构造空列表：直接写 <code>[]</code> 或 <code>list()</code></li><li>打印列表：<code>print(lst)</code>（会将列表中的元素列出，括在<strong>方括号</strong>里）</li><li>访问元素：<code>lst[3]</code> ， 下标从 <strong>0</strong> 开始。此外，还支持<strong>负数</strong>索引，<code>-1</code> 表示倒数第一个，<code>-2</code> 倒数第二个【与 C 不同】</li></ul><h4 id="修改、添加、删除元素"><a href="#修改、添加、删除元素" class="headerlink" title="修改、添加、删除元素"></a>修改、添加、删除元素</h4><ul><li>修改：直接访问元素并赋值</li><li><code>lst.append(x)</code>：在列表末尾添加元素 <code>x</code> </li><li><code>lst.insert(idx, x)</code>：在列表索引 <code>idx</code> 处插入一个元素 <code>x</code> （插入后，<code>x</code> 的索引是 <code>idx</code>，其后的元素后移一格）</li><li><code>del lst[3]</code>：删除指定元素（删除后，其后元素前移一格）</li><li><code>lst.pop()</code>：弹出<strong>并返回</strong>最后一个元素</li><li><code>lst.pop(idx)</code>：弹出<strong>并返回</strong>指定元素</li><li><code>lst.remove(x)</code>：删除<strong>第一个</strong>值为 <code>x</code> 的元素</li></ul><h4 id="组织列表"><a href="#组织列表" class="headerlink" title="组织列表"></a>组织列表</h4><ul><li><code>lst.sort()</code>、<code>lst.sort(reverse = True)</code>：对列表排序，永久性修改顺序</li><li><code>sorted(lst)</code>、<code>sorted(lst, reverse = True)</code>：返回排序后的列表，但<strong>不改变</strong>列表原有顺序</li><li><code>lst.reverse()</code>：翻转列表，永久性修改顺序</li><li><code>len(lst)</code>：返回列表长度，即元素个数（不论类型）</li></ul><h4 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h4><p>从头到尾遍历列表：<code>for i in lst:</code> 循环表达式</p><p>【与 C 不同】<code>i</code> 是列表<strong>元素</strong>，不是索引；循环结束后 <code>i</code> 停留为<strong>最后一个</strong>元素。</p><p>若要检查列表是否为空，可以用 <code>if lst:</code> 条件表达式，返回 bool</p><h4 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h4><ul><li><code>lst[l:r]</code>：返回一个列表，元素依次是 <code>lst</code> 列表的索引在<strong>左闭右开区间</strong>内的元素，省略 <code>l</code> 或 <code>r</code> 则默认从头开始或到尾结束</li><li><p><code>lst[l:r:step]</code>：指定步长为 <code>step</code> 切片，<code>step</code> 为 -1 时返回倒序</p></li><li><p>可以用循环遍历列表切片：<code>for i in lst[l:r]:</code> </p></li><li><p>复制列表：在切片中同时省略 <code>l</code> 和 <code>r</code>，即返回<strong>从头到尾</strong>的列表，如 <code>lst2 = lst1[:]</code>，而非 <code>lst2=lst1</code>，后者<code>lst1</code> 和 <code>lst2</code> 实质是同一个列表【类似 C 的引用】</p></li></ul><h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 | Tuple"></a>元组 | Tuple</h3><p>元组就是元素值<strong>不可修改</strong>（弱意义上的，其中<strong>元素的元素</strong>可以被修改）的列表。设 <code>tpl</code> 是一个元组：</p><h4 id="基础操作-1"><a href="#基础操作-1" class="headerlink" title="基础操作"></a>基础操作</h4><ul><li>定义元组：<code>tpl = (a, b, c, d)</code>，把列表定义中的方括号改成圆括号 <code>()</code> 即可</li><li>定义时的小括号有时候可以省略，可以直接用 <code>,</code> 逗号构造元组【与 C 不同，没有逗号运算符】</li><li>构造单元组：<code>(1)</code> 会被理解成表达式，要用 <code>(1,)</code></li><li>构造空元组，直接写 <code>()</code> 或 <code>tuple()</code>，但 <code>(,)</code> 会报错</li><li>访问元素：<code>tpl[3]</code> ， 下标从 <strong>0</strong> 开始。</li></ul><h4 id="遍历元组"><a href="#遍历元组" class="headerlink" title="遍历元组"></a>遍历元组</h4><p><code>for i in tpl:</code> 和列表一样</p><h4 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h4><p>元组中元素的值不能修改，但是<strong>元组变量本身</strong>可以被赋值，这点与字符串类似。此外，如果元组的中的元素是可修改的，如 List，</p><h4 id="元组解包"><a href="#元组解包" class="headerlink" title="元组解包"></a>元组解包</h4><p>经典的 Python 交换赋值代码：<code>a, b = b, a</code>，利用了解包和逗号构造</p><h3 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合 | Set"></a>集合 | Set</h3><p>集合由一组无序、互不重复的元素构成（在数学上也是如此），在内部用哈希实现。设 <code>st</code> 是一个集合：</p><h4 id="基础操作-2"><a href="#基础操作-2" class="headerlink" title="基础操作"></a>基础操作</h4><ul><li>定义集合：<code>st = &#123;1, 2, 3&#125;</code>，把列表定义的方括号改成花括号 <code>&#123;&#125;</code> 即可</li><li>构造空集合：只能用 <code>set()</code>，因为 <code>&#123;&#125;</code> 的表达被空字典占用了</li><li>由列表转集合：<code>st = set([1, 1, 1, 2, 2, 3])</code>，会自动去重，常用于去重列表的遍历 <code>for i in set(lst):</code></li><li>注意集合的元素必须是可 hash 的，不能为 list 这种可变容器变量</li></ul><h4 id="添加、删除元素"><a href="#添加、删除元素" class="headerlink" title="添加、删除元素"></a>添加、删除元素</h4><ul><li><code>st.add(4)</code>：添加一个元素</li><li><code>st.remove(2)</code>：删除一个元素</li></ul><h3 id="字典-Dictionary"><a href="#字典-Dictionary" class="headerlink" title="字典 | Dictionary"></a>字典 | Dictionary</h3><p>字典是一系列「<strong>键值对</strong>」，用于存储一组有穷映射，可将任何 Python 对象作为值，【类似于更高端版本的 C++ 的 map】。</p><h4 id="基础操作-3"><a href="#基础操作-3" class="headerlink" title="基础操作"></a>基础操作</h4><ul><li>定义字典：<code>dic = &#123;&#39;name&#39;: &#39;张三&#39;, &#39;age&#39;: 18&#125;</code>，<strong>花括号</strong>括起一系列键值对，键与值之间冒号 <code>:</code> 分隔，键值对之间逗号 <code>,</code> 分隔。</li><li>访问元素：<code>d[&#39;name&#39;]</code>，用键访问</li><li>注意字典的键必须是可 hash 的，不能为 list 或 set 这种可变容器变量，但可以是 tuple</li></ul><h4 id="添加、修改、删除"><a href="#添加、修改、删除" class="headerlink" title="添加、修改、删除"></a>添加、修改、删除</h4><ul><li>添加：直接赋值即可（即使键本来不存在），如：<code>dic[&#39;x&#39;] = 0</code> </li><li>修改：<code>dic[&#39;age&#39;] = 18</code>，直接赋值即可</li><li>删除：<code>del dic[&#39;age&#39;]</code> </li></ul><h4 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h4><ul><li>遍历所有键值对：<code>for k, v in dic.items():</code>，其中 <code>items()</code> 返回键值对的<strong>列表</strong></li><li>遍历所有键：<code>for k in dic.keys():</code>，其中 <code>keys()</code> 返回键的<strong>列表</strong>，可省略</li><li>由于 <code>keys()</code> 的本质是<strong>列表</strong>，各种对列表的操作也适用，如：<code>for k in sorted(dic.keys()):</code> 或 <code>if &#39;age&#39; in dic.keys():</code></li><li>遍历所有值：<code>for v in dic.values():</code>，其中 <code>values()</code> 返回值的<strong>列表</strong></li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>前文提到的所有容器，包括字符串、字节串都是可迭代的，这意味着它们可以用作 <code>for</code> 循环，可以用<strong>生成式</strong>构造。</p><p>最为特殊的迭代器是 <code>range</code> 类型，作为数值列表，与列表有相似之处，但它实际上<strong>不占用内存</strong>（用于大循环时很节省空间）。下面是一些常用方法：</p><ul><li><p><code>range(l, r)</code>：依次生成<strong>左闭右开区间</strong>中的整数【类似于 C++ 的 <code>for(int i = l; i &lt; r; i++)</code>】，如果省略左端，会默认以 0 开始</p></li><li><p><code>range(l, r, step)</code>：指定步长为 <code>step</code>【类似于 C++ 的 <code>for(int i = l; i &lt; r; i += step)</code>】</p></li><li><code>min(range(l, r))</code>、<code>max(range(l, r))</code>、<code>sum(range(l, r))</code>：返回数值列表的最小值、最大值、总和</li></ul><h3 id="生成式"><a href="#生成式" class="headerlink" title="生成式"></a>生成式</h3><p>使用生成式构造容器是非常常见、高效的操作，下面举几个例子：</p><ul><li><code>a = list(range(10))</code>：直接转化数值列表为基本列表</li><li><code>lst = [i ** 2 for i in a]</code>：列表生成式</li><li><code>st = &#123;x % 7 for x in a&#125;</code>：集合生成式</li><li><code>dic = &#123;x ** 2: x for x in a&#125;</code>：字典生成式，保留 <code>:</code> 来分隔键与值</li><li><code>tpl = tuple(x + 1 for x in a)</code>：元组生成式，直接用 <code>()</code> 会被当成表达式</li></ul><p>综上所述，生成式表达可以用三段式：<code>表达式 for 循环变量 in 迭代对象 if 筛选条件</code>，其中最后的筛选条件不一定要。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>Python 中不用大括号来显式地分块，而是用<strong>冒号配合缩进</strong>。代码块与代码块之间至少隔着一个空行表示结束。当一个代码块必须存在，又不想写任何语句的时候，可以写一个 <code>pass</code> 作为占位符。</p><h3 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> a == <span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;a is 1&#x27;</span>)<br><span class="hljs-keyword">elif</span> a == <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;a is 0&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;wtf is a?&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>注意，<code>elif</code> 和 <code>else</code> 后面也要有冒号配合缩进，如果有多个条件，用 <code>and</code> 和 <code>or</code> 逻辑运算符连接。</p><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>前面所列的容器、数值列表都可以用于 <code>for</code> 循环迭代，比较特别的是字符串也可以迭代：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a = <span class="hljs-string">&#x27;hello world&#x27;</span><br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> a:<br>    <span class="hljs-built_in">print</span>(c) <span class="hljs-comment"># 竖着打印出 hello world，因为 print 自带换行</span><br></code></pre></div></td></tr></table></figure><p>此外，如果在数值列表的迭代中用不到迭代变量 <code>i</code>，仅作为迭代次数使用，可以用 <code>_</code> 变量表达。</p><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a = <span class="hljs-number">10</span><br><span class="hljs-keyword">while</span> <span class="hljs-number">2</span> &lt;= a &lt; <span class="hljs-number">20</span>:    <span class="hljs-comment"># 语法糖，这种写法是被建议使⽤的</span><br>    <span class="hljs-built_in">print</span>(a)<br>    a -= <span class="hljs-number">1</span>            <span class="hljs-comment"># 注意 Python 中没有⾃增 1 和⾃减 1 运算符</span><br></code></pre></div></td></tr></table></figure><p>跳出循环可以用 <code>break</code> 和 <code>continue</code>【与 C 相同】</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;函数文档注释&quot;&quot;&quot;</span><br>    current, then = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        current, then = then, current + then<br>    <span class="hljs-keyword">return</span> current<br><br>fib(<span class="hljs-number">10</span>) <span class="hljs-comment"># 调用函数</span><br></code></pre></div></td></tr></table></figure><h4 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h4><p>函数传参本质上和赋值号是一样的，都是浅复制（指针指向）【类似 C 的形参】。</p><p>传入参数的数量可以<strong>不固定</strong>，但是必须指定默认值；也可以<strong>调换顺序</strong>，但必须指明对象。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b = <span class="hljs-number">0</span></span>):</span><br>    <span class="hljs-built_in">print</span>(a + b)<br><br>add(<span class="hljs-number">1</span>) <span class="hljs-comment"># 参数 b 采用默认 0</span><br>add(b = <span class="hljs-number">2</span>, a = <span class="hljs-number">1</span>) <span class="hljs-comment"># 调换顺序，指明对象</span><br></code></pre></div></td></tr></table></figure><p>当然，也可以传递列表等容器，但传递的也是列表的地址，在函数中修改同样会改变原列表，如果不想修改原列表可以用 <code>[:]</code> 传递切片。</p><h4 id="传递任意数量的参数"><a href="#传递任意数量的参数" class="headerlink" title="传递任意数量的参数"></a>传递任意数量的参数</h4><ul><li>在形参前加星号 <code>*</code>，Python3 会创建一个该形参名称的<strong>元组</strong></li><li>在形参前加双星号 <code>**</code>，Python3 会创建一个该形参名称的<strong>字典</strong></li></ul><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>作为动态类型语言，函数返回值可以不固定，可以多个 <code>return</code> 在不同情况下返回不同值，或者没有 <code>return</code>（等价于 <code>return None</code>）。</p><h3 id="函数模块调用"><a href="#函数模块调用" class="headerlink" title="函数模块调用"></a>函数模块调用</h3><p>函数可以被存储在模块中被调用，模块是扩展名为 .py 的文件，包含函数的代码【类似于 C 的头文件】</p><ul><li>导入<strong>整个模块</strong>：使用 <code>import pizza</code> 导入，调用时使用 <code>.</code> 句点，如：<code>pizza.make(16, &#39;green peppers&#39;)</code></li><li>导入模块中<strong>特定函数</strong>：使用 <code>from pizza import make, eat</code>，调用时无需句点，直接用函数名</li><li>导入特定函数<strong>别名</strong>：使用 <code>from pizza import make as mk</code>，调用时无需句点，直接用别名</li><li>导入模块中<strong>所有函数</strong>：使用 <code>from pizza import *</code>，调用时无需句点，但是会<strong>污染命名空间</strong>，不建议使用</li></ul><p>所有 <code>import</code> 都放在程序开头【类似于 C++ 的 <code>#include&lt;&gt;</code>】。</p><h3 id="Lambda-匿名函数"><a href="#Lambda-匿名函数" class="headerlink" title="Lambda 匿名函数"></a>Lambda 匿名函数</h3><p>和很多语言⼀样，Python 中可以使用 Lambda 匿名函数完成一些简单的逻辑，但比较特殊的地方在于，Python 中匿名函数必须只由<strong>单个表达式</strong>构成，这个表达式的值也就是匿名函数的返回值。</p><p><code>lambda</code> 关键字可以用来创建一个匿名函数，紧跟其后的是<strong>参数列表</strong>和用冒号 <code>:</code> 分割开的单个表达式。如，<code>lambda x: 2 * x</code> 是将任何输入的数乘 2，而 <code>lambda x, y: x+y</code> 是计算两个数字的和。</p><p>使用匿名函数的经验准则是保持简单以及只在本地使用一次。一种常见却不推崇的做法是将其作为简单函数的另一种<strong>声明</strong>方式，赋值给<strong>变量</strong>，如：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>doubler = <span class="hljs-keyword">lambda</span> x: <span class="hljs-number">2</span> * x<br><span class="hljs-meta">&gt;&gt;&gt; </span>doubler(<span class="hljs-number">5</span>)<br><span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(doubler)<br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">function</span>&#x27;&gt;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>对 lambda 函数命名的唯一作用可能是出于教学目的，其问题在于这使得调试不那么直观——错误信息只会提示某个 <code>lambda</code> 函数存在问题，但不会提示哪个函数。</p></blockquote><p>正确的做法应该是将其作为<strong>参数</strong>传递，如 <code>.sort</code> 函数、<code>sorted</code> 函数等，此时单个表达式会被计算为一个值并且参与后续的计算。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>integers = [(<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">5</span>, <span class="hljs-number">1</span>), (-<span class="hljs-number">4</span>, <span class="hljs-number">4</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sorted</span>(integers, key=<span class="hljs-keyword">lambda</span> x: x[-<span class="hljs-number">1</span>])<br>[(<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>), (<span class="hljs-number">5</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (-<span class="hljs-number">4</span>, <span class="hljs-number">4</span>)]<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>nums.sort(key=<span class="hljs-keyword">lambda</span> a: <span class="hljs-built_in">abs</span>(<span class="hljs-number">5</span>-a))<br><span class="hljs-meta">&gt;&gt;&gt; </span>nums<br>[<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>]<br></code></pre></div></td></tr></table></figure><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>一种【与 C 相似】的操作是：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;temp.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>)  <span class="hljs-comment"># 打开一个文件，返回表示文件的对象</span><br>contents = file.read()<span class="hljs-comment"># 读取整个文件</span><br><span class="hljs-built_in">print</span>(contents)<br>file.close()<span class="hljs-comment"># 关闭文件</span><br></code></pre></div></td></tr></table></figure><p>此外，还有一种更推崇的操作方式，使用 <code>with</code> 上下文管理器，将<strong>打开的文件的对象</strong>存储在 <code>as</code> 后的变量，这样可以避免由于忘记关闭文件导致丢失数据：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;temp.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    contents = file.read()<br>    <span class="hljs-built_in">print</span>(contents)<br></code></pre></div></td></tr></table></figure><p>回到读取本身，方法 <code>read()</code> 读取<strong>整个文件</strong>的内容并返回<strong>单个字符串</strong>，并包含每个 <code>\n</code> 换行符。</p><p>但实际操作中读入<strong>一个长字符串</strong>是丑陋而且难以处理的，我们更倾向于逐行读入，用 <code>line.rstrip()</code> 消除行末的 <code>\n</code>：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;temp.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file:  <span class="hljs-comment"># file 也可作为一个迭代器</span><br>        <span class="hljs-built_in">print</span>(line)<span class="hljs-comment"># 注意每一行末都会有一个 \n 被打印，而 print 本身又自带换行</span><br></code></pre></div></td></tr></table></figure><p>另一种逐行读入是创建一个包含文件各行内容的<strong>列表</strong>，每个元素是一行内容的字符串，包含行尾的 <code>\n</code>：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;temp.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    line1 = file.readline()<span class="hljs-comment"># 读入第一行作为字符串</span><br>    lines = file.readlines()<span class="hljs-comment"># 读入第二行以后的行（文件指针被移动了）</span><br></code></pre></div></td></tr></table></figure><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;temp.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    file.write(<span class="hljs-string">&quot;I love programming.\n&quot;</span>) <span class="hljs-comment"># wirte 不会换行，要手动加</span><br></code></pre></div></td></tr></table></figure><p><code>open()</code> 函数的第二个实参 <code>w</code> 表示写入（自动创建或<strong>覆盖</strong>原内容），<code>r</code> 表示只读，<code>a</code> 表示附加（自动创建或<strong>添加到文件末尾</strong>），<code>r+</code> 表示读写。如果不加第二个实参，则默认为 <code>r</code> 只读。</p><p>方法 <code>write()</code> 表示将<strong>字符串</strong>写入文件。如果要写入数值，应先用 <code>str()</code> 将其转化为字符串。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>Python 中的类基础用法比 C/C++ 更简洁一些，待补充。</p>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ML学习笔记 #1 梯度下降：一元线性回归</title>
    <link href="/2021/09/22/ML-Note-1/"/>
    <url>/2021/09/22/ML-Note-1/</url>
    
    <content type="html"><![CDATA[<p>该笔记是观看 <a href="https://scholar.google.com/citations?hl=zh-CN&amp;user=mG4imMEAAAAJ">Andrew-Ng</a> 在斯坦福大学教授的 <a href="https://www.coursera.org/learn/machine-learning">Machine-Learning</a> 网课所做的笔记。由于网上可见的该课程笔记繁多，而本文所记内容并无不同，仅供个人娱乐。BTW，做笔记的过程中还参考了 <a href="https://xyfjason.top">xyfJASON</a> 的博客，解答了我许多疑惑。</p><h2 id="概论-Overview"><a href="#概论-Overview" class="headerlink" title="概论 | Overview"></a>概论 | Overview</h2><p>首先给出两个「机器学习」的定义，尽管对于相关从业者来说，也不存在一个被广泛认可的定义来准确定义机器学习是什么，但或许有助于回答诸如「机器学习是什么？」之类的面试问题：</p><ul><li>Arthur Samuel (1959). Machine Learning: Field of study that gives computers the ability to learn <strong>without</strong> being explicitly programmed. </li><li>Tom Mitchell (1998) Well-posed Learning Problem: A computer program is said to <em>learn</em> from <strong>experience</strong> E with respect to some <strong>task</strong> T and some <strong>performance measure</strong> P, if its performance on T, as measured by P, improves with experience E. </li></ul><h3 id="监督学习-Supervised-Learning"><a href="#监督学习-Supervised-Learning" class="headerlink" title="监督学习 | Supervised Learning"></a>监督学习 | Supervised Learning</h3><p>如果我们给学习算法一个数据集，这个数据集由「<strong>正确答案</strong>」组成，然后运用该算法算出更多可能正确的答案，这就是监督学习。</p><p>监督学习领域有两大问题：</p><ul><li>回归（Regression）：以一系列<strong>离散值</strong>（discrete），试着推测出这一系列<strong>连续值</strong>（continuous）属性。譬如根据已知房价预测未知房价。</li><li>分类（Classification）：以一系列<strong>离散值</strong>，试着推测出同样是<strong>离散值</strong>的属性。譬如预测肿瘤的恶性与否。</li></ul><p>对于分类问题，输出的结果可以大于两个（分出许多类），输入的<strong>特征</strong>（feature）也可以更多，例如通过患者年龄和肿瘤大小等特征预测肿瘤的恶性与否。</p><p>在绘制这些样本时，可以用一个<strong>多维空间</strong>中不同颜色的<strong>样本点</strong>来表示。在一些问题中，我们希望使用无穷多的特征来学习，显然电脑的内存肯定不够用，而后文将介绍的<strong>支持向量机</strong>（SVM，Support Vector Machine）巧妙地解决了这个问题。</p><h3 id="无监督学习-Unsupervised-Learning"><a href="#无监督学习-Unsupervised-Learning" class="headerlink" title="无监督学习 | Unsupervised Learning"></a>无监督学习 | Unsupervised Learning</h3><p>对于监督学习里的每条数据，我们已经清楚地知道，训练集对应的正确答案。而在无监督学习中，这些数据「<strong>没有任何标签</strong>」或是只有「<strong>相同的标签</strong>」。</p><p>因此，我们希望学习算法能够判断出数据具有不同的<strong>聚集簇</strong>（Cluster），这就是无监督学习领域的经典问题：<strong>聚类算</strong>（Cluster Algorithm）。</p><p>譬如在谷歌新闻中，我们对收集的网络新闻分组，组成有关联的新闻；又如在鸡尾酒宴会问题中，两个位置不同的麦克风录到的两个音源，通过学习算法可以各自分离出来。</p><h2 id="一元线性回归-Univariate-Linear-Regression"><a href="#一元线性回归-Univariate-Linear-Regression" class="headerlink" title="一元线性回归 | Univariate Linear Regression"></a>一元线性回归 | Univariate Linear Regression</h2><p>前文提到，回归是监督学习的一个经典问题，这里我们将以线性回归来一窥整个监督学习的模型建立过程。假设已经拥有了回归问题的<strong>训练集</strong>（Training Set），我们将之描述为：</p><script type="math/tex; mode=display">\left\{\left(x^{(i)}, y^{(i)}\right), i=1,2, \cdots, m\right\}</script><ul><li>$m$ 代表训练集中实例的数量；</li><li>$x$ 代表<strong>特征</strong> or 输入变量；</li><li>$y$ 代表目标变量 or 输出变量；</li><li>$({x}^{(i)},{y}^{(i)})$ 代表第 $i$ 个观察实例；</li><li>$h$ 代表学习算法的解决方案或函数也称为<strong>假设</strong>（hypothesis）。</li></ul><p>为了解决这样一个问题，我们实际上是要将训练集「喂」给我们的学习算法，进而学习得到一个假设 $h$。在本文中，我们尝试用线性函数 $h_\theta \left( x \right)=\theta_{0} + \theta_{1}x$ 拟合之。因为只含有一个特征 or 输入变量，因此这样的问题叫作<strong>一元线性回归</strong>问题。</p><h3 id="代价函数-Cost-Function"><a href="#代价函数-Cost-Function" class="headerlink" title="代价函数 | Cost Function"></a>代价函数 | Cost Function</h3><p>有了上文建立的基础模型，现在要做的便是为之选择合适的<strong>参数</strong>（parameters）$\theta_{0}$ 和 $\theta_{1}$，即直线的斜率和在 $y$ 轴上的截距。</p><p>选择的参数决定了得到的直线相对于训练集的<strong>准确程度</strong>，模型所预测的值与训练集中实际值之间的差距就是<strong>建模误差</strong>（modeling error）。我们要做的就是尽量选择参数使得误差降低，即最小化 $h_{\theta}(x^{(i)})$ 和 $y^{(i)}$ 的距离。于是我们有了经典的<strong>平方误差代价函数</strong>：</p><script type="math/tex; mode=display">J\left( \theta _0,\theta _1 \right) =\frac{1}{2m}\sum_{i=1}^m{\left( h_{\theta}(x^{(i)})-y^{(i)} \right) ^2}</script><p>也即是每个数据纵坐标的预测值与真实值的差的平方之和的平均，除以 2 仅是为了后续求导方便，没有什么本质的影响。</p><p>绘制一个三维空间，三个坐标分别为 $\theta_{0}$ 和 $\theta_{1}$ 和 $J(\theta_{0}, \theta_{1})$，对每个 $\left( \theta_0, \theta_1 \right)$ 对，代入训练集可以得到一个 $J(\theta_{0}, \theta_{1})$ 值，经过一系列计算，我们得到一个<strong>碗状曲面</strong>：</p><p><img src="/img/blog/ML-Note-1-images/3d-surface.png" alt="三维空间中的碗状曲面" width="67%" /></p><p>显然，在三维空间中存在一个使得 $J(\theta_{0}, \theta_{1})$ 最小的点。为了更好地表达，我们将三维空间投影到二维，得到<strong>等高线图</strong>（Contour plot）：</p><p><img src="/img/blog/ML-Note-1-images/contour.png" alt="二维空间的等高线图" width="50%" /></p><p>这些同心椭圆的中心，就是我们要找到使得 $J(\theta_{0}, \theta_{1})$ 最小的点。</p><h3 id="梯度下降法-Gradient-Descent"><a href="#梯度下降法-Gradient-Descent" class="headerlink" title="梯度下降法 | Gradient Descent"></a>梯度下降法 | Gradient Descent</h3><p>在数学上，我们知道最小二乘法可以解决一元线性回归问题。现在有了等高线图，我们需要的是一种有效的算法，能够自动地找出这些使代价函数 $J$ 取最小值的 $\left( \theta_0, \theta_1 \right)$ 对。当然并不是把这些点画出来，然后人工读出中心点的数值——对于更复杂、更高维度、更多参数的情况，我们很难将其可视化。</p><p>梯度下降是一个用来求<strong>一般函数最小值</strong>的算法，其背后的思想是：开始时<strong>随机选择</strong>一个参数组合$\left( \theta_{0},\theta_{1},……,\theta_{n} \right)$，计算代价函数，然后一点点地修改参数，直到找到<strong>下一个</strong>能让代价函数值下降最多的参数组合。</p><p>持续这么做会让我们找到一个<strong>局部最小值</strong>（local minimum），但我们无法确定其是否就是<strong>全局最小值</strong>（global minimum），哪怕只是稍微修改初始参数，也可能最终结果完全不同。当然，在一元线性回归问题中，生成的曲面始终是<strong>凸函数</strong>（convex function），因此我们可以不考虑这个问题。</p><p>在高等数学中，我们知道「下降最多」其实指的是函数 $J$ 的<strong>梯度方向的逆方向</strong>，也即方向导数最大的方向，梯度定义为：</p><script type="math/tex; mode=display">\mathrm{grad} J=\left\{ \frac{\partial J}{\partial \theta _0},\frac{\partial J}{\partial \theta _1} \right\}</script><p>所以不断迭代进行赋值：</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha\cdot\frac{\partial}{\partial\theta_j} J(\theta_{0}, \theta_{1})</script><p>直到收敛，即可找到一个<strong>极小值</strong>。其中，$\alpha$ 就是这一步的<strong>步长</strong>，也称为<strong>学习率</strong>（Learnig rate）。学习率的选取很重要，过小则梯度下降很慢，过大则有可能不收敛。</p><h3 id="数学推导-Deduction"><a href="#数学推导-Deduction" class="headerlink" title="数学推导 | Deduction"></a>数学推导 | Deduction</h3><p>对代价函数求偏导：</p><p>$j=0$  时：$\frac{\partial}{\partial \theta _0}J(\theta _0,\theta _1)=\frac{1}{m}\sum_{i=1}^m{\left( \theta _1x^{(i)}+\theta _0-y^{(i)} \right)}$</p><p>$j=1$  时：$\frac{\partial}{\partial \theta _1}J(\theta _0,\theta _1)=\frac{1}{m}\sum_{i=1}^m{x^{(i)}\left( \theta _1x^{(i)}+\theta _0-y^{(i)} \right)}$</p><p>所以梯度方向为：</p><script type="math/tex; mode=display">\mathrm{grad } J=\left\{ \frac{\partial J}{\partial \theta _0},\frac{\partial J}{\partial \theta _1} \right\} =\left\{ \frac{1}{m}\sum_{i=1}^m{\left( \theta _1x^{(i)}+\theta _0-y^{(i)} \right)},\frac{1}{m}\sum_{i=1}^mx^{(i)}\left( \theta _1x^{(i)}+\theta _0-y^{(i)} \right) \right\}</script><h3 id="代码实现-Implementation"><a href="#代码实现-Implementation" class="headerlink" title="代码实现 | Implementation"></a>代码实现 | Implementation</h3><p>需要注意的是，迭代赋值的过程中，$\left( \theta_0, \theta_1 \right)$ 的值要同时更新，否则就会与梯度方向有微小区别。用 Python 元组解包赋值可以实现，用矩阵乘法也可实现。</p><p>此外，我们注意到在<strong>每一步</strong>迭代过程中，我们都用到了<strong>所有的</strong>训练样本，如 $\sum_{i=1}^mx^{(i)}$、$\sum_{i=1}^my^{(i)}$、$\sum_{i=1}^mx^{(i)}y^{(i)}$ 等项，这也称为<strong>批量梯度下降</strong>（Batch Gradient Descent）。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># load data, data.shape = (97, 2)</span><br>data = np.loadtxt(<span class="hljs-string">&#x27;ex1data1.txt&#x27;</span>, delimiter=<span class="hljs-string">&#x27;,&#x27;</span>, usecols=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>x = data[:, <span class="hljs-number">0</span>]<br>y = data[:, <span class="hljs-number">1</span>]<br>m = y.size<br><br><span class="hljs-comment"># parameters</span><br>alpha = <span class="hljs-number">0.01</span><br>num_iters = <span class="hljs-number">5000</span><br>theta = np.zeros(<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># X.shape = (97, 2), y.shape = (97, ), theta.shape = (2, )</span><br>X = np.c_[np.ones(m), x]  <span class="hljs-comment"># 增加一列 1 到 矩阵 X，实现多项式运算</span><br><br><span class="hljs-comment"># Gradient Descent</span><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, num_iters):<br>    error = (X @ theta).flatten() - y  <span class="hljs-comment"># error.shape = (97, )</span><br>    theta -= (alpha / m) * np.<span class="hljs-built_in">sum</span>(X * error[:, np.newaxis], a0) <span class="hljs-comment"># 0 表示每列相加</span><br><br><span class="hljs-comment"># plot</span><br><span class="hljs-built_in">print</span>(theta)<br>plt.scatter(x, y)<br>x_plot = [<span class="hljs-built_in">min</span>(x), <span class="hljs-built_in">max</span>(x)]<br>y_plot = [theta[<span class="hljs-number">0</span>] + <span class="hljs-built_in">min</span>(x) * theta[<span class="hljs-number">1</span>], theta[<span class="hljs-number">0</span>] + <span class="hljs-built_in">max</span>(x) * theta[<span class="hljs-number">1</span>]]<br>plt.plot(x_plot, y_plot, c=<span class="hljs-string">&quot;m&quot;</span>)<br>plt.show()<br></code></pre></div></td></tr></table></figure><p>得到的 $\left( \theta_0, \theta_1 \right)$ 结果是：[-3.89530051  1.19298539]，作图如下：</p><p><img src="/img/blog/ML-Note-1-images/Figure_1.png" alt="一元线性回归" width="50%" /></p><blockquote><p>Tips：在 Python 或 Matlab 中进行科学计算时，如果有多组数据或多项式运算，转化成矩阵乘法会比直接用 <code>for</code> 循环高效很多，且代码更简洁。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习笔记 #3 使用远程服务器</title>
    <link href="/2021/09/11/Linux-Note-3/"/>
    <url>/2021/09/11/Linux-Note-3/</url>
    
    <content type="html"><![CDATA[<p>在前文的基础上，介绍了<strong>远程控制</strong> Linux 服务器的情景，以及在学习中常用的<strong>不间断会话</strong>服务。</p><p>本文大部分内容参考了清华 ZAH 同学的教程，部分参考了 刘遄 老师的《<a href="https://www.linuxprobe.com">Linux 就该这么学</a>》，<a href="https://www.runoob.com/linux/linux-tutorial.html">菜鸟教程-Linux</a>。</p><h2 id="远程控制服务"><a href="#远程控制服务" class="headerlink" title="远程控制服务"></a>远程控制服务</h2><p>日常工作中，我们常常会使用远程服务器来进行开发/运维，连接远程服务器需要用到 SecureShell（SSH）。</p><h3 id="初次连接"><a href="#初次连接" class="headerlink" title="初次连接"></a>初次连接</h3><p>打开本地的终端模拟器，通过如下命令使用 SSH 连接到其他服务器：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> ssh hewei@server.hitsz.edu.cn -p 30001</span><br></code></pre></div></td></tr></table></figure><p>在这个例子中，我们尝试以用户名 <code>hewei</code> 登陆服务器 <code>server.hitsz.edu.cn</code>。服务器可以通过<strong>服务器主机名</strong>指定（如本例），也可以使用 <strong>IP </strong>指定（如 <code>hewei@192.168.1.42</code>）。SSH 的默认端口是 22，也可以通过 <code>-p port</code> 制定端口。</p><p>输入上述命令后，如果成功连接，会提示输入密码，该密码就是远程服务器中<strong>对应账户</strong>的密码。</p><blockquote><p>本文中由于没有其他服务器，就在本机上用 VirtualBox 创建了一个 Ubuntu <strong>虚拟机</strong>作为服务器，获取虚拟机 IP，在主机中用终端连接。参考文章：<a href="https://www.cnblogs.com/clqbolg/p/11729868.html">用vbox搭建Linux服务器</a>。</p><p>注意：用本方法需要确保主机接有<strong>网线</strong>，且虚拟机配置<strong>桥接网卡</strong>与主机以太网相同。</p></blockquote><p>进入服务器后，可以看到命令行左侧的提示符变成了 <code>hewei@hewei-VirtualBox ~&gt;</code>，其中 <code>~</code> 代表在 <code>/home/hewei</code> 用户目录下，<code>&gt;</code> 符号提示远程用户身份，不同服务器可能不一样。输入 <code>logout</code> 可退出远程服务器。</p><h3 id="SSH-配置文件"><a href="#SSH-配置文件" class="headerlink" title="SSH 配置文件"></a>SSH 配置文件</h3><p>上述<strong>连接</strong>远程服务器的命令还可以通过修改 SSH 配置文件来简化，进入<strong>主机</strong>所在的用户文件夹下的 <code>.ssh</code> 文件夹（SSH 密钥所在的文件夹），新建配置文件 <code>config</code>，添加：</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">HOST</span> <span class="hljs-selector-tag">training</span> (任意别名，用于助记)<br><span class="hljs-selector-tag">HostName</span> <span class="hljs-selector-tag">152</span><span class="hljs-selector-class">.136</span><span class="hljs-selector-class">.177</span><span class="hljs-selector-class">.53</span> (域名/IP)<br>    <span class="hljs-selector-tag">Port</span> <span class="hljs-selector-tag">30001</span> (端口号)<br>    <span class="hljs-selector-tag">User</span> <span class="hljs-selector-tag">hewei</span> (用户名)<br></code></pre></div></td></tr></table></figure><p>配置完文件后，我们可以使用 <code>ssh test</code> 这样的命令来连接服务器，有助于管理多个服务器的账户。</p><h3 id="免登录执行"><a href="#免登录执行" class="headerlink" title="免登录执行"></a>免登录执行</h3><p>SSH 的一个经常被忽视的特性是它可以在<strong>不登录服务器</strong>的状态下直接远程执行命令，例如在配置完 <code>config</code> 后，使用 <code>ssh 别名</code> 命令：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> ssh training ls /home/hewei</span><br></code></pre></div></td></tr></table></figure><p>这步操作同样需要输入密码，但不会登录服务器，在主机环境中直接返回结果。</p><h3 id="SSH-鉴权"><a href="#SSH-鉴权" class="headerlink" title="SSH 鉴权"></a>SSH 鉴权</h3><p>使用 SSH 当然免不了基于<strong>密钥对</strong>的验证机制，我们只需要将<strong>公钥</strong>放在服务器上，每次登录时向服务器证明客户端持有对应的<strong>私钥</strong>。这样就可以避免每次登陆都输入密码了。</p><p>在 <a href="https://hwcoder.top/2021/09/03/Git-Note-3/">Git学习笔记 #3 远程仓库使用</a> 中，同样讲述了这个问题，这里假设我们已经生成了密钥对。在<strong>本机</strong>终端下，可以通过如下命令把公钥传到服务器：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> cat ~/.ssh/id_rsa.pub | ssh training <span class="hljs-string">&#x27;mkdir -p ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys&#x27;</span></span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-comment"># 拷贝公钥，利用 ssh training 免登录操控主机，创建路径并重定向公钥到 authorized_keys</span></span><br></code></pre></div></td></tr></table></figure><p>如果<strong>本机</strong>是 Linux/MacOS，支持 <code>ssh-copy-id</code> 命令，可以用下面这种更简单的方案：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> ssh-copy-id -i ~/.ssh/id_rsa.pub training</span><br></code></pre></div></td></tr></table></figure><p>当然，如果已经连上<strong>远程</strong>终端，也可以在远程直接操作：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> mkdir -p ~/.ssh</span><br><span class="hljs-meta">$</span><span class="bash"> vi ~/.ssh/authorized_keys  <span class="hljs-comment"># 用 vi 编辑器打开，手动复制公钥进去</span></span><br></code></pre></div></td></tr></table></figure><h3 id="文件上传下载"><a href="#文件上传下载" class="headerlink" title="文件上传下载"></a>文件上传下载</h3><p>通常我们需要将文件的工程文件放到服务器上执行，如果采用了 MobaXterm、Xshell 这类增强终端，可以通过<strong>拖拽</strong>的方式直接实现文件互传。</p><p>但如果直接在<strong>本机</strong>终端中，可以通过如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-comment"># 上传文件到服务器，参数一为本地文件</span></span><br><span class="hljs-meta">$</span><span class="bash"> scp test.zip training:/home/hewei/test.zip</span> <br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-comment"># 从服务器下载文件，参数一为服务器文件</span></span><br><span class="hljs-meta">$</span><span class="bash"> scp training:/home/hewei/test.zip test.zip</span><br></code></pre></div></td></tr></table></figure><p>此外，使用 <code>scp -r</code> 可以上传文件夹，如果需要更高级的功能，可以考虑使用 <code>rsync</code>。</p><h3 id="利用-VS-Code-连接"><a href="#利用-VS-Code-连接" class="headerlink" title="利用 VS Code 连接"></a>利用 VS Code 连接</h3><p>在今年的操作系统实验课上，又学到了一招连接远程服务器的办法，不得不说 VS Code 太强大了！以下的内容需要 <code>Remote - SSH</code> 插件支持。</p><p>安装插件后，在 <code>SSH TARGETS</code> 栏选择 <code>Add New</code>，之后会弹出输入框，输入 <a href="#初次连接">初次连接命令</a>，则会弹出提示自动设置 <code>.ssh/config</code> 文件！添加成功后，左侧的 <code>SSH TARGETS</code> 栏就会增加新的远程节点。</p><p>在该节点旁边，选中 <code>Connect to Host in New Window</code> 即可打开一个 VS Code 窗口，新打开的窗口会要求你选择目标机器的平台，选择 Linux，按下回车，再确定连接，输入<strong>密码</strong>，即可连接成功。观察到终端显示的提示符是 <code>190110429@OSLabExecNode1:~$</code>，成功！</p><p>之后，点击 VS Code 侧边栏的资源管理器，就可以直接打开远程的文件夹和文件，更方便<strong>编程和调试</strong>。此外，同样可以用 SSH <strong>鉴权</strong>来简化输入密码的步骤，方法同上。在 VS Code 中按下 <code>Ctrl+反引号</code> 可以快捷打开终端。 </p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="Vim-入门"><a href="#Vim-入门" class="headerlink" title="Vim 入门"></a>Vim 入门</h3><p>通常我们将工程传到服务器上跑时，可能需要修改某些代码或参数，如果没有使用增强终端或者 VSCode Remote 等插件，我们就只能在 CLI 界面进行交互。</p><p>要在 CLI 界面简单地<strong>编辑</strong>⼀个文件，可用的选择大概有 vi, vim, nano 等，通常来说我们选择使用 vim。使用 <code>vim &lt;filename&gt;</code> 命令打开文件进行编辑。</p><p>刚打开文件时，vim 处于一个 Normal 模式，在 Normal 模式下按 <code>i</code> 进入 Insert 模式，此时就可以像其他编辑器一样对文件进行编辑。编辑后按下 <code>ESC</code> 键退回到 Normal 模式。</p><p>在 Normal 模式下按 <code>:</code> 进入 Command 模式，在这个模式下可以使用命令进行操作，常用命令有：<code>:q</code> 退出，<code>:w</code> 保存，<code>:wq</code> 保存并退出。</p><h3 id="软件包管理机制"><a href="#软件包管理机制" class="headerlink" title="软件包管理机制"></a>软件包管理机制</h3><p>大多数现代类 Unix 操作系统都提供了一个集中的<strong>软件包管理机制</strong>，以帮助用户搜索、安装和管理软件。而软件通常以包的形式存储在<strong>仓库</strong>（repository）中，对软件包的使用和管理被称为包管理。而 Linux 包的基本组成部分通常有：共享库、应用程序、服务和文档。</p><p><strong>包管理器</strong>又称软件包管理系统，它是在电脑中自动安装、配制、卸载和升级软件包的工具组合，在各种系统软件和应用软件的安装管理中均有广泛应用。</p><p>几乎每⼀个系统发行版都有它的包管理器，Ubuntu 有 <code>apt</code>，Arch 有 <code>pacman</code>，macOS 有 <code>Homebrew</code>。</p><h3 id="包管理器换源"><a href="#包管理器换源" class="headerlink" title="包管理器换源"></a>包管理器换源</h3><p>由于众所周知的原因，<strong>仓库</strong>在国内的访问速度是不佳的，往往需要更换为国内的镜像源，常见的镜像站点有清华的 Tuna，其 Ubuntu 源地址为：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</a> 。</p><p>Ubuntu 的软件配置文件时 <code>/etc/apt/source.list</code>，首先将系统自带的该文件备份：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> sudo cp /etc/apt/source.list /etc/apt/source.list.bak</span><br><span class="hljs-meta">$</span><span class="bash"> ls /etc/apt/source.list -lah <span class="hljs-comment"># 查看文件权限，发现需要 root 权限</span></span><br></code></pre></div></td></tr></table></figure><p>此时如果直接用 vim 打开文件，会发现无法进入 Insert 模式，于是需要用：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> sudo vim /etc/apt/source.list <span class="hljs-comment"># 用 root 身份打开文件</span></span><br></code></pre></div></td></tr></table></figure><p>进入编辑器后，可以进入 Insert 慢慢删除，也可以直接在 Normal 模式下输入 <code>ggyG</code> 全选删除。然后将网站中的配置文件复制进去。</p><p>现在就可以使用镜像源下载软件包了，这里以下面要用的 Tmux 为例：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-comment"># 由于包管理器是在系统中，也需要 sudo 来获得 root 权限，且需要密码</span></span><br><span class="hljs-meta">$</span><span class="bash"> sudo apt update       <span class="hljs-comment"># 检查已安装的软件包是否有可用的更新</span></span><br><span class="hljs-meta">$</span><span class="bash"> sudo apt search tmux  <span class="hljs-comment"># 在仓库中查找是否有该源文件，可以跳过</span></span><br><span class="hljs-meta">$</span><span class="bash"> sudo apt install tmux <span class="hljs-comment"># 安装软件包</span></span><br><span class="hljs-meta">$</span><span class="bash"> sudo apt remove tmux  <span class="hljs-comment"># 删除已安装软件包</span></span><br></code></pre></div></td></tr></table></figure><h2 id="不间断会话服务"><a href="#不间断会话服务" class="headerlink" title="不间断会话服务"></a>不间断会话服务</h2><p>命令行的典型使用方式是，打开一个<strong>终端窗口</strong>（terminal window，以下简称窗口），在里面输入命令。用户与计算机的这种临时的交互，称为⼀次「<strong>会话</strong>」（session） 。</p><h3 id="服务中断"><a href="#服务中断" class="headerlink" title="服务中断"></a>服务中断</h3><p>会话的⼀个重要特点是，窗口与其中启动的进程是<strong>绑定</strong>的——打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行结束。</p><p>因此，使用 SSH 远程控制服务时，当<strong>与远程主机的会话</strong>被关闭时，在远程主机上运行的命令也随之被中断。</p><p>如果运行某个重要的程序，中途是<strong>绝对不能</strong>关闭在本地打开的终端窗口或断开网络连接的，甚至连网速的波动都有可能导致任务中断，此时只能重新进行远程连接并重新开始任务。而我们需要在服务器上跑的东西恰恰就是比较<strong>占用资源</strong>的程序，通常需要执行较长时间，如果因为网速波动而中断就很难受。</p><h3 id="分离会话"><a href="#分离会话" class="headerlink" title="分离会话"></a>分离会话</h3><p>为了解决这个问题，会话与窗口可以「<strong>解绑</strong>」：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话「<strong>重新绑定</strong>」其他窗口。</p><p>Terminal  Multiplexer（终端复用器，简称为 Tmux）就是一款能够实现<strong>多窗口远程控制</strong>的开源服务程序。简单来说就是为了<strong>解决网络异常中断</strong>或为了<strong>同时控制多个远程终端窗口</strong>而设计的程序。</p><p>远程连接服务器后，输入 <code>tmux</code> 进入 Tmux 窗口，窗口下方会出现<strong>绿色</strong>的一行。在 Tmux 窗口中，输入 <code>tmux detach</code> 命令，就会将当前<strong>会话与窗口分离</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> tmux        <span class="hljs-comment"># 在终端窗口输入，进入 Tmux 窗口</span></span><br><span class="hljs-meta">$</span><span class="bash"> tmux detach <span class="hljs-comment"># 在 Tmux 窗口输入，退回终端窗口</span></span><br></code></pre></div></td></tr></table></figure><p>上述命令执行后，就会退回到本地终端窗口，但是会话和里面的进程仍然在后台运行。此时可以输入命令查看后台正在运行的 Tmux 会话：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> tmux list-session</span><br><span class="hljs-meta">$</span><span class="bash"> tmux ls  <span class="hljs-comment"># 两条命令等价</span></span><br></code></pre></div></td></tr></table></figure><p>会弹出 <code>0: 1 windows (created Mon Sept 9 20:34:12 2021)</code> 的提示信息，其中 <code>0</code> 表示该窗口标题（默认从 0 开始递增），此外也可以<strong>命名窗口</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> tmux new -s &lt;session-name&gt;  <span class="hljs-comment"># 新建 Tmux 窗口并命名</span></span><br></code></pre></div></td></tr></table></figure><h3 id="接入会话"><a href="#接入会话" class="headerlink" title="接入会话"></a>接入会话</h3><p>此时就算退出远程连接，会话也会保持运行，可以使用以下命令<strong>重新接入</strong>某个已存在的会话：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> tmux attach -t 0 <span class="hljs-comment"># 使用会话编号</span></span><br><span class="hljs-meta">$</span><span class="bash"> tmux attach -t &lt;session-name&gt;  <span class="hljs-comment"># 使用会话名称</span></span><br></code></pre></div></td></tr></table></figure><h3 id="杀死会话"><a href="#杀死会话" class="headerlink" title="杀死会话"></a>杀死会话</h3><p>在终端窗口中，如果要<strong>彻底杀死</strong>一个运行中的会话，需要用到以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> tmux kill-session -t 0     <span class="hljs-comment"># 使用会话编号</span></span><br><span class="hljs-meta">$</span><span class="bash"> tmux kill-session -t &lt;session-name&gt;  <span class="hljs-comment"># 使用会话名称</span></span><br></code></pre></div></td></tr></table></figure><p>当然，也可以先用 <code>attach</code> 命令接入会话，再按下 <code>Ctrl+D</code> 或者输入 <code>exit</code> <strong>直接退出</strong> Tmux 会话（注意退出与解绑不同）。</p><h3 id="管理多窗格"><a href="#管理多窗格" class="headerlink" title="管理多窗格"></a>管理多窗格</h3><p>有时候需要同时执行多个程序，并观察输出，就需要多个会话窗口。利用 Tmux 还可以将一个<strong>窗口切分</strong>为多个（并且独立执行会话，<strong>互不干扰</strong>）。只要使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> tmux split-window     <span class="hljs-comment"># 上下切割窗格</span></span><br><span class="hljs-meta">$</span><span class="bash"> tmux split-window -h  <span class="hljs-comment"># 左右切割窗格</span></span><br><span class="hljs-meta">$</span><span class="bash"> tmux select-pane -U / -D / -L / -R  <span class="hljs-comment"># 切换至 上/下/左/右 窗格</span></span><br></code></pre></div></td></tr></table></figure><p>在工作中，通过输入命令来切换窗格难免有些麻烦，Tmux 为用户提供了一系列快捷键来执行窗格的切换：先同时按下 <code>Ctrl+B</code> 组合键，松手后再按下 <code>%</code> 表示划分左右两个窗格，按下 <code>“</code> 表示划分上下两个窗格，<code>&lt;方向键&gt;</code> 表示到上下左右相邻的一个窗格，<code>x</code> 表示关闭窗格。</p>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习笔记 #2 高级的Shell与文件管理</title>
    <link href="/2021/09/09/Linux-Note-2/"/>
    <url>/2021/09/09/Linux-Note-2/</url>
    
    <content type="html"><![CDATA[<p>在前文的基础上，记录了 Linux 中如何充分利用 Shell 命令，以及对<strong>文件权限</strong>的管理。</p><p>本文部分内容参考了清华 ZAH 同学的教程，部分参考了 刘遄 老师的《<a href="https://www.linuxprobe.com">Linux 就该这么学</a>》，<a href="https://www.runoob.com/linux/linux-tutorial.html">菜鸟教程-Linux</a>。</p><h2 id="高级的-Shell"><a href="#高级的-Shell" class="headerlink" title="高级的 Shell"></a>高级的 Shell</h2><p>Linux 中可以将简单的 Shell 命令组合以发挥更大的作用，常见的如：与文件读写操作有关的重定向技术、处理命令输出值的管道命令符、通配符和转义字符等。这些技巧在 Shell 脚本批处理中十分常用。</p><h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>输入重定向是指把文件<strong>导入到命令</strong>中，而输出重定向则是指把原本要输出到屏幕的数据信息<strong>写入到指定文件</strong>中。</p><p>日常的学习和工作中，使用输出重定向的频率更高，所以又将输出重定向分为了<strong>标准输出</strong>重定向和<strong>错误输出</strong>重定向两种不同的技术，以及<strong>覆盖写入</strong>与<strong>追加写入</strong>两种模式。</p><blockquote><p>错误信息的输出对于执行一个<strong>自动化</strong>的 Shell 脚本非常有用，它可以把整个脚本执行过程中的<strong>报错信息</strong>都记录到文件中，便于安装后的排错工作。</p></blockquote><p>对于输入重定向，格式如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">格式</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>命令 &lt; 文件</code></td><td style="text-align:center">将文件作为命令的标准输入</td></tr><tr><td style="text-align:center"><code>命令 &lt;&lt; 分界符</code></td><td style="text-align:center">从键盘输入中读入，直到遇见分界符才停止</td></tr><tr><td style="text-align:center"><code>命令 &lt; 文件A &gt; 文件B</code></td><td style="text-align:center">将文件 A 作为命令的输入并将标准输出到文件 B</td></tr></tbody></table></div><blockquote><p>通常用输入重定向能做的事情，直接执行该命令也能做，因此使用频率较低。</p></blockquote><p>对于输出重定向，格式如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">格式</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>命令 &gt; 文件</code></td><td style="text-align:center">将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td style="text-align:center"><code>命令 2&gt; 文件</code></td><td style="text-align:center">将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td style="text-align:center"><code>命令 &gt;&gt; 文件</code></td><td style="text-align:center">将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td style="text-align:center"><code>命令 2&gt;&gt; 文件</code></td><td style="text-align:center">将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr></tbody></table></div><h3 id="管道命令符"><a href="#管道命令符" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>管道命令符 <code>|</code> 用于把<strong>前一个命令</strong>原本要输出到屏幕的信息当作<strong>后一个命令</strong>的标准输入，就像一个「管道」连接了两条命令一样，其本质是创建一个<strong>临时文件</strong>用以读写。</p><p>下面用一些例子来展示管道命令符的巧妙之处：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> grep /sbin/nologin /etc/passwd | wc -l <span class="hljs-comment"># 抓取文件中含 /sbin/nologin 的行，统计行数</span></span><br><span class="hljs-meta">$</span><span class="bash"> ls -lah /etc/ | more <span class="hljs-comment"># 罗列目录下的文件信息，用翻页的形式查看</span></span><br><span class="hljs-meta">$</span><span class="bash"> ls -lah usr/bin | grep <span class="hljs-built_in">echo</span> <span class="hljs-comment"># 罗列目录下的文件信息，抓取 echo 文件</span></span><br><span class="hljs-meta">$</span><span class="bash"> ps aux | grep bash <span class="hljs-comment"># 显示全部进程，抓取 bash 的进程信息</span></span><br></code></pre></div></td></tr></table></figure><p>此外，管道命令符在一条命令中还可以多次复用，完成更复杂的工作。</p><p>但是，由于管道运算符实现的本质，它默认会将前者的输出作为<strong>一整个临时文件</strong>传给后者，而有时候我们却需要拆散这个文件，<strong>依次输入</strong>到后者，这时就需要这个命令：</p><ul><li><code>xargs</code>：代表 eXtended ARGuments，管道命令传递参数的一个<strong>过滤器</strong>，格式为：<code>命令1 | xargs [参数] 命令2</code>。</li></ul><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>在 Git 学习中，已经介绍了一些常用的通配符，这里附上完整表格：</p><div class="table-container"><table><thead><tr><th style="text-align:center">通配符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>*</code></td><td style="text-align:center">任意字符</td></tr><tr><td style="text-align:center"><code>?</code></td><td style="text-align:center">单个任意字符</td></tr><tr><td style="text-align:center"><code>[a-z]</code></td><td style="text-align:center">单个小写字母</td></tr><tr><td style="text-align:center"><code>[A-Z]</code></td><td style="text-align:center">单个大写字母</td></tr><tr><td style="text-align:center"><code>[a-Z]</code></td><td style="text-align:center">单个字母</td></tr><tr><td style="text-align:center"><code>[0-9]</code></td><td style="text-align:center">单个数字</td></tr><tr><td style="text-align:center"><code>[[:alpha:]]</code></td><td style="text-align:center">任意字母</td></tr><tr><td style="text-align:center"><code>[[:upper:]]</code></td><td style="text-align:center">任意大写字母</td></tr><tr><td style="text-align:center"><code>[[:lower:]]</code></td><td style="text-align:center">任意小写字母</td></tr><tr><td style="text-align:center"><code>[[:digit:]]</code></td><td style="text-align:center">所有数字</td></tr><tr><td style="text-align:center"><code>[[:alnum:]]</code></td><td style="text-align:center">任意字母加数字</td></tr><tr><td style="text-align:center"><code>[[:punct:]]</code></td><td style="text-align:center">标点符号</td></tr></tbody></table></div><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>转义字符通常用于避免命令的歧义，最常用的有如下几种：</p><ul><li>反斜杠 <code>\</code>：使反斜杠后面的一个保留字符变为单纯的字符。</li><li>单引号 <code>‘’</code>：转义其中所有的变量为单纯的字符串。</li><li>双引号 <code>“”</code>：保留其中的<strong>变量属性</strong>，不进行转义处理。</li></ul><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>回归一个最本质的问题，当我们在 Shell 环境中输入一条命令时（我们知道这条命令其实是一个 C 编写的程序），Shell 是如何找到这个程序的呢？</p><p>首先，Shell 会用户是否以<strong>绝对路径或相对路径</strong>的方式输入命令（如 /bin/ls），如果是绝对路径则直接执行。如果不是，系统则需要在<strong>多个路径</strong>中查找用户输入的命令文件，而定义这些路径的变量就叫作 <strong>PATH</strong>。我们可以通过如下命令来查看：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span>  <span class="hljs-comment"># 符号 $ 表示输出环境变量的值</span></span><br>/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/root/bin<br></code></pre></div></td></tr></table></figure><p>可以看到，PATH 文件中含有多个量，都是这条命令可能存放的位置，于是解释器会在这些位置中逐个查找。</p><p>当然，为了 Linux 这样庞大系统的运行，类似的环境还有许多，我们可以使用 <code>env</code> 命令来查看所有环境变量。这里列出常用的一些变量：</p><div class="table-container"><table><thead><tr><th style="text-align:center">变量名称</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">HOME</td><td style="text-align:center">用户的主目录（即家目录）</td></tr><tr><td style="text-align:center">SHELL</td><td style="text-align:center">用户在使用的 Shell 解释器名称</td></tr><tr><td style="text-align:center">HISTSIZE</td><td style="text-align:center">输出的历史命令记录条数</td></tr><tr><td style="text-align:center">HISTFILESIZE</td><td style="text-align:center">保存的历史命令记录条数</td></tr><tr><td style="text-align:center">MAIL</td><td style="text-align:center">邮件保存路径</td></tr><tr><td style="text-align:center">LANG</td><td style="text-align:center">系统语言、语系名称</td></tr><tr><td style="text-align:center">RANDOM</td><td style="text-align:center">生成一个随机数字</td></tr><tr><td style="text-align:center">PS1</td><td style="text-align:center">Bash 解释器的提示符</td></tr><tr><td style="text-align:center">PATH</td><td style="text-align:center">定义解释器搜索用户执行命令的路径</td></tr></tbody></table></div><blockquote><p>PATH 是最重要的一个环境变量，许多黑客会在 /tmp 中存放一个与 ls 或 cd 同名的木马文件，再把路径加入 PATH。</p></blockquote><h2 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h2><p>Linux 作为一个多用户、多任务的操作系统，具有很好的稳定性与安全性，在幕后保障 Linux 系统的安全则是一系列复杂的配置工作。这里暂不介绍<strong>用户身份</strong>相关的命令，只介绍<strong>文件权限与归属</strong>。</p><h3 id="目录详解"><a href="#目录详解" class="headerlink" title="目录详解"></a>目录详解</h3><p>Unix/Linux 中，<strong>一切皆文件</strong>。涉及权限操作时，不可避免地要接触各个目录，这里简单介绍一些常用目录的作用：</p><p><img src="/img/blog/Linux-Note-2-images/directory.jpg" alt="树状目录结构"></p><p><strong>系统启动项</strong>：</p><ul><li><p>/boot：存放的启动 Linux 时使用的<strong>内核文件</strong>，包括连接文件以及镜像文件。</p></li><li><p>/etc：表示 Etcetera，存放所有的系统需要的<strong>配置文件</strong>和<strong>子目录列表</strong>。</p></li></ul><p><strong>指令集合</strong>：</p><ul><li><p>/bin：存放着最常用的<strong>程序和指令</strong>，如 <code>ls</code> 就是在 /bin/ls 目录下的。</p></li><li><p>/sbin：表示 Super User，只有系统管理员能使用的程序和指令。</p></li></ul><p><strong>账户</strong>：</p><ul><li><p>/root：<strong>系统管理员</strong>的用户主目录。</p></li><li><p>/home：用户的主目录，以各个用户的账号命名，<strong>支持多用户</strong>。</p></li><li><p>/usr：表示 Unix Shared Resources，用户的很多<strong>应用程序和文件</strong>都放在这个目录下，类似 Windows 下的 Program Files 目录。</p><ul><li>/usr/bin：系统用户使用的应用程序与指令。</li><li>/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。</li><li>/usr/src：内核源代码默认的放置目录。</li></ul></li></ul><p><strong>其他</strong>：</p><ul><li>外部文件管理：/dev、/media、/mnt，挂载外部设备，如 U盘，光驱等。</li><li>临时文件：/run，存储系统运行信息；/tmp，存储用户临时信息。</li><li>运行过程项：/var，存放日志等；/proc，管理<strong>内存空间</strong>，系统内存的映射。</li><li>扩展目录：/src，存放服务启动后需要提取的数据，不用<strong>服务器</strong>就是空。</li></ul><h3 id="权限类型"><a href="#权限类型" class="headerlink" title="权限类型"></a>权限类型</h3><p>在 Linux 系统中，每个<strong>文件和目录</strong>都有归属的所有者和所属组，并且规定了其<strong>所有者</strong>、<strong>所属组</strong>以及<strong>其他人</strong>所拥有的可读取（r）、可写入（w）、可执行（x，代表 execute）的权限。</p><p>这三个权限对于文件和目录的含义各不相同：</p><div class="table-container"><table><thead><tr><th style="text-align:center">权限</th><th style="text-align:center">文件</th><th style="text-align:center">目录</th></tr></thead><tbody><tr><td style="text-align:center">读取（r）</td><td style="text-align:center">能读取文件</td><td style="text-align:center">能够读取目录内的<strong>文件列表</strong></td></tr><tr><td style="text-align:center">写入（w）</td><td style="text-align:center">能编辑、新增、修改、删除文件</td><td style="text-align:center">能够在目录内新增、删除、重命名文件</td></tr><tr><td style="text-align:center">执行（r）</td><td style="text-align:center">能运行一个<strong>脚本</strong>程序</td><td style="text-align:center">能够<strong>进入该目录</strong></td></tr></tbody></table></div><p>三类对象，三种权限，总共需要<strong>九个标志位</strong>来限定一个文件或目录的权限范围，为了区分文件和目录等，还有<strong>一个附加标志位</strong>。权限的表示就分为<strong>字符</strong>表示和<strong>数字</strong>表示两种：</p><p><img src="/img/blog/Linux-Note-2-images/file-permission.png" alt="文件权限的字符与数字表示"></p><p>数字表示即在字符对应的<strong>二进制位</strong>填写 1 或 0，表示授权或未授权，转换为<strong>十进制</strong>就是 4、2、1。</p><p>下面以一个例子来说明这两种表示法：现在有这样一个文件，其<strong>所有者</strong>拥有可读、可写、可执行的权限，其文件<strong>所属组</strong>拥有可读、可写的权限；<strong>其他人</strong>只有可读的权限。</p><ul><li>字符表示：<code>rwxrw-r--</code></li><li>数字表示：<code>111110100</code> 即 <code>764</code></li></ul><p>那么现在我们用 <code>ls -l</code> 查看文件的信息：</p><p><img src="/img/blog/Linux-Note-2-images/ls-l.png" alt="通过ls命令查看到的文件属性信息"></p><p>这些信息依次为：<strong>文件类型与权限</strong>；硬链接数；所有者；所有组；文件大小（字节）；最后修改时间；文件名。</p><blockquote><p>文件类型有 7 种，最常见的是 <code>-</code> 表示普通文件，<code>d</code> 表示目录文件。</p><p>硬链接数，对于普通文件，表示指向存储数据块中该文件的<strong>链接数</strong>（相当于 Windows 的快捷方式）；对于目录文件，表示所在<strong>子目录级数</strong>。</p></blockquote><p>在复杂的实际情况中，单纯设置 rwx 权限已无法满足需求，因此还有 SUID、SGID 与 SBIT 三个特殊权限位，这里不多赘述。</p><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>通常来讲，修改权限的操作有以下两个：</p><ul><li><p><code>chmod</code>：代表 Change mode，格式为 <code>chmod [参数] 文件名称</code>。其中参数为数字表示的权限。</p></li><li><p><code>chown</code>：代表 Change owner，格式为 <code>chown 所有者:所有组 文件名</code>。</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>chmod +x script.sh</code></td><td style="text-align:center">给脚本添加可执行权限（默认对于任何人）</td></tr><tr><td style="text-align:center"><code>chmod 777 a.txt</code></td><td style="text-align:center">赋予所有人<strong>完整权限</strong></td></tr><tr><td style="text-align:center"><code>chmod 000 a.txt</code></td><td style="text-align:center">赋予<strong>最小权限</strong>，只有 root 才能操作</td></tr><tr><td style="text-align:center"><code>chown root:root a.txt</code></td><td style="text-align:center">修改所有者和所有组为 root</td></tr></tbody></table></div><p>此外，它们还有一个特别的共性，就是针对目录进行操作时需要加上大写参数 <code>-R</code> 来表示递归操作，即对目录内所有的文件进行整体操作。</p><h3 id="管理员权限"><a href="#管理员权限" class="headerlink" title="管理员权限"></a>管理员权限</h3><p>Linux 系统为了安全性考虑，使得许多系统命令和服务只能被 root 管理员来使用，通过一些命令可以<strong>切换或暂时切换</strong> root 权限。</p><ul><li><code>su</code>：不退出登录的情况下，<strong>切换</strong>用户身份，格式为 <code>su - 用户名称</code>。</li></ul><p>注意到命令中间有个 <code>-</code> 符号，这意味着<strong>完全切换</strong>到新的用户，即把环境变量信息也变更为新用户的相应信息，而不是保留原始的信息。用户名称可以是普通用户，也可以是 root。由普通用户切换至 root 需要输入<strong>管理员密码</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> su - root</span><br>Password:  #此处输入管理员密码<br></code></pre></div></td></tr></table></figure><ul><li><code>sudo</code>：代表 Superuser do，给普通用户提供<strong>额外</strong>的权限，格式为 <code>sudo [参数] 用户名称</code>。</li></ul><p>最常用的是为当前用户<strong>暂时</strong>提供 root 权限，此时不需要输入管理员密码，只需要<strong>当前用户密码</strong>。该命令可以避免显式输入管理员密码，但有效时间仅有 5 分钟。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> sudo su</span><br>Password:  #此处输入当前用户密码<br></code></pre></div></td></tr></table></figure><p>此外，<code>sudo</code> 还可加在其他命令前面，以获取高权限的执行，常用的有包管理命令。</p>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习笔记 #1 终端与Shell</title>
    <link href="/2021/09/06/Linux-Note-1/"/>
    <url>/2021/09/06/Linux-Note-1/</url>
    
    <content type="html"><![CDATA[<p>继 Git 后贵系的另一个暑培项目，讲授 Linux 的基本用法，恰好这学期「操作系统」课程实验需要用到 Linux，而且实验室的服务器也需要学习相关用法，故学之。</p><p>本文部分内容参考了清华 ZAH 同学的教程，部分参考了 刘遄 老师的《<a href="https://www.linuxprobe.com">Linux 就该这么学</a>》，<a href="https://www.runoob.com/linux/linux-tutorial.html">菜鸟教程-Linux</a>。</p><h2 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h2><p>Linux，全称 GNU/Linux，是一套免费使用和自由传播的类 Unix 操作系统。相比于其他系统，Linux 更加稳定且有效率、更加安全、相对不耗资源……以至于几乎所有<strong>长期稳定运行的网站服务器</strong>上、在<strong>处理大数据的集群系统</strong>中，以及需要<strong>协同工作的服务器环境</strong>都采用 Linux 系统。</p><h3 id="Linux-发行版"><a href="#Linux-发行版" class="headerlink" title="Linux 发行版"></a>Linux 发行版</h3><p>Linux 严格来说是单指操作系统的<strong>内核</strong>，因操作系统中包含了许多用户图形接口和其他实用工具。如今 Linux 常用来指「基于 Linux 的完整操作系统」，内核则改以「Linux 内核」称之。</p><p>一些组织或厂商将 Linux 内核与各种软件和文档<strong>包装</strong>起来，并提供系统安装界面和系统配置、设定与管理工具，就构成了 Linux 的发行版本。</p><p><img src="/img/blog/Linux-Note-1-images/Linux-release.jpg" alt="常见的Linux发行版"></p><h2 id="命令行与终端"><a href="#命令行与终端" class="headerlink" title="命令行与终端"></a>命令行与终端</h2><p>在学习 Linux 的过程中，有几个易混淆的概念：</p><ul><li>图形用户界面（GUI）= 使用<strong>图形</strong>方式进行交互的用户界面</li><li>命令行界面（CLI）= 使用<strong>文本</strong>命令进行交互的用户界面</li><li>控制台（Console）= 物理意义的终端，电脑主机的一部分</li><li>终端（Terminal）= TTY (Teletypewriter，打字机) = <strong>文本输入输出环境</strong></li><li>终端模拟器（Terminal Emulator）= 套壳程序，用来<strong>模拟传统终端</strong></li><li>Shell = 一个程序，<strong>命令行解释器</strong>，执行用户输入的命令并返回结果</li></ul><h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h3><p>命令行界面（Command-Line Interface，CLI）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为字符用户界面（Character User Interface，CUI）。</p><p>一般来说，在<strong>服务器</strong>中较多采用的是 CLI 界面，或许有以下几点原因：</p><ul><li>服务器的功能是对外提供服务，并不需要直观的 GUI 界面来让用户日常使用，使用 GUI 界面反而浪费资源。</li><li>使用 CLI 界面管理服务器，本质上是直接用命令控制服务器，这允许一系列的自动化脚本（Shell 脚本）出现来节省时间。</li><li>方便自动化、规模化部署服务器。</li></ul><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 等系统的桥梁，如同「<strong>壳</strong>」一般。它的本质是一个<strong>命令解释器</strong>，将用户输入的命令（符合 Shell 语法）处理成对应<strong>操作系统的控制命令</strong>，处理完毕后再将结果反馈给用户。</p><p>不同操作系统下面的 Shell 种类众多，常见的有：</p><ul><li>Windows：cmd (Command Shell)、PowerShell；</li><li>Linux/macOS：sh、bash、zsh 等。</li></ul><p>Ken Thompson 的 sh 是第一种 Unix Shell，本教程关注的是 Bash，也就是 Bourne Again Shell，Bash 也是大多数 Linux 系统默认的 Shell。</p><h3 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h3><p>终端 (Terminal)，是一种用来让用户输入数据至计算机，以及显示其计算结果的机器。早期的终端通常就是一台<strong>电子打字机</strong>（Teletypewriter, TTY），后来随着计算机的发展，打字机被键盘和显示器取代，而 GUI 界面也成了主流。</p><p>于是，这时候我们就需要一个程序来模拟传统终端的行为，即<strong>终端模拟器</strong>（Terminal Emulator），当用户打开终端模拟器时，实际上是进入一个<strong>会话进程</strong>（Session）。终端模拟器有很多，这里举几个经典的例子：</p><ul><li>GNU/Linux：gnome-terminal、Konsole；</li><li>macOS：Terminal.app、iTerm2；</li><li>Windows：Windows Terminal、Cmder 等。</li></ul><h2 id="Shell-使用"><a href="#Shell-使用" class="headerlink" title="Shell 使用"></a>Shell 使用</h2><p>在 Linux 系统中打开终端时，会看到一个提示符，通常类似 <code>hewei@hewei-VirtualBox ~$</code>。在提示符下，命令会被 Shell 环境<strong>解析并反馈</strong>到终端中。</p><p>提示符是 Shell 最主要的<strong>文本接口</strong>。它告诉你，你的主机名是 <code>hewei-VirtualBox</code>，你现在的身份是 <code>hewei</code> 并且你当前的<strong>工作目录</strong>（Current working directory）是 <code>~</code> （默认在 <code>/home/hewei/</code> 用户目录）。 </p><p><code>$</code> 符号表示您现在的身份不是 <code>root</code>，输入如下命令可以暂时切换到 <code>root</code> 权限：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">hewei@hewei-VirtualBox ~$ sudo su  <span class="hljs-comment"># 获取 root 权限</span><br>[sudo] hewei 的密码:  <span class="hljs-comment"># 在此输入密码，Terminal 下密码都是不可见的</span><br></code></pre></div></td></tr></table></figure><p>输入密码后，可以看到提示符变成了 <code>root@hewei-VirtualBox:/home/hewei#</code>，其中 <code>#</code> 符号就是超级用户权限的标志。再输入 <code>exit</code> 即可退回普通用户身份。</p><h3 id="终端快捷键"><a href="#终端快捷键" class="headerlink" title="终端快捷键"></a>终端快捷键</h3><p>在 <a href="https://hwcoder.top/2021/08/28/Git-Note-1">Git学习笔记 #1 基础知识介绍</a> 中，已经简单介绍了命令行界面的一些使用技巧，这些命令在 Linux 系统的 Bash 中同样使用。这里罗列出 Linux 常用快捷键：</p><ul><li><code>Ctrl+Shift+T</code>：唤出一个终端窗口。</li><li><code>Tab</code>：实现对命令、参数或文件的内容补全。</li><li><code>Ctrl+C</code>：终止当前进程的运行，重获终端的控制权。</li><li><code>Ctrl+Z</code>：挂起当前进程。</li><li><code>Ctrl+D</code>：结束键盘输入，若正在使用 Shell 则退出，相当于输入 <code>exit()</code>。</li><li><code>Ctrl+L</code>：清空当前终端中已有的内容，相当于输入 <code>clear</code>。</li><li><code>&lt;上下键&gt;</code>：翻看使用过的命令记录。</li><li><code>Shift+PgUp/PgDn</code>：翻页终端。</li><li><code>home/end</code>：光标快速移动到当前行首或行尾。</li><li><code>Ctrl/Shift+Ins</code> ：复制粘贴文本。</li><li><code>‘’</code> 和 <code>“”</code>：命令参数中若存在空格，需要用引号括起来。</li></ul><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p>常见的执行 Linux 命令的格式是这样的：<code>命令名称 [命令参数] [命令对象]</code>。其中，命令参数用于对命令进行调整，使之更好地贴近需求，参数分为<strong>长格式</strong>和<strong>短格式</strong>，如：<code>man --help</code>，<code>man -h</code>。短格式之间可以合并，合并后仅保留一个减号即可。</p><p>在 Linux 相关的手册中，我们会约定俗成地将可选择的、非必需的参数使用<strong>中括号</strong>引起来，而命令所要求的、必须有的参数或对象值，则不带中括号。</p><p>此外，要注意 Linux 系统中的命令、参数、对象都是<strong>严格区分大小写</strong>的。</p><h3 id="Shell-脚本"><a href="#Shell-脚本" class="headerlink" title="Shell 脚本"></a>Shell 脚本</h3><p>Shell 除了是一个<strong>交互式</strong>（Interactive）的命令解释器，它还是一种<strong>程序设计语言</strong>（Shell Script）。它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支。</p><p>用 Shell 编写的<strong>脚本文件</strong>即 <code>.sh</code> 文件，它能在 Shell 环境下运行，fork 出一个<strong>子进程</strong>，调用系统内核来执行<strong>批处理</strong>（Batch）的系统控制。在文件的第一行，通常是 <code>#!/bin/bash</code>，这句话约定了这个脚本需要哪种 Shell 环境来执行。</p><p>通过如下命令就可以执行一个 Shell 脚本：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> bash example.sh</span><br></code></pre></div></td></tr></table></figure><h2 id="常用命令摘要"><a href="#常用命令摘要" class="headerlink" title="常用命令摘要"></a>常用命令摘要</h2><p>下面罗列了部分常用指令与参数的介绍，更多功能请在帮助手册中检索。</p><h3 id="唤出帮助界面命令"><a href="#唤出帮助界面命令" class="headerlink" title="唤出帮助界面命令"></a>唤出帮助界面命令</h3><ul><li><code>man</code>：代表 Manuel，查看帮助手册，格式为 <code>man 命令名称</code>。会进入「<strong>导航</strong>」模式，使用如下快捷键进行查阅：</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;空格键&gt;</code></td><td style="text-align:center">向下翻一页</td></tr><tr><td style="text-align:center"><code>PaDn</code>/<code>PgUp</code></td><td style="text-align:center">向下/上翻一页</td></tr><tr><td style="text-align:center"><code>home</code>/<code>end</code></td><td style="text-align:center">直接前往首页/尾页</td></tr><tr><td style="text-align:center"><code>/</code></td><td style="text-align:center">从上至下搜索某个关键词，如 <code>/linux</code></td></tr><tr><td style="text-align:center"><code>?</code></td><td style="text-align:center">从下至上搜索某个关键词，如 <code>?linux</code></td></tr><tr><td style="text-align:center"><code>q</code></td><td style="text-align:center">退出帮助文档</td></tr></tbody></table></div></blockquote><h3 id="常用系统工作命令"><a href="#常用系统工作命令" class="headerlink" title="常用系统工作命令"></a>常用系统工作命令</h3><ul><li><code>echo</code>：输出<strong>字符串</strong>或<strong>变量</strong>提取后的值，格式为 <code>echo [字符串] [$变量]</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>echo &#39;hello world&#39;</code></td><td style="text-align:center">输出一个字符串参数，<code>hello world</code></td></tr><tr><td style="text-align:center"><code>echo hello world</code></td><td style="text-align:center">输出两个<strong>空格隔开</strong>的字符串参数，<code>hello</code> 和 <code>world</code></td></tr><tr><td style="text-align:center"><code>echo hello\ world</code></td><td style="text-align:center">输出一个字符串参数，<code>\</code> <strong>转义</strong>空格</td></tr><tr><td style="text-align:center"><code>echo $PATH</code></td><td style="text-align:center">输出环境变量 <code>PATH</code> 的提取值</td></tr></tbody></table></div></blockquote><ul><li><code>date</code>：显示或设置系统的时间与日期，格式为：<code>date [+指定的格式]</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>date</code></td><td style="text-align:center">显示 <code>Sat Sep 5 09:13:45 CST 2020</code></td></tr><tr><td style="text-align:center"><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code></td><td style="text-align:center">按格式显示 <code>2020-09-05 09:14:35</code></td></tr><tr><td style="text-align:center"><code>date -s &quot;20201101 8:30:00&quot;</code></td><td style="text-align:center">设置系统时间</td></tr></tbody></table></div></blockquote><ul><li><code>reboot</code>：重启系统，无格式，需要 <code>root</code> 权限。</li><li><code>poweroff</code>：关闭系统，无格式，需要 <code>root</code> 权限。</li><li><code>ps</code>：代表 Processes，查看系统中的<strong>进程状态</strong>，格式为 <code>ps [参数]</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>-a</code></td><td style="text-align:center">显示所有进程（包括其他用户的进程）</td></tr><tr><td style="text-align:center"><code>-u</code></td><td style="text-align:center">显示用户以及其他详细信息</td></tr><tr><td style="text-align:center"><code>-x</code></td><td style="text-align:center">显示没有控制终端的进程</td></tr><tr><td style="text-align:center"><code>aux</code></td><td style="text-align:center">合并三个参数，<code>ps</code> 命令可省略 <code>-</code></td></tr></tbody></table></div></blockquote><ul><li><p><code>pstree</code>：以<strong>树状图</strong>形式展示进程之间关系，无格式。</p></li><li><p><code>top</code>：<strong>动态地监视</strong>进程活动及系统负载等信息，无格式。</p></li><li><p><code>nice</code>：调整进程的<strong>优先级</strong>，格式为 <code>nice -n 优先级数字 服务名称</code>。取值为 -20 到 19，数字越小，优先级越高。</p></li><li><p><code>pidof</code>：查询指定进程的 PID，格式为 <code>pidof [参数] 服务名称</code>。</p></li><li><p><code>kill</code>：终止指定 PID 值的进程，格式为 <code>kill [参数] PID</code>。</p></li></ul><h3 id="系统状态检测命令"><a href="#系统状态检测命令" class="headerlink" title="系统状态检测命令"></a>系统状态检测命令</h3><ul><li><code>ifconfig</code>：代表 Interface config，获取网卡配置与网络状态等信息。</li><li><code>ipaddr</code>：代表 IP address，获取 IP 地址等信息。</li><li><code>uname</code>：代表 Unix name，查看系统<strong>内核</strong>版本与系统架构等信息。</li><li><code>uptime</code>：查看系统的<strong>负载信息</strong>（当前系统时间、已运行时间、启用终端数、平均负载值），无格式。</li><li><code>free</code>：显示当前系统中<strong>内存的使用量</strong>，格式为 <code>free [-h]</code>，<code>-h</code> 为易读模式（human readable）。</li><li><code>who</code>：查看当前登入主机的<strong>用户终端信息</strong>，无格式。</li><li><code>ping</code>：测试主机之间的网络连通性，格式为 <code>ping [参数] 主机地址</code>。</li><li><code>history</code>：显示执行过的命令历史，格式为 <code>history [-c]</code>，<code>-c</code> 为清空（clear）。</li></ul><h3 id="查找定位文件命令"><a href="#查找定位文件命令" class="headerlink" title="查找定位文件命令"></a>查找定位文件命令</h3><ul><li><code>pwd</code>：代表 Print working directory，显示用户当前所处的工作目录，无格式。</li><li><code>cd</code>：代表 Change directory，切换当前的工作路径，格式为 <code>cd [参数] [目录]</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>cd -</code></td><td style="text-align:center">返回到上一次所处的目录</td></tr><tr><td style="text-align:center"><code>cd .</code></td><td style="text-align:center">进入目录（无变化）</td></tr><tr><td style="text-align:center"><code>cd ..</code></td><td style="text-align:center">进入上级目录</td></tr><tr><td style="text-align:center"><code>cd /</code></td><td style="text-align:center">切换到根目录</td></tr><tr><td style="text-align:center"><code>cd ~</code></td><td style="text-align:center">切换到当前用户的 <code>/home/</code> 目录</td></tr><tr><td style="text-align:center"><code>cd ~ &lt;username&gt;</code></td><td style="text-align:center">切换到其他用户的 <code>/home/</code> 目录</td></tr><tr><td style="text-align:center"><code>cd /bin</code></td><td style="text-align:center">切换到绝对路径 <code>/bin</code> 下</td></tr></tbody></table></div></blockquote><ul><li><code>ls</code>：代表 List，显示目录中的文件信息，格式为 <code>ls [参数] [文件名称]</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>ls -a</code></td><td style="text-align:center">查看全部文件（包括隐藏文件）</td></tr><tr><td style="text-align:center"><code>ls -l</code></td><td style="text-align:center">列表形式，查看文件的属性、大小等详细信息</td></tr><tr><td style="text-align:center"><code>ls -al</code></td><td style="text-align:center">合并以上两个参数</td></tr><tr><td style="text-align:center"><code>ls -alh</code></td><td style="text-align:center">易读显示（human readable）</td></tr><tr><td style="text-align:center"><code>ls -ld</code></td><td style="text-align:center">查看当前路径文件夹的属性、大小等详细信息</td></tr></tbody></table></div></blockquote><ul><li><code>tree</code>：以树状图的形式列出<strong>目录内容及结构</strong>，无格式。</li><li><code>find</code>：指定条件查找文件所对应的位置，格式为 <code>find [查找范围] 寻找条件</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>find /etc -name &quot;host*&quot;</code></td><td style="text-align:center">查找 <code>/etc</code> 路径下 <code>host</code> 开头的文件</td></tr><tr><td style="text-align:center"><code>find / -perm -4000</code></td><td style="text-align:center">整个系统中搜索权限包括 SUID 的文件</td></tr></tbody></table></div></blockquote><ul><li><p><code>updatedb</code>：生成文件索引库，无格式。和以下命令配合使用，快于 <code>find</code>。</p></li><li><p><code>locate</code>：按照名称快速搜索文件所对应的位置，格式为 <code>locate 文件名称</code>。</p></li><li><p><code>whereis</code>：按照名称快速搜索<strong>命令</strong>、<strong>源代码</strong>及<strong>帮助文件</strong>的位置，格式为 <code>whereis 命令名称</code>。</p></li><li><p><code>which</code>：按照名称检索<strong>命令</strong>的位置，格式为 <code>which 命令名称</code>，默认在 PATH 变量所指定的路径中检索。</p></li></ul><h3 id="文本统计编辑命令"><a href="#文本统计编辑命令" class="headerlink" title="文本统计编辑命令"></a>文本统计编辑命令</h3><ul><li><code>cat</code>：代表 Concatenate，查看<strong>内容较少</strong>的纯文本文件，格式为 <code>cat [参数] 文件名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>cat a.txt</code></td><td style="text-align:center">查看当前目录下文件内容</td></tr><tr><td style="text-align:center"><code>cat -n a.txt</code></td><td style="text-align:center">查看时显示行号</td></tr><tr><td style="text-align:center"><code>cat /etc/os-release</code></td><td style="text-align:center">查看操作系统信息</td></tr></tbody></table></div></blockquote><ul><li><code>more</code>：查看<strong>内容较多</strong>的纯文本文件，格式为 <code>more [参数] 文件名称</code>。用空格键或回车键向下滚动查看。</li><li><code>head</code>：查看纯文本文件的前 <em>N</em> 行，格式为 <code>head -n [行数] 文件名称</code>。</li><li><code>tail</code>：查看纯文本文件的后 <em>N</em> 行，格式为 <code>tail [参数] 文件名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>tail -n 10 a.txt</code></td><td style="text-align:center">显示文件的后 10 行</td></tr><tr><td style="text-align:center"><code>tail -f /var/log/messages</code></td><td style="text-align:center">查看并实时刷新，常用于日志文件</td></tr></tbody></table></div></blockquote><ul><li><code>tr</code>：代表 Translate，替换文本内容中的字符，格式为 <code>tr [原始字符] [目标字符]</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>cat a.txt丨tr [a-z] [A-Z]</code></td><td style="text-align:center">把文本中的英文以全大写输出（经过管道运算符）</td></tr></tbody></table></div></blockquote><ul><li><code>wc</code>：统计指定文本文件的行数 <code>-l</code>、字数 <code>-w</code> 或字节数 <code>-c</code>，格式为 <code>wc [参数] 文件名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>wc -l /etc/passwd</code></td><td style="text-align:center">统计 <code>passwd</code> 行数，等价于求用户数</td></tr><tr><td style="text-align:center"><code>wc 1.txt</code></td><td style="text-align:center">不加参数，默认三个值都返回</td></tr></tbody></table></div></blockquote><ul><li><code>stat</code>：查看文件的具体存储细节和时间等信息，格式为 <code>stat 文件名称</code>。</li><li><code>grep</code>：代表 Global Regular Expression Print，按行提取文本内容，格式为 <code>grep [参数] 查询内容 文件名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>-b</code></td><td style="text-align:center">将可执行文件 (bin) 当作文本文件 (txt) 来搜索</td></tr><tr><td style="text-align:center"><code>-c</code></td><td style="text-align:center">仅显示找到的行数</td></tr><tr><td style="text-align:center"><code>-i</code></td><td style="text-align:center">忽略查询内容的大小写</td></tr><tr><td style="text-align:center"><code>-n</code></td><td style="text-align:center">同时显示行号</td></tr><tr><td style="text-align:center"><code>-v</code></td><td style="text-align:center">反向选择，列出不包含查询内容的行</td></tr></tbody></table></div></blockquote><ul><li><code>diff</code>：比较多个文件之间内容的差异，格式为 <code>diff [参数] 文件名称A 文件名称B</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>diff --brief diff_A.txt diff_B.txt</code></td><td style="text-align:center">仅显示判断结果</td></tr><tr><td style="text-align:center"><code>diff -c diff_A.txt diff_B.txt</code></td><td style="text-align:center">描述不同的行</td></tr></tbody></table></div></blockquote><ul><li><code>uniq</code>：代表 Unique，去除文本中连续的重复行，格式为 <code>uniq [参数] 文件名称</code>。</li><li><code>sort</code>：对文本内容进行再排序，格式为 <code>sort [参数] 文件名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>-f</code></td><td style="text-align:center">忽略大小写</td></tr><tr><td style="text-align:center"><code>-b</code></td><td style="text-align:center">忽略缩进与空格</td></tr><tr><td style="text-align:center"><code>-n</code></td><td style="text-align:center">以数值型排序</td></tr><tr><td style="text-align:center"><code>-r</code></td><td style="text-align:center">反向排序</td></tr><tr><td style="text-align:center"><code>-u</code></td><td style="text-align:center">去除重复行</td></tr><tr><td style="text-align:center"><code>-t</code></td><td style="text-align:center">指定间隔符</td></tr><tr><td style="text-align:center"><code>-k</code></td><td style="text-align:center">按照间隔符，指定第几列值</td></tr></tbody></table></div></blockquote><h3 id="文件目录管理命令"><a href="#文件目录管理命令" class="headerlink" title="文件目录管理命令"></a>文件目录管理命令</h3><ul><li><code>touch</code>：创建空白文件或设置文件的时间，格式为 <code>touch [参数] 文件名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>touch 1.txt</code></td><td style="text-align:center">创建一个空白文件</td></tr><tr><td style="text-align:center"><code>touch -d &quot;2020-05-04 15:44&quot; 1.txt</code></td><td style="text-align:center">设置文件上次修改时间</td></tr></tbody></table></div></blockquote><ul><li><code>mkdir</code>：代表 Make directory，创建空白的目录，格式为 <code>mkdir [参数] 目录名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>mkdir mydir</code></td><td style="text-align:center">在当前路径下新建文件夹</td></tr><tr><td style="text-align:center"><code>mkdir -p a/b/c/d/e</code></td><td style="text-align:center">创建层叠目录</td></tr></tbody></table></div></blockquote><ul><li><code>cp</code>：代表 Copy，复制文件或目录，格式为 <code>cp [参数] 源文件名称 目标文件名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">源文件</th><th style="text-align:center">目标文件</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">文件</td><td style="text-align:center">目录</td><td style="text-align:center">把源文件复制到该目录中</td></tr><tr><td style="text-align:center">文件</td><td style="text-align:center">文件</td><td style="text-align:center">询问是否要覆盖它（需要 <code>-i</code>）</td></tr><tr><td style="text-align:center">文件</td><td style="text-align:center">不存在</td><td style="text-align:center">执行正常的复制操作（如<strong>备份</strong>）</td></tr><tr><td style="text-align:center">目录</td><td style="text-align:center">目录</td><td style="text-align:center">递归持续复制（需要 <code>-r</code> 或 <code>-a</code>）</td></tr></tbody></table></div></blockquote><ul><li><code>mv</code>：移动文件，格式为 <code>mv [参数] 源文件名称 目标文件名称</code>。不同于复制操作，默认会把源文件删除，只保留剪切后的文件。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>mv 1.txt 2.txt</code></td><td style="text-align:center">相当于重命名文件</td></tr><tr><td style="text-align:center"><code>mv 1.txt mydir</code></td><td style="text-align:center">剪切到新目录下</td></tr></tbody></table></div></blockquote><ul><li><code>rm</code>：删除文件或目录，格式为 <code>rm [参数] 文件名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>-f</code></td><td style="text-align:center">强制执行，不询问</td></tr><tr><td style="text-align:center"><code>-i</code></td><td style="text-align:center">删除前询问（默认）</td></tr><tr><td style="text-align:center"><code>-r</code></td><td style="text-align:center">递归删除目录</td></tr><tr><td style="text-align:center"><code>-v</code></td><td style="text-align:center">显示正在删除过程</td></tr></tbody></table></div></blockquote><ul><li><code>rmdir</code>：删除<strong>空</strong>目录，格式为 <code>rmdir [参数] 目录名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>rmdir mydir</code></td><td style="text-align:center">删除当前路径的<strong>空</strong>目录</td></tr><tr><td style="text-align:center"><code>rmdir -p a/b/c</code></td><td style="text-align:center">删除层叠空目录</td></tr></tbody></table></div></blockquote><ul><li><code>file</code>：查看文件的类型，常用于无后缀文件，格式为 <code>file 文件名称</code>。</li></ul><blockquote><p>Linux 中一切皆文件，而许多文件都是没有后缀的。</p><p>不像 Windows，用户双击鼠标打开文件，此时系统会自行判断用户双击的文件是什么类型，因此需要有后缀进行区别。</p><p>而 Linux 系统则是根据用户执行的命令来调用文件，例如执行 cat 命令查看文本等，所以也就不需要强制让用户给文件设置后缀了。</p></blockquote><ul><li><code>tar</code>：文件进行打包压缩或解压，格式为 <code>tar 参数 文件名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>-c</code></td><td style="text-align:center">创建压缩文件</td></tr><tr><td style="text-align:center"><code>-x</code></td><td style="text-align:center">解开压缩文件</td></tr><tr><td style="text-align:center"><code>-t</code></td><td style="text-align:center">查看压缩包内有哪些文件</td></tr><tr><td style="text-align:center"><code>-v</code></td><td style="text-align:center">显示真正压缩或解压的过程</td></tr><tr><td style="text-align:center"><code>-C</code></td><td style="text-align:center">指定解压到的目录</td></tr></tbody></table></div></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习笔记 #4 GitHub合作开发</title>
    <link href="/2021/09/05/Git-Note-4/"/>
    <url>/2021/09/05/Git-Note-4/</url>
    
    <content type="html"><![CDATA[<p>接上文，本文介绍了 Git 基于 <strong>GitHub</strong> 的使用，以及<strong>合作开发</strong>的注意事项。文章的最后还留下了一些待填的坑…</p><p>本文大部分内容参考了 RCY 同学的教程，部分参考了 <a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰教程-Git</a>，<a href="https://www.runoob.com/git/git-tutorial.html">菜鸟教程-Git</a>，以及 Git 官网文档 <a href="https://git-scm.com/doc">Git-Documentation</a>。</p><h2 id="GitHub-合作开发"><a href="#GitHub-合作开发" class="headerlink" title="GitHub 合作开发"></a>GitHub 合作开发</h2><p>以下内容也适用于不同的服务器平台，如 Gitee、GitLab 等。</p><h3 id="新建远程仓库"><a href="#新建远程仓库" class="headerlink" title="新建远程仓库"></a>新建远程仓库</h3><p>从 GitHub 上创建一个空仓库后，通常有三个选择：</p><ul><li><strong>直接克隆</strong>到本地，会生成一个仓库文件夹，里面只有一个 <code>.git</code> 文件夹。可以在仓库文件夹中创作。</li><li>在<strong>本地新建</strong>一个同名文件夹，再创建本地仓库，添加远程仓库，推送并绑定上游分支。</li><li>对<strong>本地已有</strong>的一个仓库（确保同名），添加远程仓库，推送并绑定上游分支。</li></ul><p>对于第一种方法，只需要 <code>git clone</code> 命令即可，对于第二种方法，GitHub 提供了一系列指引命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;# test&quot;</span> &gt;&gt; README.md<br>$ git init<br>$ git add README.md<br>$ git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br>$ git branch -M main  <span class="hljs-comment"># 重命名本地主分支，避免冲突，新版本特性</span><br>$ git remote add origin https://github.com/hewei2001/test.git<br>$ git push -u origin main  <span class="hljs-comment"># 推送并绑定上游分支</span><br></code></pre></div></td></tr></table></figure><p>对于第三种情况，只需完成后面三步即可。</p><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p>在通过 GitHub 新建仓库时，我们会发现有个 <code>Add .gitignore</code> 按钮，这有什么用呢？实际上我们知道，维护真正项目时可能有一次修改会涉及到多个文件，这个时候一般大家会倾向于使用 <code>git add .</code> 的简单操作。</p><p>但是，并非所有文件都应该被放入 Git 仓库中，如：</p><ul><li>IDE / 编辑器 的<strong>配置文件</strong>（如 .vscode、.idea 等）；</li><li>数据库文件；</li><li>带有敏感信息的文件。</li></ul><p>这和便利的命令形成了矛盾，为此出现了特殊文件 <code>.gitignore</code>，它可以决定哪些的文件不需要添加到版本管理中。一个样例如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># Python3 的缓存文件（预编译模块）</span><br>__pycache__<br><span class="hljs-comment"># Vscode 的配置文件</span><br>.vscode<br><span class="hljs-comment"># Pycharm 等Jet的配置文件</span><br>.idea<br></code></pre></div></td></tr></table></figure><p><code>.gitignore</code> 是以行为单位，一行写一个规则，决定什么不被添加，书写规则也很简单：</p><ul><li>若规则不包含 <code>/</code>，会对 <code>.gitignore</code> <strong>同路径下</strong>的文件和文件夹进行屏蔽；</li><li>若规则以 <code>/</code> 结束，则只匹配在该文件夹路径下的内容；</li><li>若规则以 <code>/</code> 开始，则会从项目根目录开始匹配；</li><li><code>!</code> 开头的模式标识<strong>否定</strong>，该文件将会再次被包含，通常用于在屏蔽的文件中添加<strong>特例</strong>；</li><li>支持 <code>* ？ []</code> 在内的通配符。 </li><li>不能识别<strong>中文</strong>，因为默认编码是 GBK。</li></ul><p>创建一个 <code>.gitignore</code> 文件最便捷的方法是，在创建仓库时勾选 GitHub 自动创建，并在选项中选择合适的 <code>.gitignore</code> 文件模板，再克隆到本地。当然，也可以选择手动创建，再到网上搜索配置模板。</p><blockquote><p>在实际工程中，用 GitHub 创建仓库还可以便捷地添加合适的 LICENSE 文件。</p></blockquote><h3 id="远程服务器拒绝"><a href="#远程服务器拒绝" class="headerlink" title="远程服务器拒绝"></a>远程服务器拒绝</h3><p>如果你是在一个<strong>大合作团队</strong>中工作，很可能是 main 被<strong>锁定</strong>了（只有 Collaborators 有权限推送），其他人需要 Pull Request 流程来合并修改。</p><p>如果你直接提交到本地 main，然后试图推送修改，你将会收到这样类似的信息:</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less">! <span class="hljs-selector-attr">[远程服务器拒绝]</span> <span class="hljs-selector-tag">main</span> <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">main</span> (<span class="hljs-attribute">TF402455</span>: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)<br></code></pre></div></td></tr></table></figure><p>这里推荐一个做法：<strong>Fork</strong> 最新的仓库，此时你将拥有这个远程仓库的<strong>从分支</strong>——你的用户名就是从分支名。再将你的修改提交到这条分支，最后通过 GitHub 网站来提交一个 PR，请求主分支<strong>拉取并合并</strong>你的从分支。</p><blockquote><p>当然，如果只是几个人的<strong>小开发团队</strong>，还是建议在仓库的 <code>Settings</code> 界面找到 <code>Collaborators</code>，直接添加队友来得方便。</p></blockquote><h2 id="高端的-Git"><a href="#高端的-Git" class="headerlink" title="高端的 Git"></a>高端的 Git</h2><p>高端的操作往往意味着危险的操作，以下将介绍前文未提及的一些操作，同时也挖下一些坑以后来填。</p><h3 id="版本回退-Reset"><a href="#版本回退-Reset" class="headerlink" title="版本回退 (Reset)"></a>版本回退 (Reset)</h3><p>有时候你可能希望放弃 Git 仓库中的一部分提交，退到其他某处，这种情况下可以：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git reset &lt;Commit ID or Branch&gt;         <span class="hljs-comment"># 让 Git 仓库回退到某个记录或分支位置</span><br>$ git reset &lt;Commit Id or Branch&gt; --hard  <span class="hljs-comment"># 让所有区回退到某个记录或分支位置（将丢失你工作区和暂存区的数据）</span><br></code></pre></div></td></tr></table></figure><p>这种情况下可以带着分支一起回退，然后重新 commit，走一条完全不同的道路，而放弃了部分数据。</p><p>但是，如果你 reset 完后又后悔了，该怎么办？没关系，只要你没玩 gc 这样的危险指令，那么你 Git 仓库中的数据总有机会找回来。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git reflog <span class="hljs-comment"># 查看最近一些变动快照的操作与版本号</span><br></code></pre></div></td></tr></table></figure><p>在看到后面的快照的版本号后，则可以 reset 回去。</p><h3 id="Cherry-Pick"><a href="#Cherry-Pick" class="headerlink" title="Cherry-Pick"></a>Cherry-Pick</h3><p>一个相对高端的分支管理命令，将一些提交复制到当前所在的位置（HEAD）下面，这些提交可以来自其他分支，但不一定是顺序的！</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git cherry-pick &lt;Commit ID&gt;<br></code></pre></div></td></tr></table></figure><h3 id="Stash"><a href="#Stash" class="headerlink" title="Stash"></a>Stash</h3><p>用于将目前暂存区的东西移入一片额外空间，从而清空暂存区。</p><h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><p>无论是本博客，还是网上的文档，甚至官方的教程，都未必能把每个指令的每个参数、用法提到，因此 Git 自带的帮助文档就很重要：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git add --<span class="hljs-built_in">help</span><br>$ git <span class="hljs-built_in">help</span> add<br><span class="hljs-comment"># 以上两个指令的效果等价，都会</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习笔记 #3 远程仓库使用</title>
    <link href="/2021/09/03/Git-Note-3/"/>
    <url>/2021/09/03/Git-Note-3/</url>
    
    <content type="html"><![CDATA[<p>接上文，本文介绍了 Git 在<strong>远程仓库</strong>的使用，以及<strong>合作开发</strong>的简易教程。</p><p>本文大部分内容参考了 RCY 同学的教程，部分参考了 <a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰教程-Git</a>，<a href="https://www.runoob.com/git/git-tutorial.html">菜鸟教程-Git</a>，以及 Git 官网文档 <a href="https://git-scm.com/doc">Git-Documentation</a>。</p><h2 id="远程的-Git"><a href="#远程的-Git" class="headerlink" title="远程的 Git"></a>远程的 Git</h2><p>尽管 Git 本身是分布式的，但我们通常需要一个服务器来同步、传递我们的本地仓库数据，处于一种「<strong>伪集中式</strong>」的状态。但服务器上的内容不一定是最新的内容，只是一个用于传递的中间态而已。</p><p>因此有了一系列的相关网站，通常来说我们用以下两个：</p><ul><li>GitHub：⼀个基于 Git 的代码托管服务平台，开源社区交流代码的重要网站，参考 <a href="https://www.github.com/">https://www.github.com/</a> 。</li><li>GitLab：类似 Git，有完善的管理界面和权限控制，一般用于在企业、学校等内部网络搭建 Git 私服，参考 <a href="https://www.gitlab.com/">https://www.gitlab.com/</a> 。</li></ul><p>从代码的私有性上来看，GitLab 是一个更好的选择。但是对于开源项目而言，GitHub 依然是代码托管的首选。</p><h3 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h3><p>在使用远程仓库之前，我们要先解决鉴权问题：云服务器需要知道你是否有权力访问这个仓库。</p><p>鉴权有两种方法：</p><ol><li>用户名 + 密码</li><li>SSH 密钥对</li></ol><p>通常来说，使用密钥对比用户名密码更安全，这里不介绍相关原理，先简单讲下密钥对的配置。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;631670924@qq.com&quot;</span> <span class="hljs-comment"># 获取 SSH Key</span><br><span class="hljs-comment"># 参数 -t 代表 type 设置，默认使用 SSH2d 的 rsa</span><br><span class="hljs-comment"># 参数 -C 代表 Comment 设置，提供一个新注释</span><br><span class="hljs-comment"># 其他参数用于生成更多功能的密钥，请自行查阅相关网站</span><br>$ cat ~/.ssh/id_rsa.pub <span class="hljs-comment"># 代表 concatenate，用于连接文件并打印到标准输出</span><br></code></pre></div></td></tr></table></figure><p>密钥对生成时会需要设置密码，但由于其本身就是加密的，密码只是为了适应更特殊的情景，这里可以直接回车<strong>跳过</strong>。</p><p><code>cat</code> 命令会把<strong>公钥</strong>放到标准输出，复制到 GitHub 或 GitLab 上的对应位置即可。注意 <code>id_rsa.pub</code> 是可以公开的，而<strong>私钥</strong>存储在 <code>id_rsa</code> 文件，用于在每次操作远程仓库时与公钥进行匹配。</p><h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><p>远程仓库通常是由 clone 或 push 开始的，这里假设我们已经在 GitHub 上有了一个仓库，现在要将其克隆到本地。</p><p>常见的克隆方法有两种：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> &lt;仓库的 HTTPS URL 地址&gt;<br>$ git <span class="hljs-built_in">clone</span> &lt;仓库的 SSH Key&gt;<br></code></pre></div></td></tr></table></figure><p>前者不需要配置 SSH 也能完成，但是每次操作远程仓库都需要用户名和密码。后者是在配置完 SSH Key 后使用的，可以省去填写用户名和密码的步骤，也能帮助你克隆<strong>私有仓库</strong>。如果前面生成密钥对时设置了密码，这里就需要输入。</p><p>此外，如果要克隆一个较大的仓库（仓库有很长的提交历史或大量二进制文件），常用的一个方法是限制 clone 的深度，只克隆最新的版本：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> --depth=1 https://github.com/hewei2001/HITSZ-OpenCS<br></code></pre></div></td></tr></table></figure><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><p>现在对本地仓库查看 log，会发现除了 HEAD、main 这些原有的指针，还多了 <code>origin/</code> 的字样，这是<strong>远程仓库分支</strong>的默认标识。</p><p>这些远程分支与本地分支<strong>并存</strong>，反映了远程仓库在你上次和它「<strong>通信</strong>」时的状态，可以用前面的命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git branch --all  <span class="hljs-comment"># 参数 --all 代表所有分支，包括远程分支</span><br></code></pre></div></td></tr></table></figure><p>同样，也可以用 <code>git checkout</code> 切换到任意一个远程分支，只需要加上 <code>origin/</code>。</p><blockquote><p>远程分支有一个特别的属性，在你检出时自动进入一个「<strong>分离 HEAD 状态</strong>」。在此状态下，不会有 <code>HEAD -&gt; origin/main -&gt; node</code>，而是直接有 <code>HEAD -&gt; node</code>。这样做是因为 Git 不能直接在远程分支上进行操作，必须在本地操作后将 main 分支同步到远程，origin/main 才会发生变动。</p><p>一旦发生了分离 HEAD 并提交修改，下次 push 时本地仓库将与远程仓库发生分歧，可能需要 Rebase 操作。</p></blockquote><p>在实际操作中，我们<strong>只需要检出到本地分支</strong>即可。当克隆一个仓库时，它通常会自动地创建一个<strong>跟踪</strong> origin/main 的 main 分支。</p><p>但如果一个远程分支 origin/test 在本地没有对应分支 test，我们却要检出 test，该命令会自动复制一个「<strong>跟踪分支</strong>」作为本地分支。</p><h2 id="本地与远程的交互"><a href="#本地与远程的交互" class="headerlink" title="本地与远程的交互"></a>本地与远程的交互</h2><h3 id="下载-Fetch"><a href="#下载-Fetch" class="headerlink" title="下载 (Fetch)"></a>下载 (Fetch)</h3><p>所谓的拉取通常可由两个操作来完成，初学者往往分不清两个操作究竟分别做了什么：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git fetch  <span class="hljs-comment"># 下载--下载远程分⽀到本地</span><br>$ git pull   <span class="hljs-comment"># 拉取--使本地分支与远程分支同步</span><br></code></pre></div></td></tr></table></figure><p>下面我们用一组图来解释 <code>git fetch</code> 操作：</p><p><img src="/img/blog/Git-Note-3-images/git-fetch-1.png" alt="使用fetch前的仓库"></p><p>在这个例子中，虚线的结点代表远程仓库，它有两个我们本地仓库中没有的提交。而此时本地的远程分支 origin/main 还停留在你上次和它「<strong>通信</strong>」时的状态。如果此时使用 <code>git fetch</code>，则会出现：</p><p><img src="/img/blog/Git-Note-3-images/git-fetch-2.png" alt="使用fetch后的仓库"></p><p>可以发现，本地仓库<strong>缺失的结点</strong> C2 和 C3 被<strong>下载</strong>到了本地仓库，同时<strong>远程分支</strong> origin/main 也被更新，反映到了这一下载，但是<strong>本地分支</strong> main 依旧不变！</p><p>因此，我们可以知道：<code>git fetch</code> 并不会改变本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上原有的文件使其与远程「<strong>同步</strong>」，它只是将「同步」这一操作所需要的数据都下载下来了。</p><h3 id="拉取-Pull"><a href="#拉取-Pull" class="headerlink" title="拉取 (Pull)"></a>拉取 (Pull)</h3><p>那么，如何将这些数据真正完成「同步」呢？实际上有很多方法，上一节提到的 <code>git merge origin/main</code> 和 <code>git rebase origin/main</code> 等命令都可实现。</p><p>实际上，由于<strong>先抓取更新再合并到本地分支</strong>这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 <code>git pull</code>。</p><p>这里我们先用一个<strong>分叉</strong>的例子来演示：</p><p><img src="/img/blog/Git-Note-3-images/git-pull-1.png" alt="使用pull前的仓库"></p><p><strong>分叉</strong> (Branch Diverged) 是由于不同开发者进行了<strong>时空错位</strong>的提交导致的。观察该图，我们可以猜测本地开发者是在 C1 时刻克隆的仓库，并再克隆后完成了一次 C2 提交，而与此同时，另一个开发者在远程完成了 C3 提交。</p><p>此时如果想提交代码到远程，会提示 main 分支发生了<strong>分歧</strong>——因为远程仓库包含了本地尚不存在的结点，无法通过<strong>快速前移</strong>直接合并。Git 会提示你先将远程仓库拉取到本地解决分叉。</p><p><img src="/img/blog/Git-Note-3-images/git-pull-2.png" alt="使用pull后的仓库"></p><p>可以看到，<code>git pull</code> 其实就是 <code>git fetch</code> 和 <code>git merge origin/main</code> 两个指令的缩写。</p><p>需要注意的是，如果此时 C2 和 C3 有<strong>冲突</strong>，则 <code>git pull</code> 不完全执行，需要<strong>手动维护</strong>后再 merge，这个维护的过程对另一开发者是不可见的。</p><blockquote><p>在实际操作中，我们偶尔会用 <code>git fetch</code> 和 <code>git rebase origin/main</code> 来避免一个不必要的合并。 </p></blockquote><h3 id="推送-Push"><a href="#推送-Push" class="headerlink" title="推送 (Push)"></a>推送 (Push)</h3><p>相比于拉取，推送操作就尤为简单：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git push<br></code></pre></div></td></tr></table></figure><p>如果无分歧发生，远程仓库将会接收本地新增的结点，而远程仓库中的 main 也会指向本地仓库中 main 的位置。此外，本地仓库的远程分支 origin/main，会在这次「<strong>通信</strong>」的过程中，也移动到本地 main 的位置。</p><p>再回顾一下上面的<strong>分叉</strong>的例子，如果我们已经 merge 解决了冲突，这时再用 <code>git push</code> 则会有：</p><p><img src="/img/blog/Git-Note-3-images/git-push-1.png" alt="分叉的第一种解决方案"></p><p>可以看到，远程仓库清楚地记录了这次 merge 的历程！</p><p>而如果我们用 <code>git fetch</code> 和 <code>git rebase origin/main</code> 的组合（虽然很繁琐），但是远程仓库历史将变得十分整洁，并且能清楚地体现<strong>提交顺序</strong>。</p><p><img src="/img/blog/Git-Note-3-images/git-push-2.png" alt="分叉的第二种解决方案"></p><h3 id="Push-的参数"><a href="#Push-的参数" class="headerlink" title="Push 的参数"></a>Push 的参数</h3><p>上文介绍了最简单的 Push 命令，但这个命令看似简单，实际上却是最「模糊」的，很容易出现报错。完整的 Push 指令应该是：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;  <span class="hljs-comment"># 冒号前后无空格</span><br><span class="hljs-comment"># 例如：</span><br>$ git push origin main:<span class="hljs-built_in">test</span>  <span class="hljs-comment"># 将本地 mian 推送到 origin 的 test</span><br></code></pre></div></td></tr></table></figure><p>这个命令显式地指出了<strong>远程仓库名</strong>，如果只关联了一个远程，这个参数就可以<strong>缺省</strong>。但是如果关联了多个仓库（如 GitHub 和 Gitee），则必须用这个参数指明。</p><p>此外，它还指出了本地分支及其映射的<strong>上游分支</strong>，该命令可以用于不同名分支的推送，但实际工程中我们倾向于用本地远程<strong>同名分支</strong>（避免分歧），因此命令可以简化为：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git push origin <span class="hljs-built_in">test</span>  <span class="hljs-comment"># 将本地 test 推送到 origin 的 test</span><br></code></pre></div></td></tr></table></figure><p>但是，如果远程仓库 origin 没有一个同名的 test 分支，又会报错，此时我们需要为 test 建立上游分支，并将其<strong>跟踪绑定</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git push --set-upstream origin <span class="hljs-built_in">test</span> <span class="hljs-comment"># 推送同时绑定上游分支</span><br>$ git push -u origin <span class="hljs-built_in">test</span>  <span class="hljs-comment"># 参数 -u 为上述命令的缩写</span><br></code></pre></div></td></tr></table></figure><p>注意，一次 Push 默认<strong>只推送一个分支</strong>，因此如果不加分支名，会默认推送当前 HEAD 所在的分支。因此指令还可以逐步缺省：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git push -u origin  <span class="hljs-comment"># 表示将 当前分支 推送并绑定 同名上游分支</span><br>$ git push origin  <span class="hljs-comment"># 表示将 当前分支 推送 到 同名上游分支（需先绑定)</span><br>$ git push  <span class="hljs-comment"># 表示将 当前分支 推送 到 &lt;默认远程&gt;/同名分支（需先绑定)</span><br></code></pre></div></td></tr></table></figure><p>最后一条指令就是我们最早提及的推送命令，它需要满足：</p><ol><li>只有一个远程仓库；或者有多个仓库，但用 <code>-u</code> 绑定其中一个。</li><li>只有一条分支；或者有多条分支，但当前分支与上游分支同名并绑定。</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习笔记 #2 本地仓库使用</title>
    <link href="/2021/08/31/Git-Note-2/"/>
    <url>/2021/08/31/Git-Note-2/</url>
    
    <content type="html"><![CDATA[<p>接上文，本文在命令行的基础上介绍了常用指令的在<strong>本地的使用情景</strong>。</p><p>本文大部分内容参考了 RCY 同学的教程，部分参考了 <a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰教程-Git</a>，<a href="https://www.runoob.com/git/git-tutorial.html">菜鸟教程-Git</a>，以及 Git 官网文档 <a href="https://git-scm.com/doc">Git-Documentation</a>。</p><h2 id="本地的-Git"><a href="#本地的-Git" class="headerlink" title="本地的 Git"></a>本地的 Git</h2><h3 id="预先准备"><a href="#预先准备" class="headerlink" title="预先准备"></a>预先准备</h3><p>在正式的操作前，你需要先配置你的用户信息，这件事情通常在你的机器上只需要干一次即可，因为我们使用了全局配置。在任意⼀个目录打开你的终端，配置你的用户名和邮箱：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git config --global user.name &lt;username&gt; <span class="hljs-comment"># 替换为 GitHub 用户名</span><br>$ git config --global user.email &lt;email&gt;   <span class="hljs-comment"># 替换为绑定的邮箱</span><br><span class="hljs-comment"># username 中如果有空格，需要加双引号</span><br></code></pre></div></td></tr></table></figure><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>在想用 Git 管理的项目路径下右键进入 Bash 终端，然后将当前目录<strong>初始化</strong>为 Git 仓库。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git init<br></code></pre></div></td></tr></table></figure><p>手动新建一个文件，随便写点什么，譬如一个 hello.md，此时文件存在于工作区。下面将其跟踪并提交：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git add hello.md      <span class="hljs-comment"># 如果有更多文件，也可直接追加在后面</span><br>$ git commit -m <span class="hljs-string">&quot;Init&quot;</span>  <span class="hljs-comment"># -m: 表示 message，备注本次提交信息</span><br></code></pre></div></td></tr></table></figure><p>注意到，add  后面是<strong>文件名</strong>，也可以是<strong>目录</strong>、<strong>通配符</strong>，因此也支持以下写法：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git add .          <span class="hljs-comment"># 相对路径中 . 表示当前目录，因此这一选项会添加当前目录下所有文件</span><br>$ git add *.cpp   <span class="hljs-comment"># * 代表任意字符串，所有 .cpp后缀的文件被添加</span><br>$ git add <span class="hljs-built_in">test</span>?.cpp  <span class="hljs-comment"># ? 代表单个字符，不得为空，因此如 test1.cpp 将被添加，而 test.cpp 等不会</span><br>$ git add dir/   <span class="hljs-comment"># 添加路径下的 d 文件夹内全部文件， / 有没有皆可</span><br></code></pre></div></td></tr></table></figure><p>此外，为了体现三个区，我们可以使用一些指令来对比：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git status         <span class="hljs-comment"># 查看工作区、暂存区的文件，一般前者是红色，后者是绿色</span><br>$ git diff           <span class="hljs-comment"># 查看工作区和暂存区的差异，适用于暂存后又修改的内容</span><br>$ git diff --cached  <span class="hljs-comment"># 查看暂存区与 Git 仓库的差异，适用于提交前查看</span><br>$ git diff HEAD      <span class="hljs-comment"># 同时查看其他两个区和 Git 仓库的差异</span><br></code></pre></div></td></tr></table></figure><p><img src="/img/blog/Git-Note-2-images/git-diff.jpg" alt="Diff用法图解"></p><blockquote><p>在工程中，通常我们不用命令行查看差异，而是用 VSCode、GitHub Desktop、GitLab 等可视化工具。</p></blockquote><p>如果对于已暂存的文件后悔了，也可以取消暂存：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git reset &lt;filename&gt;  <span class="hljs-comment"># 对于该命令，如果不带参数则会清空暂存区</span><br>$ git restore --stage &lt;filename&gt;<br></code></pre></div></td></tr></table></figure><p>在完成了几次提交后，可以查看提交历史：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span><br></code></pre></div></td></tr></table></figure><p>提交历史中，每个提交记录都有对应的 commit hash 值，唯一标识了这次提交，这是 Git 用 <code>SHA-1 hash</code> 生成的加密字符串。</p><p>注：如果 log 比较长或者窗口比较小，这会触发「<strong>导航</strong>」模式，很多人第⼀次见到可能不知所措，不会退出该页面，此时可以：</p><ul><li>上下键移动或 Page Up / Down 翻页；</li><li>输入 <code>\</code> 接字符来全局查找 ；</li><li>输入 <code>q</code> 退出，与其他系统中的导航模式类似；</li><li>其他操作可以通过查询关键字「Linux less 导航」来查到。</li></ul><h2 id="分支-Branch"><a href="#分支-Branch" class="headerlink" title="分支 (Branch)"></a>分支 (Branch)</h2><p>有了前面的知识，我们已经在脑海中想象⼀副快照变更图了，本节中我们将快照称作「<strong>结点</strong>」，若干结点组织成了<strong>版本树</strong>——Git 本身正是使用了红黑树对结点进行高效管理。</p><blockquote><p>以下内容强烈推荐结合 <a href="https://learngitbranching.js.org/?locale=zh_CN">Git 分支在线教程</a> 来学习！</p></blockquote><p>目前我们的结点树基本是串行的（除了回退、重新提交会导致<strong>分叉</strong>），那么所谓的并行开发如何体现呢？</p><p>注意到了反复有⼀个单词 main 出现在命令行，这即是 Git 默认的分支：<strong>主分支</strong>（旧版本叫 master）。main 即是这个分支的名字，也是一个<strong>指针</strong>，指向了该分支的最新结点。</p><p>和它⼀起的还有⼀个单词 HEAD，这表示<strong>头指针</strong>，指向<strong>当前所处</strong>的结点。在你做分支相关的操作前，会有 <code>HEAD -&gt; main -&gt; 最新结点</code>，直到你将它们分开。</p><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>与初始化仓库类似，创建分支也很方便：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git branch <span class="hljs-built_in">test</span>  <span class="hljs-comment"># 创建⼀个名为 test 的分⽀</span><br></code></pre></div></td></tr></table></figure><p>注意：创建完后分支的即会指向当前所在的结点，因此当前最新结点同时被 main、test、HEAD 指向，即 <code>HEAD -&gt; main(test) -&gt; 最新结点</code>。</p><p>对于已有的分支，也可以通过以下命令查看、切换：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git branch <span class="hljs-comment"># 查看本地分支，带 * 的为 HEAD 指向的当前分支</span><br>$ git checkout <span class="hljs-built_in">test</span>  <span class="hljs-comment"># 检出，表示切换到 test 分支</span><br><br><span class="hljs-comment"># 上述的创建、切换操作也可以被缩减为一步操作</span><br>$ git checkout -b <span class="hljs-built_in">test</span> <span class="hljs-comment"># 创建⼀个名为 test 的分⽀并且切换过去</span><br></code></pre></div></td></tr></table></figure><p>切换分支后，可以看到出现在命令行右侧的 main 已经变成了 test。查看 log 也可发现 <code>HEAD -&gt; test(main) -&gt; 最新结点</code>。</p><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>如果此时我们已经在不同的分支提交了不同修改 C2 和 C3，那么如何将分支合并到一起，使得并行开发结果汇总呢？</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git checkout main  <span class="hljs-comment"># 切换到 main 分⽀</span><br>$ git merge <span class="hljs-built_in">test</span>     <span class="hljs-comment"># 让 main 分⽀合并 test 分⽀的结点</span><br></code></pre></div></td></tr></table></figure><p>对于分支的合并，Git 有专门的<strong>图形化输出</strong>命令来进行查看版本树（也可以用其他可视化工具）：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --graph --oneline --all<br><span class="hljs-comment"># oneline 表示用行来显示记录，最上方的是最新的提交</span><br><span class="hljs-comment"># all 表示显示所有分支，如果没有则只显示当前分支及其祖先</span><br><br><span class="hljs-comment"># 当然，还有其他许多参数可以美化版本树，这里贴一个大神的版本</span><br>$ git <span class="hljs-built_in">log</span> --graph --all --pretty=format:<span class="hljs-string">&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27;</span> --abbrev-commit --date=relative<br></code></pre></div></td></tr></table></figure><p>为展示方便，这里使用在线教程里的图例：</p><p><img src="/img/blog/Git-Note-2-images/git-merge-1.png" alt="main分支合并test分支"></p><p>可以看到，合并后产生了一个新结点 C4，该结点具有<strong>双父结点</strong>，指向原来的 C2 和 C3。需要注意的是，该结点属于 main 分支，是 main 分支的最新结点（被指针 main 所指），而 test 仍指向旧的 C2。</p><p>如果要把 test 分支也<strong>同步</strong>到新结点，只需要让 test 分支合并 C4，也就是合并<strong>当前</strong>的 main 分支：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git checkout <span class="hljs-built_in">test</span>  <span class="hljs-comment"># 切换到 test 分⽀</span><br>$ git merge main     <span class="hljs-comment"># 让 test 分⽀合并 main 分⽀的结点</span><br></code></pre></div></td></tr></table></figure><p>而由于 main 分支的最新结点 C4 继承自 C2，此时的 Git 不会有任何操作，只是简单地将指针 test 移动到指针 main 所在位置，即<strong>快速前移</strong>（fast-forward）：</p><p><img src="/img/blog/Git-Note-2-images/git-merge-2.png" alt="test分支合并main分支"></p><blockquote><p>多数情况下，我们会先用<strong>主分支合并从分支</strong>，如果之后需要再从分支继续开发，才会把<strong>从分支快速前移</strong>！</p></blockquote><h3 id="冲突的合并"><a href="#冲突的合并" class="headerlink" title="冲突的合并"></a>冲突的合并</h3><p>如果 C2 和 C3 修改的代码不在同一文件的同一处，上述的 merge 是没有问题的，但是一旦发生冲突，<code>git merge test</code> 命令时就会提示错误。</p><p>此时如果我们用 <code>git status</code> 查看，会发现<strong>工作区</strong>里有一个新的状态「<strong>未合并的路径</strong>」，里面就是冲突的文件。打开该文件，会发现 Git 已经在里面标记出了双方修改的内容（用 VSCode 等 IDE 将看得更清楚）。</p><p>而我们只需要<strong>手动维护</strong>冲突，将该文件手动加入暂存区，最后再提交，就会生成一个新的结点，该结点无异于直接使用 <code>git merge test</code> 命令得到的。</p><h3 id="变基-Rebase"><a href="#变基-Rebase" class="headerlink" title="变基 (Rebase)"></a>变基 (Rebase)</h3><p>一个来回穿插的版本树是有点凌乱的，此时不得不提到第二种合并分支的办法：变基 (rebase) 操作。Rebase 实际上就是取出<strong>从分支</strong>的提交记录，「<strong>复制</strong>」它们，然后在<strong>主分支</strong>逐个的放下去。</p><p>Rebase 的优势就是可以创造更<strong>线性</strong>的提交历史。如果两个分支没有冲突，如上文提到的第一种情况，直接 Merge 会出现一个新的结点（实际上该结点并没有做出实质的修改，反而使版本树变得冗长）。</p><p>此时如果我们用 Rebase 操作，则可以简化版本树：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git checkout <span class="hljs-built_in">test</span>  <span class="hljs-comment"># 切换到 test 分⽀</span><br>$ git rebase main    <span class="hljs-comment"># 让 test 分⽀以 main 为基，因此 test 成为 main 的后代</span><br></code></pre></div></td></tr></table></figure><blockquote><p>注意，Rebase 操作通常是让<strong>从分支变基到主分支</strong>，这与 Merge 操作是相反的！</p></blockquote><p><img src="/img/blog/Git-Note-2-images/git-rebase.png" alt="test分支变基到main"></p><p>观察该图，我们可以发现 test 分支上的工作在 main 的最顶端，同时我们也得到了一个更线性的提交序列。</p><p>而提交记录 C2 依然存在（树上那个半透明的节点），而 C2’ 是我们 Rebase 到 main 分支上的 C2 的副本，它们具有不同的 hash 值，可以通过 log 查看。</p><p>之后我们也可以通过类似的操作，把 main <strong>快速前移</strong>到最新的结点：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git checkout main  <span class="hljs-comment"># 切换到 main 分⽀</span><br>$ git rebase <span class="hljs-built_in">test</span>    <span class="hljs-comment"># 让 main 分⽀以 test 为基，快速前移</span><br><span class="hljs-comment"># 当然，z也可以用前面的 merge 操作</span><br></code></pre></div></td></tr></table></figure><blockquote><p>Rebase 操作在没有冲突时将非常舒适，可以避免没有意义的合并结点（尤其是涉及到远程仓库时），但是一旦发生了<strong>冲突</strong>，操作将十分繁琐！这里不再赘述，具体工程中如果遇到了请根据 Git 的自动提示逐步操作。</p></blockquote><p>而对于 Rebase 后的从分支上的结点，就变成了所谓的「<strong>悬垂结点</strong>」，这些结点的访问将十分复杂。此外，如果这个从分支被<strong>废弃</strong>，我们也可以用以下指令将其删去：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git branch -d <span class="hljs-built_in">test</span>  <span class="hljs-comment"># 删除名为 test 的分⽀，用于合并后废弃的分支</span><br></code></pre></div></td></tr></table></figure><h2 id="分叉-Branch-Diverged"><a href="#分叉-Branch-Diverged" class="headerlink" title="分叉 (Branch Diverged)"></a>分叉 (Branch Diverged)</h2><p>分叉是分支的一种特殊情况，往往是因为某些「不友好」操作而产生，最终被废弃掉。对于<strong>单人操作</strong>的仓库，其产生原因可能是：</p><ul><li>Reset 后旧分支：版本回退后重新提交，这种情况下往往是要弃用旧分支。但如果旧的分支仍有需要保留的更改，则需要 Cherry-Pick 等操作。</li><li>Rebase 后从分支：上文介绍到，Rebase 将创造更线性的主分支，但这样做的代价是从分支将被废弃，成为一个无用的分叉。</li></ul><p>上述情形的发生往往可以人为进行控制，而对于<strong>多人操作</strong>的仓库，如果不同开发者同时对一个结点进行了更改，将会造成「不可控」的分叉，具体情形及解决方法将在下一节介绍。</p>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习笔记 #1 基础知识介绍</title>
    <link href="/2021/08/28/Git-Note-1/"/>
    <url>/2021/08/28/Git-Note-1/</url>
    
    <content type="html"><![CDATA[<p>无意中发现了清华贵系科协的暑培项目，内容都十分贴合计算机系学生的学习需求，正好下学期有「软件工程」课，就决定先把 Git 入门了。</p><p>本文大部分内容参考了 RCY 同学的教程，部分参考了 <a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰教程-Git</a>，<a href="https://www.runoob.com/git/git-tutorial.html">菜鸟教程-Git</a>，以及 Git 官网文档 <a href="https://git-scm.com/doc">Git-Documentation</a>。</p><h2 id="版本控制软件"><a href="#版本控制软件" class="headerlink" title="版本控制软件"></a>版本控制软件</h2><p>版本控制是合作开发、工程项目中必要的手段，考虑以下情况：</p><ul><li>需求模糊：不得不准备两种方案。</li><li>伟大尝试：如果尝试失败，可以回到旧的版本。</li><li>组员弃坑：删除掉难以开发的代码。</li><li>并行开发：需要合并代码时，人工比对容易遗漏。</li></ul><p>为了让这样繁琐的工作自动化，就有了以下的工具：</p><ul><li>Git：行业内最为流行的版本控制软件，采用<strong>分布式</strong>。</li><li>SVN(Subversion)：较早期的版本控制软件，采用<strong>集中式</strong>。</li></ul><h2 id="关于-Git"><a href="#关于-Git" class="headerlink" title="关于 Git"></a>关于 Git</h2><p>事实上，Git 仅在过去十年里，就以极快地速度占据了市场。与 SVN 的集中式不同的是，Git 采用的分布式，除了少数的交互步骤外，版本控制操作、历史记录都在本地，这保证了它极高的操作效率。</p><blockquote><p>所谓集中式， 即所有人都把代码放到一个远程的服务器，要写代码时将远程资源拉取到本地，用一个同一的仓库来实现协同。</p><p>所谓分布式，即每个人都有自己的仓库，每个仓库都可能存放着最新的代码，需要修改时直接在本地修改（即使断网），需要同步时再与远程仓库交互。</p></blockquote><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>多数版本控制软件是基于<strong>差异</strong>的控制，即不同版本间记录的是文本的「<strong>变化</strong>」，版本切换时再根据 delta 前进和后退。</p><p><img src="/img/blog/Git-Note-1-images/deltas.png" alt="Delta-based"></p><p>而 Git 采用的是「<strong>快照</strong>」的方法，对每个版本记录全部文件快照并建立索引（特别地，没有变动的文件只是创建一个<strong>链接</strong>指向之前的快照）。</p><p><img src="/img/blog/Git-Note-1-images/snapshots.png" alt="Snapshot-based"></p><p>这样做的好处是，Git <strong>切换版本和分支</strong>的速度远快于第一种模式。因为 Delta-based 模式下，切换版本相当于一个线性遍历的过程，而 Git 相当于是在文件系统层面做了一个哈希索引。</p><p>此外，快照并不是以整个文件为单位的，否则修改一行就需要增量整个文件的大小，在 Git 中是以<strong>行</strong>为单位进行 diff 的。因此对于二进制文件，Git 的功能就相对较差。</p><h3 id="基本状态"><a href="#基本状态" class="headerlink" title="基本状态"></a>基本状态</h3><p>Git 中用三个状态来区分文件，生成版本：</p><ul><li>已修改 (modified)：你的文件<strong>修改</strong>了，但是没和 Git 发生关系，如同没有 Git 存在⼀般。</li><li>已暂存 (staged)：已修改文件被<strong>标记</strong>后的状态，下次提交 (commit) 时将为它生成快照，多数情况下处于暂存态后紧接着便被提交。</li><li>已提交 (committed)：已经安全地保存到<strong>本地数据库</strong>的数据，通常来说不手动清理则不会丢失。</li></ul><p>这三个状态对应到了 Git 的三个区域：工作区、暂存区、Git 仓库：</p><p><img src="/img/blog/Git-Note-1-images/areas.png" alt="三个区域"></p><p>如果修改了一个已暂存的文件，它会同时出现在工作区和暂存区两个区域，此时可以选择<strong>再次暂存</strong>，覆盖掉暂存区的文件；也可以选择<strong>恢复工作</strong>，撤销后来的修改，覆盖掉工作区的文件（但暂存区的仍然保留）。</p><p>因此，我们可以对这三个区域加以定义：</p><ul><li>工作区是可以直接看到的文件，包括已修改和未修改；</li><li>暂存区本身是个文件，记录了下次要提交（快照）的文件列表信息；</li><li>Git 仓库包含了数据库、元数据等，是 Git 最重要的部分，它的全部数据存储在项目根目录的 .git 路径下，其大小甚至会超过其他文件之和。</li></ul><h2 id="使用-Git"><a href="#使用-Git" class="headerlink" title="使用 Git"></a>使用 Git</h2><p>在官网的文档中有详细的介绍，这里仅介绍部分常用内容。</p><h3 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h3><p>Git 同时提供了 GUI 和 Bash 的操作方式，但图形界面功能不够齐全，同时容易误触造成无法逆转的文件改动。</p><p>使用命令行界面 (Command Line Interface) 意味着：</p><ul><li>几乎放弃鼠标功效，最大化键盘作用；</li><li>放弃炫酷的界面显示，用文本配合着色传递信息；</li><li>你所学的操作到了服务器上仍然能流畅使用。</li></ul><p>对 Windows 而言，cmd 、Power Shell、WSL、Git 都可以提供命令行界面，为了执行下列 Git 指令，需要使用 Git 提供的终端，在文件夹中右键选中 <code>Git Bash Here</code> 即可。</p><p>关于命令行界面，有这些常用快捷键：</p><ul><li><code>Tab</code>：实现对命令、参数或文件的内容补全。</li><li><code>Ctrl+C</code>：终止当前进程的运行，重获终端的控制权。</li><li><code>Ctrl+D</code>：结束键盘输入，即退出终端，相当于输入 <code>exit()</code>。</li><li><code>Ctrl+I</code>：清空当前终端中已有的内容，相当于输入 <code>clear</code>。</li><li><code>&lt;上下键&gt;</code>：翻看使用过的命令记录。</li><li><code>Shift+PgUp/PgDn</code>：翻页终端。</li><li><p><code>Ctrl/Shift+Ins</code> ：复制粘贴文本，有的系统下可用 <code>Ctrl+Shift+C/V</code>。</p></li><li><p><code>‘’</code> 和 <code>“”</code>：命令是以空格来作为间隔符的，参数中若存在空格，必须用<strong>引号</strong>括起来。</p></li></ul><p>一些在 Git 使用中会用到的 Shell 命令有：</p><ul><li><code>ls</code>：List，罗列当前文件夹下的<strong>文件和下级文件夹</strong>，并且会用颜色区分二者，如果用 <code>dir</code> 目录命令则无区分。</li><li><code>cd</code>：Change Directory，<strong>改变目录</strong>，这里再介绍一下路径的表示：<ul><li><code>.</code> 代表当前目录，也可代表当前目录下所有文件。</li><li><code>..</code> 代表上级目录，<code>cd ..</code> 即回退上级。</li><li><code>/</code> 代表盘符根目录，<code>cd /</code> 即切换到根目录。</li><li>输入当前目录下的文件夹名，即可进入该文件夹，可以用 <code>Tab</code> 补全。</li></ul></li><li><code>mkdir</code>：Make Directory，在当前目录下<strong>新建文件夹</strong>。</li><li><code>touch</code>：<strong>新建空文件</strong>或改变已有文件的时间戳属性。</li><li><code>echo</code>：Echo Protocol（应答协议），强制显示文字，直接使用会将字符串显示在终端。<ul><li>利用该命令也可新建文件，如：<code>echo ‘test’ &gt; 1.txt</code>，强制输出内容到一个记事本文件，如果没有该文件则强制创建一个。</li><li>此外，新建文件还可以用其他<strong>重定向</strong>命令辅助完成，如<code>cd . &gt; 1.txt</code>，<code>type NUL &gt; 1.txt</code>，<code>copy NUL &gt; 1.txt</code>。</li></ul></li></ul><h3 id="Git-基本指令"><a href="#Git-基本指令" class="headerlink" title="Git 基本指令"></a>Git 基本指令</h3><p>这里先列举一些基本指令，它们的使用格式基本都是 <code>git &lt;instruction&gt; &lt;other-params-if-needed&gt;</code> 。以下列举的都是 <code>&lt;instruction&gt;</code> 项，对应的参数在后面介绍。</p><p>本地基本操作：</p><ul><li><code>init</code>：告诉 Git 你要让它接管这个文件夹。</li><li><code>config</code>：做相关配置，告诉 Git 你是谁。</li><li><code>add</code>：文件从<strong>工作区</strong>转到<strong>暂存区</strong>，即「跟踪」。</li><li><code>commit</code>：文件从<strong>暂存区</strong>转到 Git <strong>仓库</strong>，即「提交」。</li></ul><p>远程基本操作：</p><ul><li><code>clone</code>：克隆远程仓库到本地。</li><li><code>push</code>：本地数据库同步到远程，即「推送」。</li><li><code>pull</code>：远程数据库同步到本地，即「拉取」。</li></ul><p>分支操作：</p><ul><li><code>branch</code>：分支基本操作。</li><li><code>checkout</code>：分支、版本的切换。</li></ul><p>状态切换：</p><ul><li><code>stash</code>：⼀个栈式额外存储区。</li><li><code>reset</code>：版本回退。</li></ul><p>信息获取：</p><ul><li><code>log</code>：查看记录。</li><li><code>reflog</code>：查看操作记录（常用于 reset 后撤销操作时寻找版本号）</li><li><code>status</code>：查看<strong>已修改</strong>和<strong>已暂存</strong>的文件。</li><li><code>diff</code>：查看不同 <strong>区/版本</strong> 间的差异。</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数理逻辑应试笔记</title>
    <link href="/2021/08/27/Mathematical-Logic/"/>
    <url>/2021/08/27/Mathematical-Logic/</url>
    
    <content type="html"><![CDATA[<p>该笔记是本人于哈尔滨工业大学（深圳）2021 年春季学期「数理逻辑」课程的笔记，最终课程成绩是满分。授课教师为任世军，是本部经验丰富的老教师。</p><p>由于笔记是在考前复习时才逐渐整理的，笔记内容偏<strong>应试风格</strong>，标题顺序也是按照哈工大「数理逻辑」课程一贯的出题模板来的，涵盖了课程所学，主要包括：命题逻辑、三大系统中定理的证明、谓词逻辑。</p><h2 id="命题逻辑部分"><a href="#命题逻辑部分" class="headerlink" title="命题逻辑部分"></a>命题逻辑部分</h2><h3 id="求-主-析取-合取范式"><a href="#求-主-析取-合取范式" class="headerlink" title="求(主)析取/合取范式"></a>求(主)析取/合取范式</h3><p>一般会涉及到三个原子命题，唯一方法——列真值表。</p><p>列真值表的顺序可以依照语法分析树。</p><p>主合取看 0，主析取看 1，直接写。列真值表一定要<strong>反复检查细节</strong>。蕴含的前后件不要看反了。</p><h3 id="用完备联结词组表示公式"><a href="#用完备联结词组表示公式" class="headerlink" title="用完备联结词组表示公式"></a>用完备联结词组表示公式</h3><p>通常最终结果要化为与非式、或非式。</p><p>先把原式子中的「蕴含、等价」全换成「与、或、非」。（<strong>可以用等价式化简，但没必要，除非很明显的吸收律</strong>）</p><ul><li><strong>与非</strong>：</li></ul><p>用德摩根律把 $\lor$ 全消掉，再把 $\land$ 用</p><script type="math/tex; mode=display">p\land q\Leftrightarrow \lnot \left( p\uparrow q \right)</script><p>替换，再把所有的 $\lnot$ 用下式替换，注意此时 p 可能是个很长的式子。</p><script type="math/tex; mode=display">\lnot p\Leftrightarrow p\uparrow p</script><ul><li><strong>或非</strong>：</li></ul><p>同理，也是消掉另一个符号，再把或替换了，再替换非。</p><h3 id="判断逻辑蕴含-逻辑等价的正确性"><a href="#判断逻辑蕴含-逻辑等价的正确性" class="headerlink" title="判断逻辑蕴含/逻辑等价的正确性"></a>判断逻辑蕴含/逻辑等价的正确性</h3><ol><li><strong>逻辑蕴含</strong>，一般前提会有多个</li></ol><p>通常做法是，给前提均指派为真，利用公式法，推出一系列公式，然后推得右边的公式的值恒为 1，则<strong>成立</strong>。</p><p>如果推不到右边，可以先假设右边为 0（反证法），推出左边的值可以均为 1，则<strong>不成立</strong>。</p><p><strong>注意</strong>：假设右边为 1 没用，不充分。</p><ol><li><strong>逻辑等价</strong>，一般是一对一，两边都比较长</li></ol><p>理论上可以用<strong>真值表</strong>，但是语法分析树太长了。</p><p>如果可以一眼判断出<strong>不成立</strong>，那么枚举一个反例也行。</p><p>通常做法是，两边利用公式法化简，最后推出的赋值式相等，则对于任意的指派 $v$，都有 $A^v = B^v$，故成立。</p><p>化简过程中，有一些较长的非、蕴含符号可以替换成与非，如：</p><script type="math/tex; mode=display">\begin{aligned}\lnot p\rightarrow q\,\,&\text{换成 } p\lor q\\\lnot \left( p\rightarrow \lnot q \right) \,\,&\text{换成 } p\land q\end{aligned}</script><p>避免列赋值式太长。</p><p>注意：化简到最后可能形式上不相等，这时候可以两个式子<strong>联立消项</strong>，看最后是不是<strong>永真式</strong>，如果不是，同样可以举反例（举反例不好直接想到，因此还是要推理，可以先用 PC 的方法变形看看）。</p><h2 id="PC-中定理的证明"><a href="#PC-中定理的证明" class="headerlink" title="PC 中定理的证明"></a>PC 中定理的证明</h2><p>依次使用以下方法。</p><h3 id="1-逆向推理法（直接法）"><a href="#1-逆向推理法（直接法）" class="headerlink" title="1 逆向推理法（直接法）"></a>1 逆向推理法（直接法）</h3><p>对待证明定理进行等价转化，转变成熟悉的形式。常用工具：</p><ul><li>加前件定理3：去相同前件</li><li>加后件定理4：去相同后件</li><li>逆否转换：四种情况</li><li><p>前件互换定理2：前件移到里面后</p></li><li><p>公理2：提出前件</p></li><li>补前件定理：去单个前件，只需证出后件就可以</li><li>三段论定理8：需要多次加前件、后件时</li></ul><p>例题：</p><ol><li><strong>二难推理</strong>（后面发现用定理18更好做）</li></ol><script type="math/tex; mode=display">\vdash \left( A\rightarrow C \right) \rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( A\lor B \right) \rightarrow C \right) \right)</script><p>观察形式，发现三项都有共同后件 $C$，则三项全取逆否</p><script type="math/tex; mode=display">\left( \lnot C\rightarrow \lnot A \right) \rightarrow \left( \left( \lnot C\rightarrow \lnot B \right) \rightarrow \left( \lnot C\rightarrow \lnot \left( \left( A\lor B \right) \right) \right) \right)</script><p>利用公理 2 及 加前件定理可以去掉前件 $\lnot C$</p><script type="math/tex; mode=display">\lnot A\rightarrow \left( \lnot B\rightarrow \lnot \left( A\lor B \right) \right)</script><p>再用逆否转换，前件互换等定理即可逆向</p><p><strong>类似题</strong>：</p><script type="math/tex; mode=display">\vdash \left( A\rightarrow C \right) \rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( \left( A\rightarrow B \right) \rightarrow B \right) \rightarrow C \right) \right)</script><p>也必须用逆否来做。</p><ol><li><strong>作业题5</strong>（常规做法是演绎定理，其他都很麻烦）</li></ol><script type="math/tex; mode=display">\vdash \left( A\rightarrow \left( B\rightarrow C \right) \right) \rightarrow \left( \left( C\rightarrow D \right) \rightarrow \left( A\rightarrow \left( B\rightarrow D \right) \right) \right)</script><p>先前件互换可使得后件两项都含 $A$</p><script type="math/tex; mode=display">\left( C\rightarrow D \right) \rightarrow \left( \left( A\rightarrow \left( B\rightarrow C \right) \right) \rightarrow \left( A\rightarrow \left( B\rightarrow D \right) \right) \right) \,\,</script><p>发现去掉前件 $A$ 后还可以去掉前件 $B$</p><p>但是再用一次前件互换即可得到定理4的形式</p><script type="math/tex; mode=display">\left( C\rightarrow D \right) \rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( B\rightarrow D \right) \right)</script><ol><li><strong>砍头操作</strong></li></ol><p>砍头操作有两种办法：将</p><script type="math/tex; mode=display">\left( \lnot A\rightarrow B \right) \rightarrow \left( \left( \lnot A\rightarrow \lnot B \right) \rightarrow A \right)</script><p>变成</p><script type="math/tex; mode=display">B\rightarrow \left( \left( \lnot A\rightarrow \lnot B \right) \rightarrow A \right)</script><p><strong>方法一</strong>：先添前件（用公理1再分离）变成</p><script type="math/tex; mode=display">B\rightarrow \left( \left( \lnot A\rightarrow B \right) \rightarrow \left( \left( \lnot A\rightarrow \lnot B \right) \rightarrow A \right) \right)</script><p>再用公理2分离，前件是公理1的形式，后件自然成立，总计要4行</p><p><strong>方法二</strong>：直接用三段论定理8，因为</p><script type="math/tex; mode=display">B\rightarrow \left( \lnot A\rightarrow B \right)</script><p>显然成立，用三段论定理8接上，只需要2行，但是要分条件（有可能不允许使用定理8，如作业题PC1）</p><ol><li><strong>反公理2</strong>（19 年试卷的答案，思路清奇，没用定理18）</li></ol><script type="math/tex; mode=display">\vdash \left( \left( A\rightarrow B \right) \rightarrow \left( A\rightarrow C \right) \right) \rightarrow \left( A\rightarrow \left( B\rightarrow C \right) \right)</script><p>一开始观察三项前件都有 $A$，以为可以用类似二难推理的办法做。</p><p>但是！注意到整体的形式是「两项推一项」，与二难推理不同，因此不能用公理2来提出前件，再去掉前件。</p><p>观察发现，后件 $A\to(B\to C)$ 可以用一次前件互换定理，得到</p><script type="math/tex; mode=display">\vdash \left( \left( A\rightarrow B \right) \rightarrow \left( A\rightarrow C \right) \right) \rightarrow \left( B\rightarrow \left( A\rightarrow C \right) \right)</script><p>此时有共同的后件，可以用加后件定理快速解决。</p><h3 id="2-利用定理18"><a href="#2-利用定理18" class="headerlink" title="2 利用定理18"></a>2 利用定理18</h3><p>定理18证明的简便性和方法1相近，尝试方法1失败后，若形式符合$(A \to B)\to C$，可以考虑定理18</p><p>将原式子拆成 $\lnot A \to C$ 和 $B \to C$ ，再用方法1</p><p>例题：</p><ol><li><strong>反公理2</strong>（书上用演绎定理证明，很简短）</li></ol><script type="math/tex; mode=display">\vdash \left( \left( A\rightarrow B \right) \rightarrow \left( A\rightarrow C \right) \right) \rightarrow \left( A\rightarrow \left( B\rightarrow C \right) \right)</script><p>如果看前两项，想用逆推的方法解决，但是发现加前件定理用不了，因为接不上。直接考虑定理18。</p><ul><li>拆成</li></ul><script type="math/tex; mode=display">\left( A\rightarrow C \right) \rightarrow \left( A\rightarrow \left( B\rightarrow C \right) \right)</script><p>只需前件互换，去掉后件即可证明。</p><ul><li>拆成</li></ul><script type="math/tex; mode=display">\lnot \left( A\rightarrow B \right) \rightarrow \left( A\rightarrow \left( B\rightarrow C \right) \right)</script><p>比较复杂，需要前件互换，<strong>再摘掉 A</strong></p><p>（<strong>注意：这一步可以不需要前件互换，只需用公理1+三段论，直接砍后件头</strong>）</p><p>（<strong>附注</strong>：砍后件头，倒过来书写时其实是加后件头，与前面的砍头操作不同）</p><script type="math/tex; mode=display">\lnot \left( A\rightarrow B \right) \rightarrow \left( B\rightarrow C \right)</script><p>然后再换前件，因为前面的 <strong>$\lnot$ 是在整体上的，必须要和单体进行一次逆否转换</strong></p><script type="math/tex; mode=display">B\rightarrow \left( \lnot \left( A\rightarrow B \right) \rightarrow C \right)</script><p>再对里面做逆否，此时 $\lnot$ 已经转移到单独的 $C$ 上了</p><script type="math/tex; mode=display">B\rightarrow \left( \lnot C\rightarrow \left( A\rightarrow B \right) \right)</script><p>需要前件互换，<strong>再摘掉 $\lnot C$</strong> </p><p>（<strong>注意：这一步可以不需要前件互换，只需用公理1+三段论，直接砍后件头</strong>）</p><ul><li>补充</li></ul><script type="math/tex; mode=display">\lnot \left( A\rightarrow B \right) \rightarrow \left( B\rightarrow C \right)</script><p>前面的 <strong>$\lnot$ 是在整体上的，还有另一种办法可以消去</strong></p><p>因为 $\lnot (A \to B)$ 可以推出 $A$ 或 $\lnot B$ ，利用<strong>三段论</strong>定理可以接上去。</p><p>此题可以用 $\lnot B$，转化后的形式是定理6。</p><ol><li><strong>二难推理</strong></li></ol><script type="math/tex; mode=display">\vdash \left( A\rightarrow C \right) \rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( A\lor B \right) \rightarrow C \right) \right)</script><p>二难推理系列的题目，比思维流更好的办法其实是定理18，并且套路十分明显。</p><ul><li>拆成</li></ul><script type="math/tex; mode=display">\lnot A\rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( A\lor B \right) \rightarrow C \right) \right)</script><p>首先第一部分，由于 $C$ 在后件的两个后件，此时用加后件定理可以轻松消去 $C$。</p><script type="math/tex; mode=display">\lnot A\rightarrow \left( \left( A\lor B \right) \rightarrow B \right)</script><p>再用一次前件互换定理，发现就是定理1。</p><ul><li>（<strong>这一步纯套路，每题都是一样</strong>）拆成</li></ul><script type="math/tex; mode=display">C\rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( A\lor B \right) \rightarrow C \right) \right)</script><p>此时不能直接用加后件了，否则最前面的  $C$ 消不掉。直接前件互换，</p><script type="math/tex; mode=display">\left( B\rightarrow C \right) \rightarrow \left( C\rightarrow \left( \left( A\lor B \right) \rightarrow C \right) \right)</script><p>发现后件是公理1，于是摘掉前件，成立。</p><p><strong>类似题</strong>：</p><script type="math/tex; mode=display">\vdash \left( A\rightarrow C \right) \rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( \left( A\rightarrow B \right) \rightarrow B \right) \rightarrow C \right) \right)</script><p>也可以用同样的套路秒做。</p><h3 id="3-反证法"><a href="#3-反证法" class="headerlink" title="3 反证法"></a>3 反证法</h3><p>前两种方法都想不出来的情况下考虑，书写过程会相对繁琐。</p><ol><li>基本方法</li></ol><p>假定原定理为0，按照依次将式子标上0和1，直到推出矛盾（一般会有多处，找容易的）。</p><p>证明时显而易见的（前几条）可以不用加注释，可以理解成真值表的体现。</p><p>后面的推理过程可以按标0和1的顺序来，通常都是由大后件的结论往前件找矛盾。</p><p><strong>最常使用：三段论定理</strong>，用于把 $\lnot P$ 接上去，最后才能转到矛盾。</p><ol><li>推演技巧</li></ol><p>最无脑的方法是把所有单项都用 $\lnot P$ 推出来，再进行排列组合出矛盾。</p><p>高级的方法是抓住「<strong>矛盾块</strong>」（通常是原式的一端），再把「<strong>另一个矛盾块</strong>」通过逆向推理法（直接法）证到原式的另一端，即可。</p><h3 id="4-演绎定理"><a href="#4-演绎定理" class="headerlink" title="4 演绎定理"></a>4 演绎定理</h3><p>没啥好说的，一般不给用，对三个以上变量比较友好，提取出所有前件后就可以用直接法证明。</p><h2 id="ND-中定理的证明"><a href="#ND-中定理的证明" class="headerlink" title="ND 中定理的证明"></a>ND 中定理的证明</h2><h3 id="思维流"><a href="#思维流" class="headerlink" title="思维流"></a>思维流</h3><p>本质是<strong>逆向推理法</strong>，逆推的同时可以注意左端项的逻辑规律（赋1，看矛盾）</p><p>结合常见形式及解决套路可以更快解决。</p><ol><li><strong>当右端项包含 $\lnot$ 时：</strong></li></ol><script type="math/tex; mode=display">\lnot A\land \lnot B\vdash \lnot \left( A\lor B \right)</script><p>用 $\lnot +$ 规则把右端项挪到左边时，要导出矛盾，往往这个矛盾是右端项的<strong>部分</strong>，如析取、合取的部分。</p><p>此时的惯常做法是将这两个矛盾合取，如 $A\land \lnot A$ ，这个式子必定为0，事实上左边此时的两个式子已经自相矛盾。</p><p>当然不一定要用 $A\land \lnot A$，因为左边矛盾的情况下，赋1可以推出很多对矛盾，只是这个最常见。</p><ol><li><strong>当左端项有 $\lor$ 时：</strong></li></ol><script type="math/tex; mode=display">\lnot A\lor \lnot B\vdash \lnot \left( A\land B \right)</script><p>充分利用析取，将其两项分别放到左端，用 $\in$ 规则把两项先推出来。</p><p>左端多出来的两项最终也需要消去。</p><ul><li>这就需要 $\lor-$ 规则，因此上面推出来的两式要最后导出到同一个目标，通常是$A\land \lnot A$，这类式子。</li><li>也有可能是需要 $\to +$ 规则，把小项拿到右边当前件。</li></ul><p><strong>注意</strong>：如果 $\lor$ 是含在某个大的式子里，也可以将小项直接拿到外面来推。</p><ol><li><strong>当右端项有 $\lor$ 时：</strong></li></ol><script type="math/tex; mode=display">\lnot \left( A\land B \right) \vdash \lnot A\lor \lnot B</script><p>一般可以用 $\lor -$ 简化，只需证一半，但是保留哪一半要根据左边的情况推理，即思维流。</p><p>但有时也不能上来就简化，因为左边的条件可能太宽泛了（太少了），因此可能要加上一些小项再看。</p><p>这时候常用的是 $-$ 规则。这也是最难用的一个规则。</p><ol><li><strong>当左端项有 $\land$ 时：</strong></li></ol><script type="math/tex; mode=display">A\land \left( {B}\lor {C} \right) \vdash \left( {A}\land {B} \right) \lor \left( {A}\land {C} \right)</script><p>利用 $\land -$ 规则，将两个子命题拆出来。</p><p>当然不能白拆，要和前几条综合起来用，往往时加入了很多项后，用这个来助攻。</p><ol><li><strong>当右端项有 $\land$ 时：</strong></li></ol><p>可能是要把两个细分都推出来。</p><script type="math/tex; mode=display">\lnot \left( {A}\lor {B} \right) \vdash \lnot {A}\land \lnot {B}</script><p>也可能是要整个推出，即生成未出现过的项，常用 $\lor-$ 规则。</p><script type="math/tex; mode=display">\left( A\land {B} \right) \lor \left( {A}\land {C} \right) \vdash {A}\land \left( {B}\lor {C} \right)</script><ol><li><strong>在右端生成从未出现过的项：</strong></li></ol><p>常用 $\lor-$ 规则，但是这种必须有理有据的推出，而且左端要含 $\lor$。</p><p>另一个方法是 $\lnot -$，矛盾可以推任意。</p><ul><li>通常的用法是：</li></ul><script type="math/tex; mode=display">\begin{aligned}XXX, A, \lnot A&\vdash A\\XXX, A, \lnot A&\vdash \lnot A\\XXX, A, \lnot A&\vdash B\end{aligned}</script><ul><li>然后再想办法消掉多出来的单项，如</li></ul><script type="math/tex; mode=display">XXX, \lnot A\vdash A\rightarrow B</script><ul><li>或者再利用 $\lor-$ ，二者结合，如</li></ul><script type="math/tex; mode=display">\begin{aligned}XXX, A, \lnot A&\vdash B\\XXX, A, B&\vdash B\\XXX, A&\vdash \lnot A\lor B\\XXX, A&\vdash B\end{aligned}</script><p>例：（需要用到两种引入方法）</p><script type="math/tex; mode=display">\left( A\lor B \right) \land \left( \lnot B\lor C \right) \vdash A\lor C</script><p>按照思维流推断，发现最开始可以引入 $B$，$\lnot B$ 的矛盾推任意。</p><p>而右端项的析取，一次只能推一半。</p><p>推一半的时候，还是需要引入新项，此时用 $\lor-$ ，因为左端项还有个析取（隐藏在合取中）可以用，将两个子项单独拿出来放到左边，即可推出。</p><ol><li><strong>当左端项有 $\to$ 时：</strong></li></ol><p>由于ND中没有分离规则，所以要利用好这个 $\to$ 需要先在左端加上前件，用两次 $\in$ 规则。</p><p>最后再用 $\to -$ 规则把后件推到右端。 </p><ol><li><strong>当左端项包含 $\lnot$ 时：</strong></li></ol><script type="math/tex; mode=display">\lnot ( A\to B ) \vdash A\land \lnot B</script><p>想按照逻辑推出东西基本不可能，最好的办法是利用已有的一个 $\lnot$ ，制造矛盾，使得矛盾可以推任意，或者 $\lnot +$。</p><p>但是如果要制造矛盾，必须引入新的变量，这样左边就会多一个元素，即使 $\lnot -$ 推出了任意，但左边也不符合。</p><p>因此可以用 $\lnot +$ 规则，在左边引入一个<strong>待求右端项</strong>的 $\lnot$ ，推出矛盾后再用反证法把<strong>待求变量</strong>移到右边，此时可能要用 $\lnot \lnot-$ 规则。</p><h2 id="FC-中定理的证明"><a href="#FC-中定理的证明" class="headerlink" title="FC 中定理的证明"></a>FC 中定理的证明</h2><h3 id="两种书写格式"><a href="#两种书写格式" class="headerlink" title="两种书写格式"></a>两种书写格式</h3><ol><li><p>用 PC 中的公式序列，最后再补上 $\Gamma$ ，不用序号，用「<strong>从而</strong>…」连接结论。</p><p>常用于 <strong>FC 反证法定理8</strong>、<strong>双向证明</strong>（先证后证）</p></li><li><p>用 ND 中的演绎序列，直接证出结果（书写内容多），如果此时<strong>要用 PC 或者 FC 的定理</strong>，需要在公式前面写 $\vdash$，并在下一条用分离规则导出（<strong>注意</strong>：不用写用若干次 $+$ 规则）。 </p><p>常用于 <strong>FC 存在消除定理10</strong></p></li></ol><p>具体证明过程依次使用以下方法。</p><h3 id="存在消除定理"><a href="#存在消除定理" class="headerlink" title="存在消除定理"></a>存在消除定理</h3><p>当式子左端有 $\exists xA$ 或 $\exists x(A\to B)$ 的量词时，优先考虑用存在消除定理10。</p><p>在左端补上 $A$ 或 $(A\to B)$ ，并用 ND 中的规则推出想要的右端项。</p><p>接着就可以用存在消除定理把左端补上的东西消除了。</p><script type="math/tex; mode=display">\begin{aligned}&\left( 1 \right) \exists v\left( B\rightarrow A \right) , B\rightarrow A, B\vdash A\\&\left( 2 \right) \exists v\left( B\rightarrow A \right) , B\vdash \exists v\left( B\rightarrow A \right) \\&\left( 3 \right) \exists v\left( B\rightarrow A \right) , B\vdash A\,\,\end{aligned}</script><p><strong>注意</strong>：虽说「存在」消除定理，但是最后消掉的是 $\exists x$ 里面的东西。</p><p><strong>警告</strong>：使用该方法时，(3) 式中左右端项都不能有 $v$ 的自由出现！</p><h3 id="反证法定理"><a href="#反证法定理" class="headerlink" title="反证法定理"></a>反证法定理</h3><p>反证法不一定是最优解，但是是最 FC 的做法，一般标准答案会用。当右端的整体上有个 $\lnot$ 打头，或者右端有个 $\exists x$ 时，建议使用。</p><script type="math/tex; mode=display">\begin{aligned}&\text{从而}\varGamma \vdash A\,\,\text{且} \varGamma \vdash \lnot A\\&\text{从而公式集}\varGamma \text{不一致，由}FC\text{反证法定理}8\\&\text{得}\forall vB\rightarrow A\vdash \lnot \forall v\lnot \left( B\rightarrow A \right)\end{aligned}</script><p>注意：如果左右都有 $\exists x$，优先用存在消除定理。</p><h3 id="思维流-1"><a href="#思维流-1" class="headerlink" title="思维流"></a>思维流</h3><p>前两种方法都不可以使用的时候考虑，跟 ND 中的证明没啥区别。可能会用到一些 PC 中的定理，如三段论定理8、逆否定理、以及一些小套件（定理6，定理9）。</p><h3 id="其他小技巧"><a href="#其他小技巧" class="headerlink" title="其他小技巧"></a>其他小技巧</h3><ol><li>FC 定理 9 平时用的少，但是有时有妙用。</li></ol><script type="math/tex; mode=display">\begin{aligned}&\left( 1 \right) \exists v\left( B\rightarrow A \right) , B\vdash A\\&\left( 2 \right) \exists v\left( B\rightarrow A \right) , \forall vB\vdash A\end{aligned}</script><ol><li><p>FC 也有<strong>演绎定理</strong>，并且考试中可以<strong>直接使用</strong>。（省步骤，不然就得用 ND 中复杂的规则来代替）</p><p>比如往左放就要用 $(+)$ 再用 $(\to-)$ 规则，往右放就要用 $(\to +)$ 规则。</p></li><li><p>全称推广定理 和 定理1 是互逆的关系，是 PC/ND 系统与 FC 联系的关键。常用于导出待证明式子右端项。</p></li><li><p>补充：使用 FC 定理时，有的定理有限制。</p></li></ol><ul><li>公理4 （项 t 对 v 可代入）</li><li>公理6 （v 在 A 中无自由出现）</li><li><strong>全称推广定理5</strong> （v 在 $\Gamma$ 中无自由出现）</li><li>定理9 （v 在 $\Gamma$ 中无自由出现）</li><li><strong>存在消除定理10</strong> （v 在 $\Gamma$ 和 B 中无自由出现）（在最后一行前后都无自由出现）</li></ul><h2 id="谓词演算部分"><a href="#谓词演算部分" class="headerlink" title="谓词演算部分"></a>谓词演算部分</h2><h3 id="构造语义和指派"><a href="#构造语义和指派" class="headerlink" title="构造语义和指派"></a>构造语义和指派</h3><p>语义就是 $U=<D,I>$ 即论域和解释，其中论域部分令 $D=\{1, 2\}$。</p><p>解释部分 $I$ 要加横杠，分别对常元、函词、谓词做一个映射。<strong>构造时根据要求，巧妙选择</strong>。</p><script type="math/tex; mode=display">\begin{aligned}&\bar{a}=1\\&\bar{f}\left( 1,1 \right) =1,\bar{f}\left( 1,2 \right) =1,\bar{f}\left( 2,1 \right) =1,\bar{f}\left( 2,2 \right) =1\\&\bar{R}=\left\{ 1,2 \right\} ,\bar{P}=\left\{ \left( 1,1 \right) \right\} ,\bar{Q}=\oslash\end{aligned}</script><p><strong>注意</strong>：函词是<strong>个体</strong>映射到<strong>个体</strong>，谓词是取这些<strong>个体</strong>时值为 <strong>True</strong>。<strong>一元谓词跟函词很容易混淆</strong>。</p><p>指派 $s$ 就是给变元取值。</p><script type="math/tex; mode=display">\bar{x}=2,\bar{y}=1</script><p>注意：书写时展开函词的时候，<strong>横杠</strong>都要加上。特别是多层函词时。</p><script type="math/tex; mode=display">\overline{f\left( x,y \right) }=\bar{f}\left( \bar{x},\bar{y} \right)</script><p>判断真假的时候，简单的直接写 T 或 F 就可以（需要横杠），表示映射。</p><p>但是含有<strong>任意、存在量词</strong>的必须用标准写法（不用横杠）<strong>拆去</strong>。</p><script type="math/tex; mode=display">\begin{aligned}&\models _U\left( \forall x \right) P\left( x \right) \left[ s \right] \,\, iff.\models _UP\left( x \right) \left[ s\left( x|1 \right) \right] \,\,\text{且} \models _UP\left( x \right) \left[ s\left( x|2 \right) \right] \\&\models _U\left( \exists x \right) P\left( x \right) \left[ s \right] \,\, iff.\models _UP\left( x \right) \left[ s\left( x|1 \right) \right] \,\,\text{或} \models _UP\left( x \right) \left[ s\left( x|2 \right) \right]\end{aligned}</script><h3 id="构造自然语句的形式化"><a href="#构造自然语句的形式化" class="headerlink" title="构造自然语句的形式化"></a>构造自然语句的形式化</h3><p>格式要注意，在开头要令出谓词、函词，一般不需要论域（除非真的只有一种个体词）。</p><p><strong>每个出现的个体词</strong>都应该有对应的谓词，如「作家」「作品」「小说」「学生」「实数」。</p><p>一个基本原则：$\forall \text{配}\rightarrow \text{，}\exists \text{配}\land $</p><p>常用短语：</p><ul><li>并非所有：$\lnot \forall x$</li><li>有且仅有、唯一：$\exists x\left( R\left( x \right) \land \forall u\left( R\left( u \right) \rightarrow E\left( x, u \right) \right) \right) $</li><li>不是就是、要么要么：$\forall x\left( R\left( x \right) \rightarrow P\left( x \right) \oplus Q\left( x \right) \right) $</li></ul><p>例题：形式化表示第二数学归纳法。</p><script type="math/tex; mode=display">\begin{aligned}&\text{令谓词：}\\&F\left( x \right) \text{表示当}n=x\text{时，命题成立；}\\&L\left( x,k \right) \text{表示}x<k\text{；}\\&P\left( x \right) \text{表示}x\text{是正整数。}\\&\left( 1 \right) F\left( 1 \right) \\&\left( 2 \right) \forall k\left( \left( P\left( k \right) \land \forall x\left( P\left( x \right) \land L\left( x,k \right) \rightarrow F\left( x \right) \right) \right) \rightarrow F\left( k \right) \right) \\&\left( 3 \right) \forall x\left( P\left( x \right) \rightarrow F\left( x \right) \right)\end{aligned}</script>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>本科课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR课程项目-文学检索-开发文档</title>
    <link href="/2021/08/25/IR-Project/"/>
    <url>/2021/08/25/IR-Project/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/blog/IR-Project-images/logo.png" alt="logo" style="zoom: 33%;" /></p><p><code>Description</code>：本文档作为 2021 年夏季学期 IR 课程 Project 搜索引擎搭建的开发文档，检索主题为「<strong>文学</strong>」。</p><p><code>Date</code>：2021-08</p><p><code>Copyleft</code>：© 2021 Hwcoder. All rights reserved.</p><h2 id="系统说明"><a href="#系统说明" class="headerlink" title="系统说明"></a>系统说明</h2><p>中国文学有数千年悠久历史，以特殊的内容、形式和风格构成了自己的特色，有自己的审美理想，有自己的起支配作用的思想文化传统和理论批判体系，是世界文学宝库中光彩夺目的瑰宝。</p><p>本搜索引擎主要收录了与<strong>中国文学</strong>有关的网页文档，包括但不限于民族文学、宗教文学、语言文学、诗词文学、中国外国文学等，爬取网站均来自中国社科院等官方机构。</p><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p><img src="/img/blog/IR-Project-images/system.png" alt="系统架构"></p><p>本搜索引擎系统主要架构如上图所示。 </p><p>检索的源文档由网络爬虫从给定的种子页面开始爬取，爬取到本地后利用 Python 中的 BeautifulSoup4 模块进行网页的解析，并写入文档数据库中。 之后利用搜索引擎解决方案 Xunsearch（迅搜）构建搜索引擎，利用索引器 Indexer 对文档数据进行索引，并构建基于 Xapian 的后端搜索服务器与前端的搜索应用，向用户展示出搜索功能。 </p><h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h3><h4 id="网络爬虫：Larbin"><a href="#网络爬虫：Larbin" class="headerlink" title="网络爬虫：Larbin"></a>网络爬虫：Larbin</h4><p>Larbin 是一种开源的网络爬虫，用 C++ 语言实现。其设计简单，具有高度的可配置性，能够配置抓取深度、间隔、并发度、代理，并支持通过后缀名对抓取网页进行过滤。Larbin 具有非常高的效率，可以轻易获取单个网站的所有链接，自动扩展 url 页面并抓取与保存，从而为搜索引擎提供广泛的数据来源。 </p><p>然而，Larbin 只是一个爬虫，<strong>只抓取网页</strong>，并不负责网页的解析、数据库的存储以及索引的建立，也不支持分布式系统。另外，Larbin 已经较长时间不再更新，因而不支持 https 协议，这在今天很大程度上造成了网页页面的局限性。</p><p>这里采用由国人在基于原版 Larbin2.6.3 版本上继续开发并发布于 GitHub 的 Larbin2.6.5 版本进行搜索引擎系统的构建。</p><p>项目网址：<a href="https://github.com/ictxiangxin/larbin">https://github.com/ictxiangxin/larbin</a></p><h4 id="网页解析：BeautifulSoup4-bs4"><a href="#网页解析：BeautifulSoup4-bs4" class="headerlink" title="网页解析：BeautifulSoup4 (bs4)"></a>网页解析：BeautifulSoup4 (bs4)</h4><p>BeautifulSoup4 是一个可以从 HTML 或 XML 文件中提取数据的 Python 库。</p><p>由于 HTML 和 XML 文件本身是<strong>结构化的文本</strong>，有一定的规则，通过它的结构可以简化信息提取。类似的网页信息提取库还有 Lxml 和 Pyquery 等，但是 bs4 相比其他的库更加简单易用。</p><p>本项目就采用 BeautifulSoup4 快速对网页文档内容进行解析和格式化。</p><p>官方文档：<a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/">https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/</a></p><h4 id="前端-amp-搜索引擎：Xunsearch-amp-Xapian"><a href="#前端-amp-搜索引擎：Xunsearch-amp-Xapian" class="headerlink" title="前端&amp;搜索引擎：Xunsearch &amp; Xapian"></a>前端&amp;搜索引擎：Xunsearch &amp; Xapian</h4><p>Xunsearch（迅搜）是一款以 GPL 协议开源发布的高性能、全功能的<strong>全文检索</strong>解决方案，并针对<strong>中文</strong>深度优化和处理，用于帮助开发者针对海量数据快速建立搜索引擎。 </p><p>Xunsearch 采用结构化分层设计，包含后端服务器和前端开发包两大部分。后端是用 C/C++ 基于 Xapian 搜索库、SCWS 中文分词、libevent 等开源库开发，借鉴了 nginx 的多进程多线程混合工作方式，是一个可承载高并发的高性能服务端。前端则是使用流行的脚本语言编写了开发工具包（SDK)。 </p><p>本项目采用 Xunsearch 还考虑了以下特点：</p><ul><li>具有为搜索而自主开发 SCWS 中文分词库，支持复合分词、自定义补充词库，保障查全率、准确率。</li><li>索引接口齐全，索引添加简便，支持实时搜索，支持多种数据源（SQL、JSON、CSV 等）。</li><li>除通用搜索引擎功能外，还内置支持拼音检索、分面搜索、相关搜索、同义词搜索、搜索纠错建议等专业功能。</li></ul><p>官方地址：<a href="http://www.xunsearch.com/">http://www.xunsearch.com/</a> </p><p>此外，Xunsearch 的高速响应能力还离不开 Xapian 这一搜索引擎库。</p><p>Xapian 是一个允许开发人员轻易地添加<strong>高级索引和搜索功能</strong>到他们的应用系统的高度可修改的工具，它在支持概率论检索模型的同时也支持布尔型操作查询集。</p><p>Xapian 相比 Lucene 有更多的优势：基于 C++ 开发的强可移植性（可以运行在 Linux, MacOS, Windows 系统上），丰富的查询机制（概率性搜索排名、相关度反馈、邻近搜索、布尔搜索、词干提取、通配符查询、别名查询、拼写纠正等）和较强的检索性能。</p><h2 id="设计文档"><a href="#设计文档" class="headerlink" title="设计文档"></a>设计文档</h2><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><p>主机：</p><ul><li>系统：Windows 10</li><li>带宽：40 Mbps</li></ul><p>虚拟机：</p><ul><li>软件：Oracle VM VirtualBox 6.1.26</li><li>配置设置：<ul><li>内存：2GB</li><li>磁盘：20GB</li><li>处理器：Intel(R) Core(TM) i5-9300H CPU @ 2.40GHz（核心数：1） </li></ul></li><li>系统：Linux Ubuntu 20.04</li><li>依赖环境：<ul><li>Apache 2.4.41</li><li>PHP 7.4.3</li><li>Python 3.8.10</li></ul></li></ul><h3 id="总体设计流程"><a href="#总体设计流程" class="headerlink" title="总体设计流程"></a>总体设计流程</h3><ol><li>安装 Ubuntu 虚拟机，配置环境，安装 Larbin 和 Xunsearch。</li><li>配置 Larbin 爬虫选项，选定种子页面，爬取文档。</li><li>利用 BeautifulSoup4 模块编写脚本 Parser.py 解析文档，存储为 csv 文件。</li><li>生成 Xunsearch 配置文件，构建索引，生成搜索框架。</li><li>部署至 Apache HTTP Server，前后端代码再开发，优化搜索页面。</li></ol><h3 id="各模块设计细节"><a href="#各模块设计细节" class="headerlink" title="各模块设计细节"></a>各模块设计细节</h3><h4 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h4><p>网络爬虫模块使用 Larbin2.6.5 进行网页文档的爬取。在按照配置进行爬取 30 分钟后，最终获得 10965 个文档（约 409 MB）。由于爬虫自身的限制，这些文档均来自 http 站点。 </p><p>以下是关键的配置项及说明：</p><ul><li>是否锁定种子站点：<strong>否</strong>。取消锁定才能根据链接爬取到更多内容。</li><li>是否使用扩展链接：<strong>否</strong>。大部分网页为了提高排名，都会引入无关的友链，由于本项目是专题检索，故关闭此功能避免进入其他域名。</li><li>同一个服务器的两次请求的间隔时间：<strong>无限制</strong>。通常基于礼貌原则，我们应该限制访问频率，但由于关闭了扩展链接，爬虫只会在少数域名中爬取，如果限制了间隔时间会使得爬取效率极低。</li><li>是否哈希页面以去重：<strong>是</strong>。由于站点固定，去重可以减少大量数据冗余。</li></ul><p>以下是种子网页地址：</p><ul><li><a href="http://philosophychina.cssn.cn/">http://philosophychina.cssn.cn/</a> （中国哲学网-中国社科网子域名）</li><li><a href="http://literature.cssn.cn/">http://literature.cssn.cn/</a> （中国文学网-中国社科网子域名）</li><li><a href="http://cel.cssn.cn/#story1">http://cel.cssn.cn/#story1</a> （中国民族文学网-中国社科网子域名）</li><li><a href="http://ling.cssn.cn/">http://ling.cssn.cn/</a> （中国语言文学网-中国社科网子域名）</li><li><a href="http://iwr.cssn.cn/">http://iwr.cssn.cn/</a> （中国宗教文学网-中国社科网子域名）</li><li><a href="http://ifl.cssn.cn">http://ifl.cssn.cn</a> （中国外国文学网-中国社科网子域名）</li><li><a href="http://www.china-language.edu.cn/">http://www.china-language.edu.cn/</a> （中国语言学网）</li><li><a href="http://www.huaxiawen.com/">http://www.huaxiawen.com/</a> （华夏古代文学网）</li><li><a href="http://www.zgwenxue.com/">http://www.zgwenxue.com/</a> （中国文学网）</li><li><a href="http://www.eduwx.com/">http://www.eduwx.com/</a> （教育文学网）</li><li><a href="http://www.wgwxzz.cn/">http://www.wgwxzz.cn/</a> （外国文学网）</li><li><a href="http://www.zhexue.org/">http://www.zhexue.org/</a> （哲学网）</li><li><a href="http://www.52shici.cn/">http://www.52shici.cn/</a> （吾爱诗词网）</li></ul><p>在终端运行爬虫过程如下：</p><p><img src="/img/blog/IR-Project-images/Larbin1.png" alt="Larbin运行过程" style="zoom: 67%;" /></p><p>打开 localhost:8081 查看统计结果：</p><p><img src="/img/blog/IR-Project-images/Larbin2.png" alt="Larbin运行结果" style="zoom:67%;" /></p><p>从统计结果可以看出，共收到 13783 个 URL，访问了 13783 个页面，最终成功爬取 10965 个页面。</p><p><img src="/img/blog/IR-Project-images/Larbin3.png" alt="爬取速度变化" style="zoom:67%;" /></p><p>从上图可以具体地得出爬虫的爬取效率，可见爬虫爬取的速度随着时间的推移会发生较大的变化。</p><h4 id="网页解析"><a href="#网页解析" class="headerlink" title="网页解析"></a>网页解析</h4><p>解析器模块利用 Python 的 BeautifulSoup4 和 Pandas 模块编写，前者可以对网页文档进行解析，后者便于将数据以 csv 文件形式保存，便于后续搜索引擎使用。 </p><p>调用 BeautifulSoup4 的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path + file, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    soup = BeautifulSoup(f.read(), <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>    <span class="hljs-keyword">if</span> soup.title == <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> soup.title.string == <span class="hljs-literal">None</span>:<br>        title.append(<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        title.append(soup.title.string.replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;\r&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>))<br>    body.append(soup.get_text().replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;\r&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>))<br></code></pre></div></td></tr></table></figure><p>调用 Pandas 的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">data = &#123;<span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-built_in">id</span>, <span class="hljs-string">&#x27;title&#x27;</span>: title, <span class="hljs-string">&#x27;body&#x27;</span>: body, <span class="hljs-string">&#x27;urls&#x27;</span>: urls&#125;<br>frame = pd.DataFrame(data)<br><span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>    frame.to_csv(<span class="hljs-string">&#x27;data_u.csv&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8-sig&#x27;</span>, index=<span class="hljs-literal">False</span>)<br><span class="hljs-keyword">else</span>:<br>    frame.to_csv(<span class="hljs-string">&#x27;data_u.csv&#x27;</span>, mode=<span class="hljs-string">&#x27;a+&#x27;</span>, header=<span class="hljs-literal">False</span>, encoding=<span class="hljs-string">&#x27;utf-8-sig&#x27;</span>, index=<span class="hljs-literal">False</span>)<br></code></pre></div></td></tr></table></figure><p>处理结果如下：</p><p><img src="/img/blog/IR-Project-images/data.png" alt="处理后的数据（部分）" style="zoom: 67%;" /></p><p>可以看到每个文档被分出 id, title, body, urls 四个字段，存储在一个 csv 文件中。 </p><h4 id="前端-amp-搜索引擎"><a href="#前端-amp-搜索引擎" class="headerlink" title="前端&amp;搜索引擎"></a>前端&amp;搜索引擎</h4><p>搜索引擎模块利用 Xunsearch 提供的开发工具即可实现。首先确定运行环境正常，然后编写配置文件对格式化的 csv 文件建立索引，并生成搜索骨架代码，即可实现基本检索功能。 </p><p>首先利用工具包中的 RequiredCheck 检查当前环境是否满足 Xunsearch 的运行条件：</p><p><img src="/img/blog/IR-Project-images/xun1.png" alt="迅搜运行条件检查" style="zoom:50%;" /></p><p>环境正常后，利用工具包中的配置文件生成工具 IniWizzard，在 Web 交互页面中即可完成各个字段的设计：</p><p><img src="/img/blog/IR-Project-images/xun2.png" alt="配置生成工具" style="zoom: 50%;" /></p><p>其中，各个字段的含义如下：</p><ul><li>id 为主键，作为每个文档的标识符。</li><li>title 为文档的标题，赋予较高权重。</li><li>body 为文档的内容，截取 300 个字符作为搜索结果的摘要显示。</li><li>urls 作为每个文档在展示时的附属信息，不需要进行索引。 </li></ul><p>此后，就可以用工具包中的索引管理器 Indexer 批量建立索引：</p><p><img src="/img/blog/IR-Project-images/xun3.png" alt="批量建立索引" style="zoom: 67%;" /></p><p>在 db 文件夹下，可以看到建立的索引文件：</p><p><img src="/img/blog/IR-Project-images/xun4.png" alt="建立的索引文件" style="zoom: 67%;" /></p><p>此时，可以用工具包中配备的测试工具 Quest，在当前索引中进行测试搜索，测试给定查询词的返回的数据。 </p><p><img src="/img/blog/IR-Project-images/xun5.png" alt="测试搜索" style="zoom:50%;" /></p><p>可以看到搜索功能已经可以使用了，这时需要用到工具包中的骨架代码生成工具 SearchSkel，生成前端代码。</p><p><img src="/img/blog/IR-Project-images/xun6.png" alt="骨架代码生成" style="zoom: 67%;" /></p><p>最后，运行 Apache2.0，将生成的 search 目录放到 /var/www/html 中，即可在本地服务器 localhost 访问搜索页面，实现搜索引擎的功能。 </p><p><img src="/img/blog/IR-Project-images/xun7.png" alt="基础页面"></p><p>点击文档标题，会返回对应的文档主键（id）：</p><p><img src="/img/blog/IR-Project-images/xun8.png" alt="点击标题后的弹框" style="zoom: 67%;" /></p><h4 id="页面再开发"><a href="#页面再开发" class="headerlink" title="页面再开发"></a>页面再开发</h4><p>可以看到，直接生成的框架文件有如下的不足：</p><ul><li>前端较为简陋，重点不够突出。</li><li>由于使用了国外的 cdn，访问速度较慢。</li><li>搜索结果点击后无法直接跳转至页面。</li></ul><p>开发 style.css 和 search.tpl 文件后，可以得到新的页面：</p><p><img src="/img/blog/IR-Project-images/xun9.png" alt="再开发后的页面"></p><h2 id="页面展示"><a href="#页面展示" class="headerlink" title="页面展示"></a>页面展示</h2><p>网站部署到 web 可访问目录后，可以通过虚拟机的端口转发设置，实现在主机上访问，也可以购买 HTTP 映射服务后在给定域名访问。这里选择最简单的在虚拟机中访问。</p><h3 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h3><p>使用搜索前：</p><p><img src="/img/blog/IR-Project-images/page0.png" alt="使用搜索前" style="zoom: 67%;" /></p><p>使用搜索后：</p><p><img src="/img/blog/IR-Project-images/page1.png" alt="使用搜索后" style="zoom:67%;" /></p><p>在使用了搜索功能后，搜索引擎将分析<strong>搜索日志</strong>，从而提供<strong>热门搜索词</strong>。 此外，可以看到搜索时可以选择多种方式，页脚有标明版权、处理时间以及作者的信息。</p><h3 id="搜索页面"><a href="#搜索页面" class="headerlink" title="搜索页面"></a>搜索页面</h3><p>点击搜索后，会反馈查询结果的标题、文档摘要以及文档对应的原网址，并进行对查询词进行高亮表示（标题中红字、摘要中加粗），并会返回检索条目、检索时间、检索相似度等信息。</p><p>特别地，在页脚还提供了相关的搜索内容的联想，下图是在搜索「散文」后的联想：</p><p><img src="/img/blog/IR-Project-images/page2.png" alt="相关搜索" style="zoom:67%;" /></p><h3 id="部分功能"><a href="#部分功能" class="headerlink" title="部分功能"></a>部分功能</h3><ol><li>查询联想</li></ol><p><img src="/img/blog/IR-Project-images/page3.png" alt="查询联想" style="zoom:67%;" /></p><ol><li>拼音联想</li></ol><p><img src="/img/blog/IR-Project-images/page4.png" alt="拼音联想" style="zoom:67%;" /></p><ol><li>搜索纠错</li></ol><p><img src="/img/blog/IR-Project-images/page5.png" alt="搜索纠错" style="zoom:67%;" /></p><ol><li>拼音纠错</li></ol><p><img src="/img/blog/IR-Project-images/page6.png" alt="拼音纠错" style="zoom:67%;" /></p><ol><li>布尔检索</li></ol><p><img src="/img/blog/IR-Project-images/page7.png" alt="未使用布尔检索的结果" style="zoom:67%;" /></p><p>插入否定连接词后：</p><p><img src="/img/blog/IR-Project-images/page8.png" alt="插入布尔连接词后的结果" style="zoom:67%;" /></p><h2 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h2><p>下表随机选取 10 个与本搜索引擎相关的查询词进行检索，评估搜索引擎的 Top5 查准率（precision@5）与平均响应时间（mean responding time）。 </p><div class="table-container"><table><thead><tr><th style="text-align:center">查询</th><th style="text-align:center">查准率@5</th><th style="text-align:center">响应时间/s</th><th style="text-align:center">匹配文档总数</th></tr></thead><tbody><tr><td style="text-align:center">校园文学</td><td style="text-align:center">4</td><td style="text-align:center">0.0219</td><td style="text-align:center">2000</td></tr><tr><td style="text-align:center">宗教文学</td><td style="text-align:center">5</td><td style="text-align:center">0.0186</td><td style="text-align:center">1000</td></tr><tr><td style="text-align:center">汉语</td><td style="text-align:center">5</td><td style="text-align:center">0.0210</td><td style="text-align:center">990</td></tr><tr><td style="text-align:center">藏语</td><td style="text-align:center">3</td><td style="text-align:center">0.0229</td><td style="text-align:center">68</td></tr><tr><td style="text-align:center">季羡林</td><td style="text-align:center">1</td><td style="text-align:center">0.0173</td><td style="text-align:center">50</td></tr><tr><td style="text-align:center">鲁迅</td><td style="text-align:center">4</td><td style="text-align:center">0.0188</td><td style="text-align:center">501</td></tr><tr><td style="text-align:center">毛泽东诗词</td><td style="text-align:center">5</td><td style="text-align:center">0.0221</td><td style="text-align:center">300</td></tr><tr><td style="text-align:center">马克思主义哲学中国化</td><td style="text-align:center">5</td><td style="text-align:center">0.0356</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">散文作品</td><td style="text-align:center">4</td><td style="text-align:center">0.0128</td><td style="text-align:center">800</td></tr><tr><td style="text-align:center">小说集</td><td style="text-align:center">3</td><td style="text-align:center">0.0225</td><td style="text-align:center">120</td></tr></tbody></table></div><p>计算得：平均查准率为 3.9，平均响应时间为 0.02135s。</p><p>从结果上看，该搜索引擎在对应领域有着良好的表现，且响应迅速，但是对著名人物作品的查询则稍显不足。</p><p>此外，在部分检索结果中，有些无关文档由于重复出现了查询词而被赋予较高的「相似度」，但实际上 Top 10 返回结果的「相似度」都很高，可以考虑用 PageRank 等算法优化网站排名，提高 MRR 等指标。</p>]]></content>
    
    
    <categories>
      
      <category>项目经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #11 问答系统</title>
    <link href="/2021/08/25/IR-Note-11/"/>
    <url>/2021/08/25/IR-Note-11/</url>
    
    <content type="html"><![CDATA[<p>在传统的搜索引擎中，通常是以关键词为索引，通过匹配而返回相似的文档。然而，有时用户在搜索引擎中检索，并非想得到若干个网页，而是直接返回询问的答案，免去用户人工定位信息的过程。</p><p><strong>问答式信息检索</strong>，是一种允许用户以自然语言方式询问，系统从单语或多语文档集中查找并返回<strong>确切答案或者蕴含答案文本片断</strong>的新型信息检索的方式。</p><p>要做到这一点，就需要先做到：</p><ol><li>理解问句中的查询意图。</li><li>根据分析结果去检索匹配文档，尽量缩小范围。</li><li>在返回的文档中提取答案信息或定位答案文本。</li></ol><p>当然，早期还有一种做法是构建 FAQ (Frequently Asked Questions，常用问题解答) 库，将用户的问句与问题库中的问句进行相似度匹配，直接返回对应的答案。</p><h2 id="AskMSR-Shallow-approach"><a href="#AskMSR-Shallow-approach" class="headerlink" title="AskMSR: Shallow approach"></a>AskMSR: Shallow approach</h2><p>AskMSR 是 Microsoft Research 提出的是一种简易的基于检索的问答系统。</p><p>其大体步骤分为六步：</p><ol><li>Rewrite Query：重写查询，并将问句类型归类。</li><li>Search Engine：将所有重写结果输入到搜索引擎，返回前若干个文档。</li><li>Mine N-grams：文档分词，N 通常枚举 1，2，3，根据出现频率给出置信度。</li><li>Filter N-grams：过滤分词结果，保留与问题类型相关的。</li><li>Tile N-grams：组合分词结果，把重叠可拼接的词 merge，置信度也相加。</li><li>N-best Answers：答案通常都是多个，以置信度排序。</li></ol><h3 id="重写查询-Query-Rewriting"><a href="#重写查询-Query-Rewriting" class="headerlink" title="重写查询 | Query Rewriting"></a>重写查询 | Query Rewriting</h3><p>如果只是检索用户输入的问句，很可能返回的就是含有句子本身的文档。而根据我们的直觉：用户需要的答案通常在语义上与查询<strong>相近</strong>的句子中。为此，我们需要将疑问句改写成<strong>陈述句</strong>，如果在文本中有这样一句陈述句，它可能本身就包含了问题的答案。</p><p>重写后的陈述句不一定是满足语法规则的句子，但是这并不影响检索结果。一个 query 可以被改写成若干个问题，并通过搜索引擎查询更多个相似的文本片段。</p><p>此外，重写问句时，通常要对语言的语法规则有一点了解，从而对问题进行分类。如在英语中：Who 对应人名，When 对应时间，Where 对应地名等。这将用于后续的分词结果的过滤。</p><h2 id="模式挖掘-ISI-Surface-patterns-approach"><a href="#模式挖掘-ISI-Surface-patterns-approach" class="headerlink" title="模式挖掘 | ISI: Surface patterns approach"></a>模式挖掘 | ISI: Surface patterns approach</h2><p>在 AskMSR 中，我们只在句法相近的句子中寻找答案，但是实际上很多答案会隐藏在不同的形式中。如果我们使用特征短语——<strong>模式</strong>（Pattern），就可以检索到不同形式的答案。</p><p>例如在问题 “When was <code>person</code> born ?” 中，答案的形式可能是：</p><ul><li>Mozart was born in 1756.</li><li>Gandhi (1869-1948) …</li></ul><p>这两种特征短语可以挖掘出如下的模式：</p><ul><li><code>NAME</code> was born in <code>BIRTHDATE</code></li><li><code>NAME</code> (<code>BIRTHDATE</code> - <code>DEATHDATE</code>)</li></ul><p>对于不同的模式，我们也可以赋予不同的置信度（准确度）。而后我们就可以用这两种模式在搜索引擎中匹配结果，并根据置信度返回结果排序。</p><p>在 2002 年 Hovy 等人还提出 QA Typology 的问答分类体系，将常见的问答分为以下六种类型：BIRTHDATE、LOCATION、INVENTOR、DISCOVERER、DEFINITION、WHY-FAMOUS，并给出了对应类型下常用的模式和置信度。这在使用中取得了较高的 MRR (Mean Reciprocal Rank)。</p><h3 id="Shortcomings-amp-Extensions"><a href="#Shortcomings-amp-Extensions" class="headerlink" title="Shortcomings &amp; Extensions"></a>Shortcomings &amp; Extensions</h3><p>接下来分析 ISI 可能出现的问题，以及改进的方法。</p><p>第一，由于使用了简单的字符串匹配，可能会在文档中出现「模式符合，但并非答案」的句子，这就需要利用<strong>词性标注</strong>（Part-Of-Speech Tagging）对答案内容加以分析，从而修改置信度。</p><p>第二，原始的模式不支持<strong>长距离</strong>答案的匹配，实际中的陈述句中如果含有形容词、副词或者更长的插入语，就容易割裂模式。如「Mozart, who was a famous classical composer, was born in 1756.」中，原始的模式就会漏掉答案。因此我们需要在原始的模式中插入可任意文本填充的空白字段。</p><p>第三，当问句中的 <code>NAME</code> 以<strong>同义词或释义</strong>的形式出现时，直接字符串匹配的模式也会漏掉答案。这时就需要对问句中的关键词进行语义上的扩展，需要用到 WordNet 等词典。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #10 查询相关反馈</title>
    <link href="/2021/08/25/IR-Note-10/"/>
    <url>/2021/08/25/IR-Note-10/</url>
    
    <content type="html"><![CDATA[<p>用户在检索信息时，通常会以一个简短的 query 开始，这样的查询往往得不到其最想要的结果。而用户会在得到结果后优化自己的 query，如：增删词项、重新赋权、加入布尔运算符等。</p><p><strong>相关反馈</strong>（Relevance Feedback）的主要思想就是：在信息检索的过程中通过用户交互来优化查询，从而提高最终的检索效果。我们的目的是实现一个良好的<strong>反馈机制</strong>。</p><h2 id="最佳查询-Best-Query"><a href="#最佳查询-Best-Query" class="headerlink" title="最佳查询 | Best Query"></a>最佳查询 | Best Query</h2><p>为了使反馈能让 query 真正往「更好」的方向演变，需要定义评价 query 的一个指标。通常我们在<strong>向量空间模型</strong>中评价之，因为可以较好地表达相似度。</p><p>假设我们要找一个最优查询向量 $\vec{q}$，它与相关文档之间的相似度最大，和不相关文档之间的相似度最小。若 $C_r$ 表示相关文档集，$C_{nr}$ 表示不相关文档集，我们希望找到的最优的是 $\vec{q}$ 应当满足：</p><script type="math/tex; mode=display">\begin{aligned}\vec{q}_{opt} &= argmax[Sim(\vec{q},C_r)-Sim(\vec{q},C_{nr})]\\&=argmax(\frac{1}{|C_r|}\sum_{\vec{d}_j\in C_r}{\vec{q}\cdot \vec{d}_j}-\frac{1}{|C_{nr}|}\sum_{\vec{d}_j\in C_{nr}}{\vec{q}\cdot \vec{d}_j})\\&=argmax(\vec{q}\cdot \vec{a})\end{aligned}</script><p>其中 $argmax(x)$​​​​ 函数是返回使 $x$​​​​ 最大的变量，相似度 $Sim$​​​​ 的求法则采用余弦夹角， $\vec{q}$​​​​ 和 $\vec{d}$​​​ ​采用归一化后的<strong>单位向量</strong>。此外，我们令：</p><script type="math/tex; mode=display">\vec{a}=\frac{1}{|C_r|}\sum_{\vec{d_j}\in{C_r}}{\vec{d_j}} - \frac{1}{|C_{nr}|}\sum_{\vec{d_j}\in{C_{nr}}}{\vec{d_j}}</script><p>若使 $\vec{q}\cdot{\vec{a}}$ 最大，$\vec{q}$ 需要与 $\vec{a}$ 平行，且 $\vec{q}$​ 为单位向量，故有最佳查询：</p><script type="math/tex; mode=display">\vec{q}_{opt}=\frac{1}{|C_r|}\sum_{\vec{d_j}\in{C_r}}{\vec{d_j}} - \frac{1}{|C_{nr}|}\sum_{\vec{d_j}\in{C_{nr}}}{\vec{d_j}}</script><p>这就是说，最优的查询向量等于相关文档的质心向量和不相关文档的质心向量的差，相当于是最接近相关文档，同时最远离不相关文档。</p><h3 id="查询优化-Query-Modification"><a href="#查询优化-Query-Modification" class="headerlink" title="查询优化 | Query Modification"></a>查询优化 | Query Modification</h3><p>然而，即使有了上述最佳查询的表示方法，也无法直接求出来——因为检索本来的目的就是要找相关文档，而所有的相关文档事先是未知的。</p><p>Rocchio 提出在真实的检索情景中，我们可以利用已检索到的部分相关文档 $D_r$ 和不相关文档 $D_{nr}$，逐步修改原始的查询向量：</p><script type="math/tex; mode=display">\vec{q}_m=\alpha\vec{q}_0 + \beta \frac{1}{|D_r|}\sum_{\vec{d_j}\in{D_r}}{\vec{d_j}} - \gamma\frac{1}{|D_{nr}|}\sum_{\vec{d_j}\in{D_{nr}}}{\vec{d_j}}</script><p>修改后的新查询从 $\vec{q}_{0}$​​ 开始，向着相关文档的质心向量靠近了一段距离，而同时又与不相关文档的质心向量远离了一段距离——更加接近最优查询了。通过不断迭代，可以观察到查询效果确实有显著的提升。</p><h2 id="查询反馈-Relevance-Feedback"><a href="#查询反馈-Relevance-Feedback" class="headerlink" title="查询反馈 | Relevance Feedback"></a>查询反馈 | Relevance Feedback</h2><p>通常情况下，反馈可分为以下两种：</p><ul><li>真实相关反馈：搜索引擎返回结果，用户提供反馈，搜索引擎根据反馈返回更好的结果。</li><li>假设相关反馈：搜索引擎得到结果但不返回，根据结果自动优化 query，根据优化后的 query 返回「更好」的结果。</li></ul><h3 id="点击流数据-Clickthrough-Data"><a href="#点击流数据-Clickthrough-Data" class="headerlink" title="点击流数据 | Clickthrough Data"></a>点击流数据 | Clickthrough Data</h3><p>在真实相关反馈中，用户往往不愿意主动提供反馈信息（如标记相关或不相关文档），于是搜索引擎收集用户的<strong>间接反馈</strong>。</p><p>而点击流数据则是这个领域最常用的一种反馈，可以在不干扰用户的情况下大量收集（此外还有一种补充用户行为信息的方法是眼动追踪）。</p><p>同一搜索结果中，用户进行点击浏览的结果被认为是相关的，或者说是「用户更<strong>偏好</strong>的」。如果用户查看了每个搜索引擎下面显示的文本短摘要后，决定跳过它并点击在排序中低于它的结果，就可以说用户相对更喜欢这个被点击的结果。</p><h3 id="局部上下文分析-Local-Context-Analysis"><a href="#局部上下文分析-Local-Context-Analysis" class="headerlink" title="局部上下文分析 | Local Context Analysis"></a>局部上下文分析 | Local Context Analysis</h3><p>在假设相关反馈中，还可分为两种基本方法：</p><ul><li>局部分析（Local Analysis）：从结果集合排名靠前的文档中产生反馈信息。</li><li>全局分析（Global Analysis）：从外部资源产生反馈信息，如同义词典（用于扩充查询）。</li></ul><p>同义词典构建的代价十分昂贵，通常考虑用<strong>上下文和短语结构</strong>进行分析获得。而如果把这个思想用于局部分析，则诞生了 LCA 方法：一种聚焦于从反馈结果中筛选出与 query 相关性更高的 term，再用这些 term 扩展 query 重新检索的方法。</p><p>大致的步骤如下：</p><ol><li>找到与这个 query 检索结果排名靠前的文章，使用一个固定长度（如 300 个词）的滑动窗口，来划分<strong>段落</strong>。引入段落是为了最小化冗长文档中的无关内容。</li><li>对段落进行检索排序，找到结果排名靠前的段落，对其使用语义分析和文本分词、词性标注技术找到<strong>名词项</strong>。名词在搜索引擎中往往被视为最重要的词。</li><li>统计名词项的出现次数，以及出现时离 query 的距离，通过特殊的加权方法来选择出候选 term。</li><li>将排名靠前的几个候选 term 加入到原始 query 中，进行新的查询。</li></ol><h2 id="排序学习-Learning-to-Rank"><a href="#排序学习-Learning-to-Rank" class="headerlink" title="排序学习 | Learning to Rank"></a>排序学习 | Learning to Rank</h2><p>相关反馈信息，包括前述文章中提到的相关度、重要度，其实只是 IR 中许多因子的冰山一角。实际中可能还有若干、数十个因子，这些因子最后会加权构成一个统一的<strong>指标函数</strong>。</p><p>这个指标函数的输入是数据集（包括查询和文档集），输出是最终检索出的 ranklist。如何构造这样一个复杂的函数呢？</p><p>对于构造函数，人们最原始的想法通常是拟合所有 <query, ranklist> 点，但是这显然不适用于这种规模的问题。</p><h3 id="机器学习的使用-Machine-learning-for-IR-ranking"><a href="#机器学习的使用-Machine-learning-for-IR-ranking" class="headerlink" title="机器学习的使用 | Machine learning for IR ranking"></a>机器学习的使用 | Machine learning for IR ranking</h3><p>过去的 IR 系统较少用到机器学习，是因为缺乏训练集，特别是在真实世界中得到的数据集（而不是学术论文中），因为很难收集到用户检索的真实需求和对返回文档的相关反馈。</p><p>此外，过去的 IR 系统往往只使用少量的<strong>特征</strong>（feature），如词项频率、逆文档频率、term 出现的位置等。</p><p>少量的特征带来的是构造函数的便利。而随着现在网络的发展、算力的提升，大家开始关注数据集中大量的特征，并尝试用机器学习使用这些特征。</p><p>定义 loss function $l(r_a,r_b)$​​​，其中 $r_a$ 是基于用户反馈得到的「标准排名」，$r_b$ 是通过拟合的排序函数 <em>F</em> 计算出的「模拟排名」。我们要寻找到一个 <em>F</em> 使得损失最小——这就是机器学习的目标。</p><h3 id="Example-title-amp-body"><a href="#Example-title-amp-body" class="headerlink" title="Example - title &amp; body"></a>Example - title &amp; body</h3><p>下面以一个例子说明机器学习在 IR 中的应用。考虑查询中的 term 出现在文档的 title (标题) 或 body (正文) 中对返回结果排名的影响。</p><p>为此，我们需要对 term 出现的四种情况分别打分：</p><script type="math/tex; mode=display">\operatorname{score}\left(d, q\right)=g {s_{t}}\left(d, q\right)+(1-g) s_{b}\left(d, q\right)</script><p>其中 $s_t$ 和 $s_b$ 函数是关于 term 是否存在于文档对应位置的布尔函数（0/1），故 score 的结果只有 0, <em>g</em>, 1-<em>g</em>, 1 四种。我们要求的就是权重 <em>g</em>。</p><p>在第 <em>j</em> 个查询中，我们对检索结果中的文档 <em>i</em> 定义如下<strong>损失函数</strong>：</p><script type="math/tex; mode=display">\varepsilon\left(g, \Phi_{j}\right)=\left(r\left(d_{i}, q_{j}\right)-\operatorname{score}\left(d_{i}, q_{j}\right)\right)^{2}</script><p>这里简单的定义 <em>r</em> 函数是关于二者是否相关的布尔函数（0/1），使用平方误差是为了让结果更连续。</p><p>在训练集中，我们标注出所有结果的 $s_t$ 、 $s_b$ 和 <em>r</em> 函数的取值——八种情况，并分别统计其次数。例如，$n_{01r}$ 表示 $s_t=0,s_b=1$ 且相关的例子，$n_{01n}$ 表示 $s_t=0,s_b=1$​ 且不相关的例子，其平方误差之和为：</p><script type="math/tex; mode=display">[1-(1-g)]^{2} n_{01 r}+[0-(1-g)]^{2} n_{01 n}</script><p>同样的，我们对其他三组也进行计算后相加，化简可得：</p><script type="math/tex; mode=display">\left(n_{01 r}+n_{10 n}\right) g^{2}+\left(n_{10 r}+n_{01 n}\right)(1-g)^{2}+n_{00 r}+n_{11 n}</script><p>要求这个函数的极小值，只需用对关于 <em>g</em> 的导数求零点即可。如果考虑更多的变量，则需要求<strong>偏导</strong>，再用拉格朗日常数法等数值分析方法。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
      <tag>NLP</tag>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #9 网页排序</title>
    <link href="/2021/08/25/IR-Note-9/"/>
    <url>/2021/08/25/IR-Note-9/</url>
    
    <content type="html"><![CDATA[<p>当我们在一个小的文档库中查询时，即使 query 很模糊，我们只要返回所有相关文档即可，甚至不需要<strong>猜测</strong>用户的查询需求。</p><p>但如果在一个大的文档集中查询时（比如谷歌），往往可以返回大量的相关文档。如果基于相关度的 ranking，往往无法区分哪些文档该呈现在最前面，甚至可能时一些低质量的网页对于某些词的词频很高，从而排在了前面。</p><p>此时我们就不能只聚焦与「相关度」，PageRank 算法通过计算一个页面的「<strong>重要度</strong>」，从而判别网页质量，得到排序。</p><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>如何衡量「重要度」？用点击率、权威性？然而，这些数据都是爬虫无法爬取到的，同时也难以正确衡量。</p><p>科学家们从 Bibliometrics (文献计量学) 中借鉴了如下观点：</p><ul><li>Bibliographic coupling (引文耦合)：两篇文章具有相近的引用。</li><li>Co-citation (协同引用)：两篇文章被大量其他文章同时引用。</li><li>Impact factor (影响因子)：一个期刊中的文章的年平均被引次数，衡量了一个期刊的「<strong>重要度</strong>」。</li></ul><p>例如，最权威的 SCI 往往只收录其认为重要的期刊，也只记录其中的期刊相互引用的次数。当一篇文章被 SCI 收录的文章引用时，通常也可以说明其有一定的影响力——即重要度的「<strong>传递</strong>」。</p><p>对于文献引用的可视化，我们通常称为 Citation Graph，通常是一个 Directed Acyclic Graph (有向无环图，DAG)，因为较早的文章无法修改而引用后来的文章。</p><p>在网页中，我们可以 Hyperlinks (超链接) 来类比引用，从而形成一个 Hyperlink Graph，区别是这类图中可以有环路。</p><p>从而引出网页排序的基本假设：</p><ul><li>The rank of a web page is higher if many pages link to it.</li><li>Links from highly ranked pages are given greater weight than links from less highly ranked pages. </li></ul><h2 id="PageRank-Algorithm"><a href="#PageRank-Algorithm" class="headerlink" title="PageRank Algorithm"></a>PageRank Algorithm</h2><p>基于上述假设，我们很容易可以得到当前页面的链入、链出数。但是，要怎么知道链入当前页面的<strong>前序页面</strong>，其重要度是多少呢？</p><h3 id="随机游走模型-Random-Walk-Model"><a href="#随机游走模型-Random-Walk-Model" class="headerlink" title="随机游走模型 | Random Walk Model"></a>随机游走模型 | Random Walk Model</h3><p>在一个封闭的 Hyperlink Graph 中，随机选取一个页面作为访问起点，随机选取其链出的页面进行访问，再对下一个页面重复上述操作。</p><p>大量重复后，统计每个结点被访问的频率，用频率近似概率后，我们可以发现访问概率较大者通常有着较多的链入，或者其链入页面也有着较大的访问概率。用公式表示就是：</p><script type="math/tex; mode=display">\mathrm{Pr}\left( P_i \right) =\mathrm{Pr}\left( P_i\mid P_1 \right) \mathrm{Pr}\left( P_1 \right) +\mathrm{Pr}\left( P_i\mid P_2 \right) \mathrm{Pr}\left( P_2 \right) +\cdots +\mathrm{Pr}\left( P_i\mid P_N \right) \mathrm{Pr}\left( P_N \right)</script><p>其中 $\mathrm{Pr}\left( P_i\mid P_1 \right) $​​ 表示从编号为 1 的网页跳转到编号为 <em>i</em> 的网页的概率，其计算方式为：</p><script type="math/tex; mode=display">\mathrm{Pr}\left( P_i\mid P_1 \right) =\begin{cases}    0\text{，如果}P_1\text{到}P_i\text{没有链入}\\    \frac{1}{m}\text{，}m\text{为}P_1\text{的链出数}\\\end{cases}</script><h3 id="矩阵表示-Matrix-Representation"><a href="#矩阵表示-Matrix-Representation" class="headerlink" title="矩阵表示 | Matrix Representation"></a>矩阵表示 | Matrix Representation</h3><p>令 $w_i=\mathrm{Pr}\left( P_i \right) $，则 $\boldsymbol{w}=\left[ \mathrm{Pr}\left( P_1 \right) ,\mathrm{Pr}\left( P_2 \right) ,\cdots ,\mathrm{Pr}\left( P_N \right) \right] ^T$，再令 $\boldsymbol{B}_i=\left[ \mathrm{Pr}\left( P_i\mid P_1 \right) ,\mathrm{Pr}\left( P_i\mid P_2 \right) ,\cdots ,\mathrm{Pr}\left( P_i\mid P_N \right) \right] $，则有：</p><script type="math/tex; mode=display">w_{i}=B_i\cdot \boldsymbol{w}</script><p>特别地，当 <em>i</em> 取遍 1 到 N 的所有值后， 得到矩阵形式：</p><script type="math/tex; mode=display">\boldsymbol{w}=B\cdot \boldsymbol{w}</script><p>其中 <em>B</em> 称作<strong>标准化链接矩阵</strong>，矩阵中的每个元素代表列号对应的 Page 链入行号对应的 Page 的概率，每列之和为 1。当一个页面没有链出时，这一列全为 0。</p><p>于是我们可以用<strong>迭代</strong>方法求解这个方程的稳定解 $\boldsymbol{w}_k$​​​——即我们想求的访问概率向量，也就是<strong>重要度</strong>向量。只需要将 $\boldsymbol{w}_0$​​​ 设为全 1 向量（因为一开始随机访问到每个页面的概率都相同），不断代入即可。</p><h3 id="阻尼迭代-PageRank-with-Damping"><a href="#阻尼迭代-PageRank-with-Damping" class="headerlink" title="阻尼迭代 | PageRank with Damping"></a>阻尼迭代 | PageRank with Damping</h3><p>然而，现在存在的问题是，上面的所有推导都是建立在理想状态下的，即假设所有网页组成的这个有向图是<strong>强连通</strong>的。</p><p>当 Hyperlink Graph 存在 link loops (<strong>循环陷阱</strong>)，即存在一个小的子图，只有链入没有链出，所有随机游走的用户到了这几个网页后，就如同进了黑洞一般，一直在里面“打转”，出不来了。</p><p>这样就使得当游走次数趋于无穷时，最终陷阱中结点的访问次数远大于其他结点。这样会使得计算出的 $\boldsymbol{w}$ 向量中，陷阱外的结点访问概率都为 0。</p><p>PageRank 算法最终采用了<strong>阻尼因子</strong>（damping factor）的修正，使得进入陷阱后仍有机会跳出循环。</p><script type="math/tex; mode=display">\boldsymbol{w}_k=d\boldsymbol{w}_0+\left( 1-d \right) B\cdot \boldsymbol{w}_{k-1}</script><p>其中 $\boldsymbol{w}_0$​ 为全 1 向量，<em>d</em> 是实验确定的常数，通常取 0.15。</p><h3 id="结合相关度-Combined-Method"><a href="#结合相关度-Combined-Method" class="headerlink" title="结合相关度 | Combined Method"></a>结合相关度 | Combined Method</h3><p>有了重要度向量后，当有查询时，我们只需要先确定<strong>命中文档</strong>（至少有一个 term 与 query 相同的文档），再将其用重要度排序即可。</p><p>然而，这样做的缺点是，没有考虑到查询和文档的相关性——即，有可能一篇文档虽然有相同的 term，但主题却相去甚远。</p><p>于是，有人提出了结合 Term Weighting 和 PageRank 的方法，在确定命中文档后，利用传统的权重计算方法，计算出 query 和每个 doc 的相似度 $s_j$。再和重要度 $p_j$​ 线性加权算出排序指标：</p><script type="math/tex; mode=display">c_j=\lambda s_j+\left( 1-\lambda \right) p_j</script><p>其中 $\lambda$​ 为实验确定的常数。</p><h3 id="PageRank-算法缺点"><a href="#PageRank-算法缺点" class="headerlink" title="PageRank 算法缺点"></a>PageRank 算法缺点</h3><ol><li><p>忽略了查询，则忽略了 query 和 doc 主题相关性，导致结果的相关性降低。</p></li><li><p>没有过滤广告链接和功能链接（例如常见的分享链接）。这些链接通常没有什么实际价值，前者链接到广告页面，后者常常链接到某个社交网站首页。</p></li><li><p>对新网页不友好。因为即使是非常好的新页面也不会有很多链入，要成为一个高重要度的页面仍需要很长时间的推广。</p></li></ol><h2 id="主题敏感-PR-Topic-Sensitive-PageRank"><a href="#主题敏感-PR-Topic-Sensitive-PageRank" class="headerlink" title="主题敏感 PR | Topic-Sensitive PageRank"></a>主题敏感 PR | Topic-Sensitive PageRank</h2><p>在实际的网络中，PageRank 算法还存在「<strong>主题漂移</strong>」问题，特别对于大量随意交互外链的站点，会导致搜索引擎返回主题无关结果。</p><p>同时，前面的讨论提到，PageRank 忽略了 query 的主题相关性，也导致了结果的相关性降低。同一查询词在<strong>不同语境</strong>下，语义上指向的可能是不同的主题，但 PageRank 无论如何都是返回「重要度」最高的页面。</p><p>理想情况下，应为每个用户的偏好维护一套专用的「主题重要度」向量，但面对海量用户这种方法显然不可行。所以搜索引擎一般会选择一种称为主题敏感的折中方案。</p><h3 id="基本思想-Basic-Idea"><a href="#基本思想-Basic-Idea" class="headerlink" title="基本思想 | Basic Idea"></a>基本思想 | Basic Idea</h3><p><strong>基本假设</strong>：在 PageRank 的随机游走模型中，用户倾向于选择具有<strong>同一个主题</strong>的链出网页。</p><p>基于这个假设，可以预定义几个话题类别，例如体育、娱乐、科技等等，对于某个网页来说，对应某个主题类型都有相应的 PageRank 分值，然后想办法关联用户的话题倾向，根据用户的话题倾向排序结果。</p><h3 id="矩阵形式-Matrix-Form"><a href="#矩阵形式-Matrix-Form" class="headerlink" title="矩阵形式 | Matrix Form"></a>矩阵形式 | Matrix Form</h3><p>与原始的 PageRank 不同，新的算法对出度为 0 的网站加以处理以保证<strong>收敛性</strong>。引入了向量 $\boldsymbol{d}$​​​ 来指示某一个网页是否出度为 0，若为 0 则对应项为 1。</p><script type="math/tex; mode=display">d_{i}= \begin{cases}1 & \text { if } \operatorname{deg}(j)=0 \\ 0 & \text { otherwise }\end{cases}</script><p>向量 $\boldsymbol{p}$ 来表示访问各个网页的概率均等，代替 $\boldsymbol{w}_0$​ 的写法：</p><script type="math/tex; mode=display">\boldsymbol{p}=\left[\frac{1}{n}\right]_{n \times 1}</script><p>两个矩阵的乘积所得的矩阵 <em>D</em> 表示出度为 0 的网页将以均等概率访问其他网页。与前述提到的矩阵 $B$​​ 具有互补的特性，补充了在随机游走模型中，一个网页出度为 0 时的访问页面的情况。这样做使得最终矩阵的每一列之和都为 1。</p><script type="math/tex; mode=display">D=\boldsymbol{p} \times \boldsymbol{d}^{T}</script><p>则最终排名的计算方法为：</p><script type="math/tex; mode=display">\boldsymbol{Rank} =d \boldsymbol{p} + (1-d)(B+D) \cdot  \boldsymbol{Rank}</script><h3 id="偏置向量-ODP-Biasing"><a href="#偏置向量-ODP-Biasing" class="headerlink" title="偏置向量 | ODP-Biasing"></a>偏置向量 | ODP-Biasing</h3><p>主题的预定义参考了 <a href="www.dmoz.org">ODP</a> (Open Directory Project) 网站，利用 ODP 中 16 个顶级分类下的 URLs 生成了 16 组偏置 PageRank 向量 (biased PageRank vectors)。</p><p>为了实现这一点，算法中采用了新的向量 $\boldsymbol{v_j}=\boldsymbol{p}$，针对每个主题有：</p><script type="math/tex; mode=display">v_{j i}=\left\{\begin{array}{cl}\frac{1}{\left|T_{j}\right|} & i \in T_{j} \\0 & i \notin T_{j}\end{array}\right.</script><p>其中 $T_{j}$​ 表示在契合第 <em>j</em> 个主题的网页集合。包含在这些网页中的页面被赋予较大的跳转概率值，而其他网站则相对减少。</p><h3 id="查询打分-Query-Time-Importance-Score"><a href="#查询打分-Query-Time-Importance-Score" class="headerlink" title="查询打分 | Query-Time Importance Score"></a>查询打分 | Query-Time Importance Score</h3><p>此外，还需要在给定一个查询 <em>q</em> 的时候，估算出该查询落在某个主题 $c_j$ 的概率。文章使用了<strong>朴素贝叶斯分类器</strong>（naive-Bayes classifier），将查询 <em>q</em> 中的每个 term 分词记作 $q_i$，利用贝叶斯公式：</p><script type="math/tex; mode=display">P\left(c_{j} \mid q\right)=\frac{p\left(c_{j}\right) \cdot P\left(q \mid c_{j}\right)}{P\left(q\right)} \propto P\left(c_{j}\right) \cdot \prod_{i} P\left(q_{i} \mid c_{j}\right)</script><p>而 $P\left(q_{i} \mid c_{j}\right)$ 则容易用统计的方法估计出来，对于 $P\left(c_{j}\right)$​ 则采用<strong>先验概率</strong>的方法，根据用户的查询历史（上下文）进行动态调整。</p><p>计算出了查询落在各个主题的概率后，再用这个概率对各个主题下的 <strong><em>Rank</em></strong> 向量进行线性加权，即可得到最终排序用的评分：</p><script type="math/tex; mode=display">s_{q d}=\sum_{j} P\left(c_{j} \mid q^{\prime}\right) \cdot r_{j d}</script><h2 id="HITS-Hyperlink-Induced-Topic-Search"><a href="#HITS-Hyperlink-Induced-Topic-Search" class="headerlink" title="HITS: Hyperlink-Induced Topic Search"></a>HITS: Hyperlink-Induced Topic Search</h2><p>这里再介绍一种基础的网页排序算法——基于超链接追敏的主题排序，对于一个查询，不再返回单一的网页排名，而是同时返回两个列表：</p><ul><li>包含链接的 Hub 网页，收录了主题相关的权威网页链接。</li><li>包含内容的 Authority 网页，有着与主题相关的高质量内容。</li></ul><p>那么，如何排序这两个列表呢？</p><p><strong>基本假设</strong>：</p><ul><li>一个好的 Hub 网页指向该主题的许多 Authority 网页。</li><li>一个好的 Authority 网页被许多好的 Hub 网页指向。</li></ul><p>基于这两个假设，我们可以提出两个指标来衡量每个页面：枢纽值（Hub Scores）和权威值（Authority Scores），这两种值是互相依存、互相影响的。</p><ul><li>枢纽值，指的是页面上所有出链指向页面的权威值之和。</li><li>权威值，指的是页面的所有入链所在的原页面的枢纽值之和。</li></ul><h3 id="算法步骤-HITS-Algorithm"><a href="#算法步骤-HITS-Algorithm" class="headerlink" title="算法步骤 | HITS Algorithm"></a>算法步骤 | HITS Algorithm</h3><ol><li><p>找出 root set：根据用户 query 中的 term，在文档集中找出包含至少一个 term 的的文档，使他们构成 root set。</p></li><li><p>找出 <strong>base set</strong>：在 root set 的基础上，找出集合中网页链入或链出并且不在 root set 中的网页，并把他们加入到集合中，从而构成 base set。</p></li><li>计算每一个网页的枢纽值 h(x) 和权威值 a(x)，初始时，所有 h 值和 a 值均为 1。</li><li><strong>迭代</strong>更新两个值直至收敛。为了防止两个值太大，可以在每次迭代后归一化。归一化的指标不重要，因为我们只关注相对排名。</li><li>返回两个值分别排序的列表。</li></ol><h3 id="HITS-算法缺点"><a href="#HITS-算法缺点" class="headerlink" title="HITS 算法缺点"></a>HITS 算法缺点</h3><ol><li>尽管限制了计算对象在 base set 中，但在线计算效率还是太低，不如 PR 快。</li><li>主题漂移现象仍未解决。如果在集合里包含与查询主题无关的页面，且含有大量相互链接，可能会排到前列。这种现象被称为<strong>紧密链接社区</strong>现象。</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #8 倒排索引模型</title>
    <link href="/2021/08/25/IR-Note-8/"/>
    <url>/2021/08/25/IR-Note-8/</url>
    
    <content type="html"><![CDATA[<p>文件组织架构，也称 index (索引)，常用于提升一个检索系统的性能。</p><p>回顾向量空间模型，我们知道在查询时，命中的 doc 应该是与 query 最为相近的几个向量。当查询时，若只在所有<strong>可能相似的文档</strong>（至少含有一个 query 中的关键词）中查找，可以大大减少资源浪费。</p><p>那么就需要先得到 query 中各个 term 出现过的文档，再取<strong>并集</strong>，最后在并集中进行相似度的计算——「<strong>过滤</strong>」思想。</p><p>此时用特殊的索引方式，就可以更快地实现文档的过滤。有人提出 Hash 的设想，但是 Hash 的缺点在于不能模糊匹配，当用户的 Query 和词典中的 term 略有差距时，可能在 hash table 中会相距十分遥远。</p><h2 id="倒排文件-Inverted-Files"><a href="#倒排文件-Inverted-Files" class="headerlink" title="倒排文件 | Inverted Files"></a>倒排文件 | Inverted Files</h2><p>我们通过一组对比，引入「<strong>倒排</strong>」的概念：</p><ul><li>正排索引：已知文档 doc，得到 doc 的 所有 term 的位置序列，实现方式是「文档编号 + term 数组」</li><li>倒排索引：已知 term，找到包含 term 的文档 d1, d2, d3… 实现方式是「term做键的字典，值是文档编号数组」</li></ul><p>由此我们可以得到倒排文件组织架构的<strong>构成</strong>：</p><ul><li>Index file：索引文件，以<strong>词典</strong>（Lexicon）的形式存储词项，链接到 Posting file 的空间。</li><li>Postings file：记录文件，以倒排表的形式存储每个 term 对应在 Doc file 中的df、tf、DocID、pos 等相关信息。 </li><li>Document file：文档文件，存储所有文档。</li></ul><p>有了上述的架构，当用户输入 query 时，我们可以提取出 term，直接访问对应的 Index file，再根据链接来到 Posting file。对于多个 term，可以先完成交、并等逻辑运算，得到结果后，再去访问过滤后的文档集。</p><h2 id="构建倒排文件"><a href="#构建倒排文件" class="headerlink" title="构建倒排文件"></a>构建倒排文件</h2><p>由此，我们可以知道当爬取到新的文档时，构建索引的步骤：</p><ol><li>Tokenizer：提取 token 流。</li><li>Linguistic modules：规范化，得到 term 集合。</li><li>Indexer：在对应的 term 键值下新增该文档的编号。</li></ol><h3 id="文档解析-Document-Parsing"><a href="#文档解析-Document-Parsing" class="headerlink" title="文档解析 | Document Parsing"></a>文档解析 | Document Parsing</h3><p>接下来介绍搜索引擎如何解析一个新爬取到的文档，这个过程往往是离线进行的（在线进行的是用户查询过程）。</p><p>而由于文档的多样性，往往解析过程中会面临各式各样的问题：文件格式、各国语言、字符编码、停用词等。这些问题往往用<strong>启发式</strong>（heuristically）的方法解决。</p><ul><li>断词、标记化 | Tokenization</li></ul><p>Token 来自文档的原始字符串，是根据空格划分提取出的原始单词。在实际中，要考虑：是否保留 \’s 、是否保留连字符、专有名词是否拆开、数字嵌入等子问题。</p><p>而针对不同语言，也有更多新的问题：法语中大量的 \’ 使用、德语中名词复合现象、中文日文不适用空格分词、日语的平假片假、阿拉伯语的书写次序等。</p><ul><li>停用词 | Stop words</li></ul><p>在文本中，往往还需要把最频繁出现的无意义词停用。在文档解析中，如何利用停用词进行压缩空间？在查询优化中，如何判别停用词？当停用词有意义时，如何识别？这些都是需要考虑的问题。</p><ul><li>标准化词项 | Normalization</li></ul><p>在英语中，通常时以定义「<strong>等价集</strong>」（equivalence classing）来归并词项。通常将单词归并到其原型，而对于特殊的单词有特殊的规则，例如规定 “U.S.A.” 归并于 “USA”，规定 “anti-discriminatory” 归并于 “antidiscriminatory”。</p><p>对于有的单词，不同形式可能含有不同语义，例如 window/windows/Windows。此时在查询时可以先做<strong>不对称展开</strong>（asymmetric expansion），对展开项搜索后取并集。</p><ul><li>辞典和探测法纠错 | Thesauri &amp; Soundex</li></ul><p>主要针对 Synonyms (同义词)、Homonyms (同形同音异义词)，这种情况下也可以利用等价集和不对称展开解决。</p><p>此外，当用户查询中有英文拼写错误时，常用的方法是 Soundex (探测法)，返回同音字串。Soundex 是基于语音启发式方法生成的<strong>语音等价集</strong>。这种方法在汉语拼音中同样有很大应用。</p><ul><li>词干分析与词形还原 | Stemming &amp; Lemmatization</li></ul><p>将单词的名词、动词、形容词等形式统一归并到<strong>词根</strong>，将单复数、人称所有格、时态等统一归并到<strong>原型</strong>。</p><h3 id="文档文件-Document-file"><a href="#文档文件-Document-file" class="headerlink" title="文档文件 | Document file"></a>文档文件 | Document file</h3><p>解析完文档后，我们可以将新的文档直接存入文档集，也可以利用<strong>摘要生成</strong>技术生成 Surrogates (文档替代品)，减少存储空间。</p><p>此外，当我们搜索到页面文档时，其文件格式可能各不相同，如 HTML、XML 等，故检索到网页后还需要进行 Page Purifing (文档净化)，从而获得便于识别的文本文档和内部链接。</p><h3 id="记录文件-Posting-File"><a href="#记录文件-Posting-File" class="headerlink" title="记录文件 | Posting File"></a>记录文件 | Posting File</h3><p>之前的文章介绍过，用于连接 term 和 doc 的词典表往往是个稀疏矩阵。而倒排文件用<strong>链表</strong>的形式存储每一行的内容，即包含此 term 的所有 doc 及其基本信息，串接而成。链表中的每个元素称为一个 posting (记录)。</p><p>其中，基本信息可以包含：Document ID (文档的唯一标识)、Location Pointer (该文档在 Doc file 中的位置)、原始的权重因子。</p><p>存储原始的权重因子，是为了在查找的时候更方便的计算词项权重。可以包括 df、tf、最大频度、总文档数等等。</p><p>此外，链表中的元素以 Doc ID 排序，这样存储有利于多页倒排表的<strong>合并</strong>匹配。</p><h3 id="索引文件-Index-File"><a href="#索引文件-Index-File" class="headerlink" title="索引文件 | Index File"></a>索引文件 | Index File</h3><p>索引文件通常以词典的形式存储 term ID、含有该 term 的文档数以及该 term 在记录文件中的位置（指针）。</p><p>以下列出几种常用的索引文件组织形式：</p><ul><li><p>Linear Index | 线性索引</p></li><li><p>Binary Tree | 二叉树</p></li><li><p>Right Threaded Binary Tree | 右索二叉树</p></li><li><p>B-trees | B树</p></li><li><p>B+-tree | B+树</p></li><li>Tries | 搜索树</li></ul><h2 id="特征选取-Feature-Selection"><a href="#特征选取-Feature-Selection" class="headerlink" title="特征选取 | Feature Selection"></a>特征选取 | Feature Selection</h2><p>前文提到，在解析一篇文档获得索引时，最简单的方法就是先提取 token，再获得 term 作为索引。而在真正高效的索引模型（Index Model）中，往往要先对文档进行<strong>特征选取</strong>，从而构成索引。</p><p>而特征选择问题，可以转化为词项权重（term weighting）计算，一篇文档中权重较大的 term 往往更能表示这篇文档。</p><h3 id="词项频率-TF"><a href="#词项频率-TF" class="headerlink" title="词项频率 | TF"></a>词项频率 | TF</h3><p>在前面的文章中有提到，tf 及其衍生的权重计算方法，是 IR 模型中最常用的权重计算方法。这里就不再重复介绍，仅提及一个有趣的定理 <code>Zipf&#39;s Law</code>。</p><p>该定理描述了如下现象：在一个大的文档集中，统计出各个词项的 tf 排名后，记排名为 <em>r</em>，频率为 <em>f</em>，则有</p><script type="math/tex; mode=display">f\cdot r\approx \mathrm{const}</script><p>而在实际中，排名最高的词项通常都是停用词，最「<strong>重要</strong>」的词往往词频不是很高，而最罕见的词往往没有普遍价值。这也与 <em>tf·idf</em> 的思想契合，下图说明了这一点。</p><p>在倒排文档中，移除停用词和罕见词、保留重要词，可以节约大量的记录空间。</p><p><img src="/img/blog/IR-Note-8-images/index_tf.png" alt="词项频率与重要度的关系" style="zoom:67%;" /></p><h3 id="索引规模-Index-Scale"><a href="#索引规模-Index-Scale" class="headerlink" title="索引规模 | Index Scale"></a>索引规模 | Index Scale</h3><p>对于一个确定大小的文档集，需要多少词项才能很好的索引全部文档呢？这便是根据文档集大小确定词典大小（Lexicon Size）的问题。<code>Heap&#39;s Law</code> 对此进行了估算：</p><script type="math/tex; mode=display">n=|V|=K \cdot N^{\beta} \text { with constants } K, 0<\beta<1</script><p>其中，<em>K</em> 通常取 10 到 100 间的整数，$\beta$​​​ 通常取 0.4 到 0.6 之间的小数。绘制出的图如下：</p><p><img src="/img/blog/IR-Note-8-images/index_scale.png" alt="索引规模的变化曲线" style="zoom:50%;" /></p><h3 id="词项判别模型-Term-Discrimination-Model"><a href="#词项判别模型-Term-Discrimination-Model" class="headerlink" title="词项判别模型 | Term Discrimination Model"></a>词项判别模型 | Term Discrimination Model</h3><p>在一个向量空间中，文档由<strong>基向量</strong>加权构成的向量表示。</p><p>我们可以计算文档之间的相似度，相似度越高，代表空间越紧凑，反之则越松散。计算文档集两两之间的相似度需要 $O(n^2)$ 的复杂度。</p><p>当然，如果先计算出一个「<strong>平均文档</strong>」，再计算其他文档与其的相似度，则只需要 $O(n)$​ 的复杂度。</p><p>词项判别模型则是通过<strong>引入</strong>一个新的 term 作为基向量，观察相似度的变化分析该 term 的重要性。大致的思想是：</p><ul><li>如果一个 term 引入后，向量空间变松散了，则说明这个 term 有效的区分了不同文档，这个词通常是<strong>中频词</strong>（重要词）。</li><li>如果一个 term 引入后，向量空间没有变化，则说明这个 term 没有太大价值，这个词通常是<strong>低频词</strong>（罕见词）。</li><li>如果一个 term 引入后，向量空间变紧凑了，则说明这个 term 将文档同一化了，这个词通常是<strong>高频词</strong>（停用词）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #7 IRLbot</title>
    <link href="/2021/08/25/IR-Note-7/"/>
    <url>/2021/08/25/IR-Note-7/</url>
    
    <content type="html"><![CDATA[<p>本文是 WWW2008 最佳论文「IRLbot: Scaling to 6 Billion Pages and Beyond」的阅读报告。相关领域：网络信息检索。</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>随着验证 URL 唯一性的复杂度平方增长、BFS 爬行顺序和固定的每主机速率限制，现有的爬虫算法不能有效地应对在大型爬虫中产生的大量 URL、高度分枝的垃圾页面（highly-branching spam）、数百万页博客站点以及服务器端脚本（server-side scripts）产生的无限循环。作者提供了一组处理这些问题的技术，并在称为 IRLbot 的实现中测试它们的性能。</p><p><strong>关键词</strong>：IRLbot, large-scale, crawling</p><h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>作者称本文不是针对数据挖掘器，而是致力于设计能够适应<strong>当前和未来网络规模</strong>的网络爬虫：从一个给定的 seed URL 集合开始，递归地访问集合中的页面，并在这个过程中动态地改变下载顺序，最终可以下载到所有有用的网页；同时，在下载的过程中，无论规模多大，都应当保持一定的速度。</p><p>当然，还有以下考虑：爬虫需要限制对于单一网站、单一服务器的访问频率（礼貌策略），避免陷入垃圾网站和服务器端脚本产生的无限循环。</p><p>具体而言，作者提出了三类问题：</p><h3 id="规模扩展问题-Scalability"><a href="#规模扩展问题-Scalability" class="headerlink" title="规模扩展问题 | Scalability"></a>规模扩展问题 | Scalability</h3><p>每个爬虫系统都必须面对一个固有的取舍：在处理规模（<strong>scalability</strong>）、性能（performance）和硬件资源使用（resource usage）三者中做出权衡。</p><p>一般来说，较大的规模将导致较低的性能与较高的资源使用，较高的性能需要降低规模与增加资源使用。因而，大多数爬虫只能兼顾三者之二（大型慢速爬虫、小型快速爬虫，大型快速却需要占用大量资源的爬虫）。</p><p>本文希望在给定性能标准和硬件资源的情况下，研究规模的扩展问题。</p><h3 id="网站信誉与垃圾网站问题-Reputation-and-Spam"><a href="#网站信誉与垃圾网站问题-Reputation-and-Spam" class="headerlink" title="网站信誉与垃圾网站问题 | Reputation and Spam"></a>网站信誉与垃圾网站问题 | Reputation and Spam</h3><p>与早期的网络相比，如今的网络已发生了很大变化，主要是在服务器端脚本生成的动态网站和垃圾网站两个方面。二者性质不同，却都给爬虫带来了一个新的挑战：必须要有一种在爬虫爬取网页的过程中实时决定<strong>哪些站点包含有用信息</strong>、实时<strong>决定爬取优先级</strong>的方法。</p><p>因为，传统的广度优先搜索往往会由于以下原因而降低效率：</p><ul><li>来自垃圾网站 URL 分支过多，甚至可能取代合法的 URL；</li><li>单个域名中动态创建新主机名，DNS 解析不及；</li><li>来自网页的延迟攻击，故意在来自爬虫程序 IP 地址的所有请求中引入 HTTP 和 DNS 延迟。</li></ul><h3 id="礼貌问题-Politeness"><a href="#礼貌问题-Politeness" class="headerlink" title="礼貌问题 | Politeness"></a>礼貌问题 | Politeness</h3><p>网络爬虫对某一服务器的频繁访问，往往会对服务器的正常性能造成影响，因而也容易招致服务器的拒绝访问或是举报、诉讼，因而需要对爬虫设置一定速度的限制。</p><p>直接给爬虫设置这种对单一服务器、单一 IP 地址的访问速度限制并不复杂，却容易导致爬虫的效率在特定情况下（待爬取的 URL 只来自于极少的几个服务器或 IP，由于限制不得不减慢速度）极大地降低效率。</p><p>因而需要设计一种可以避免这种情况的发生的爬虫。 </p><h2 id="解决规模扩展问题"><a href="#解决规模扩展问题" class="headerlink" title="解决规模扩展问题"></a>解决规模扩展问题</h2><h3 id="磁盘检查算法-Disk-check-Algorithms"><a href="#磁盘检查算法-Disk-check-Algorithms" class="headerlink" title="磁盘检查算法 | Disk-check Algorithms"></a>磁盘检查算法 | Disk-check Algorithms</h3><p>规模问题最终体现在使用 <code>URLseen</code> 确认 URL 的唯一性和使用 <code>RobotsCache</code> 检查 robot.txt 的符合上。此外，还要将新的 URL 再传递给 <code>URLseen</code> ，以及在必要时更新 <code>RobotsCache</code>。主要牵涉到磁盘与存储器的交互。</p><p>在先前的方法中，无论是使用 RAM 散列存储的 <strong>Mrcator-B</strong>，还是使用内存中二叉搜索树的 <strong>Ploybot</strong>，随着爬取规模的增大，执行这一步骤的开销都会快速增长。为了降低这一开销，需要一种更有效的数据存储结构。 </p><h3 id="DRUM-Disk-Repository-with-Update-Management"><a href="#DRUM-Disk-Repository-with-Update-Management" class="headerlink" title="DRUM - Disk Repository with Update Management"></a>DRUM - Disk Repository with Update Management</h3><p>论文中提出了 DRUM 技术，这个技术结合了桶排序和哈希算法。</p><p>DRUM 的目的是允许高效地存储大量 <key, value> 对的集合，其中 key 是某些数据的唯一标识符（hash），value 是附加到密钥的任意信息。通过这样的设计，可以实现对大规模键值对数据的存储，并实现快速的检查（check）、更新（update）、检查＋更新（check+update）的操作。 </p><p>下图展示了 DRUM 的操作流程：</p><p><img src="/img/blog/IR-Note-7-images/DRUM.png" alt="DRUM" style="zoom:50%;" /></p><p>在该图中，一个连续的元组 <key, value, aux> 流到达了 DRUM，其中 aux 是与每个键相关联的一些辅助数据。随后被分割为 <key, value> 与 aux 两个部分，分入内存中的各桶，并在一次操作中将所有的桶中的 <key, value> 与磁盘存储阵列中的数据进行合并。此外，通过读取 cache <em>Z</em> 中的 $\varDelta$ 字块，并与桶中的 key 比较，可以确定其唯一性。</p><p>利用这一技术，在论文中的爬虫系统创建了多个存储模块，包括 <code>URLseen</code> 模块、<code>RobotsCache</code> 模块、<code>RobotsRequested</code> 模块、<code>PLDindegree</code> 模块，分别赋予元组一定的意义，赋予各模块特定的操作，以此大大提高系统规模化的效率。 </p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>论文中主要通过给定一系列参数来推导 <code>URLseen</code> 的开销，从而比较各种数据结构的优劣。参数定义及推导过程详见论文。</p><p>Mrcator-B：</p><script type="math/tex; mode=display">\omega(n, R)=\frac{2(H+P) p H}{R} n^{2}</script><p>Ploybot：</p><script type="math/tex; mode=display">\omega(n, R)=\frac{2(b+4 P) p b q}{R} n^{2}</script><p>DRUM：（论文中公式有两种情况）</p><script type="math/tex; mode=display">\omega(n, R)=n b\left(\frac{(H+b)(2 U H+p H n)}{b D}+2+p+\frac{2 H}{b}\right)</script><p>并做出了如下比较：</p><p><img src="/img/blog/IR-Note-7-images/DRUM2.png" alt="DRUM和其他模型的比较" style="zoom:67%;" /></p><p>可以看出 DRUM 模型的效率远超过原来两个模型。此外论文中还针对磁盘性能和平均爬虫效率（下载速率）做出了比较，这里不再赘述。</p><h2 id="解决垃圾网站问题"><a href="#解决垃圾网站问题" class="headerlink" title="解决垃圾网站问题"></a>解决垃圾网站问题</h2><h3 id="计算站点信誉-Computing-Domain-Reputation"><a href="#计算站点信誉-Computing-Domain-Reputation" class="headerlink" title="计算站点信誉 | Computing Domain Reputation"></a>计算站点信誉 | Computing Domain Reputation</h3><p>拥有大量动态网页的合法网站与制造大量垃圾网页的恶意网站（quickly branching site），都使得爬虫在礼貌性原则、DNS 查找以及爬取本身的限制下变得低效，也会浪费带宽下载许多无用的内容。</p><p>然而，由于互联网规模不断扩大，拥有同样有用大量网页的合法网站与恶意网站相互混杂，使得简单的<strong>限制分支因子</strong>或限制<strong>每个域名的最大 pages/hosts 数量</strong>，并不能合理的解决这个问题。而在之前的研究中，无论是 BFS 的爬取策略，还是 PageRank、BlockRank、SiteRank 算法，也极易使爬虫陷入到这种海量网站中。</p><p>事实上，严格的<strong>页面级排名</strong>对于控制大量分支垃圾网站并不是绝对必要的。作者发现可以通过根据<strong>域名信誉</strong>来判断网页类型、决定对某一域名的网站搜索的深度，域名信誉是根据垃圾网站必须付费的域名资源程度来确定的。</p><h3 id="STAR-Spam-Tracking-and-Avoidance-through-Reputation"><a href="#STAR-Spam-Tracking-and-Avoidance-through-Reputation" class="headerlink" title="STAR - Spam Tracking and Avoidance through Reputation"></a>STAR - Spam Tracking and Avoidance through Reputation</h3><p>论文指出，只要在「域名信誉」的基础上给每个 PLD (Pay-Level Domain) 分配「<strong>预算</strong>」，即可侦测出垃圾网站。论文在 PLD 这个较粗的粒度上进行“预算”的计算，流程如下图：</p><p><img src="/img/blog/IR-Note-7-images/STAR.png" alt="STAR" style="zoom:50%;" /></p><p>利用 DRUM 的存储结构，存储爬虫在爬去过程中得到的 PLD 网络图的信息，构造 <code>PLDindegree</code> 模块。通过模块中考察域名的链入数，为各个域名动态地分配“预算”，并按照“预算”指示单位时间内爬虫能够从该域名爬取多少新的链接，最终避免垃圾网站的困扰。</p><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>从理论上说，从其他 PLD 获得链入需要付出（金钱）代价，一般的垃圾网站在代价面前很可能不会获得高的“预算”，故使用这一方法来鉴别网站的质量。 </p><h2 id="解决礼貌问题"><a href="#解决礼貌问题" class="headerlink" title="解决礼貌问题"></a>解决礼貌问题</h2><h3 id="速率限制-Rate-Limiting"><a href="#速率限制-Rate-Limiting" class="headerlink" title="速率限制 | Rate Limiting"></a>速率限制 | Rate Limiting</h3><p>IRLbot 从一开始的主要目标之一就是在访问配置不佳（就带宽或服务器负载而言）的站点时遵守严格的速率限制策略。尽管较大的站点更难崩溃，但不受限制的访问频率往往也会被视为 DOS 攻击。</p><p>而在之前的研究中，简单地设置单个主机的访问延迟，可能会导致“多主机共用”的<strong>托管服务器</strong>崩溃，若设置单个服务器的访问延迟，又将大大降低效率，甚至可能在大规模的网页中最终无法正常工作。</p><p>另一方面，在已经得到各网站“预算”的情况下，若仅仅只是重复地扫描未爬取的链接队列并从中选取需要爬取的链接，只能在高昂的花费下得到极少的有用链接。因而需要想办法更有效地利用“预算”的结果给出爬取各网页的延迟，才能实现高效的爬虫。 </p><h3 id="BEAST-Budget-Enforcement-with-Anti-Spam-Tactics"><a href="#BEAST-Budget-Enforcement-with-Anti-Spam-Tactics" class="headerlink" title="BEAST - Budget Enforcement with Anti-Spam Tactics"></a>BEAST - Budget Enforcement with Anti-Spam Tactics</h3><p>此方法的目标不是丢弃 URL，而是<strong>延迟</strong>它们的下载，直到更多地了解它们的<strong>合法性</strong>。</p><p>大多数网站的排名较低是因为它们没有权重高的链入，这并不一定意味着它们的内容是无用的，或者它们属于垃圾网站。在所有其他条件相同的情况下，排名较低的域名应该以某种近似循环（round-robin）的方式爬取，并谨慎控制它们的分支。</p><p>此外，随着爬取的进行，域名会改变它们的声誉，而先前未通过预算检查的 URL 需要重新计算预算，并且以不同的速率爬取。</p><p><img src="/img/blog/IR-Note-7-images/BEAST.png" alt="BEAST" style="zoom:50%;" /></p><p>如图所示，在经过修正之后，论文给出了一种不需要依赖数据规模增大硬盘读写能力的实现方式: </p><p>将通过 STAR 赋予了一定预算的成批链接进行检查，将通过检查的、有较高预算的链接按照预算排名高低分到 <em>j</em> 个队列中，将暂时未通过检查的、只有排名的链接分到一个单独的队列 $Q_F$ 中；当前 <em>j</em> 个队列中的链接全部爬取完成后，重新检查队列 $Q_F$，并将其中通过检查的链接分到已有队列的两倍数量的队列中。</p><p>不断重复上述过程，不断动态地增加队列的数量，直至达到某些停止条件。用这种办法可以合理地决定网页的爬取顺序。 </p><h3 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h3><p>采取 BEATS 的办法，一方面保留了队列的不同优先级，使得队列 $Q_F$ 中具有较高预算的链接可以尽快地得到爬取；另一方面利用不断增长的 <em>j</em> 使得预算较低的链接不断地推迟被爬取的时机，实现爬取的延迟。 </p><h2 id="实验验证"><a href="#实验验证" class="headerlink" title="实验验证"></a>实验验证</h2><h3 id="模型构建"><a href="#模型构建" class="headerlink" title="模型构建"></a>模型构建</h3><p>在充分整合 DRUM, STAR, BEAST 技术之后，论文搭建形成了如图所示的爬虫系统 IRLbot。</p><p><img src="/img/blog/IR-Note-7-images/IRLbot.png" alt="IRLbot" style="zoom:50%;" /></p><p>并从 crawling threads 得到新链接开始，涉及到 URL 唯一性确认，“预算”的确认，robot.txt 的确认，“预算”的检查以及最终页面的下载，形成了一个完整的处理流程。 </p><h3 id="效率验证"><a href="#效率验证" class="headerlink" title="效率验证"></a>效率验证</h3><p>论文中提到，在 2007 年 6 月 9 日至 8 月 3 日的这段时间，IRLbot 运行在单一服务器上，并以 1GB/s 的速度连接互联网。最终在 41 天的运行过程中，爬取了 63 亿的页面。</p><p>此外，通过分析排名最高的 1000 个网站，发现其中的大部分网站都非常权威知名，这也说明了 STAR 信誉计算的有效性。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #6 网络信息检索</title>
    <link href="/2021/08/25/IR-Note-6/"/>
    <url>/2021/08/25/IR-Note-6/</url>
    
    <content type="html"><![CDATA[<p>随着互联网的兴起，Web 的增多，网络信息检索成为 IR 中的一大主题。</p><p>简要介绍以下几个相关概念：</p><ul><li>最广的是 Network ，一个物理层面的<strong>广义网络</strong>。</li><li>其次，是互联网。因特网和其他类似的由计算机相互连接而成的<strong>大型网络系统</strong>都可算是互联网，Internet 是互联网中最大的一个。</li><li>再者，是 Internet，即因特网。由许多小的<strong>子网</strong>互联而成的一个逻辑网，每个子网中连接着若干台计算机（主机）。</li><li>最后，是 Web，也称 World Wide Web，即万维网。它使用超文本技术将遍布全球的各种信息资源链接起来，以便于用户访问。Web 只是 Internet 上的一个<strong>应用层服务</strong>。</li></ul><h2 id="网络信息检索-Web-Search"><a href="#网络信息检索-Web-Search" class="headerlink" title="网络信息检索 | Web Search"></a>网络信息检索 | Web Search</h2><p><strong>Goal</strong> | 目标</p><p>Provide information discovery for large amounts of open access material on the web.</p><p><strong>Challenges</strong> | 挑战</p><ul><li><p>Volume of material — several billion items, growing steadily</p></li><li><p>Items created dynamically or in databases (deep web, about 150 times of web pages of surface web) </p></li><li><p>Great variety — length, formats, quality control, purpose, etc.</p></li><li><p>Inexperience of users — range of needs</p></li><li><p>Economic models to pay for the service — 订阅、广告、许可</p></li></ul><p><strong>Strategies</strong> | 策略</p><ul><li>Subject hierarchies (<strong>分类目录</strong>) + human indexing — 1st Generation</li><li>Web crawling (<strong>网页爬取</strong>) + automatic indexing — 2nd Generation</li><li>Human directed web crawling and automatic indexing — Mixed models</li></ul><p><strong>Components</strong> | 组成</p><ul><li>Web crawler: URL Server + <strong>Crawler</strong> + Store Server</li><li>Indexing system: URL Resolver + Indexer + <strong>Pagerank</strong> (离线网页排名算法)</li><li>Search system: Sorter + Searcher (在线检索服务)</li></ul><h2 id="网络爬虫-Web-crawler"><a href="#网络爬虫-Web-crawler" class="headerlink" title="网络爬虫 | Web crawler"></a>网络爬虫 | Web crawler</h2><p>Web crawler，也称 Web spider，用于下载网页的一种程序。只要给出 seed URLs (Uniform Resource Locator) 的初始集，就可以<strong>递归地</strong>（recursively）根据集合中的链接下载更多的页面。有两种特殊的爬虫：</p><ul><li><p>Focused web crawler，针对特定类别的网站的专业爬虫，需要分类方法支持。</p></li><li><p>Deep web crawler，针对动态网页的深网爬虫，需要脚本模拟动作支持。</p></li></ul><p>对于所有的爬虫，最重要的是抓取一个页面中的链接，扩充初始集。</p><p>此外，一个爬虫，还要考虑性能（爬取大量页面）、礼貌性（避免过载服务器、违法操作）、应对故障（破损链接、超时、爬虫陷阱）、搜索策略（DFS/BFS），存储网页（并行文件系统）等。</p><h3 id="礼貌性-Politeness"><a href="#礼貌性-Politeness" class="headerlink" title="礼貌性 | Politeness"></a>礼貌性 | Politeness</h3><p>「恶意爬虫」往往会在短时间内大量访问同一个站点，造成 DDoS 攻击（Distributed denial of service attack，分布式拒绝服务攻击），进而导致网站的瘫痪。此外，还存在非法爬取私人信息、非法收集数据等行为。</p><p>为了在法律上限制爬虫，有以下的协议：</p><p><strong>Robots Exclusion Protocol</strong>：网站管理者可以注明该网站的哪些路径是不可被爬虫访问的，这些协议会体现在 <a href="http://.../robots.txt">http://.../robots.txt</a> 中。</p><p><strong>Robots META tag</strong>：HTML 作者可以注明该页面中的文件不可被索引，或该页面不可被用于解析以获得更多链接。只需要在 HTML 文本中添加以下命令：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robots&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;noindex, nofollow&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="爬虫性能-Performance"><a href="#爬虫性能-Performance" class="headerlink" title="爬虫性能 | Performance"></a>爬虫性能 | Performance</h3><p>爬虫面向的信息往往是极庞大的，超过了一台机器的性能范围。现实中，通常采用<strong>并行分布式</strong>爬虫，将任务量划分到各台机器。那么如何分配任务才能使得各台机器承受的压力均匀呢？</p><h4 id="Distributing-the-Workload"><a href="#Distributing-the-Workload" class="headerlink" title="Distributing the Workload"></a>Distributing the Workload</h4><p>首先可以将机器编号 0 至 N-1，再对一个 URL 的主域名（Domain name）做<strong>哈希</strong>，得到一个 0 至 N-1 的值，并分配到对应机器。这样做的好处有：</p><ul><li>同一域名只在一台机器上访问，这样就可以防止多台机器<strong>同时访问</strong>了同一域名（避免对其造成 DoS 攻击）。</li><li>不需要主服务器的分配，减少了机器间的沟通，主域名下的子域名全在同一台机器中。</li><li>每台机器有独立的 DNS cache (域名缓存)，可以提高查询效率。</li></ul><h4 id="Software-Hazards"><a href="#Software-Hazards" class="headerlink" title="Software Hazards"></a>Software Hazards</h4><p>此外，要提高爬虫的性能，还要实现软件故障的处理：</p><ul><li>过慢、无应答的 DNS/HTTP 服务器</li><li>过大、无限大的页面（自动填充型）</li><li>无限的链接（随时间变化的路径）</li><li>破损的 HTML 页面</li></ul><h4 id="Extract-Links"><a href="#Extract-Links" class="headerlink" title="Extract Links"></a>Extract Links</h4><p>抓取页面中的链接、解析页面中的链接也会遇到许多难题：</p><ul><li>相对路径、绝对路径</li><li>CGI (Common Gateway Interface, 公共网关接口) 动态生成的页面</li><li>Server-side 服务端脚本</li><li>隐藏在 JavaScript 代码中的链接</li></ul><h2 id="爬虫架构-Crawler-Architecture"><a href="#爬虫架构-Crawler-Architecture" class="headerlink" title="爬虫架构 | Crawler Architecture"></a>爬虫架构 | Crawler Architecture</h2><p>接下来介绍一种经典的<strong>分布式</strong>爬虫架构 <code>High performance large scale web spider architecture</code>。</p><p><img src="/img/blog/IR-Note-6-images/WebCrawler1.png" alt="爬虫架构" style="zoom:67%;" /></p><ul><li><strong>URL Manager</strong></li></ul><p>存放所有访问过的 URL 记录，以及待访问队列。</p><ul><li><strong>Pool of data collector</strong></li></ul><p>数据收集池，按照 URL Manager 分配的序列访问网页，内部通常由多台机器多线程地收集网页数据。</p><ul><li><strong>Set of filters</strong></li></ul><p>实现数据统计、页面索引、链接提取的功能，并返回新的连接到 URL Manager。</p><ul><li><strong>Storage manager</strong></li></ul><p>负责压缩、解压缩、存储、检索数据。</p><ul><li><strong>Communicator</strong></li></ul><p>通信器，将新找到的页面和找到它的页面连接，完成 URL 去重等任务。</p><p><img src="/img/blog/IR-Note-6-images/WebCrawler2.png" alt="工作流程"></p><h3 id="URL-队列-URL-Frontier"><a href="#URL-队列-URL-Frontier" class="headerlink" title="URL 队列 | URL Frontier"></a>URL 队列 | URL Frontier</h3><p>URL Frontier 维护了一个包含大量 URL 的队列，并且每当有爬虫线程寻找 URL 的时候，它都会按照某种顺序重新排序。以何种顺序返回队列中的 URL，需要有两个方面的考虑：</p><ul><li>第一个要考虑的是具有很高更新频率的高质量页面，即<strong>页面的优先级</strong>。一个页面的优先级权值应该是由它的改变频率和它本身网页质量（使用一些恰当的质量评估方法）共同决定的。</li><li>第二个要考虑的就是<strong>礼貌策略</strong>：我们必须避免在很短的时间间隔内重复抓取同一个主机。因此，如果URL队列被设计成简单的优先级队列的话，可能会造成对某一主机的大量的访问请求。</li></ul><p><img src="/img/blog/IR-Note-6-images/URL_Frontier.png" alt="URL队列工作流程"></p><p>上图展示了一个基于<strong>礼貌性和权值策略</strong>的URL队列的实现。它的目标是确保：</p><ul><li>每次只有一个连接去访问一台主机；</li><li>连续对同一个主机的访问请求之间存在几秒钟的等待时间；</li><li>具有高优先级的页面将会被优先爬取。</li></ul><p>其中有两个重要的子模块，前部分的 Front 队列集合 F，以及后部分的 Back 队列集合 B。这两种队列均是 FIFO 队列。</p><p>Front 队列实现了对权值相关处理，而 Back 队列实现了对礼貌策略的相关处理。在一条 URL 被添加到队列的过程中，它将会先后穿越 Front 和 Back 队列。</p><p>首先，权值计算器会给该 URL 分配一个介于 1 和 F 之间的整数权值，再进入相应的 Front 队列，具有<strong>很高更新频率</strong>的文档（如新闻页面）将会被赋予一个很高的权值（通过启发式方法）。而后高权值对应的 Front 队列也会更高频率的吞吐 URL。</p><p>此外，我们需要维护一个<strong>堆</strong>，堆里存放着的条目对应每一个 Back 队列，该条目记录着该队列所对应的主机可以再次被连接的最早时间。注意：每个队列仅对应一个主机，即满足分布式的要求。</p><p>请求获取 URL 的爬虫线程会抽取出<strong>堆顶元素</strong>（时间最早者），然后一直等到相应时间后访问之。从而避免访问频率过高。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #5 检索系统评价</title>
    <link href="/2021/08/25/IR-Note-5/"/>
    <url>/2021/08/25/IR-Note-5/</url>
    
    <content type="html"><![CDATA[<p>前述文章介绍了几种基本信息检索模型，本文将介绍如何评价一个现有的文档检索系统。</p><h2 id="Evaluation-in-Document-Retrieval"><a href="#Evaluation-in-Document-Retrieval" class="headerlink" title="Evaluation in Document Retrieval"></a>Evaluation in Document Retrieval</h2><p>一个检索系统的好坏，通常取决于其检索结果与用户查询的相关性，此外还有检索用时、检索范围等等。这里仅针对评价相关性展开讨论。</p><h3 id="相关性-Relevance"><a href="#相关性-Relevance" class="headerlink" title="相关性 | Relevance"></a>相关性 | Relevance</h3><p>如何度量相关性？考虑如下三个待实现的要素：</p><ul><li><p>A <strong>benchmark</strong> document collection (基准文档集)</p></li><li><p>A <strong>benchmark</strong> suite of queries (基准查询集)</p></li><li><p>A <strong>usually binary assessment</strong> of either Relevant or Nonrelevant for each query and each document (对基准查询结果打分)</p></li></ul><p>当然，这个「打分标准」可能会随每个人的<strong>信息需求</strong>而变化（the information need is <strong>translated</strong> into a query），因此这个指标不是确定的（more than binary）。</p><p>有了以上三个基本要素，我们就可以构造出一个合理的<strong>测试集</strong>：包含文档集、查询集和有关评价机制。</p><h3 id="测试集-Test-collections"><a href="#测试集-Test-collections" class="headerlink" title="测试集 | Test collections"></a>测试集 | Test collections</h3><p>在制定测试集的时候，往往要先标注好相关的「查询-文档」对。对于小的测试，可以采用人工标注（遍历文档集和查询集）。</p><p>但对于较大的测试集则不行（如 TREC 测试集）。此时，可以采用如下方法：</p><ul><li>Pooling | <strong>池化</strong></li></ul><p>直接用已有的几个检索系统在「总的基准文档集」中检索，取出每个检索的前 n 个结果，取<strong>并集</strong>，用这个「新的集合」作为「模拟基准文档集」进行标注，这样就可以大大减少范围。</p><ul><li>Sampling | 抽样</li></ul><p>可以通过随机抽样估计真实相关集的大小。</p><ul><li>Search-based</li></ul><p>与其阅读所有的文档，不如人工用较宽泛的 Query 先得到一些检索结果，再在这些结果中标记。</p><h2 id="有效性度量-Effectiveness-measures"><a href="#有效性度量-Effectiveness-measures" class="headerlink" title="有效性度量 | Effectiveness measures"></a>有效性度量 | Effectiveness measures</h2><p>有了合理的测试集，只需要用待测试 IR 查询「基准查询集」的内容，对查询结果与「查询-文档」对比较，即可得到有效性度量。</p><p>以下介绍两个在度量有效性过程中常用的变量。</p><h3 id="精度和召回率-Precision-and-Recall"><a href="#精度和召回率-Precision-and-Recall" class="headerlink" title="精度和召回率 | Precision and Recall"></a>精度和召回率 | Precision and Recall</h3><p>在检索结果的 Top n 中，我们定义如下变量：</p><p>Precision (精度): Proportion of a retrieved set that is relevant.</p><p>Recall (召回率): Proportion of all relevant documents in the collection included in the retrieved set.</p><p>与这两个概念相关的还有 Miss (漏识率) 和 Fallout (误报率)。</p><p>对应的混淆矩阵（Confusion Matrix）如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:center">/</th><th style="text-align:center">相关</th><th style="text-align:center">不相关</th></tr></thead><tbody><tr><td style="text-align:center">检索到</td><td style="text-align:center">A</td><td style="text-align:center">B</td></tr><tr><td style="text-align:center">未检索到</td><td style="text-align:center">C</td><td style="text-align:center">D</td></tr></tbody></table></div><script type="math/tex; mode=display">\text{精度}=\frac{A}{A+B}, \text{召回率}=\frac{A}{A+C}, \text{漏识率}=\frac{C}{A+C}, \text{误报率}=\frac{B}{B+D}</script><p>这样的计算过程没有考虑到检索结果的顺序，事实上相关文档排在前列的搜索引擎才是我们最需要的。</p><h4 id="有序检索-Ranked-retrieval"><a href="#有序检索-Ranked-retrieval" class="headerlink" title="有序检索 | Ranked retrieval"></a>有序检索 | Ranked retrieval</h4><p>考虑搜索引擎返回的结果是有序的，取 Top n，则计算 P/R 的方法可以加以修正：</p><p>对检索到的文档按照 ranking 排列，顺次计算 P/R，每次计算时考虑前 k 个文档。最后会得到一组 n 个 P/R 值，再对 Top n 中的「相关文档」对应的 Precision 取平均。</p><p><img src="/img/blog/IR-Note-5-images/PR_ranking1.png" alt="同一关键词的查询结果" style="zoom:67%;" /></p><p><img src="/img/blog/IR-Note-5-images/PR_ranking2.png" alt="平均值计算" style="zoom:50%;" /></p><p>上图中，我们对搜索引擎 A 和搜索引擎 B 查询了同一关键词，并取了 Top 10 的查询结果，其中各有 5 篇相关文档，经过计算可发现，A 的检索结果更优。</p><p>但是，如果我们要对同一个搜索引擎 A 用不同的关键词来查询呢？</p><p><img src="/img/blog/IR-Note-5-images/PR_ranking3.png" alt="不同关键词的查询结果" style="zoom:67%;" /></p><p>对于不同的 query 可能 Top n 中有数量不同的相关文档，此时的 Recall 就会不一致。如果我们要计算同一 Recall 值处的精度，则需要用到插值方法。</p><h4 id="跨查询平均-Averaging-across-queries"><a href="#跨查询平均-Averaging-across-queries" class="headerlink" title="跨查询平均 | Averaging across queries"></a>跨查询平均 | Averaging across queries</h4><p>仅用个别的 query 难以在数据巨大的文档集中得到准确的 P/R 值。因此需要考虑更多的 query，并对结果再次平均。</p><p>由此，引出两种平均的思想：</p><ul><li>Micro-average (<strong>微平均</strong>): each relevant document is a point in the average. 只针对该搜索引擎下一个 query 的命中结果，求出平均精度。</li><li>Macro-average (<strong>宏平均</strong>): each query is a point in the average (Most Common). 针对该搜索引擎下的许多 query 的微平均精度，再求总的平均精度。</li></ul><p>做宏平均的过程中，最重要的是将所有 query 视作平等的点。因为在微平均的过程中，我们往往只关注一些大样本、常见样本，而这些样本并不能完全体现搜索引擎的性能。而宏平均关注其他小样本、偏僻样本，这些样本的检索结果体现了搜索引擎内部的类别分布是否均匀。</p><p>这种方法也称作 MAP (<strong>Mean Average Precision</strong>)，平均之上的平均。</p><h4 id="绘图-Recall-Precision-graphs"><a href="#绘图-Recall-Precision-graphs" class="headerlink" title="绘图 | Recall/Precision graphs"></a>绘图 | Recall/Precision graphs</h4><p>如果只关注平均精度，则会隐藏检索结果的一些有效信息。如果用图表的形式呈现，则更能观察到趋势。</p><p>如果直接把 ranked retrieval 的结果画在图中，会得到一条「<strong>锯齿状</strong>」的曲线。因为在同一个召回率下，随着结果数的增长，精度是垂直向下的。</p><p><img src="/img/blog/IR-Note-5-images/PR_graph1.png" alt="锯齿状的PR图" style="zoom: 80%;" /></p><p>此时，如果我们想要关注曲线中的：</p><ul><li>特定召回率（10%、20%等）下的精度</li><li>零召回率（系统尚未返回结果）下的精度</li></ul><p>由于各个 query 对应的相关文档总数不同，观测到的召回率点也不同。此时就需要对离散的点用 interpolate (插值)，做出连续的曲线，才能确定这些点的精度。接下来讨论如何选取适合的插值方法。</p><blockquote><p>直接连接各点？连接最大值？连接最小值？连接平均值？</p><p>零召回率时假设为零？假设为最大精度？假设为平均精度？与起始点相等？</p></blockquote><p><strong>基本原则</strong>：从<strong>平均</strong>来看，随着召回率的增加，精度应该是单调递减的。</p><p>基于这个原则，可以得到</p><script type="math/tex; mode=display">P(R)=\max \left\{P^{\prime}: \quad R^{\prime} \geq R \wedge\left(R^{\prime}, P^{\prime}\right) \in S\right\}</script><p>即：选取「当前区间」最大的精度点，再以「召回率大于该点的区间」为「新区间」，选取最大的精度点，迭代至 100%。</p><p>最后用「<strong>阶梯状</strong>」曲线连接以上各点，可以得到单调递减的曲线。</p><p><img src="/img/blog/IR-Note-5-images/PR_graph2.png" alt="阶梯状的PR图" style="zoom:67%;" /></p><h3 id="E-and-F"><a href="#E-and-F" class="headerlink" title="E and F"></a>E and F</h3><p>综合考虑 P/R 值，可以计算出如下<strong>单值评价指标</strong>。</p><h4 id="E-Measure"><a href="#E-Measure" class="headerlink" title="E Measure"></a>E Measure</h4><p>用于强调精度或召回率中的某一个指标，同时兼顾另一个指标。</p><script type="math/tex; mode=display">E=1-\frac{1}{\alpha \frac{1}{P}+(1-\alpha) \frac{1}{R}}</script><p>根据 $\alpha$ 的取值，增大 $\alpha$ 代表强调精度的重要性，反之强调召回率。</p><p>令 $\alpha =\frac{1}{\beta ^2+1}$ ，可以得到</p><script type="math/tex; mode=display">E=1-\frac{\left(\beta^{2}+1\right) P R}{\beta^{2} P+R}</script><p>当 $\beta = 1$ 时可得到二者相同重要性的效果，此时的 $E$ 具有的<strong>物理意义</strong>是所有相关文档 $A+C$ 和所有检索到文档 $A+B$ 的集合的<strong>对称差</strong>的基数除以两个集合的基数。</p><h4 id="F-Measure"><a href="#F-Measure" class="headerlink" title="F Measure"></a>F Measure</h4><p>将 $E$ 取补，可以得到</p><script type="math/tex; mode=display">F_{\beta}=1-E=\frac{\left(\beta^{2}+1\right) P R}{\beta^{2} P+R}</script><p>其中 $F_1$ 分数则是 P/R 值的调和平均，较为平均的兼顾了二者。这是分类与信息检索中最常用的指标之一。</p><script type="math/tex; mode=display">F_{1}=\frac{2 P R}{P+R}=\frac{1}{\frac{1}{2}\left(\frac{1}{R}+\frac{1}{P}\right)}</script><p>之所以使用<strong>调和平均</strong>而不是算术平均，是因为在<strong>算术平均</strong>中，任何一方对数值增长的贡献相当，任何一方对数值下降的责任也相当；而<strong>调和平均</strong>在增长的时候会偏袒较小值，也会惩罚精确率和召回率相差巨大的极端情况，很好地兼顾了精确率和召回率。</p><h3 id="单值评价指标-Other-Single-Valued-Measures"><a href="#单值评价指标-Other-Single-Valued-Measures" class="headerlink" title="单值评价指标 | Other Single-Valued Measures"></a>单值评价指标 | Other Single-Valued Measures</h3><p>类似 $E$ 和 $F$ 这样的单值评价指标之所以重要，是因为这样能够更好的优化度量。此外，在文档评价中，我们还有如下指标：</p><ul><li>期望搜索长度 | Expected search length</li></ul><p>定义在弱顺序文档，量化的用户查找 K 个相关文档所需工作量。这项指标计算预期用户在找到第 K 个相关文档之前，按顺序浏览搜索结果列表将要看到的非相关文档的数量。</p><ul><li>损益平衡点 | Breakeven point</li></ul><p>寻找 Precision 等于 Recall 的点，通常在分类任务中用到。</p><ul><li><strong>平均排序倒数</strong> | <strong>MRR</strong> (Mean Reciprocal Rank)</li></ul><p>对于某些 IR 系统（如问答系统或主页发现系统），只关心第一个标准答案返回的 rank，越前越好，这个位置的倒数称为 Reciprocal Rank (RR) ，对问题集合求平均，则得到 MRR。即，把标准答案在被评价系统给出结果中的排序取倒数作为它的准确度，再对所有的问题取平均。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #4 概率模型</title>
    <link href="/2021/08/25/IR-Note-4/"/>
    <url>/2021/08/25/IR-Note-4/</url>
    
    <content type="html"><![CDATA[<p>前面介绍的模型，都是通过对<strong>相似性</strong>的计算，得出最佳匹配的模型。而概率检索模型，则是基于概率原理，越过相似性，直接对<strong>相关性</strong>进行计算的一种检索模型。</p><p>利用相关性有一个好处，就是对于两个不相似的词，如果它们因为某些因素联系起来了，那么也会出现在检索结果中。</p><h2 id="朴素贝叶斯分类-Naive-Bayes"><a href="#朴素贝叶斯分类-Naive-Bayes" class="headerlink" title="朴素贝叶斯分类 | Naive Bayes"></a>朴素贝叶斯分类 | Naive Bayes</h2><p>贝叶斯公式是概率论中非常基础的公式，其解决的核心点在于根据已有信息，对未知事物发生结果的概率计算。这里简单介绍一下作为模型的引入。</p><p>如果我们有文档 <em>D</em>，可以记 $P(R=1|D)$ 为文档和查询相关的概率（这里的 <em>R</em> 只有 0 和 1 两种取值），这表示在文档确定的情况下，发生 $R=1$ 假设的<strong>后验概率</strong>。</p><p>与此同时，$P(R=1)$ 可以表示该假设的<strong>先验概率</strong>，意思是在完全对文档无所知的情况下，这个文档的<strong>分类</strong>情况满足假设的概率。</p><p>以下我们将 $R=1$ 简写为 <em>R</em>，$R=0$ 简写为 <em>NR</em>，表示一下贝叶斯公式：</p><script type="math/tex; mode=display">P(R|D) = \frac{P(RD)}{P(D)} = \frac{P(D|R)P(R)}{P(D)}</script><p>实际上，贝叶斯公式是做了一个转换，将复杂的概率式转化为三个更好计算的概率式。</p><ul><li>$P(D)$ 表示随机选取一篇文档，恰好是特定的 <em>D</em> 的概率，这个概率对于所有文档都是一致的，如果只是作比较，就不需要考虑。</li><li>$P(R)$ 表示假设 <em>R</em> 成立的先验概率，如果有已知的数据集，我们可以用相似文档的频率近似概率；如果没有，也可以先设为 0.5。但应用在比较中，也是不需要考虑的。</li><li>$P(D|R)$ 表示任意一篇文档被归类为相似后，恰好是特定的 <em>D</em> 的概率，需要所用特殊的方法来估计。</li></ul><p>所以，<strong>判断</strong>一篇文档是否相似，只需要比较 $P(R|D)$ 和 $P(NR|D)$ 两个值的大小，就是比较 $P(D|R)P(R)$ 和 $P(D|NR)P(NR)$。</p><h2 id="概率检索-Probabilistic-Retrieval"><a href="#概率检索-Probabilistic-Retrieval" class="headerlink" title="概率检索 | Probabilistic Retrieval"></a>概率检索 | Probabilistic Retrieval</h2><p>概率检索模型与贝叶斯分类的思想非常接近，但还是有本质区别的。概率检索模型的根本目的不是<strong>分类</strong>，它不需要根据查询判断一个文档属于“相关”或者“不相关”，而是计算这个文档属于属于“相关”或者“不相关”的<strong>概率大小</strong>为文档<strong>排序</strong>。</p><p>因此，在概率检索模型中，我们首先要定义一个<strong>相关度指标</strong>，考虑前文中提到的 $P(D|R)P(R)$ 和 $P(D|NR)P(NR)$，由于 $P(R)$ 和 $P(NR)$ 在同一个查询下对所有文档都是一致的，因此只要关注剩余部分之比（也称为<strong>优势率</strong>）：</p><script type="math/tex; mode=display">\alpha = \frac{P(D|R)}{P(D|NR)}</script><p>显然，这个比值越大，代表该文档与查询的相关度越大，因此我们最后就通过 $\alpha$ 将文档排序。</p><h3 id="风险最小化-Risk-Minimization"><a href="#风险最小化-Risk-Minimization" class="headerlink" title="风险最小化 | Risk Minimization"></a>风险最小化 | Risk Minimization</h3><p>此外，在检索过程中，我们还要决定一篇文档是否被召回，即设定一个<strong>召回阈值</strong>。一般我们会选择<strong>贝叶斯最优决策定理</strong>（Bayes’ Optimal Decision Rule）来决定一个文档是否相关，进而确定是否将其返回。</p><p>所谓的贝叶斯最优决策定理其实很简单，当 $P\left( R|D \right) &gt;P\left( NR|D \right) $ 时，我们认定该文档是相关文档，将其返回。</p><p>但在实际中，我们还要考虑<strong>最小化期望损失</strong>（<strong>也称为贝叶斯风险</strong>，Bayes Risk），即「返回一篇不相关文档」或「没有返回一篇相关文档」的损失。</p><p>举个例子，在就诊看病的过程中，将患病者诊断为「健康」而错失治疗时机，远比健康者诊断为「患病」代价大得多。因此我们也认为「没有返回一篇相关文档」的代价要大于「返回一篇不相关文档」。</p><p>如果记 $c_{rr}$ 为 cost of deciding <strong>relevant when relevant</strong>， $c_{rn}$ 为 cost of deciding <strong>relevant when not relevant</strong>，$c_{nn}$ 和 $c_{nr}$ 同理。那么就有：</p><script type="math/tex; mode=display">c_{nr}P\left( R|D \right) +c_{nn}P\left( NR|D \right) >c_{rn}P\left( NR|D \right) +c_{rr}P\left( R|D \right)</script><p>移项，并引入贝叶斯公式后：</p><script type="math/tex; mode=display">\left( c_{nr}-c_{rr} \right) P\left( D|R \right) P\left( R \right) >\left( c_{rn}-c_{nn} \right) P\left( D|NR \right) P\left( NR \right)</script><p>结合相关度指标，可以等到新的阈值：</p><script type="math/tex; mode=display">\alpha =\frac{P(D|R)}{P(D|NR)}>\frac{\left( c_{rn}-c_{nn} \right)P\left( NR \right)}{\left( c_{nr}-c_{rr} \right)P\left( R \right)}</script><h2 id="二值独立检索-Binary-Independence-Retrieval"><a href="#二值独立检索-Binary-Independence-Retrieval" class="headerlink" title="二值独立检索 | Binary Independence Retrieval"></a>二值独立检索 | Binary Independence Retrieval</h2><p>前面提到，$P(D|R)$ 表示任意一篇文档被归类为相似后，恰好是特定的 <em>D</em> 的概率，在通常的<strong>朴素贝叶斯分类</strong>中，通常有两种方法来估计：</p><ul><li>用 <em>D</em> 在类别 <em>R</em> 中的比例来估计，显然，这个方法在检索中不适用，因为同一文档 <em>D</em> 几乎不可能在 <em>R</em> 中出现过。</li><li>将 <em>D</em> 看作由 0 和 1 <strong>二值</strong>组成的向量，每个维度代表了一种词项是否包含在该文档中，默认词项之间是相互<strong>独立</strong>的，然后用下面的公式计算：</li></ul><script type="math/tex; mode=display">P(D|R) = \prod_{T_i \in D}{P(T_i=1|R)}\prod_{T_j \notin D}{P(T_j=0|R)}</script><p>其中，<em>T</em> 就代表文档中的词项 term，$P(T|R)$ 就是该词项在归类为相似的文档集中<strong>出现或不出现</strong>的概率。</p><h3 id="公式推演"><a href="#公式推演" class="headerlink" title="公式推演"></a>公式推演</h3><p>在以上的概念下，不妨记：</p><ul><li>相似文档集中 $P(T_k=1|R)$ 为 $p_k$，$P(T_k=0|R)$ 为 $1-p_k$。</li><li>不相似文档集中 $P(T_k=1|NR)$ 为 $q_k$，$P(T_k=0|NR)$ 为 $1-q_k$。</li></ul><p>则相关度指标可表示为：</p><script type="math/tex; mode=display">\alpha = \frac{\prod_{T_k \in D}p_k \prod_{T_k \notin D} 1 - p_k}{\prod_{T_k \in D}q_k \prod_{T_k \notin D}1 - q_k}</script><p>再做一个数学上的等价变换，如下：</p><script type="math/tex; mode=display">\begin{aligned}\alpha &= \frac{\prod_{T_k \in D}p_k \prod_{T_k \notin D}1 - p_k}{\prod_{T_k \in D}q_k \prod_{T_k \notin D}1 - q_k} = \frac{\prod_{T_k \in D}p_k}{\prod_{T_k \in D}q_k} \cdot \frac{\prod_{T_k \notin D}1 - p_k}{\prod_{T_k \notin D}1 - q_k}\\&= (\frac{\prod_{T_k \in D}p_k}{\prod_{T_k \in D}q_k} \cdot \frac{\prod_{T_k \in D}1 - q_k}{\prod_{T_k \in D}1 - p_k}) \cdot (\frac{\prod_{T_k \in D}1 - p_k}{\prod_{T_k \in D}1 - q_k} \frac{\prod_{T_k \notin D}1 - p_k}{\prod_{T_k \notin D}1 - q_k})\\&= \frac{\prod_{T_k \in D}p_k(1 - q_k)}{\prod_{T_k \in D}q_k(1 - p_k)} \cdot \frac{\prod 1 - p_k}{\prod 1 - q_k} \end{aligned}</script><p>在同一查询下，相似文档集和不相似文档集是固定的，也就是说 $p_k$ 和 $q_k$ 的值也是相同的。故公式的第二部分（与文档 <em>D</em> 无关）可以忽略，简化成</p><script type="math/tex; mode=display">\alpha=\prod_{T_k \in D}\frac{p_k(1 - q_k)}{q_k(1 - p_k)}</script><p>取对数将乘积转化为求和得到用于排序的两，称为 RSV (Retrieval Status Value，<strong>检索状态值</strong>)：</p><script type="math/tex; mode=display">RSV_D=\sum_{T_k \in D} \left(\log \frac{p_k}{1 - p_k} + \log \frac{1 - q_k}{q_k} \right)</script><h3 id="Estimation-using-training-data"><a href="#Estimation-using-training-data" class="headerlink" title="Estimation using training data"></a>Estimation using training data</h3><p>现在我们只要计算出 $p_k$ 和 $q_k$ 的值就成功了。在计算之前，我们先写出下面的索引项出现列联表：</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">相关文档</th><th style="text-align:center">不相关文档</th><th style="text-align:center">总数</th></tr></thead><tbody><tr><td style="text-align:center"><strong>包含</strong>词项 $T_k$</td><td style="text-align:center">r</td><td style="text-align:center">n-r</td><td style="text-align:center">n</td></tr><tr><td style="text-align:center"><strong>不包含</strong>词项 $T_k$</td><td style="text-align:center">R-r</td><td style="text-align:center">N-n-R+r</td><td style="text-align:center">N-n</td></tr><tr><td style="text-align:center"><strong>总数</strong></td><td style="text-align:center">R</td><td style="text-align:center">N-R</td><td style="text-align:center">N</td></tr></tbody></table></div><p>则可以得到估算式：</p><script type="math/tex; mode=display">p_k=\frac{r}{R}, q_k=\frac{n-r}{N-R}</script><p>同时，为了避免可能出现的<strong>零频问题</strong>（比如所有的相关文档都包含或不包含某个特定的词项），一种很常规的做法是在之前的表格中的每个量的基础上都加上 0.5 来<strong>平滑处理</strong>，因此总数也做相应改变：</p><script type="math/tex; mode=display">p_k=\frac{r+0.5}{R+1}, q_k=\frac{n-r+0.5}{N-R+1}</script><h3 id="Estimation-without-training-data"><a href="#Estimation-without-training-data" class="headerlink" title="Estimation without training data"></a>Estimation without training data</h3><p>用上式代入得到的计算式也称作 <code>Robertson-Sparck Jones</code> 等式，这个式子的计算条件是知道相关文档总数 R，但实际上大多数时候我们都是不知道的。</p><p>一种可行的方案是，初始时令相关文档数为 0，这是因为在实际检索情景下，文档库中往往只有少部分是和查询词相关的内容：</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">相关文档</th><th style="text-align:center">不相关文档</th><th style="text-align:center">总数</th></tr></thead><tbody><tr><td style="text-align:center"><strong>包含</strong>词项 $T_k$</td><td style="text-align:center">0</td><td style="text-align:center">n</td><td style="text-align:center">n</td></tr><tr><td style="text-align:center"><strong>不包含</strong>词项 $T_k$</td><td style="text-align:center">0</td><td style="text-align:center">N-n</td><td style="text-align:center">N-n</td></tr><tr><td style="text-align:center"><strong>总数</strong></td><td style="text-align:center">0</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr></tbody></table></div><p>此时的 $p_k$ 值可以用常数来代替，如 0.3。</p><h2 id="修正公式"><a href="#修正公式" class="headerlink" title="修正公式"></a>修正公式</h2><p>在本文的最后，我们再来讨论一个问题，在前面讲到的 $p_k$ 和  $q_k$的值估算过程中，我们其实是用到了之前提过的<strong>文档频率</strong> <em>df</em>。</p><p>而在之前的文章中，还有词频、逆文档频率、文档长度等等多种因素未被考虑到。因此，基于最初的原理和假设，可以对原来的 RSV 公式增加修正因子，使得模型更加精确。</p><h3 id="BM25-Weighting"><a href="#BM25-Weighting" class="headerlink" title="BM25 Weighting"></a>BM25 Weighting</h3><p>这是一种最常用的加权方法，考虑了<strong>词频</strong>和<strong>文档长度</strong>。BM25 模型为文档 $D_i$ 每个词项项 $T_j$ 分配了一个系数 $B_{i,j}$ ，由下计算生成：</p><script type="math/tex; mode=display">B_{i,j}=\frac{\left( K_1+1 \right) f_{i,j}}{K_1\left[ (1-b)+b\frac{\mathrm{len}\left( D_i \right)}{\,\,\mathrm{avg}\_\mathrm{doclen}} \right] +f_{i,j}}</script><p>其中，$K_1$ 和 <em>b</em> 为经验参数，用于调节词频和文档长度在权重计算中起到的作用，一般来讲， $K_1$ 取 1，<em>b</em> 取 0.75 已经被证明是合理的假设。而 $f_{i,j}$ 则为词项 $T_j$ 在文档 $D_i$ 中的词频，avg_doclen 为平均文档长度。</p><h3 id="Multiple-Fields"><a href="#Multiple-Fields" class="headerlink" title="Multiple Fields"></a>Multiple Fields</h3><p>在 BM25 的之后，还有一种针对其提出的修正方法。将文档划分成不同的<strong>域</strong>，如：title/abstract/body，并对不同域赋予不同的权重（每个 term 出现的<strong>当量</strong>不同）。例如，term 在标题出现 1 次相当于在 abstract 出现 1.5 次。</p><p>同理，文档长度也相应的进行加权调整，最后可以计算出新的修正因子：</p><script type="math/tex; mode=display">\begin{aligned}\widetilde{t f}_{i} &=\sum_{s=1}^{S} w_{s} t f_{s i} \\\widetilde{d l} &=\sum_{s=1}^{S} w_{s} s l_{s}\end{aligned}</script><p>最后计算出的频度替换原始的频度，代入 BM25 Weighting 公式。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #3 向量空间模型</title>
    <link href="/2021/08/22/IR-Note-3/"/>
    <url>/2021/08/22/IR-Note-3/</url>
    
    <content type="html"><![CDATA[<p>回忆前两个模型，我们发现统计语言模型在布尔模型上，做出了最佳匹配和排序结果的改进。但是，仍然没有考虑到「<strong>词项的权重</strong>」。</p><p>在向量空间模型中，我们容易联想到用向量来表示文档和查询，再通过计算余弦来得到两个向量的距离，从而得到相似性度量。</p><p>那么，如何选取向量空间 basis vector (基向量)？如何将目标转化为向量？如何为各个维度选取 magnitide (幅值)，从而考虑权重？如何在高维空间计算向量距离？</p><h2 id="向量空间模型-Vector-Space-Model"><a href="#向量空间模型-Vector-Space-Model" class="headerlink" title="向量空间模型 | Vector Space Model"></a>向量空间模型 | Vector Space Model</h2><p>通常地，我们选择用 linearly independent (线性独立) 或 orthogonal (正交) 的基向量来张成<strong>向量空间</strong>，这样可以使得维度最少。那么，如何选取基向量？</p><p>这是一个特征选择问题，在 IR 中，通常有两种方式：</p><ol><li><p>Core concept (核心概念) 的思想：把词语的类型分类，按照其在不同分类上的「倾斜程度」决定向量的值，可以使维度尽量少。但是，由于语义上的多样性，很难实现。目前有 WordNet, HowNet, HNC 等模型。</p></li><li><p>把出现过的 term 都当作是一个基向量，并<strong>假设</strong>所有的基向量都是相互正交、相互独立的。这样将会得到一个维度不断增长的向量空间（随着词典表扩大）。</p></li></ol><p>以下我们采用第二种方式。一个 Doc 或 Query 的向量表示就是：所有出现在文档中的 term 的向量之和。</p><h3 id="词项权重-Term-Weighting"><a href="#词项权重-Term-Weighting" class="headerlink" title="词项权重 | Term Weighting"></a>词项权重 | Term Weighting</h3><p>当一个 term 在文档中不断出现时，在这个方向上的向量幅值就会很大。这样比起布尔模型的 0/1 二值，更能反映了这个 term 的重要性。这便是决定权重的 <em>tf</em> (<strong>term frequency</strong>，词项频率) 方法。</p><p>然而，原始的 <em>tf</em> 值会面临这样一个严重的问题：即在和查询进行相关度计算时，所有 term 都被认为是同等重要的。</p><p>实际上，某些 term 对于相关度计算来说几乎没有或很少有区分能力。一个很直接的想法就是给包含在较多文档中的词项赋予较低的权重。为此，引入变量 <em>df</em> (<strong>document frequency</strong>，文档集频率)，即有多少文档包含了该 term。df 值越大，说明该 term 越不重要。</p><p>为了计算的方便，将其标准化得到 <em>idf</em> (<strong>inverse document frequency</strong>，逆文档频率)：</p><script type="math/tex; mode=display">idf_t=\log \left( \frac{N}{df_t} \right)</script><p>观察该式发现，<em>idf</em> 虽然可以使得在较多文档中的词项权值降低，但与 <em>tf</em> 相反的是，这样做的缺点是：对那些极少出现的词极度敏感。</p><p>为此，我们将二者结合在一起，诞生了 <strong><em>tf·idf</em></strong> 方法——在文本处理领域中使用最广泛的数值权重计算方法。方法基于的思想和构造的统计量都很简单，但是在实际中却表现了很好的性能。</p><p>在 VSM 中，我们会将词项的 <em>tf·idf</em> 存储在词典表（词项-文档）矩阵中，作为向量的幅值，用于后续的计算。</p><h3 id="相似度计算-Similarity"><a href="#相似度计算-Similarity" class="headerlink" title="相似度计算 | Similarity"></a>相似度计算 | Similarity</h3><p>当我们已经把文档表示成 $R^{v}$ 上的向量，从而可以计算文档与文档之间的相似度（根据向量内积或者<strong>余弦夹角</strong>）。</p><p>设 $D_1$ 和 $D_2$ 表示 VSM 中的两个向量：</p><script type="math/tex; mode=display">\begin{aligned}&D_{1}=D_{1}\left(w_{11}, w_{12}, \ldots, w_{1 n}\right) \\&D_{2}=D_{2}\left(w_{21}, w_{22}, \ldots, w_{2 n}\right)\end{aligned}</script><p>可以借助于 N 维空间中两个向量之间的某种距离来表示文档之间的相似度，常用的方法是使用向量之间的內积来计算：</p><script type="math/tex; mode=display">\operatorname{Sim}\left(D_{1}, D_{2}\right)=\sum_{k=1}^{n} w_{1 k} \times w_{2 k}</script><p>考虑到向量的<strong>归一化</strong>，则可以使用两个向量的余弦值来表示相似系数：</p><script type="math/tex; mode=display">\operatorname{Sim}\left(D_{1}, D_{2}\right)=\cos \theta=\frac{\sum_{k=1}^{n} w_{1 k} \times w_{2 k}}{\sqrt{\sum_{k=1}^{n} w_{1 k}^{2} \sum_{k=1}^{n} w_{2 k}^{2}}}</script><p>要注意，这里使用向量内积，是基于对所有向量相互独立、相互正交的假设，否则计算内积也就失去了意义。对于相关的基向量，应该评估 Term 之间的相关度 $T_{i,j}$，再把向量当成多项式计算，最后代入 $T_{i,j}$。</p><p>此外，在其他的考虑权重的模型中，如 Lucene，在计算相似度时引入了更多的因子，如 <em>tf·idf</em>，$boost_t$，<em>overlap(q,d)</em> 等，对应用情形、平滑度加以考量。</p><h3 id="VSM-实际应用"><a href="#VSM-实际应用" class="headerlink" title="VSM 实际应用"></a>VSM 实际应用</h3><p>在 IR 中应用 VSM 模型时，相似度在检索结果中有两种体现：</p><ol><li><strong>Threshold</strong> (阈值)：对于每个查询，只在相似度大于一定阈值的文档中检索，如 Sim &gt; 0.50 的文档中，减少查询范围。</li><li><strong>Ranking</strong>：对于每个查询，返回相似度排名 Top n 的文档，以相似度排序。</li></ol><p>而 VSM 模型也有着致命的<strong>缺点</strong>：</p><ul><li><p>对于大的文档集（10w+ term），向量维度太多导致难以存储和计算。</p></li><li><p>一篇文档的词数（1k+ term）远低于总的词数——高维稀疏矩阵。</p></li><li>词项之间的相关性，导致了大量冗余的基向量。</li></ul><h2 id="潜层语义索引-Latent-Semantic-Indexing"><a href="#潜层语义索引-Latent-Semantic-Indexing" class="headerlink" title="潜层语义索引 | Latent Semantic Indexing"></a>潜层语义索引 | Latent Semantic Indexing</h2><p>潜层语义索引，也被称为 LSA (Latent Semantic Analysis，潜在语义分析)，是针对向量空间的「<strong>高维稀疏</strong>」问题提出的解决方法，利用线性代数中的<strong>奇异值分解</strong>降低维度（去除噪音），同时尽量减少信息的损失。</p><h3 id="奇异值分解-Singular-Value-Decomposition"><a href="#奇异值分解-Singular-Value-Decomposition" class="headerlink" title="奇异值分解 | Singular Value Decomposition"></a>奇异值分解 | Singular Value Decomposition</h3><p>参考：<a href="https://www.cnblogs.com/pinard/p/6251584.html">https://www.cnblogs.com/pinard/p/6251584.html</a></p><p>对于一个 $t\times d$​​ 矩阵 $A$​​​，可以分解为下面三个矩阵：</p><script type="math/tex; mode=display">A_{t\times d}=U_{t\times t}\varSigma _{t\times d}V^T_{d\times d}</script><p>其中 $U$​ 和 $V$​ 都是<strong>酉矩阵</strong>，即满足 $U^TU=I, V^TV=I$​。$\varSigma$​ 一个 $t\times d$​ 矩阵，除了主对角线上的元素以外全为 0，主对角线上的每个元素都称为<strong>奇异值</strong>。</p><p>利用酉矩阵性质得：</p><script type="math/tex; mode=display">A=U\Sigma V^T \Rightarrow A^T=V\Sigma^T U^T \Rightarrow A^TA = V\Sigma^T U^TU\Sigma V^T = V\Sigma^2V^T</script><p>可以看出 $A^TA$ 的特征向量组成的矩阵，就是我们 SVD 中的 $V^T_{d\times d}$​ 矩阵。进一步我们还可以看出我们的特征值矩阵等于奇异值矩阵的平方。</p><p>利用以上原理，我们可以得出 SVD <strong>分解步骤</strong>：</p><ol><li>假设词典矩阵为 $A$，首先求出 $AA^T$，会得到一个 $t\times t$ 的方阵。</li><li>既然是方阵，就可以进行特征值分解，得到 <em>t</em> 个特征值和对应的特征向量。</li><li>将特征值按方差大小排序，用所有的列向量张成一个 $t\times t$ 的矩阵 $U_{t\times t}$。</li><li>同理可以用 $A^TA$ 求出 $d\times d$ 的矩阵 $V^T_{d\times d}$。</li><li>利用前面求出的特征值，开方后得到 $\varSigma _{t\times d}$。​</li></ol><h3 id="利用-SVD-降维"><a href="#利用-SVD-降维" class="headerlink" title="利用 SVD 降维"></a>利用 SVD 降维</h3><p>对于奇异值，它跟我们特征分解中的特征值类似，在奇异值矩阵中也是按照从大到小排列。通常，奇异值的<strong>衰减</strong>得特别快，在很多情况下，前 10% 甚至 1% 的奇异值之和就占了全部的奇异值之和的 99% 以上的比例。</p><p>也就是说，我们也可以用最大的 k 个的奇异值和对应的左右奇异向量来近似描述矩阵。也就是说：</p><script type="math/tex; mode=display">A_{t\times d}=U_{t\times t}\varSigma _{t\times d}V^T_{d\times d}\approx U_{t\times k}\varSigma _{k\times k}V^T_{k\times d}</script><p>其中 <em>k</em> 要比 <em>t</em> 小很多，也就是一个大的矩阵可以用三个小的矩阵，此时存储空间可以大量节省。通常 <em>k</em> 的值即为我们假设的<strong>主题数</strong>。</p><p>SVD 分解后，$U_{il}$ 对应第 <em>i</em> 个词和第 <em>l</em> 个词义的相关度。$V_{jm}$ 对应第 <em>j</em> 个文档和第 <em>m</em> 个主题的相关度。$\Sigma_{lm}$ 对应第 <em>l</em> 个词义和第 <em>m</em> 个主题的相关度。</p><p>这样我们通过一次 SVD，就可以得到词和词义的相关度，词义和主题的相关度，以及文档和主题的相关度。</p><h3 id="LSI-的使用"><a href="#LSI-的使用" class="headerlink" title="LSI 的使用"></a>LSI 的使用</h3><p>通过计算后，我们关注新的矩阵 $V^T_{k\times d}$​ ，所有的文档已经简化成了和 k 个主题的相关度。假设此时的查询为 $Q=q_1q_2\cdots q_t$​​​​，​其中 <em>q</em> 取 0 或 1，则</p><script type="math/tex; mode=display">Q_{1\times k}=Q_{1\times t}U_{t\times k}\varSigma _{k\times k}</script><p>可将 <em>t</em> 维的查询转化成 <em>k</em> 维的「<strong>与主题的相关度</strong>」，此时就可以与文档进行相似度计算了。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #2 统计语言模型</title>
    <link href="/2021/08/22/IR-Note-2/"/>
    <url>/2021/08/22/IR-Note-2/</url>
    
    <content type="html"><![CDATA[<p>基于对布尔模型的改进，提出一种新的最佳匹配模型。</p><h2 id="统计语言模型-Statistical-Language-Models"><a href="#统计语言模型-Statistical-Language-Models" class="headerlink" title="统计语言模型 | Statistical Language Models"></a>统计语言模型 | Statistical Language Models</h2><p>首先探讨的是 Doc (文档) 的呈现形式，引入 Topic (<strong>主题</strong>) 来表述一个文档的隐含语义，起到索引作用。基于以下两个假设：</p><ul><li>Words common in document are common in topic.</li><li>Words not in document much less likely.</li></ul><p>可以得出，Topic 是由 Doc 中的一些关键词勾勒出来的。于是引入 $P(w|Doc)$ 概率分布表：统计每个词在文档中出现频度（频率）——基于大数定律。</p><p>但 Topic 的难确定性（语义理解不同、可能有多个主题）导致其难以直接计算，因此可以用近似估算。</p><script type="math/tex; mode=display">P\left( w|Topic_D \right) \approx P\left( w|D \right) =tf\left( w,D \right) /len\left( D \right)</script><p>事实上，我们可以认为 Topic 是一种「<strong>语言模型</strong>」，$P\left( w|Topic_D \right)$ 可以认为是在 Topic 下生成该 word 的概率，即该 word 在这个「语言模型」中被生成的概率，故 word 可以不在 Topic 中出现，但也有概率生成。</p><h3 id="语言模型化-Language-Modeling"><a href="#语言模型化-Language-Modeling" class="headerlink" title="语言模型化 | Language Modeling"></a>语言模型化 | Language Modeling</h3><p>定义 <em>M</em> 为我们试图描述的 language (语言)，<em>s</em> 为该语言下观测到的文本串（由许多词条构成）。</p><ul><li><p><em>M</em> can be thought of as a “source” or a generator - a <strong>mechanism</strong> that can spit out strings that are legal in the language.</p></li><li><p>$P(s|M)$ is the probability of getting “<em>s</em>” during random sampling from <em>M</em>.</p></li></ul><p>语言的规模可大可小，把每种语言的规模缩小为一个 Topic（对应着语料库中的一个文档）；这个 Topic 就决定了任意一个字符串在这个 Topic 所对应的「语言模型」中出现的概率：比如，在一个描述信息检索发展历史的文档中，“Washington” 出现的概率就会远远小于 “Robertson”。</p><p>那么，一旦我们确定了这个 Doc 所对应的「语言模型」$M_D$ ，而 <em>Q</em> 是用户的 Query，我们是不是可以求出这个「语言模型」下<strong>生成</strong> <em>Q</em> 的概率？概率最大者就是与查询最相关的文档。那么，我们就可以根据 $P(Q|M_D) $ 给所有的 Doc 排序，得到我们的查询结果。</p><h2 id="多元语言模型-N-gram-Language-Models"><a href="#多元语言模型-N-gram-Language-Models" class="headerlink" title="多元语言模型 | N-gram Language Models"></a>多元语言模型 | N-gram Language Models</h2><p>对于一个较长的 Query，我们采用<strong>分词</strong>的方法来计算它的生成概率。为此，首先通过几个例子明确语言模型中 N-gram 的概念：</p><ul><li>Unigram 一元分词，把句子分成一个一个的汉字，如：哈/工/大/深/圳</li><li>Bigram 二元分词，每两个字组成一个词语，如：哈工/工大/大深/深圳</li><li>Trigram 三元分词，每三个字组成一个词语，如：哈工大/工大深/大深圳</li></ul><p>在以上例子中，我们可以知道一个文本串在一元语言中生成的概率将这样计算：</p><script type="math/tex; mode=display">P\left( w_1w_2w_3 \right) =P\left( w_1 \right) \cdot P\left( w_2 \right) \cdot P\left( w_3 \right)</script><p>在二元语言中将这样计算：</p><script type="math/tex; mode=display">P\left( w_1w_2w_3 \right) =P\left( w_1 \right) \cdot P\left( w_2|w_1 \right) \cdot P\left( w_3|w_2 \right)</script><p>可以发现，在 Unigram 中我们假设了单词之间的<strong>独立性</strong>，这就意味着它的本质是词的多项分布，而一个文本串可以看作是这个分布的一个实例。</p><p>对于更多元的分词 N-gram，我们是假设每个单词出现的概率只与它之前的 n-1 个单词<strong>相关</strong>，因此采用了条件概率。事实上，这是一种基于马尔可夫假设的模型，此时的文本串应是有序相关的，这就不属于 BoW 的范畴。</p><p>一般情况下，N 的取值都很小，实际<strong>自然语言处理</strong>应用中最多的是将 N = 3 的三元分词模型。原因如下：</p><ul><li>N 元模型的空间复杂度，是 N 的指数函数，即 $O\left( \left| V \right|^N \right) $，<em>V</em> 是一种语言的词汇量，一般在几万到几十万个。时间复杂度也是一个指数函数$O\left( \left| V \right|^{N-1} \right) $。</li><li>即使使用 N = 4 、N = 5 也不可能覆盖所有词与词之间的相关性。某两个词可能是一段话和一段话之间才会出现的。</li></ul><h3 id="多元语言模型的参数估计"><a href="#多元语言模型的参数估计" class="headerlink" title="多元语言模型的参数估计"></a>多元语言模型的参数估计</h3><p>针对一元模型，只需要统计该「语言模型」生成的文档中，出现该 term 的频率，用频率近似概率即可——<strong>大数定律</strong>。</p><p>这里对二元模型展开探讨：估计 $P\left( w_i|w_{i-1} \right)$，利用条件概率：</p><script type="math/tex; mode=display">P\left(w_{i} \mid w_{i-1}\right)=\frac{P\left(w_{i-1}, w_{i}\right)}{P\left(w_{i-1}\right)}</script><p>于是，我们只需要统计 $\left(w_{i-1}, w_{i}\right)$ 的有序词对在文档中的出现次数，再统计 $w_{i-1}$ 的出现次数，即可估计其概率。</p><p>然而，存在这样一个问题：在文本中，两个词没有连续出现过，即频度为 0，那么它的概率就是 0 吗？如果词对 $\left(w_{i-1}, w_{i}\right)$ 和 $w_{i-1}$ 的出现次数相同，其概率就是 1 吗？这就涉及到了统计的可靠性问题，也称「<strong>不平滑问题</strong>」。</p><p>解决这些问题的主要方法是<strong>古德-图灵估计</strong>（Good-Turing Estimate）和<strong>卡茨退避法</strong>（Katz backoff）。</p><ul><li><p>对出现次数大于某个阈值的词，频率不下调，即用频率代替概率；</p></li><li><p>对出现次数小于这个阈值的词，频率才下调，利用古德-图灵估计的相对频度来调整；</p></li><li><p>对出现次数等于 0 的词，利用卡茨退避法给予一个比较小的概率值。</p></li></ul><p>这部分的内容属于语料库的自然语言处理，本文中不赘述，仅在后文针对零频问题介绍几种方法。</p><h2 id="查询排序问题-Ranking"><a href="#查询排序问题-Ranking" class="headerlink" title="查询排序问题 | Ranking"></a>查询排序问题 | Ranking</h2><p>当给定查询 <em>Q</em> 时，怎么根据统计语言模型进行排序呢？有三种排序方法，分别是：</p><ol><li><strong>查询似然排序</strong> | Query-likelihood</li></ol><p>为每个 Doc 确定其所对应的 $M_D$，而用户的 Query 记为 $q=(q_1,q_2,\cdots,q_k)$ 。则该查询在每个文档的「语言模型」下生成的概率可如下计算：</p><script type="math/tex; mode=display">P\left(q_{1} \ldots q_{k} \mid M_{D}\right)=\prod_{i=1}^{k} P\left(q_{i} \mid M_{D}\right)</script><p>将所有计算结果排序，即可得到检索结果。要注意，这种方法对每个 Doc 计算出的概率都独立于其他 Doc，相关文档没有被利用到。</p><ol><li><strong>文档似然排序</strong> | Document-likelihood</li></ol><p>查询似然的翻转版本，为每个 Query 确定其所对应的 $M_Q$，计算任意一个文档在该查询的「语言模型」下生成的概率：</p><script type="math/tex; mode=display">P\left(D \mid M_{Q}\right)=\prod_{w \in D} P\left(w \mid M_{Q}\right)</script><p>但是，这种方法存在如下问题：</p><ul><li>文档的长度相差很大，很难比较。</li><li>由于文档中出现的词很多没有出现在查询中，将会出现零频问题。</li><li>将会出现无意义的作弊网页，如将 Query 中的关键词无限重复。</li></ul><p>要解决这些问题，需要引入 Likelihood Ratio (似然比)，对文档长度加以归一。</p><script type="math/tex; mode=display">P\left(M_{Q} \mid D\right)=\frac{P\left(M_{Q}\right) P\left(D \mid M_{Q}\right)}{P(D)} \approx \frac{c \prod_{w \in D} P\left(w \mid M_{Q}\right)}{\prod_{w \in D} P(w \mid G E)}</script><p>其中，对每个文档计算其可能 「生成 $M_Q$」的概率，在用贝叶斯公式展开，其中的 $P\left(M_{Q}\right)$ 对于每个文档可视作常数，再由分母的约束，对文档加以限制。</p><ol><li>Ranking by <strong>Model Comparison</strong></li></ol><p>结合前两种方法，提出了<strong>交叉熵</strong>（cross-entropy）的概念：</p><script type="math/tex; mode=display">H\left(M_{Q} \| M_{D}\right)=-\sum_{w} P\left(w \mid M_{Q}\right) \log P\left(w \mid M_{D}\right)</script><p>这种方法同时考虑了查询 $M_Q$ 和文档 $M_D$，直接比较两种模型的相似度。要注意，$M_Q$ 和 $M_D$ 在公式中的顺序不能调换。</p><h3 id="零频问题-Zero-frequency-problem"><a href="#零频问题-Zero-frequency-problem" class="headerlink" title="零频问题 | Zero frequency problem"></a>零频问题 | Zero frequency problem</h3><p>有了上述排序模型，现在我们只需要从查询和文档中估算出 $M_Q$ 和 $M_D$。</p><p>在本文的「语言模型」中，我们只需采用<strong>一元分词模型</strong>，独立性和独立分布可以简化许多问题。然而，在<strong>极大似然估计</strong>下，还是有个问题急需解决——零频问题，即有的 term 根本不出现在观测集中，我们该如何估算其概率？</p><p>这里介绍三种 Discounting Methods (折扣法) 来 Smoothing (平滑) ：</p><ol><li><p>Laplace correction：把每个词的词频都加 1，分母的总频数加上词项数 N。但是这种方法不适合较大的词典表。</p></li><li><p>Lindstone correction：把每个词都加一个很小的值 ε，分母的总频数加上 Nε。</p></li><li><p>Absolute Discounting：把词频不等于 0 的词减去一个很小的值 ε，再把减去的总值平均分配到词频为 0 的词上去，不改变分母。</p></li></ol><p>除了折扣法，还有诸如插值法、退避法等方法也可以用于平滑。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #1 概论&amp;布尔模型</title>
    <link href="/2021/08/22/IR-Note-1/"/>
    <url>/2021/08/22/IR-Note-1/</url>
    
    <content type="html"><![CDATA[<p>该笔记是本人于哈尔滨工业大学（深圳）2021 年夏季学期「信息检索」课程的笔记，授课教师为 <a href="https://scholar.google.com/citations?hl=zh-CN&amp;user=7aR5D4sAAAAJ">陈清财</a> 教授。姑且算是一门 NLP 入门课程。</p><h2 id="概论-Overview"><a href="#概论-Overview" class="headerlink" title="概论 | Overview"></a>概论 | Overview</h2><h3 id="What’s-Information-Retrieval"><a href="#What’s-Information-Retrieval" class="headerlink" title="What’s Information Retrieval?"></a>What’s Information Retrieval?</h3><p>Indexing, retrieving, and organizing text by probabilistic or statistical.</p><p><strong>Comparing IR to Databases</strong>:</p><div class="table-container"><table><thead><tr><th></th><th>Databases</th><th>IR</th></tr></thead><tbody><tr><td>Data</td><td>Structured</td><td>Unstructured</td></tr><tr><td>Fields</td><td>Clear semantics</td><td>No fields</td></tr><tr><td>Queries</td><td>Defined(SQL)</td><td>Free text (自然语言) + Boolean</td></tr><tr><td>Recoverability</td><td>Critical</td><td>Downplayed</td></tr><tr><td>Matching</td><td>Exact</td><td>Imprecise (need to measure)</td></tr></tbody></table></div><h3 id="信息检索的基本方法-Basic-Approach-to-IR"><a href="#信息检索的基本方法-Basic-Approach-to-IR" class="headerlink" title="信息检索的基本方法 | Basic Approach to IR"></a>信息检索的基本方法 | Basic Approach to IR</h3><p>大多数成功的方法都是基于概论统计，而不是自然语言理解。因为自然语言在缺少约束的状态（unrestricted domains）下具有极大不确定性，而人工标注又十分昂贵。</p><p><strong>统计方法的核心思想</strong>：Relevant (相关) Items are Similar (相似). Usually look for documents matching query words.</p><p>The similarity can be measured by: </p><ul><li>String matching/comparison (字符串匹配)</li><li>Same vocabulary (词汇) </li><li>Probability that documents arise from same model (文档出现概率)</li><li>Same meaning of text (语义) — Hard to achieve</li></ul><h4 id="词袋-“Bag-of-Words”"><a href="#词袋-“Bag-of-Words”" class="headerlink" title="词袋 | “Bag of Words”"></a>词袋 | “Bag of Words”</h4><p>Compares words <strong>without regard to order</strong>.</p><p><strong>Stop word (停用词)</strong>：屏蔽对文章分类无效的高频词。</p><h3 id="基础检索模型-Retrieval-Models"><a href="#基础检索模型-Retrieval-Models" class="headerlink" title="基础检索模型 | Retrieval Models"></a>基础检索模型 | Retrieval Models</h3><p>检索模型：建立在 Doc 和 Query 之间的模型，用于描述相似性、排序相似性。</p><p>检索变量：queries (查询), documents (文档), terms (术语), relevance<br>judgments (相关性判别)。</p><h4 id="Exact-vs-Best-Match"><a href="#Exact-vs-Best-Match" class="headerlink" title="Exact vs. Best Match"></a>Exact vs. Best Match</h4><p>精确匹配：二值 (0/1) 匹配，检索结果无序，可以用 boolean queries (布尔查询)、proximity operators (邻接算子)、simple regular expressions (正则表达式)。对文档量级有限制。</p><p>最佳匹配：相似度 (0~1) 匹配，检索结果按照相似度排序。</p><h2 id="布尔模型-Boolean-Retrieval"><a href="#布尔模型-Boolean-Retrieval" class="headerlink" title="布尔模型 | Boolean Retrieval"></a>布尔模型 | Boolean Retrieval</h2><p>一种最常见的精确匹配模型，通常结果是无序呈现（unranked），有的模型会增加简单的排序。</p><p>精确匹配模型最直接的想法：<strong>线性扫描</strong>，从头到尾扫描文档集，对每个文档都查看是否包含关键词。在 Unix/Linux 系统中的文本扫描命令 grep 做的就是这种工作。然而，当需要检索的文档规模非常大时，这种线性扫描的方式的效率会变得非常低下。</p><h3 id="如何实现-Boolean-Retrieval"><a href="#如何实现-Boolean-Retrieval" class="headerlink" title="如何实现 Boolean Retrieval"></a>如何实现 Boolean Retrieval</h3><p>需要实现如下的模块：</p><ul><li>Term-document incidence (<strong>词典表</strong>): 类似 index (索引) 的文档呈现的形式，一个矩阵中，用 0 和 1 标记文档中出现的 term (词项)。</li><li><p>Boolean queries (布尔查询): AND, OR, AND-NOT.</p></li><li><p>Incidence vector (关联向量): 0/1 vector, bitwise AND。</p></li><li><p>Proximity operators (邻接算子): phrases - “”、same sentence - “ /s ”、same paragraph - “/p” 等等。</p></li></ul><h3 id="实现中的要点"><a href="#实现中的要点" class="headerlink" title="实现中的要点"></a>实现中的要点</h3><p>在词典表实现中，为了避免矩阵过大，还可以引入 inverted index (<strong>倒排索引</strong>) 存储矩阵，这里不再赘述。下面介绍两个实现步骤中的概念。</p><p><strong>token (词条) vs. term (词项)</strong>：</p><p>对于英文文本而言，词条就是根据空格把单词一个一个地提取出来，把原始文本分割开。词项则是更加统一规范的的词条。</p><p>例如在文本中可能出现 “apple”、“apples”、“Apple” 这类 token，但我们知道这几个 token 都是表达苹果（apple）的意思，因此，在构建索引的时候通常会把这几个 token 统一还原为 “apple”，只为 “apple” 建立索引项，那么 “apple” 就是一个 term 了。</p><h3 id="Features-to-Note-about-Queries"><a href="#Features-to-Note-about-Queries" class="headerlink" title="Features to Note about Queries"></a>Features to Note about Queries</h3><ul><li>Queries are developed incrementally. 查询表达式是可增长的，往往一直增加直到查询出正确结果。</li><li>Queries are complex. 用到了一定公式，对初学者不友好。</li><li>Queries are long (av. 9-10 words). 不同于通常的自然语言询问，只需要 1-2 个单词。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo配置与扩展</title>
    <link href="/2021/08/21/Hexo-Configuration/"/>
    <url>/2021/08/21/Hexo-Configuration/</url>
    
    <content type="html"><![CDATA[<p>Hello My World 的姊妹篇。</p><p>本站基于 Hexo + GitHub 搭建，采用 Fluid 主题。</p><p>这篇文章记录了博客的配置历程，包括：主题配置、域名配置、功能扩展。</p><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>本站采用的是 Fluid 主题，以下的配置在路径 <code>hewei2001/_config.fluid.yml</code> 中可以实现。该文件的介绍参见 <a href="https://hexo.fluid-dev.com/docs/guide/#%E6%96%87%E7%AB%A0%E9%A1%B5%E9%A1%B6%E9%83%A8%E5%A4%A7%E5%9B%BE">主题配置指南</a> 。以下仅介绍部分较为特殊的配置，其他内容可在指南中找到。</p><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p><code>lib</code>: 选择生成高亮的库，可选项有 highlightjs 和 prismjs，对应下面两组配置。</p><p>这里选择 <code>highlightjs</code>，将 <code>style</code> 修改为 <code>Night Owl</code> 风格，将 <code>bg_color</code> 修改为 <code>true</code> 以适配暗色代码框。</p><p>其他尝试过的主题还有 <code>Atom One Dark Reasonable</code>、<code>Vs 2015</code>、<code>Github Dark Dimmed</code>，都是不错的暗色风格。</p><h3 id="Mac-风格代码块"><a href="#Mac-风格代码块" class="headerlink" title="Mac 风格代码块"></a>Mac 风格代码块</h3><p>在 GitHub 的 Issue 发现有人提供了自定义样式实现 Mac 风格代码块的方法，遂尝试之。首先在路径 <code>hewei2001/themes/fluid/source/css</code> 下新建文件 <code>mac.styl</code>，复制以下代码：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-selector-class">.highlight</span><br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#011627</span><br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span><br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">30px</span> <span class="hljs-number">0</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, .<span class="hljs-number">4</span>)<br>    <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">30px</span><br><br>    <span class="hljs-selector-pseudo">&amp;::before</span><br>      <span class="hljs-attribute">background</span>: <span class="hljs-number">#fc625d</span><br>      <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span><br>      <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">20px</span> <span class="hljs-number">0</span> <span class="hljs-number">#fdbc40</span>, <span class="hljs-number">40px</span> <span class="hljs-number">0</span> <span class="hljs-number">#35cd4b</span><br>      <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27; &#x27;</span><br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">12px</span><br>      <span class="hljs-attribute">left</span>: <span class="hljs-number">12px</span><br>      <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">20px</span><br>      <span class="hljs-attribute">position</span>: absolute<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">12px</span><br></code></pre></div></td></tr></table></figure><p>然后在路径 <code>hewei2001/_config.fluid.yml</code> 中找到 <code>custom_css</code> 选项，加入 <code>/css/mac.css</code> 代码，注意这里后缀名依然使用 <code>.css</code>，不然无法识别！</p><h3 id="行内代码颜色"><a href="#行内代码颜色" class="headerlink" title="行内代码颜色"></a>行内代码颜色</h3><p>默认的行内代码颜色和正文颜色是继承关系，且行内代码背景色也不明显，因此视觉上难以区分。但是配置文件中又没有对应选项可以修改，查阅 GitHub 的 Issue 发现，有人曾提供过一个解决方案。</p><p>打开路径 <code>hewei2001/themes/fluid/source/css/_pages/_base</code> 下的 <code>base.styl</code> 文件，找到 <code>code</code> 配置项，修改颜色为 <code>#be4bdb</code>。</p><h3 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h3><p>Valine 是国内的一款极简风格的评论软件，也是 Fluid 支持的评论软件之一。在 <code>comment</code> 中选择 <code>valine</code>，之后找到相应的配置区域进行如下操作：</p><p>进入官网 <a href="https://leancloud.cn/">LeanCloud</a> 完成注册，然后在控制台创建一个项目 <code>Blog.Comments</code> 后，获取密钥（App ID 和 App Key），在对应位置填入。其他内容选项可以在官网找到说明。</p><h3 id="访问人数统计"><a href="#访问人数统计" class="headerlink" title="访问人数统计"></a>访问人数统计</h3><p>Fluid 主题提供两种网站的 PV、UV 统计数来源：<a href="https://www.leancloud.cn/">LeanCloud</a> 与 <a href="http://busuanzi.ibruce.info/">不蒜子</a>。不蒜子不需要申请账号，直接开启即可，但有时候会响应缓慢拖慢整个页面加载。LeanCloud 使用前需要申请账号，由于前面使用评论功能时已经注册，我们这边直接使用就行。</p><p>在控制台创建一个项目 <code>Blog.Counter</code> 后，获取密钥（App ID 和 App Key）和大陆服务器地址，填入 <code>web_analytics</code> 配置项中 <code>leancloud</code> API 相关参数。</p><h3 id="内置-Tag-插件"><a href="#内置-Tag-插件" class="headerlink" title="内置 Tag 插件"></a>内置 Tag 插件</h3><p>Fluid 内置了一些 Tag 插件，用于实现 Markdown 不容易生成的样式，以下仅列出两种常用的使用语法，添加在 md 文件中：</p><ol><li>脚注</li></ol><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">正文[^1]<br><br><span class="hljs-section">## 参考</span><br>[<span class="hljs-symbol">^1</span>]: <span class="hljs-link">参考资料1</span><br>[<span class="hljs-symbol">^2</span>]: <span class="hljs-link">参考资料2</span><br></code></pre></div></td></tr></table></figure><ol><li>Tag 便签</li></ol><p>在 markdown 中加入如下的代码来使用便签：</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">&#123;% note success %&#125;<br>文字 或者 <span class="hljs-code">`Markdown`</span> 均可<br>可选便签：primary/secondary/success/danger/warning/info/light<br>&#123;% endnote %&#125;<br></code></pre></div></td></tr></table></figure><p>或者使用 HTML 形式：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-primary&quot;</span>&gt;</span>标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="Latex-数学公式"><a href="#Latex-数学公式" class="headerlink" title="Latex 数学公式"></a>Latex 数学公式</h3><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">math:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span> <span class="hljs-string">或</span> <span class="hljs-string">katex</span><br></code></pre></div></td></tr></table></figure><p>其中 <code>specific</code> 建议开启：当为 true 时，只有在文章 Front-matter 里指定 <code>math: true</code> 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度。</p><p>由于 Hexo 默认的 Markdown 渲染器不支持复杂公式，所以必须更换渲染器。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ npm uninstall hexo-renderer-marked --save  <span class="hljs-comment"># 卸载原渲染器</span><br>$ npm install hexo-renderer-kramed --save    <span class="hljs-comment"># mathjax</span><br>$ npm install @upupming/hexo-renderer-markdown-it-plus --save  <span class="hljs-comment"># katex</span><br></code></pre></div></td></tr></table></figure><p>这里选择 MathJax，是因为对 LaTeX 语法支持全面，且右键点击公式有扩展功能菜单。</p><p>但是 Hexo 中默认会将下划线解析为斜体，使得用 MathJax 渲染公式下标有时会出错，需要找到路径 <code>node_modules\kramed\lib\rules\inline.js</code>，修改：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//第11行：取消对 \ 和 &#123;&#125; 的转义 escape</span><br><span class="hljs-attr">escape</span>: <span class="hljs-regexp">/^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/</span>,<br><span class="hljs-built_in">escape</span>: <span class="hljs-regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,<br><span class="hljs-comment">//第20行：</span><br>em: <span class="hljs-regexp">/^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,<br>em: <span class="hljs-regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,<br></code></pre></div></td></tr></table></figure><blockquote><p>Tips1：在使用数学公式时，应当避免使用两个连续的 <code>&#123;&#125;</code>，否则会被 Hexo 解释为特殊标签，从而报错。</p><p>Tips2：Hexo 对公式的支持不如 Typora 好，譬如多行公式需要用 <code>\begin&#123;aligned&#125; ... \end&#123;aligned&#125;</code> 和 <code>$</code> 定位符。</p><p>Tips3：Hexo 中变量的上下标只能用 LaTeX 实现而不能用 Enhanced Markdown 语法。</p></blockquote><h2 id="域名配置"><a href="#域名配置" class="headerlink" title="域名配置"></a>域名配置</h2><h3 id="部署到-Coding-Pages"><a href="#部署到-Coding-Pages" class="headerlink" title="部署到 Coding Pages"></a>部署到 Coding Pages</h3><p>Coding 可以算是国内的 GitHub，尽管并不是特别流行，但部署到上面可以使国内访问速度更快，还可以提交百度收录（GitHub 禁止了百度的爬取）。</p><p>注意：由于 Coding 在前段时间改版后，原有的个人版 Pages 下架，以企业版的形式重新开放，新版的静态网站服务需调用腾讯云对象存储 COS、内容分发网络 CDN、SSL 证书产品等资源，其中 COS 和 CDN 采用用量<strong>计费模式</strong>。故本博客暂不采用 Coding 部署。</p><h3 id="添加百度谷歌收录"><a href="#添加百度谷歌收录" class="headerlink" title="添加百度谷歌收录"></a>添加百度谷歌收录</h3><p>如果仅部署在 GitHub Pages，是无法被百度收录的，因为 GitHub 禁止了百度爬虫，最常见的解决办法是双线部署到 Coding Pages 和 GitHub Pages。</p><p>本站暂不考虑。</p><h3 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h3><p>有了 GitHub Pages 服务器自带的域名后，还可以到阿里云再购买一个自定义域名，然后将域名解析到博客的域名，具体过程如下：</p><ol><li>注册阿里云，实名认证后在购买下 hwcoder.top 域名。</li><li>打开域名控制台，进入<strong>域名解析</strong>列表，进入新买的域名，添加两条记录：<ul><li>主机记录：@；记录类型：A；记录值为 GitHub Pages 域名的 IP。</li><li>主机记录：www；记录类型：CNAME；记录值为 GitHub Pages 域名。</li></ul></li><li>在路径 <code>hewei2001/source</code> 下新建一个 <code>CNAME</code> 文件，里面填写我们买的域名，注意文件不需要任何后缀。</li><li>GitHub 中打开对应仓库，在 Setting 中找到 Pages，添加 Custom Domain 为新买的域名，旁边的一个 <code>Enforce HTTPS</code> 勾选后我们的网站就变为 <a href="https://hwcoder.top。">https://hwcoder.top。</a></li><li>路径 <code>hewei2001/_config.yml</code> 的<code>#URL</code> 部分，更改为新域名。</li></ol><p>以上操作后就可以在自定义的域名访问博客站点了，如果显示的内容与本地服务器查看内容不同，<strong>清除浏览器缓存</strong>后即可解决。如果不能解决，检查是否以上步骤有错。</p><h2 id="其他功能扩展"><a href="#其他功能扩展" class="headerlink" title="其他功能扩展"></a>其他功能扩展</h2><p>以下配置是在 Fluid 主题中不具有的功能，通过各种插件实现。</p><h3 id="备份博客到-GitHub"><a href="#备份博客到-GitHub" class="headerlink" title="备份博客到 GitHub"></a>备份博客到 GitHub</h3><p>由于 Hexo 博客是静态托管的，所有的原始数据都保存在本地，如果哪一天电脑坏了，或者是误删了本地数据就很危险了。</p><p>GitHub 上可以找到一个 <code>hexo-git-backup</code> 插件，但似乎已经不再更新了，仅支持 Hexo 3.x.x 版本，尝试后放弃。</p><h3 id="压缩静态资源"><a href="#压缩静态资源" class="headerlink" title="压缩静态资源"></a>压缩静态资源</h3><p>博客中有大量 HTML、CSS、JS 文件，这些文件为了阅读方便会加入许多回车和空行，但在页面解析时其实会浪费部分时间，此外如果有许多插图，也会拖慢网页加载，并占据 GitHub 仓库的存储空间。</p><p>目前有关插件有 <code>gulp</code>、<code>hexo-neat</code>、<code>hexo-all-minifier</code>。推荐采用集成度比较高的 <code>hexo-all-minifier</code> 来实现，由于在安装依赖包过程报错，本站最终采用了 <code>hexo-neat</code>。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ npm install hexo-all-minifier --save  <span class="hljs-comment"># 出现 npm ERR! code ELIFECYCLE 错误</span><br>$ npm install hexo-neat --save <span class="hljs-comment"># 换成这个后成功安装</span><br></code></pre></div></td></tr></table></figure><p>之后在配置文件 <code>hewei2001/_config.yml</code> 中增加如下内容就行：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># hexo-neat</span><br><span class="hljs-comment">## Docs: https://github.com/rozbo/hexo-neat</span><br><span class="hljs-attr">neat_enable:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 压缩 html</span><br><span class="hljs-attr">neat_html:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">exclude:</span><br><span class="hljs-comment"># 压缩 css  </span><br><span class="hljs-attr">neat_css:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">exclude:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;**/*.min.css&#x27;</span><br><span class="hljs-comment"># 压缩 js</span><br><span class="hljs-attr">neat_js:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">mangle:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">output:</span><br>  <span class="hljs-attr">compress:</span><br>  <span class="hljs-attr">exclude:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;**/*.min.js&#x27;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;**/jquery.fancybox.pack.js&#x27;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;**/index.js&#x27;</span> <br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello My World</title>
    <link href="/2021/08/19/Hello-My-World/"/>
    <url>/2021/08/19/Hello-My-World/</url>
    
    <content type="html"><![CDATA[<p>谨以此文纪念该个人网站的诞生。</p><p>本站基于 Hexo + GitHub 搭建，采用 Fluid 主题。</p><p>这篇文章记录了博客的搭建历程，以及 Hexo 的使用指南。</p><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>早在大学入学时，夏老师就告知了个人博客的重要性。</p><p>期间也看过许多漂亮的个人网站，也看到很多大神的技术博客，偶尔会心动一下。</p><p>于是乎，咕到了大二快结束时，打开了这个新世界的大门。</p><h2 id="搭建历程"><a href="#搭建历程" class="headerlink" title="搭建历程"></a>搭建历程</h2><h3 id="1-安装-Node-js"><a href="#1-安装-Node-js" class="headerlink" title="1. 安装 Node.js"></a>1. 安装 Node.js</h3><p>官网：<a href="nodejs.org">nodejs.org</a></p><p>安装后在 cmd 命令行输入 <code>node -v</code> 即可查看版本。</p><h3 id="2-注册-GitHub"><a href="#2-注册-GitHub" class="headerlink" title="2. 注册 GitHub"></a>2. 注册 GitHub</h3><p>注册后，创建仓库：<a href="https://github.com/hewei2001/hewei2001.github.io">https://github.com/hewei2001/hewei2001.github.io</a></p><p>此时在浏览器中已经可以访问域名：<a href="https://hewei2001.github.io">https://hewei2001.github.io</a></p><p>注意，仓库名必须取 <code>&lt;username&gt;.github.io</code>，如果仓库取了其他名字，最后访问的域名会是：<a href="https://用户名.github.io/仓库名/">https://用户名.github.io/仓库名/</a></p><h3 id="3-下载-Git"><a href="#3-下载-Git" class="headerlink" title="3. 下载 Git"></a>3. 下载 Git</h3><p>官网：<a href="gitforwindows.org">gitforwindows.org</a></p><p>安装时按照默认配置即可，其中有个 MinTTY 终端模拟器的选项会默认选上，如果不选则会使用 Windows 自带的终端 cmd 显示 Git Bash。</p><p>安装后在 cmd 命令行输入 <code>git</code> 即可调出功能目录。</p><p>此后就在 cmd 中配置 Git 个人基本信息（绑定 GitHub）：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ git config --global user.name <span class="hljs-string">&quot;hewei2001&quot;</span><br>$ git config --global user.email <span class="hljs-string">&quot;631670924@qq.com&quot;</span><br></code></pre></div></td></tr></table></figure><p>配置完才后续才可以正常提交远程仓库（详见博客 Git 分类下其他文章）。</p><h3 id="4-配置-GitHub-SSH"><a href="#4-配置-GitHub-SSH" class="headerlink" title="4. 配置 GitHub SSH"></a>4. 配置 GitHub SSH</h3><p>该步骤旨在建立当前主机与 GitHub 的安全连接，以后提交/拉取仓库才不需要重复输入密码。</p><p>打开 Git Bash 输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;631670924@qq.com&quot;</span> <span class="hljs-comment"># 获取 SSH Key</span><br></code></pre></div></td></tr></table></figure><p>完成后，在提示路径下找到 .ssh 文件夹中的 id_rsa.pub 公钥文件，用记事本打开拷贝。</p><p>在 GitHub 个人设置中找到 SSH，新建，输入 Key。</p><p>配置后可以用如下命令测试是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ ssh -T git@github.com<br><span class="hljs-comment"># 运行结果出现类似如下即表示成功</span><br><span class="hljs-comment"># Hi hewei2001! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></code></pre></div></td></tr></table></figure><h3 id="5-安装-Hexo"><a href="#5-安装-Hexo" class="headerlink" title="5. 安装 Hexo"></a>5. 安装 Hexo</h3><p>官网：<a href="hexo.io">hexo.io</a>，有中文官网。</p><p>在电脑中新建 Blog 文件夹，如 <code>D:\Blog</code>。</p><p>在 cmd 命令行打开 D 盘，用 <code>cd Blog</code>命令进入 Blog 子目录。或者在文件夹路径栏直接输入 <code>cmd</code>。</p><p>输入 Hexo 官网上的全局安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ npm install hexo-cli -g<br></code></pre></div></td></tr></table></figure><p>输入初始化部署命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo init hewei2001<br></code></pre></div></td></tr></table></figure><p>即可在 Blog 目录下新建<strong>博客文件夹</strong> hewei2001。用 <code>cd hewei2001</code>命令进入博客子目录。</p><p>输入安装 Node.js 包管理器命令，安装所有的依赖：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ npm install<br></code></pre></div></td></tr></table></figure><p>输入生成本地预览命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo s<br></code></pre></div></td></tr></table></figure><p>默认会生成 <code>localhost:4000</code> 端口的网址，在浏览器中可以访问。</p><h3 id="6-安装编辑器"><a href="#6-安装编辑器" class="headerlink" title="6. 安装编辑器"></a>6. 安装编辑器</h3><p>主要用于编写文档和修改配置，这里选择 VsCode 即可，打开路径 <code>hewei2001/source/_posts/hello-world.md</code>，随便修改内容后保存。</p><p>在 hewei2001 目录中运行 Git Bash。</p><p>依次输入清理缓存、生成博客文件（静态页面）、<strong>生成本地预览</strong>命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo cl <span class="hljs-comment"># 表示 clean</span><br>$ hexo g  <span class="hljs-comment"># 表示 generate</span><br>$ hexo s  <span class="hljs-comment"># 表示 server</span><br></code></pre></div></td></tr></table></figure><p>在浏览器中访问即可查看更改。之后按下 Ctrl + C 即可退出预览进程。</p><h3 id="7-将-Hexo-发布至-GitHub"><a href="#7-将-Hexo-发布至-GitHub" class="headerlink" title="7. 将 Hexo 发布至 GitHub"></a>7. 将 Hexo 发布至 GitHub</h3><p>打开路径 <code>hewei2001/_config.yml</code>，更改基础参数。</p><ul><li><code>#Site</code> 部分的站点描述自行修改</li><li><code>#URL</code> 部分，将链接改为 <a href="https://hewei2001.github.io">https://hewei2001.github.io</a> </li><li><code>#Deployment</code> 部分<ul><li><code>type</code> 改为 git</li><li><code>repo</code> 改为 <a href="https://github.com/hewei2001/hewei2001.github.io.git">https://github.com/hewei2001/hewei2001.github.io.git</a></li><li><code>branch</code> 改为 gh-pages</li></ul></li></ul><p>进入 Hexo 官网，复制 hexo-deployer-git 的安装命令，在 Git Bash 中安装。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ npm install hexo-deployer-git --save<br></code></pre></div></td></tr></table></figure><p>依次输入清理缓存、生成博客文件（静态页面）、<strong>提交远程仓库</strong>命令：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo cl<br>$ hexo g<br>$ hexo d  <span class="hljs-comment"># 表示 deploy，安装了上面的 hexo-deployer-git 才可用</span><br></code></pre></div></td></tr></table></figure><p>初次使用该操作可能会弹出一个 GitHub 登录界面，用于当前主机的身份验证。</p><p>在浏览器中访问 <a href="https://hewei2001.github.io">https://hewei2001.github.io</a>  即可查看站点。</p><h2 id="Hexo-使用"><a href="#Hexo-使用" class="headerlink" title="Hexo 使用"></a>Hexo 使用</h2><p>以下介绍其他常用的 Hexo 操作命令，需要在博客文件夹下打开 Git Bash 使用。</p><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo n <span class="hljs-string">&quot;文章名&quot;</span> <span class="hljs-comment"># 代表 new</span><br></code></pre></div></td></tr></table></figure><p>文章名不需要文件后缀，会自动生成 Markdown 文件，且带有预先定义的参数（在 Front-matter 中），如标题、日期、标签等。</p><p>以下是一些常用的参数及默认设置：</p><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>title</code></td><td>标题，最好用<strong>引号</strong>括起来</td><td>文章的文件名</td></tr><tr><td><code>date</code></td><td>建立日期</td><td>文件建立日期</td></tr><tr><td><code>updated</code></td><td>更新日期</td><td>文件更新日期</td></tr><tr><td><code>comments</code></td><td>开启文章的评论功能</td><td>true</td></tr><tr><td><code>categories</code></td><td>分类（不适用于分页）</td><td>无</td></tr><tr><td><code>tags</code></td><td>标签（不适用于分页）</td><td>无</td></tr><tr><td><code>excerpt</code></td><td>摘要，优先于 <code>&lt;!-- more --&gt;</code></td><td>无</td></tr><tr><td><code>index_img</code></td><td>文章封面图，用 /img/ 相对路径</td><td>无</td></tr><tr><td><code>math</code></td><td>公式转换，关闭时加速加载</td><td>true</td></tr><tr><td><code>sticky</code></td><td>文章置顶，数值越大越靠前</td><td>无</td></tr></tbody></table></div><p>注意 Hexo 采用的是 GitHub Favored Markdown，书写规范与标准 Markdown 有微小区别，可以查阅 GitHub 上的说明。</p><h3 id="布局管理"><a href="#布局管理" class="headerlink" title="布局管理"></a>布局管理</h3><p>在上面新建文章时，我们还可以制定布局：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo n [layout] <span class="hljs-string">&quot;文章名&quot;</span> <br></code></pre></div></td></tr></table></figure><p>其中，<code>layout</code> 可替换为 post（文章，默认）、draft（草稿）、page（页面）。默认值可以在配置文件中修改 <code>default_layout</code> 来改动。不同布局的文件会存储在不同位置。</p><p>对于 page 布局，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件，页面布局顾名思义就是用来 DIY 我们博客页面的，不会被渲染。 </p><p>对于 draft 布局，在建立时会被保存到 <code>source/drafts</code> 文件夹中，但不会显示在页面上，如果我们不想某一篇文章显示在页面上，也可以把它移动到该文件夹中。</p><p>此外，还有关于 draft 的一些操作：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo s --draft  <span class="hljs-comment"># 在服务器预览时加入草稿文件</span><br>$ hexo publish [layout] <span class="hljs-string">&quot;文章名&quot;</span>  <span class="hljs-comment"># 将草稿发布为 post 或 page</span><br></code></pre></div></td></tr></table></figure><h3 id="修改默认布局"><a href="#修改默认布局" class="headerlink" title="修改默认布局"></a>修改默认布局</h3><p>上述布局管理中的三种布局，还对应这三种模板，这些模板可以在 <code>hewei2001/scaffolds</code> 路径下找到，我们可以提前修改 post 模板，这样每次新建文章时就不需要自己添加 Front-matter 了。</p><p>以下是我修改后的 Front-matter 布局：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> &#123;&#123; <span class="hljs-string">titl</span> &#125;&#125;<br><span class="hljs-attr">excerpt:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/home/</span><br><span class="hljs-attr">math:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">date:</span> &#123;&#123; <span class="hljs-string">date</span> &#125;&#125;<br><span class="hljs-attr">updated:</span><br><span class="hljs-attr">categories:</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-attr">sticky:</span> <br></code></pre></div></td></tr></table></figure><h3 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h3><p>在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p><p>首先要创建「分类」和「标签」本身所在的<strong>页面</strong>，打开博客文件夹，执行 <code>hexo new page xxx</code> 命令。Fluid 主题不需要，已经自带「分类」、「标签」和「归档」页面了，故这里不展开介绍。</p><p>此后就可以 post 布局的文章指定分类和标签了，也需要在对应文章的 Front-matter 中设置。Hexo 不支持给一篇文章指定多个同级分类，因此需要规划好。下面是指定方法：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">categories:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">技术经验</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">博客</span>  <span class="hljs-comment"># 「博客」会作为「技术经验」的子类</span><br><span class="hljs-attr">tags:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">Hexo</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">Git</span>  <span class="hljs-comment"># 「Hexo」与「Git」是同级标签</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
