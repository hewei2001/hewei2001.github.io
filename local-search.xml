<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2022年保研回忆录</title>
    <link href="/BaoYan-Memoir.html"/>
    <url>/BaoYan-Memoir.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-个人情况"><a href="#1-个人情况" class="headerlink" title="1. 个人情况"></a>1. 个人情况</h2><ul><li>本科：中流 985 计算机专业</li><li>夏令营排名：6/300+，预推免排名：7/300+，综测排名：2/300+</li><li>荣誉奖项：一次国家奖学金，若干学业奖学金、企业奖学金</li><li>竞赛经历：数学建模国赛一等奖、美赛 H 奖（完全没用）</li><li>科研经历：两篇 NLP 相关论文（非一作，夏令营时在投）</li><li>最终去向：复旦大学计算机学硕</li></ul><h2 id="2-最初定位"><a href="#2-最初定位" class="headerlink" title="2. 最初定位"></a>2. 最初定位</h2><ul><li>院校选择：主要冲 <strong>华五</strong>，没敢奢求清北本部，本校及同层次学校 <strong>不报</strong>（机会留给其他同学）</li></ul><script type="math/tex; mode=display">心仪学校: \mathrm{FDU.nlp}\geqslant  \mathrm{RUC.gl}\geqslant \mathrm{USTC}\approx  \mathrm{CAS.ia}\approx  \mathrm{PKU.rw}\geqslant  \mathrm{NJU.nlp}\approx  \mathrm{ZJU}</script><script type="math/tex; mode=display">心仪导师: 人品(指导、实习)\geqslant 方向 \approx 科研实力(组里资源、论文数量、学生数量) > 补贴、知名度等</script><ul><li><p>方向：AI 方向，最好与 NLP/RecSys 相关，可接受偏软件工程（本科导师方向），也可接受其他 AI 方向；</p></li><li><p>填报学位：倾向<strong>学硕</strong>，可考虑强组直博、科研向的专硕、纯实习的专硕；</p></li><li>其他考虑：最好有宿舍，工位，以及大学的人文氛围。</li></ul><h2 id="3-参营情况"><a href="#3-参营情况" class="headerlink" title="3. 参营情况"></a>3. 参营情况</h2><p>入营大部分都是靠<strong>排名筛选</strong>，优营基本取决于面试，看重<strong>机试能力、科研经历、临场发挥</strong>。这部分先按下不表，下面介绍本人的报名及参营情况：</p><div class="table-container"><table><thead><tr><th style="text-align:center">学校</th><th style="text-align:center">学院/实验室</th><th style="text-align:center">类型</th><th style="text-align:center">入营</th><th style="text-align:center">优营</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">中科院</td><td style="text-align:center">软件所中文信息处理</td><td style="text-align:center">学硕</td><td style="text-align:center">X</td><td style="text-align:center">-</td><td style="text-align:center">需要提前参加机试才能入营</td></tr><tr><td style="text-align:center">复旦</td><td style="text-align:center">计算机学院</td><td style="text-align:center">学硕</td><td style="text-align:center">✔</td><td style="text-align:center">候补</td><td style="text-align:center">9.19 候补到，<strong>最终去向</strong></td></tr><tr><td style="text-align:center">人大</td><td style="text-align:center">高瓴人工智能学院</td><td style="text-align:center">学硕</td><td style="text-align:center">✔</td><td style="text-align:center">候补</td><td style="text-align:center">9.28 下午候补到，放弃</td></tr><tr><td style="text-align:center">北大</td><td style="text-align:center">软件与微电子学院</td><td style="text-align:center">专硕</td><td style="text-align:center">✔</td><td style="text-align:center">✔</td><td style="text-align:center">优营放弃</td></tr><tr><td style="text-align:center">南大</td><td style="text-align:center">人工智能学院</td><td style="text-align:center">学硕</td><td style="text-align:center">✔</td><td style="text-align:center">X</td><td style="text-align:center">笔试通过，面试放弃</td></tr><tr><td style="text-align:center">南大</td><td style="text-align:center">计算机学院</td><td style="text-align:center">学硕</td><td style="text-align:center">X</td><td style="text-align:center">-</td><td style="text-align:center">菜！</td></tr><tr><td style="text-align:center">中科院</td><td style="text-align:center">自动化所</td><td style="text-align:center">学硕</td><td style="text-align:center">X</td><td style="text-align:center">-</td><td style="text-align:center">候补入营，根本补不到</td></tr><tr><td style="text-align:center">北大</td><td style="text-align:center">计算机学院</td><td style="text-align:center">学硕</td><td style="text-align:center">X</td><td style="text-align:center">-</td><td style="text-align:center">菜！</td></tr><tr><td style="text-align:center">北大</td><td style="text-align:center">智能学院</td><td style="text-align:center">学硕</td><td style="text-align:center">X</td><td style="text-align:center">-</td><td style="text-align:center">菜！</td></tr><tr><td style="text-align:center">上交</td><td style="text-align:center">电院</td><td style="text-align:center">学硕</td><td style="text-align:center">✔</td><td style="text-align:center">X</td><td style="text-align:center">时间冲突放弃机试</td></tr><tr><td style="text-align:center">中科大</td><td style="text-align:center">网安学院</td><td style="text-align:center">学硕</td><td style="text-align:center">✔</td><td style="text-align:center">✔</td><td style="text-align:center">优营放弃</td></tr></tbody></table></div><p>预推免：</p><div class="table-container"><table><thead><tr><th style="text-align:center">学校</th><th style="text-align:center">学院/实验室</th><th style="text-align:center">类型</th><th style="text-align:center">入营</th><th style="text-align:center">优营</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">清华</td><td style="text-align:center">软件学院</td><td style="text-align:center">专硕</td><td style="text-align:center">✔</td><td style="text-align:center">X</td><td style="text-align:center">菜！</td></tr><tr><td style="text-align:center">清华</td><td style="text-align:center">深研院人工智能</td><td style="text-align:center">专硕</td><td style="text-align:center">X</td><td style="text-align:center">-</td><td style="text-align:center">和清软只能入一个</td></tr><tr><td style="text-align:center">中科院</td><td style="text-align:center">自动化所</td><td style="text-align:center">学硕</td><td style="text-align:center">X</td><td style="text-align:center">-</td><td style="text-align:center">再次被拒，生气</td></tr><tr><td style="text-align:center">浙大</td><td style="text-align:center">计算机学院</td><td style="text-align:center">学硕</td><td style="text-align:center">✔</td><td style="text-align:center">X</td><td style="text-align:center">参营前补到复旦，遂放弃</td></tr></tbody></table></div><h2 id="4-关键时间点"><a href="#4-关键时间点" class="headerlink" title="4. 关键时间点"></a>4. 关键时间点</h2><ol><li>保研前夕（上一年）：联系导师进组做科研，了解科研的流程，初步阅读论文、跑实验；</li><li>前期准备（2 - 3 月）：浏览网上的保研经验贴，整理目标学校及考核内容，准备<strong>简历</strong>；</li><li>陶瓷导师（4 月起）：在学校官网、谷歌学术、知乎、导师评价网查找感兴趣老师的信息，发邮件联系（一定要有诚意，至少<strong>不要把导师的基本信息、研究方向说错</strong>），陶瓷老师后很可能需要<strong>提前面试</strong>，特别是强组；</li><li>报名材料（5 月中旬 - 6 月初）：证书扫描件、推荐信、成绩单及排名证明、个人陈述等；</li><li>面试准备（5 月初 - 7 月底）：<ul><li><strong>自我介绍</strong>：科研 &gt;&gt; 项目类竞赛 &gt; 技能类竞赛</li><li><strong>专业课</strong>：数据结构 &gt;&gt; 操作系统 = 计组 = 计网 &gt;&gt; 其他成绩单上的课</li><li><strong>数学课</strong>：线代 = 概率论 &gt;&gt; 高数</li><li><strong>算法题</strong>：力扣 Hot100 &gt; 其他刷题平台</li><li><strong>AI 方向</strong>：机器学习基础 &gt;&gt; 深度学习基础 &gt; NLP 基础 = CV 基础</li><li><strong>其他</strong>：学校特色题（如智力题、编程语言基础）&gt; 英语问答 = 性格问答 &gt; 政治问答</li></ul></li><li>夏令营集中进行（7 月）：有些学校可能会冲突，需要进行取舍。记得准备好手机支架、安静房间；</li><li>保研间隙（8 月）：因为拿了保底就先躺平，几乎没怎么准备预推免。想冲预推免的同学<strong>建议</strong>继续准备上述面试内容，同时根据目标院校的机试难度<strong>适当刷题</strong>，如果不是实在没项目，不建议这时候再花大心思去卷这些，不如多刷面经准备面试题。</li><li>预推免集中进行（9 月）：有的预推免实际参营不到入营的一半，机会很大，坚持就是胜利；</li><li>鸽与被鸽（9 月中旬起）：<strong>不要因为之前只拿了候补而沮丧</strong>！以下几个时间<strong>鸽子大量起飞</strong>：<ul><li>清深、清软、清华网研院、贵系开奖：清华夏令营不发 offer，预推免将吸收一大批华五优营；</li><li>北大预推免开奖：北大夏令营发出部分 offer，但预推免仍会招人；</li><li>比目标院校<strong>高一档</strong>的学校开奖：这里的「<strong>高一档</strong>」可以是 title 高、地理优势、学硕优势、方向优势甚至各种你想不到原因，但<strong>就是会有人鸽</strong>；</li><li>9.20 - 9.28：内心尚存良知的海王们会放弃一些 offer，防止老师招不到学生；</li><li>9.28 中午：学校要求限定时间内接受通知，至此彻底放弃其他 offer。<strong>大量学校被鸽穿</strong>，网上流传的包括：上交密院 浙大计院 浙大软院 南大计院 南大软院 人大信院 人大高瓴 北航计院 武大计院 西交计院 中山计院 吉大计院 东南网安 国科大杭高院 东南软件 电子科大深圳。<strong>圣经预言的场景一一应验</strong>。</li></ul></li></ol><blockquote><p>这里的「<strong>鸽穿</strong>」并不是真的有几十个人放鸽子，实际上同一所学校可能只有一两个人放鸽子，但是当名额顺延下来的时候，其他候补同学要么已经接受了待录取通知、要么已经进了其他学校的组不忍心鸽、要么担心候补上只能找到坑导，于是大家纷纷放弃，招生办就一直顺延。</p><p>在这里我 <strong>强烈谴责</strong> 那些<strong>非得等到 928 中午才鸽</strong>的人，也许你们只是想晒一张「<strong>拒绝 XX</strong>」的截图装逼，但是很可能另一位候补同学就因为在其他学校的催促下仓皇点了接收，从而错失了梦校的 offer。</p></blockquote><h2 id="5-夏令营细节"><a href="#5-夏令营细节" class="headerlink" title="5. 夏令营细节"></a>5. 夏令营细节</h2><p>大部分参营细节在其他人的经验中都提到了，这里仅简单列举部分夏令营。如果有院方或者同学认为文章内容违反了<strong>保密承诺书</strong>，请直接私信我，我会第一时间删除相应内容。</p><h3 id="复旦计算机"><a href="#复旦计算机" class="headerlink" title="复旦计算机"></a>复旦计算机</h3><p>入营要求比较高，强制卡 rank，联系老师应该也没用。300 人入营，因为和清北夏令营时间冲突最终只来了 200+ 人，但是发放的名额依然很少。入营后有联络员联系。</p><p>第一天上午线上宣讲，介绍各个实验室情况。晚上进行<strong>志愿的填报</strong>，这个很重要，大型 <strong>博弈</strong> 现场，后续优营的评选、候补的情况完全都是在你填报的志愿队列排序。系统实时更新，可以看到当前报考人数/招生人数。学硕名额略多于专硕名额。</p><blockquote><p>学硕竞争更为激烈，但是往往拿了学硕 offer 的大佬更有可能去「高一档」学校，因此富贵险中求，能进候补队列就是胜利！</p></blockquote><p>第二天上午机考，两小时三题，需要提交代码和思路文档。不设监考，不计入总分（但面试会看，间接影响评分）。往年复旦的题目一般出自力扣，差不多是 Easy、Medium 难度，不会评测，但今年不一样，OJ 评测，题目难度很大。第一题接近 Hard，第二题 Hard++，第三题可能是金牌题（咱也不知道）。</p><p>第二天下午英语面试，6 - 8 分钟。需要自我介绍，提问范围较广，会涉及课程和自我介绍中提及的项目等。</p><p>第三天专业面试，15 分钟左右，每个会议室都会有一位大佬驻场，<strong>各个方向侧重问的内容不一</strong>。先中文自我介绍。接下来问机试解题思路等，还有 Python 等语言基础知识。之后的内容根据不同方向有不同问法（人工智能方向侧重问机器学习和科研经历，其他方向侧重 408）。最后会问是否专硕和是否调剂，只需要回答是或否。</p><h3 id="人大高瓴"><a href="#人大高瓴" class="headerlink" title="人大高瓴"></a>人大高瓴</h3><p>入营要求高，也是卡 rank 的，学硕名额最终只有 24 个，比去年缩水了一点。整个流程可能为了杜绝作弊保证公平性，步骤繁杂、有大量等候流程、非常浪费时间、教务老师也比较严格，参营体验一般。</p><p>先进行笔试（75 分），1.5h。官方发布的范围是数学、程序设计、数据结构与算法。题目很难，需要准备很多内容。最后需要手写一道算法题的思路，是很经典的题，循序渐进，难度 Medium - Hard。</p><p>过几天才是开营仪式，笔试不筛人。各个老师都会来做介绍发言，高瓴有非常多年轻学术能力强的老师，值得一听。可以在这个时候就选定一批<strong>自己能接受的导师</strong>，以防最后候补到了不知道联系谁。</p><p>最后是面试（基础 75 分 + 综合 50 分），15min，同一组序号靠后的同学可能要等很久，并且等待过程中需要开着双机位什么都不能做。先翻译一篇英文摘要后进正式面试会议。本人是同组序号最后一个，坐牢了四个小时，心态爆炸，最后面试时老师也急着下班吃饭，体验很差。</p><h3 id="北大软微"><a href="#北大软微" class="headerlink" title="北大软微"></a>北大软微</h3><p>北大各个学院的报名材料是最多的，一向非常繁琐，是今年少数需要推荐信的院校之一。</p><p>需要注意的是，一向以放养、<strong>就业导向</strong>闻名的软微学院，在开营招生会上宣布今年改成<strong>科研导向</strong>！具体的内容其他博客应该会介绍，这里就不展开了。</p><p>入营应该是靠 rank 初筛，可能会结合简历。初筛过后会给出一个论文清单，需要选择方向并阅读对应的论文，提交一份 1500 字的阅读报告。有人卷到了 4000 字最后还是没入营，很惨。</p><p>面试时用 PPT 对选择的论文进行汇报和提问，之后提问一些个人的基本情况，几乎不问基础知识，老师可能会对自我介绍中的科研感兴趣。有英语提问。</p><p>面试后可能会有导师电话联系，给<strong>非常短的时间</strong>让你确定来不来，一般和老师确定来的都能给 offer，也有不少同学当场放弃，最后优营率可能达 70% 以上。值得一提的是，今年<strong>夏令营没有 wl</strong>，原来也不打算开预推免（最后还是开了），有点普信了这下子。</p><blockquote><p>这个阶段需要比较谨慎，因为软微大多数导师不做科研，接的是横向项目，组里并没有能支撑「科研导向」的实力。老师之间差别也比较大，可以直接深入询问老师是否放实习、培养方案、组里方向、横向项目等。</p><p>如果志在科研或算法岗，建议谨慎选择横向较多的组；如果志在开发岗，今年很可能会失去软微的实习优势；如果志在体制内，无脑冲就完事了。</p></blockquote><h3 id="中科大网安"><a href="#中科大网安" class="headerlink" title="中科大网安"></a>中科大网安</h3><blockquote><p>这里强烈安利中科大何向南组的 <a href="https://fulifeng.github.io/">冯福利老师</a> ，科研实力非常强，人也非常年轻，沟通起来轻松愉快，给了我很多帮助和鼓励！对<strong>推荐系统、信息检索、自然语言处理</strong>等方向感兴趣的都可以联系。老师在<strong>网安和大数据学</strong>院都有招生名额，通过组里的考核后老师会建议你报名相应的夏令营。</p></blockquote><p>中科大是少有的几所弱 com 学校，同时入营 bar 也是华五相对较低的，优营率很高，但是往年都是被鸽惨的学校（地域因素）。</p><p>网安学院无机试无笔试，面试有两轮，<strong>一轮含英语提问，一轮不含</strong>。其他流程一模一样，只是面试官不一样。共享屏幕用 PPT 自我介绍，抽题号问专业知识，因为我本身没有学过网安知识点，基本都是乱答。<strong>没学过就如实告知</strong>，有的老师会现场出你学过的其他专业课问题，或者翻看简历提问科研。</p><p>优营后需要自己联系导师完成双选，双选后才能向学院确定 offer，没有双选则优营不算数。因此<strong>最好提前联系导师</strong>防止名额不够。当时因为已经拿了软微的 offer，就私聊老师放弃双选了。</p><h2 id="6-预推免细节"><a href="#6-预推免细节" class="headerlink" title="6. 预推免细节"></a>6. 预推免细节</h2><h3 id="清华软院"><a href="#清华软院" class="headerlink" title="清华软院"></a>清华软院</h3><p>入营 bar 较高，和其他院在同一个系统填报，个人推测只能入一个学院，因为我报名的清深材料一直显示未查看。需要两封推荐信，而且要把链接发到推荐老师的邮箱，比较麻烦。推荐报名专硕或直博，留给外校的学硕名额非常少。</p><p>先是机试，外校机试占比 20%，三小时四题，难度 1 Easy，1 Medium，2 Hard。题目类型比较常规，跟其他几个院不一样（清深、网研院、贵系是同一套题，据说都是大模拟）。OJ 系统，提交后立刻判分，无罚时，可骗分。大部分人应该做出了三题，我比较菜只做出两题多。</p><blockquote><p>值得一提的是，这次的 Easy 居然就是考试前几天 LeetCode 的每日一题<strong>原题</strong>，一道 Hard 也涉及了每日一题的知识点（虽然我还是不会）。很梦幻。</p></blockquote><p>过几天后面试，占比 80%。面试前不知道顺序，需要在腾讯会议等待，如果是序号靠后的同学可能比较煎熬。需要共享屏幕自我介绍，之后常规提问。老师可能会对<strong>软件工程相关</strong>的项目比较感兴趣。</p><h2 id="7-后记"><a href="#7-后记" class="headerlink" title="7. 后记"></a>7. 后记</h2><h3 id="最终去向"><a href="#最终去向" class="headerlink" title="最终去向"></a>最终去向</h3><p>9 月 19 日收到了复旦大学打来的候补电话，当天正好是清华除贵系以外的学院开奖，不少大佬选择了清软或清深，于是当即接受。此前一直有在和一位 NLP 组的梦导保持联系，正好当天看到群里有同学鸽了学硕，于是询问后上岸。</p><p>随后就放弃了软微的 offer，因为已经进组学习了一段时间，老师似乎很生气，但最后也无奈放我走了。当初没有 offer 的时候收到了软微的电话，给考虑的时间不多，一度以为就这样上岸了。我也不喜欢这样的鸽子行为，深感抱歉，只能尽可能降低对老师的影响。</p><p>至此，整个持续好几个月的保研应该完整地结束了，最终的结果（学校、导师、地域、环境）都让我非常满意，也不会和女朋友异地，算是一个圆满的句号。这一路上认识了很多其他本科学校的小伙伴，都非常优秀且人都很有趣，一路上给了我很多帮助，也间接影响了最后的选择。感谢一路帮助过我的本科老师、外校老师、学长学姐、以及历年撰写保研经验的前辈们。最后，感谢女朋友 <a href="https://yiwen-ding.github.io/">CindyWen</a> 的一路陪伴，宣传一下她的 <a href="https://yiwen-ding.github.io/Baoyan-essay">保研回忆</a>，未来还请多多指教！</p><h3 id="谨记"><a href="#谨记" class="headerlink" title="谨记"></a>谨记</h3><ol><li>联系导师的最佳时间是「<strong>等到你的简历成型，不会让老师认为你不够优秀</strong>」的时候，越早越好。</li><li>提前规划好刷题、复习时间！不要等到暑假才集中准备，各种材料、系统填报<strong>非常占用时间</strong>。</li><li>复习专业课，与其盲目刷书看课件，不如去<strong>看面经整理常见问题</strong>，然后自己归纳答案。</li><li>线上参营的坏处是大部分 offer 集中在少部分人手里，但是最后 offer 都会释放，<strong>每个人都会有学上</strong>！</li><li>富贵险中求！报名人数越多、竞争越激烈的<strong>强组强导，最后越容易被鸽</strong>！优营的大佬大概率会有更好的去向。</li><li>跟老师保持联系时真诚相待，如果<strong>有其他目标院校在报考，最好先跟老师说清楚最后期限</strong>，大部分导师都会理解的。</li><li><strong>警惕有黑历史的学校、导师</strong>，如果不得已选择，最好手中再拿一个保底。</li><li>不可能去的学校就不要报名了，报名时间省下来刷两道题不好吗？<strong>把机会留给其他同学</strong>！</li><li>及时释放手中<strong>不会去</strong>的 offer，你的释放可能会让其他同学上岸梦校。</li></ol>]]></content>
    
    
    <categories>
      
      <category>心情随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法入门笔记 #2 STL标准库</title>
    <link href="/Algo-Note-2.html"/>
    <url>/Algo-Note-2.html</url>
    
    <content type="html"><![CDATA[<p>STL (Standard Template Library) 标准模板库，是一个具有工业强度的，高效的 C++ 程序库。文章开头先附上一个 STL 常用模板，方便取用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span> <span class="hljs-comment">// 万能头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-comment">// 大部分的 STL 保留字位于 std 命名空间</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> y second  <span class="hljs-comment">// 结合 pair 用</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> db;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-keyword">int</span>&gt; vi;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii; <span class="hljs-comment">// 常用于坐标系</span><br><br>vector&lt;<span class="hljs-keyword">int</span>&gt; a;<br>a.<span class="hljs-built_in">pb</span>(<span class="hljs-number">1</span>);<br><br>vector&lt;pii&gt; p;<br>p.<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">mp</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)); <span class="hljs-comment">// 支持 C++ 11 及以上的平台 mp 可以用 &#123;&#125; 代替</span><br></code></pre></td></tr></table></figure><h2 id="Algorithm-算法库"><a href="#Algorithm-算法库" class="headerlink" title="Algorithm 算法库"></a>Algorithm 算法库</h2><p>头文件 <code>#include&lt;algorithm&gt;</code> 定义了 STL 中基础的算法，大部分方法可以在容器中找到对应函数，例如不修改内容的 <code>find</code>、<code>count</code> 等操作，修改内容的 <code>remove</code>、<code>replace</code>、<code>swap</code> 等操作，以及排序、二分查找、两数取最大最小、交换两数等算法。</p><p>这里列出常用的几个操作：</p><ul><li><code>__gcd(1024, 256);</code>：求最大公约数。</li><li><code>min(&#123;a, b, c, d&#125;)</code>：返回多个数的最值，需要用<strong>大括号</strong>包围（C++11 以上）。</li><li><code>sort(a,a+n)</code>、<code>stable_sort(a,a+n)</code>：前者采用快速排序，后者采用归并排序，<strong>不改变相等元素的相对位置</strong>，除了数组指针也支持迭代器 <code>sort(v.begin(), v.end())</code>。<ul><li>如果要自定义比较函数 cmp，遵循以下模板：<code>bool cmp(T &amp;a,T &amp;b)&#123;return a&lt;b;&#125;</code>，在力扣刷题时要在函数前加上 <code>static</code>。</li><li>默认是升序排列，如果要降序排列则用 <code>sort(v.begin(), v.end(), greater&lt;int&gt;());</code></li></ul></li><li><code>reverse(v.begin(),v.end())</code>：翻转 vector 容器，也可以用于 string 字符串的翻转。</li><li><code>lower_bound(a,a+n,x)</code>：返回<strong>升序数组</strong>中可以插入元素 x 的<strong>最低位置</strong>，也就是<strong>大于等于</strong> x 的第一个数的地址；</li><li><code>upper_bound(a,a+n,x)</code>：返回<strong>升序数组</strong>中可以插入元素 x 的<strong>最高位置</strong>，也就是<strong>大于</strong> x 的第一个数的地址；<ul><li>简记：假设有一个数组 <code>1 1 2 2 2 3 3</code>，如果 x 选 2，则可以插在第一个 2 的位置，也可以插在第一个 3 的位置，此时其他元素后移，不会改变升序。</li><li>将得到地址减<strong>去数组的起始地址</strong>就可以得到下标：<code>pos = lower_bound(a,a+n,x) - a;</code></li><li>此方法在前两个参数构成的<strong>前闭后开</strong>区间内查找，如果不存在满足的元素则返回 <code>end()</code>，如果数组是降序的，则需要加上参数 <code>greater&lt;int&gt;()</code>。</li></ul></li><li><code>nth_element(first，kth，end)</code>：将<strong>第 k 小</strong>元素放到它该放的位置上，左边元素都小于等于它，右边元素都大于等于它。这是一个<strong>原地算法</strong>，会改变原数组，复杂度 $O(n)$。<ul><li>除了数组指针也支持迭代器 <code>nth_element(v.begin(), v.begin() + k, v.end())</code>，如果要选择<strong>第 k 大</strong>元素，可以使用 <code>nth_element(v.begin(), v.begin() + k, v.end(), greater&lt;int&gt;())</code>。</li></ul></li><li><code>next_permutation(a,a+n)</code>、<code>next_permutation(v.begin(), v.end())</code>：原地算法，改变原数组、向量、字符串为按字典序的全排列中的下一排列，返回 bool 值为 0 时表示结束。</li><li><code>accumulate(a,a+n,0)</code>、<code>accumulate(v.begin(), v.end(), 0)</code>：用加法运算符求出元素序列的和，第三个参数是和的初值。该方法也可以自定义加法运算符，作为第四个参数输入。</li><li><code>unique(a,a+n)</code>：去除数组中<strong>相邻的重复</strong>元素（配合排序使用），返回去重后的尾地址。这里的去除并非真正意义的 erase，而是将重复的元素放到容器的末尾。<ul><li>将尾地址<strong>减去数组的起始地址</strong>就能得到去重后的个数：<code>n = unique(a,a+n) - a;</code>，然后遍历。</li><li>结合向量的批量删除操作<strong>真正去掉重复</strong>：<code>v.erase(unique(v.begin(), v.end()), v.end());</code>，之后用 <code>n = v.size()</code> 就能得到去重后的个数。</li></ul></li></ul><h2 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串 | string"></a>字符串 | string</h2><p>string 是 C++ 特有的字符串变量类型。</p><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li>头文件 <code>#include&lt;string&gt;</code></li><li>声明 string 变量：<ul><li>直接声明并等号赋值：<code>string str=&quot;12345678&quot;;</code></li><li>声明一个副本：<code>string s(str);</code></li><li>声明一个字符串数组的复制品：<code>char ch[]=&quot;12345678&quot;; string s(ch);</code></li><li>利用迭代器复制区间：<code>string s(str.begin(),str.end()-2);</code></li><li>将 int 变量转 string：<code>string strNum=to_string(intNum);</code></li></ul></li><li>运算符（重载后）：<ul><li>比较运算符 <code>==  &gt;  &lt;  &gt;=  &lt;=  !=</code> 用法参考 <code>strcmp</code></li><li>加法运算符 <code>+  +=</code> 用于连接两个字符串</li><li>下标运算符 <code>[]</code> 用于获取特定位置</li></ul></li><li>特性函数：<ul><li>返回当前容量，即不必挪动就能存放的字符数：<code>s.capacity();</code></li><li>返回经过挪动后能存放的最大容量：<code>s.max_size();</code></li><li>返回当前在内存空间中的大小（字节数），不计终止符：<code>s.size();</code> 或 <code>s.length();</code></li><li>判断当前字符串是否为空：<code>s.empty();</code></li><li>返回当前 string 对应的<strong>字符数组</strong>的头指针：<code>printf(&quot;%s&quot;, s.c_str());</code></li></ul></li><li>查找运算：<ul><li>返回 str 在 s 中第一次出现的位置，没找到就返回 -1：<code>s.find(str);</code></li><li>同上，从下标为 index 处开始查找：<code>s.find(str,idx);</code></li><li>同上，查找对象换成字符：<code>s.find(&#39;x&#39;);</code></li><li>返回 str 在 s 中最后一次出现的位置：<code>s.find_last_of(str);</code></li></ul></li><li>其他运算：<ul><li>在下标 p 位置插入，原有的后移，但不能插在结束符后的空间：<code>s.insert(p, &quot;hello&quot;);</code></li><li>在末尾插入一个字符：<code>s.push_back(&#39;a&#39;);</code>（和 vector 很相似）</li><li>删除 p 开始的所有字符：<code>s.erase(p);</code></li><li>交换当前字符串与 str 的值：<code>s.swap(str);</code></li><li>返回从下标 i 开始的子串：<code>s.substr(0)</code></li><li>返回从下标 i 到下标 j 的子串：<code>s.substr(0,3)</code>，如果超过总长度则输出原字符串</li><li>将 string 变量转 int：<code>int num = stoi(s);</code></li></ul></li></ul><h3 id="特殊性质"><a href="#特殊性质" class="headerlink" title="特殊性质"></a>特殊性质</h3><ul><li>string 拥有一个特殊的输入输出流库：<code>#include&lt;sstream&gt;</code>，可以将任意类型的变量输出到流中，再以字符串的形式读出。如 int 转 string 操作：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#inlcude<span class="hljs-meta-string">&lt;sstream&gt;</span></span><br>stringstream ss;<br>ss &lt;&lt; intNum;<br>string strNum = ss.<span class="hljs-built_in">str</span>(); <span class="hljs-comment">//.str()是&lt;sstream&gt;库中的函数</span><br></code></pre></td></tr></table></figure><ul><li>由于 string 也是容器，因此支持迭代器和下标两种访问操作，通常用下标方便处理更复杂的输出。</li></ul><h3 id="易混淆的库"><a href="#易混淆的库" class="headerlink" title="易混淆的库"></a>易混淆的库</h3><ul><li>cstring：与 C 兼容的字符串处理库，使用字符串数组、指针操作<ul><li><code>strcpy(a,b)</code>：将 b 字符串拷贝到 a 处，遇到 <code>&#39;\0&#39;</code> 停止，可能溢出</li><li><code>strcat(a,b)</code>： 将 b 字符串连接到 a 处，可能溢出</li><li><code>strcmp(a,b)</code>：比较 a,b 字符串，直到遇到不相同的字符或者 <code>&#39;\0&#39;</code>，都相同返回 0，首个不同字符 a&lt;b 则返回负数，否则返回正数</li><li><code>strlen(a)</code>：返回 a 字符串的长度，不含 <code>&#39;\0&#39;</code></li><li><code>strstr(a,b)</code>：在 a 中查找 b 字符串，返回第一次出现位置的指针</li><li><code>memset(a,&#39;x&#39;,n)</code>：将 a 指向的内存空间，逐字节地赋值为字符 x，此处也可替换成 0-255 的十进制或十六进制数字</li><li><code>memcpy(a,b,n)</code>：将 b 指向的内存空间拷贝 n 个字节到 a，可能溢出</li><li><code>memcmp(a,b,n)</code>：比较两个内存空间的前 n 个字节</li></ul></li><li>cctype：用于字符类型的判别与处理<ul><li><code>isalnum()</code>：如果参数是字母数字，即字母或者数字，函数返回 true</li><li><code>isalpha()</code>：如果参数是字母，函数返回 true</li><li><code>isdigit()</code>：如果参数是数字（0－9），函数返回 true</li><li><code>isgraph()</code>：如果参数是除空格之外的打印字符，函数返回 true</li><li><code>islower()</code>：如果参数是小写字母，函数返回 true</li><li><code>isprint()</code>：如果参数是打印字符（包括空格），函数返回 true</li><li><code>isupper()</code>：如果参数是大写字母，函数返回 true</li><li><code>isxdigit()</code>：如果参数是十六进制数字，即 0－9、a－f、A－F，函数返回 true</li><li><code>tolower()</code>：如果参数是大写字符，返回其小写，否则返回该参数</li><li><code>toupper()</code>：如果参数是小写字符，返回其大写，否则返回该参数</li></ul></li></ul><h2 id="向量-vector"><a href="#向量-vector" class="headerlink" title="向量 | vector"></a>向量 | vector</h2><p>vector 是一个能够存放任意类型的<strong>动态数组</strong>，能够增加和压缩数据，是<strong>同一种类型</strong>的对象的集合，每个对象都有一个对应的整数索引值。</p><p>向量中的元素按照<strong>严格的线性顺序排序</strong>，可以通过元素在序列中的位置访问对应的元素。使用一个内存分配器对象来动态地处理它的存储需求。</p><h3 id="基础操作-1"><a href="#基础操作-1" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li><p>头文件 <code>#include&lt;vector&gt;</code></p></li><li><p>创建 vector 对象：</p><ul><li>直接创建：<code>vector&lt;int&gt; v;</code>（实际中通常会 <code>typedef vector&lt;int&gt; vi;</code>）</li><li>直接创建并初始化（类似数组）：<code>vector&lt;int&gt; v=&#123;1,2,3&#125;;</code></li><li>创建一个副本：<code>vector&lt;int&gt; v_b(v_a);</code></li><li>创建含有 <code>n</code> 个元素 <code>a</code> 的对象：<code>vector&lt;int&gt; v(n,a);</code></li><li>创建含有 <code>n</code> 个元素且全 0 的对象：<code>vector&lt;int&gt; v(n);</code></li><li>创建二维对象：<code>vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n));</code></li></ul></li><li><p>插入、删除元素：</p><ul><li>尾部插入元素：<code>v.push_back(a);</code></li><li>尾部删除元素：<code>int a = v.pop_back();</code></li><li>任意位置插入元素：<code>v.insert(v.begin()+i, a)</code>，在下标 i 的元素前面插入 a。</li></ul></li><li><p>删除元素：<code>v.erase(v.begin()+2)</code>，删除下标 2 的元素。</p><ul><li>批量删除：<code>v.erase(v.begin()+i, v.begin()+j)</code>，删除左闭右开区间。</li><li>批量赋<strong>递增值</strong>：<code>iota(v.begin(), v.end(), 1);</code>，赋值后的向量元素为 $\{1, 2, 3,\cdots\}$.</li></ul></li><li><p>特性函数：</p><ul><li>向量大小：<code>v.size()</code></li><li>内存中向量能包含的最大元素个数：<code>v.max_size()</code></li><li>清空：<code>v.clear();</code></li><li>判断空：<code>v.empty()</code></li></ul></li><li><p>访问元素：</p><ul><li><p>随机访问成员：<code>v.at(i)</code>，返回元素的引用</p></li><li><p>数组运算符：<code>v[i]</code>，返回元素的引用</p></li><li><p>特定元素访问：<code>v.front()</code> 和 <code>v.back()</code> 返回第一个和最后一个元素的引用</p></li><li><p>迭代访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 声明迭代器，此时的 it 类似指针</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator it; <span class="hljs-comment">// 这里可以换成 auto</span><br><span class="hljs-keyword">for</span>(it=vec.<span class="hljs-built_in">begin</span>(); it!=vec.<span class="hljs-built_in">end</span>(); it++)<br>    cout&lt;&lt;*it&lt;&lt;endl;  <span class="hljs-comment">// 访问指针指向的元素，有 *</span><br><br><span class="hljs-comment">// C++11 新语法，此时的 item 为元素本身</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item:vec)<br>    cout&lt;&lt;item&lt;&lt;endl;  <span class="hljs-comment">// 不需要 *，且此时修改不会影响原数组（深拷贝）</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;item:vec)<br>    item++;    <span class="hljs-comment">// 如果带有 &amp; 就可以修改元素（浅拷贝）</span><br><br><span class="hljs-comment">// 不用迭代器直接用下标索引遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++)<br>    cout&lt;&lt;vec[i]&lt;&lt;endl;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="特殊性质-1"><a href="#特殊性质-1" class="headerlink" title="特殊性质"></a>特殊性质</h3><ul><li><code>v.begin()</code> 与 <code>v.end()</code> 返回的是<strong>指针</strong>，指向第一个元素和最后一个元素的<strong>下一个位置</strong>（无意义），只能赋值给迭代器。<ul><li>与普通指针相同，<code>*(v.begin()+i)</code> 可以访问下标 i 的元素。</li><li>与普通数组相同，使用 sort 排序时，必须要用 <code>sort(v.begin(),v.end());</code></li></ul></li><li><code>v.front()</code> 与 <code>v.back()</code> 返回的是元素的<strong>引用</strong>，可以赋值给<strong>别名变量</strong>（浅拷贝）或普通变量（深拷贝）。<ul><li>引用是 C++ 特有的语法，声明引用变量 <code>int &amp;a=v.front();</code> 时，共享同一内存单元。</li><li>类似的还有随机访问 <code>v.at(i)</code> 和数组运算符 <code>v[i]</code>，也可以赋值给别名变量或普通变量。</li></ul></li><li>vector 作为函数的参数或者返回值时，必须用 <code>&amp;</code> <strong>传引用调用</strong>：<ul><li><code>double Distance(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b)</code></li><li>注意<strong>普通数组传引用</strong>调用时需要<strong>带个数</strong>：<code>(int (&amp;a)[10])</code>，传指针不需要：<code>(int *a)</code> 或 <code>(int a[])</code></li></ul></li><li>能够存放任意类型，意味着可以嵌套其他数据结构：<ul><li>定义二维动态数组：<code>vector&lt;vector&lt;int&gt;&gt; v;</code></li><li>定义静态数组内一维动态数组：<code>vector&lt;int&gt; a[100];</code>，可用于邻接表。</li><li>定义结构体数组：<code>vector&lt;Student&gt; v;</code>，结构体需要全局定义。</li><li>两个存放相同类型元素的向量可以使用<strong>比较运算符</strong>，依据字典序逐个比较。</li></ul></li><li>vector 的 push_back() 代价虽然是均摊的 O(1)，但是当数据量大的时候会很慢。所以如果需要使用的话，可以用 <code>vector&lt;int&gt; v(n);</code> 初始化再赋值。</li></ul><h2 id="配对-pair"><a href="#配对-pair" class="headerlink" title="配对 | pair"></a>配对 | pair</h2><p>pair 可以将<strong>两个任意类型</strong>的元素绑定成一组元素，其内部实现就是一个 <code>template&lt;class T1,class T2&gt;</code> 的结构体。可以用来组成更高级的映射 map，也可以用来表示<strong>坐标</strong>等双元素的结构体。当一个函数需要返回两个数据的时候，可以选择 pair。</p><h3 id="基础操作-2"><a href="#基础操作-2" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li>头文件 <code>#include&lt;utility&gt;</code></li><li>创建 pair 对象：<ul><li>直接创建：<code>pair&lt;int,int&gt; p;</code>（实际中通常会 <code>typedef pair&lt;int,int&gt; pii;</code>）</li><li>创建并赋值：<code>pair&lt;int,int&gt; p(3,4);</code></li><li>使用 C++ 括号运算符赋值：<code>pair&lt;int,int&gt; p = &#123;3，4&#125;;</code></li><li>先创建后赋值：<code>p = make_pair(3,4);</code></li></ul></li><li>访问对象：<ul><li>等价于结构体变量：<code>cout &lt;&lt; p.first &lt;&lt; &#39; &#39; &lt;&lt; p.second;</code>（注意不是指针）</li></ul></li><li>嵌套：<ul><li>三元 pair：<code>pair&lt;int, pair&lt;int, int&gt;&gt; p(1,&#123;2,3&#125;);</code></li><li>其他容器：<code>vector&lt;pair&lt;int, int&gt;&gt;</code>（实际中通常会 <code>vector&lt;pii&gt; v</code>）</li></ul></li></ul><h3 id="特殊性质-2"><a href="#特殊性质-2" class="headerlink" title="特殊性质"></a>特殊性质</h3><ul><li><p>在某些情况函数想要返回两个数据时，可以将 pair 对象作为返回值，此时函数外接收的对象可以是 pair，也可以直接通过 std::tie 进行接收：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">pair&lt;string, <span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getPreson</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Steve&quot;</span>, <span class="hljs-number">25</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>string name; <span class="hljs-keyword">int</span> ages;<br><span class="hljs-built_in">tie</span>(name, ages) = <span class="hljs-built_in">getPreson</span>(); <span class="hljs-comment">// 类似 Python 中的元组解包</span><br>cout &lt;&lt; <span class="hljs-string">&quot;name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;, ages: &quot;</span> &lt;&lt; ages &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组 | tuple"></a>元组 | tuple</h2><p>C++11 引入的 tuple 可以将<strong>多个任意类型</strong>的元素绑定成一组元素，是泛化的 pair。通常将其当作一个简易的结构体使用，避免复杂的声明，用法与 pair 非常类似。</p><h3 id="基础操作-3"><a href="#基础操作-3" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li>头文件 <code>#include&lt;tuple&gt;</code></li><li>创建 tuple 对象：<ul><li>直接创建：<code>tuple&lt;int,int,int&gt; tup;</code></li><li>创建并赋值：<code>tuple&lt;int,int,int&gt; tup(1, 2, 3);</code></li><li>创建并使用函数赋值：<code>tuple&lt;int,int,int&gt;tup = make_tuple(1, 2, 3);</code> 和 pair 不同，这里的<strong>创建步骤不能省略</strong>！</li></ul></li><li>访问对象（注意<strong>不要漏掉括号</strong>）：<ul><li>get 函数：<code>cout &lt;&lt; get&lt;0&gt;(tup) &lt;&lt; &#39; &#39;&lt;&lt; get&lt;1&gt;(tup);</code>，返回的是元素的引用，因此可以修改</li></ul></li><li>元组解包：<ul><li>主动声明变量：<code>tie(a, b, c) = tup;</code></li><li>自动声明变量：<code>auto&amp; [a, b, c] = tup;</code> 如果某个元素不需要用到，可以用 <code>_</code> 代替</li></ul></li><li>嵌套到其他容器（以向量为例）：<ul><li>声明：<code>vector&lt;tuple&lt;int, int, int&gt;&gt; tups;</code></li><li>插入：<code>tups.push_back(make_tuple(1, 2, 3))</code> 或 <code>tups.emplace_back(1, 2, 3);</code></li></ul></li></ul><h2 id="映射-map"><a href="#映射-map" class="headerlink" title="映射 | map"></a>映射 | map</h2><p>map 是一个存放<strong>一对一映射</strong>（pair）的关联容器，存储的<strong>关键字和值</strong>可以定义为任意类型，各个键值对的<strong>键互不相同且不允许被修改</strong>，但值可以相同。</p><p>map 的内部实现为<strong>红黑树</strong>（弱平衡二叉树），是二叉搜索树的升级版，具有对数据进行<strong>排序</strong>的功能。因此我们可以认为 map 内部所有键值对都是按 key 排序的，key 必须为<strong>可排序的类型</strong>（包括自定义类型）。</p><p>需要强调的是，map 中对元素增删改查的时间复杂度都是 $O(\log n)$，但使用迭代器遍历 map 的复杂度是 $O(n)$。</p><h3 id="基础操作-4"><a href="#基础操作-4" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li><p>头文件 <code>#include&lt;map&gt;</code></p></li><li><p>创建 map 对象：</p><ul><li>直接创建：<code>map&lt;string,int&gt; mp;</code></li><li>创建并初始化：<code>map&lt;string,int&gt; mp=&#123;&#123;"A", 10&#125;, &#123;"B", 20&#125;, &#123;"C", 30&#125;&#125;;</code></li></ul></li><li><p>插入元素：</p><ul><li>用 insert 函数插入 pair：<code>mp.insert(pair&lt;string, int&gt;(&quot;hw&quot;, 2001));</code> 通常会结合 typedef 简化；</li><li>前者也可以用 make_pair 替换：<code>mp.insert(make_pair(&quot;hw&quot;, 2001));</code></li><li>C++ 11 标准支持<strong>花括号初始化</strong>：<code>mp.insert(&#123;&quot;hw&quot;, 2001&#125;);</code></li><li>用 insert 函数插入 value_type 数据：<code>mp.insert(map&lt;string, int&gt;::value_type(&quot;hw&quot;, 2001));</code></li><li>用数组运算符<strong>访问并插入</strong>（最常用）：<code>mp[“hw”]=2001;</code>，此时<strong>不受唯一性限制</strong>，可以覆盖已有的键值对；</li></ul></li><li><p>删除元素（erase 函数）：</p><ul><li>删除迭代器指向元素：<code>auto it=mp.find(&quot;hw&quot;); mp.erase(it);</code></li><li>删除关键字：<code>bool flag = mp.erase(&quot;hw&quot;);</code> 如果找到并删除则返回 1，否则返回 0</li><li>删除迭代器指向区间元素：<code>mp.erase(++mp.begin(), mp.end());</code></li></ul></li><li><p>特性函数：</p><ul><li>键值对数目：<code>mp.size()</code></li><li>清空：<code>mp.clear();</code></li><li>判断空：<code>mp.empty()</code></li></ul></li><li><p>访问元素：</p><ul><li><p>随机访问成员：<code>mp.at(&quot;hw&quot;)</code>，返回元素的引用，如果访问到<strong>未知元素会抛出异常</strong>。</p></li><li><p>数组运算符访问：<code>cout &lt;&lt; mp[&quot;hw”];</code>，返回元素的引用，如果访问到未知元素会返回一个<strong>全零的空值</strong>！</p></li><li><p>查找元素：<code>auto it=mp.find(&quot;hw&quot;);</code> 返回指向元素的迭代器，如果没找到，则返回 <code>mp.end()</code>；此外，如果想<strong>判断一个元素是否存在</strong>，可以直接 <code>mp.count(&quot;hw&quot;) != 0</code>，该值在 map 和 set 中只能为 0 或 1。</p></li><li><p>迭代访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 声明迭代器，此时的 it 类似结构体指针</span><br>map&lt;string,<span class="hljs-keyword">int</span>&gt;::iterator it; <span class="hljs-comment">// 这里可以换成 auto</span><br><span class="hljs-keyword">for</span>(it=mp.<span class="hljs-built_in">begin</span>(); it!=mp.<span class="hljs-built_in">end</span>(); it++)<br>    cout&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;it-&gt;second&lt;&lt;endl; <span class="hljs-comment">// 不能直接 * 访问</span><br><br><span class="hljs-comment">// C++11 新语法，此时的 item 类似结构体</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;item: mp)<br>    cout&lt;&lt;item.first&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;item.second&lt;&lt;endl; <span class="hljs-comment">// 结构体直接用 . 访问属性</span><br><br><span class="hljs-comment">// 反向迭代访问</span><br>map&lt;string,<span class="hljs-keyword">int</span>&gt;::reverse_iterator it;<br><span class="hljs-keyword">for</span>(it = mp.<span class="hljs-built_in">rbegin</span>(); it != mp.<span class="hljs-built_in">rend</span>(); it++)<br>    cout&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="特殊性质-3"><a href="#特殊性质-3" class="headerlink" title="特殊性质"></a>特殊性质</h3><ul><li>map、set、multimap、multiset 的迭代器是没有加减法的，仅支持自增 <code>it++</code>、自减 <code>it--</code> 的操作，不支持 <code>it+1</code>、<code>mp.begin()+1</code> 操作。这是因为这些容器采用了特殊的数据结构，没有「<strong>两个元素之距离</strong>」的概念。</li><li>采用迭代器遍历 map、set 的复杂度是 $O(n)$，这是因为二叉树的遍历是 $O(E)$，每一条边只会被自上而下、自下而上各访问一次。</li><li>由于内部有序，map 和 set 支持 <code>mp.lower_bound(key)</code> 、<code>mp.upper_bound(key)</code>、<code>equal_range(key)</code> 运算，返回指向特定结构体的迭代器指针。但是考虑到 map 和 set 中都不会有重复的 key，此方法在 multimap、multiset 更常用。</li><li>map 和 set 的插入删除，并不会使已经赋值的 iterator 失效，这是因为插入删除<strong>不会改变内部的树结构</strong>，不需要进行内存拷贝和移动；但是对于 vector 而言，每次插入删除<strong>都可能使其失效</strong>，即使是调用 push_back 的尾部插入，除了因为连续存放导致的内存平移，还可能涉及到容量倍增等操作。牢记一个原则：<strong>不要使用过期的迭代器</strong>。</li></ul><h3 id="哈希表-unordered-map"><a href="#哈希表-unordered-map" class="headerlink" title="哈希表 | unordered_map"></a>哈希表 | unordered_map</h3><p>如果只是需要一个映射关系，而不需要其有序，可以用 unordered_map。和 map 容器相似，unordered_map 同样以<strong>键值对</strong>（pair）的形式存储数据，存储的各个键值对的<strong>键互不相同且不允许被修改</strong>。</p><p>无序映射的底层采用<strong>哈希表</strong>存储结构，根据键的 hash 值来判断元素是否相同，不具有对数据的排序功能，但可以实现 $O(1)$ 查找、插入。由于无序，不支持 <code>lower_bound()</code> 和 <code>upper_bound()</code> 等方法。</p><p>常用的操作与 map 类似：</p><ul><li><p>头文件 <code>#include &lt;unordered_map&gt;</code></p></li><li><p>创建 unordered_map 对象：<code>unordered_map&lt;string,int&gt; hash;</code></p></li><li><p>$O(1)$ 插入元素（最常用）：<code>hash[&quot;ABC&quot;]=5;</code></p></li><li><p>$O(1)$ 查询元素（最常用）：<code>int n=hash[&quot;ABC&quot;];</code></p></li><li><p>判断关键字是否存在：<code>hash.count(&quot;ABC&quot;) != 0</code> 或 <code>hash.find(&quot;ABC&quot;) != hash.end()</code>，前者更为常用。</p></li><li><p>迭代访问（较少用）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 声明迭代器，此时的 it 为结构体指针</span><br>unordered_map&lt;string,<span class="hljs-keyword">int</span>&gt;::iterator it;<br><span class="hljs-keyword">for</span>(it=hash.<span class="hljs-built_in">begin</span>(); it!=hash.<span class="hljs-built_in">end</span>(); it++)<br>    cout&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;<br><br><span class="hljs-comment">// C++11 新语法，此时的 item 为结构体</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item: hash)<br>    cout&lt;&lt;item.first&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;item.second&lt;&lt;endl;<br></code></pre></td></tr></table></figure></li></ul><p>如果想让自定义的 class 作为 key 来使用 unordered_map，则还自行需要实现：重载<strong>哈希函数</strong>、判断两个 class 变量是否相等的函数（重载<strong>等价运算符</strong>）。</p><blockquote><p>哈希集合 unordered_set 有时也会用到，方法类似，不再单独介绍。</p></blockquote><h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><p>具有和 map 相同的诸多特性，最主要的区别在于，multimap 容器中可以同时存储<strong>多个键相同的键值对</strong>。</p><p>和 map 相比，multimap 未提供 <code>at()</code> 成员方法，也没有重载 <code>[]</code> 运算符。这意味着，map 容器中通过指定键获取键值对的方式，将不再适用于 multimap 容器。其实这很好理解，因为 multimap 容器中指定的键可能对应多个键值对，而不再是 1 个。</p><p>值的一提的是，由于 multimap 可存储多个具有相同键的键值对，因此 <code>lower_bound()</code>、<code>upper_bound()</code>、<code>equal_range()</code> 以及 <code>count()</code> 方法会经常用到。</p><h2 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 | set"></a>集合 | set</h2><p>set 是一个存放同一类型元素的<strong>集合</strong>容器，满足数学定义上集合的<strong>互异性</strong>——即 set 中每个元素只能出现一次。其内部实现也为红黑树，因此能根据元素的值自动进行排序。</p><p>set 中对元素增删改查的时间复杂度都是 $O(\log n)$，但使用迭代器遍历 set 的复杂度是 $O(n)$。</p><h3 id="基础操作-5"><a href="#基础操作-5" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li><p>头文件 <code>#include&lt;set&gt;</code></p></li><li><p>创建 set 对象：</p><ul><li>直接创建：<code>set&lt;int&gt; st;</code></li><li>创建并初始化：<code>set&lt;int&gt; st=&#123;1, 2, 3, 4&#125;;</code></li><li>创建并拷贝：<code>set&lt;int&gt; new_st(st);</code></li></ul></li><li><p>插入、删除元素：</p><ul><li>插入一个元素：<code>st.insert(3);</code></li><li>删除一个元素：<code>st.erase(3);</code></li><li>删除迭代器指向元素：<code>auto it=st.find(3); st.erase(it);</code></li><li>删除区间内的元素：<code>st.erase(++st.begin(), st.end());</code></li></ul></li><li><p>特性函数：</p><ul><li>元素个数：<code>st.size();</code></li><li>清空集合：<code>st.clear();</code></li><li>判断空：<code>st.empty();</code></li></ul></li><li><p>访问元素：</p><ul><li><p>查找元素：<code>auto it=st.find(&quot;hw&quot;);</code> 返回指向元素的迭代器，如果没找到，则返回 <code>st.end()</code>；此外，如果想<strong>判断一个元素是否存在</strong>，可以直接 <code>st.count(&quot;hw&quot;) != 0</code>，该值在 map 和 set 中只能为 0 或 1。</p></li><li><p>有序性：<code>st.lower_bound(2)</code>、<code>st.upper_bound(2)</code>，返回指向特定结构体的迭代器指针。</p></li><li><p>迭代访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 声明迭代器，此时的 it 类似指针</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=st.<span class="hljs-built_in">begin</span>(); it!=st.<span class="hljs-built_in">end</span>(); it++)<br>    cout&lt;&lt;*it&lt;&lt;endl; <span class="hljs-comment">// 访问指针指向的元素，有 *</span><br><br><span class="hljs-comment">// C++11 新语法，此时的 item 为元素本身</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;item: st)<br>    cout&lt;&lt;item&lt;&lt;endl; <span class="hljs-comment">// 不需要 *</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="特殊性质-4"><a href="#特殊性质-4" class="headerlink" title="特殊性质"></a>特殊性质</h3><ul><li><p>map 和 set 本身都是以升序排列，但是对于 set 而言有时候会改变其排序的方式，也可能引入结构体，因此需要用到自定义比较函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 元素不是结构体，重载 () 运算符</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span>&#123;</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp;a, <span class="hljs-keyword">const</span> T &amp;b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a.data &gt; b.data;<br>    &#125;<br>&#125;<br>set&lt;T, cmp&gt; st;<br><br><span class="hljs-comment">// 元素是结构体，直接将比较函数写在结构体内</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Info</span>&#123;</span><br>string name;<br><span class="hljs-keyword">float</span> score;<br><span class="hljs-comment">// 重载 &lt; 操作符，自定义排序规则</span><br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> Info &amp;a) <span class="hljs-keyword">const</span>&#123;<br><span class="hljs-comment">// 按 score 从大到小排列</span><br>        <span class="hljs-keyword">return</span> a.score &lt; score;<br>    &#125;<br>&#125;<br>set&lt;Info&gt; s;<br></code></pre></td></tr></table></figure></li></ul><h3 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h3><p>multiset 使用频率相对较低，其和 set 的区别在于，multiset 容器中可以同时存储<strong>多个相同的元素</strong>，不再有互异性。</p><p>但是由于 set 结构的有序性，当我们需要一个「<strong>时刻有序的数组</strong>」时，支持 $O(\log n)$ 地插入、删除、修改数组元素后<strong>依然保持有序</strong>，multiset 就会派上用场。经常结合  <code>lower_bound()</code>、<code>upper_bound()</code> 使用。</p><h2 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 | stack"></a>栈 | stack</h2><p>从一段进栈，从同一端出栈，满足后进先出（LIFO）。</p><h3 id="基础操作-6"><a href="#基础操作-6" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li>头文件 <code>include&lt;stack&gt;</code></li><li>创建 stack 对象：<code>stack&lt;int&gt; s;</code></li><li>操作元素：<ul><li>栈顶压入元素：<code>s.push(x);</code></li><li>栈顶弹出元素：<code>s.pop();</code>，注意此时<strong>没有返回值</strong>；</li><li>返回栈顶元素：<code>s.top()</code>，返回<strong>元素的引用，因此可以直接修改</strong>。</li></ul></li><li>特性函数：<ul><li>栈长度：<code>s.size()</code></li><li>判断栈空：<code>s.empty()</code></li></ul></li></ul><h3 id="特殊性质-5"><a href="#特殊性质-5" class="headerlink" title="特殊性质"></a>特殊性质</h3><ul><li>当栈为空的时候，如果调用 <code>s.top()</code> 则出现<strong>数组越界</strong>报错，解决办法是在使用该方法前加一个栈空判断：<code>!s.empty() &amp;&amp; s.top()</code>。该方法同样适用于队列、向量等容器。</li><li>C++11 新增 <code>s.emplace(x)</code> 操作，用于在栈顶压入元素，参数为<strong>直接对象</strong>时相当于 <code>s.push(x)</code>，区别在于当参数为<strong>构造函数对象</strong>时，例如 <code>s.push(data(x,y))</code> 和 <code>s.emplace(data(x,y))</code> 时，此时后者可以简化为 <code>s.emplace(x,y)</code>。</li></ul><h2 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列 | queue"></a>队列 | queue</h2><p>从一端入队，从另一端出队，满足先进先出（FIFO）的结构。普通的队列基于链表结构实现，而优先队列基于堆结构实现。</p><h3 id="基础操作-7"><a href="#基础操作-7" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li>头文件 <code>#include&lt;queue&gt;</code></li><li>创建 queue 对象：<code>queue&lt;int&gt; q;</code></li><li>操作元素：<ul><li>队尾插入元素：<code>q.push();</code></li><li>队首弹出元素：<code>q.pop();</code>，注意此时<strong>没有返回值</strong>；</li><li>返回队首元素：<code>q.front()</code>，返回<strong>元素的引用，因此可以直接修改</strong>；</li><li>返回队尾元素：<code>q.back()</code>，返回元素的引用，因此可以直接修改。</li></ul></li><li>特性函数：<ul><li>队列长度：<code>q.size();</code></li><li>判断队空：<code>q.empty();</code></li><li>注意队列和栈都没有 clear 函数，想要清空只能重新初始化：<code>q = queue&lt;int&gt; ();</code></li></ul></li></ul><h3 id="优先队列-priority-queue"><a href="#优先队列-priority-queue" class="headerlink" title="优先队列 | priority_queue"></a>优先队列 | priority_queue</h3><p>利用自带的优先队列可以实现最大堆和最小堆，其<strong>头文件和队列相同</strong>，特性函数也相同。此时优先级最高的先出队，默认情况下优先级就是「整数的大小」。出入队的复杂度为 $O(\log n)$，$n$ 为队列的大小。下面介绍基础的用法：</p><ul><li>创建 priority_queue 对象：<ul><li>优先队列有<strong>三个参数</strong>，其声明形式为：<code>priority_queue&lt;类型, vector&lt;类型&gt;, less&lt;类型&gt;&gt;</code>，后两个参数可以省略，第一个参数不能省略，三个 <code>类型</code> 保持一致。</li><li>构建最大堆（大顶堆）：<code>priority_queue&lt;int&gt; max_heap;</code> 或 <code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; max_heap;</code></li><li>构建最小堆（小顶堆）：<code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; min_heap;</code> </li></ul></li></ul><ul><li>操作元素：<ul><li>在完全二叉树的底部插入元素，并上浮到相应位置：<code>heap.push();</code></li><li>从堆顶弹出元素，并填充二叉树底部元素，然后下滤到相应位置：<code>heap.pop();</code></li><li>返回堆顶元素：<code>heap.top()</code>，注意和普通队列的区别！</li></ul></li></ul><p>如果想自定义其他优先级，则需要在<strong>自定义结构体</strong> cmp 中重载括号运算符 <code>()</code>，使其变成<strong>仿函数</strong>（Functor），并替换 <code>less&lt;类型&gt;</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span>&#123;</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp;a, <span class="hljs-keyword">const</span> T &amp;b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a.data &lt; b.data;<br>    &#125;<br>&#125;;<br>priority_queue&lt;T, vector&lt;T&gt;, cmp&gt; heap; <br></code></pre></td></tr></table></figure><p>或者在主函数外<strong>自定义比较函数</strong> cmp（类似 sort 的写法），再用 <code>decltype</code> 进行<strong>类型自动推断</strong>（转为仿函数）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">comp</span><span class="hljs-params">(T &amp;a, T &amp;b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a.data &gt; b.data;<br>&#125;<br>priority_queue&lt;T ,vector&lt;T&gt;, <span class="hljs-keyword">decltype</span>(&amp;cmp)&gt; <span class="hljs-built_in">heap</span>(cmp);<br></code></pre></td></tr></table></figure><h2 id="双端队列-deque"><a href="#双端队列-deque" class="headerlink" title="双端队列 | deque"></a>双端队列 | deque</h2><p>具备栈和队列的功能，但是操作要慢一点（常数级）。在实际使用中可以和 vector 类比，vector 的优势是对<strong>中间</strong>的操作速度快（例如索引遍历、迭代器遍历），deque 优势是对<strong>首端</strong>的操作速度快（例如删除头部）。在对尾端操作上（例如尾端插入），二者速度相仿。</p><p>在实际应用中，常用于实现单调队列、滑动窗口等算法。</p><h3 id="基础操作-8"><a href="#基础操作-8" class="headerlink" title="基础操作"></a>基础操作</h3><ul><li>头文件 <code>#include &lt;deque&gt;</code></li><li>创建 deque 对象：<code>deque&lt;int&gt; dq;</code></li><li><p>操作元素：</p><ul><li>返回队首元素：<code>dq.front();</code></li><li>返回队尾元素：<code>dq.back();</code></li><li>队首插入一个元素：<code>dq.push_front();</code></li><li>队尾插入一个元素：<code>dq.push_back();</code></li><li>队首弹出一个元素：<code>dq.pop_front();</code></li><li>队尾弹出一个元素：<code>dq.pop_back();</code></li></ul></li><li><p>特性函数：</p><ul><li>双端队列长度：<code>dq.size();</code></li><li>判断队空：<code>dq.empty();</code></li><li>清空队列：<code>dq.clear();</code></li><li>返回指向第一个元素和最后一个元素的指针（只能赋值给迭代器）：<code>v.begin()</code>、 <code>v.end()</code></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>算法入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法入门笔记 #1 杂记</title>
    <link href="/Algo-Note-1.html"/>
    <url>/Algo-Note-1.html</url>
    
    <content type="html"><![CDATA[<p>该笔记是去年尝试入坑 ACM 竞赛的遗留物，为作机试的准备，重新整理一遍以加深印象。以下部分内容出自<strong>刘汝佳</strong>的《算法计算入门经典》，也就是俗称的「<strong>紫书</strong>」，部分内容参考了网上流传甚广的博客。</p><h2 id="算法竞赛技巧"><a href="#算法竞赛技巧" class="headerlink" title="算法竞赛技巧"></a>算法竞赛技巧</h2><ol><li>数组在 <code>main</code> 外面定义可以开得更大：避免<strong>爆栈</strong>，在全局区申请分担压力；<code>main</code> 函数返回 0，是为了告诉操作系统、IDE、调试器、OJ，程序正常结束。</li><li>对复杂的表达式化简不仅可以减少计算量，还能减少<strong>中间结果溢出</strong>的可能，尤其是带除法运算的浮点数，绝对会爆 double，必须把表达式通分后除最大公约数。</li><li><p>使用 <code>while(scanf(&quot;%d&quot;, &amp;x) == 1)</code>读入<strong>未知量</strong>数据：<code>scanf</code> 会成功返回读入变量的个数，如果有多个变量，则用 <code>== 2</code>。否则即使只成功一个，返回 <code>1</code>，循环还是会执行。如果发生错误输入/中止符，中止前输入的数也会被保存。</p><ul><li><p>此时运行代码时如果用键盘输入，则最后一个 Enter 无法中止程序，因为函数默认略过换行。</p></li><li><p>在 Windows 下，输入完毕后先按 Enter 再按 <code>Ctrl+Z</code> 再按 Enter 可以结束输入，相当于人工输入一个 EOF，换成 <code>while(scanf() != EOF)</code> 也行。</p></li><li><p>在 Linux 下，输入完毕后按 <code>Ctrl+D</code> 即可。</p></li></ul></li><li>使用 <code>while(cin&gt;&gt;x)</code> 读入<strong>未知量</strong>数据：正常输入，直到遇到文件结束符 EOF 或人工输入 <code>Ctrl+Z</code>，istream 返回无效假条件；错误输入，如用字符输入整型变量，也会返回假条件，强制结束循环；如果有多个读入 <code>&gt;&gt;x&gt;&gt;y</code>，只要发生上面任意一种，都会中止，但在中止前输入的数会保存；<ul><li>证明了 <code>&gt;&gt;</code> 运算符返回值是同样的 istream。</li></ul></li><li>打表法：对于输入范围在 1e3 以内，暴力复杂度较高的情况，使用一个 <code>freopen(&quot;ans.txt&quot;,&quot;w&quot;,stdout);</code> 即可将输出重定向到文本，再<strong>造好数组格式的输出</strong>，手动复制到代码里提交即可；<ul><li>一维数组：造输出时用 <code>printf(&quot;%d,&quot;,num);</code> 不要忘记输出逗号，复制到 <code>int ans[]=&#123;这里&#125;;</code> 。</li><li>二维数组：造输出时用 <code>printf(f[%d][%d]=%d&quot;,i,j,d[n][m]);</code>，复制到一个 <code>void get_ans()&#123;这里&#125;</code>。</li><li>如果有 <code>long long</code> 输出，必须带上 <code>LL</code>，用 <code>printf(&quot;f[%d][%d]=%lldLL&quot;,i,j,d[n][m]);</code>。</li></ul></li><li>O3 优化：如果代码里有 STL 的话，请一定加上这句话 <code>#pragma GCC optimize(3)</code>，一般的 OJ 都是默认开启的，洛谷需要手动点一下。<ul><li>开启 O3 后编译器会自动 <code>inline/register</code> 加速，节省时间（代价是汇编代码变多，可能编译失败）。</li><li>开启 O3 后编译器会自动 <code>const</code> 所有不修改的常量，加速取模等复杂运算。</li><li>开启 O3 后编译器会自动将乘法变成移位运算。</li></ul></li><li><code>cin/cout</code> 解绑：原生的 <code>cin/cout</code> 的速度非常慢，因为要和 <code>scanf/printf</code> 进行同步，所以需要加上 <code>ios::sync_with_stdio(false); cin.tie(0);</code><ul><li>注意解绑后，不能使用 <code>scanf/printf</code> 了，快读也是不可以的。解绑后的 <code>cin/cout</code> 的速度是比 <code>scanf</code> 要快的，因为不用类型判断。</li><li>解绑后可以 <code>#define endl &quot;\n&quot;</code>，因为 <code>endl</code> 在使用的时候不仅仅是换行，还会清空缓冲区。速度上可能比 <code>&quot;\n&quot;</code> 换行慢了 10 倍。</li></ul></li></ol><h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><ol><li>最常用的方法：<strong>输出中间结果</strong>，提交代码时记得注释掉；</li><li>使用 <code>exit(0);</code> 中断程序，如果没有问题，则往下继续中断，也可以用来定位 bug；</li><li>编译时加入以下参数 <code>-Wall -Wshadow</code>：增强警告信息，列举所有有遮盖关系的变量（覆盖）；</li><li>调试时不想反复输入数据，可用<strong>重定向输入输出</strong>，这样就会把文件作为流：<ul><li><code>freopen(&quot;input.in&quot;, &quot;r&quot;, stdin);</code></li><li><code>freopen(&quot;output.out&quot;, &quot;w&quot;, stdout);</code></li><li>如果懒得注释可以用 <code>#define LOCAL</code>，再在 <code>#ifdef LOCAL</code> 和 <code>#endif</code> 两句中重定向，提交代码时删除定义语句 <code>#define LOCAL</code>。</li></ul></li><li><strong>断言</strong>表达式 <code>assert(判断语句)</code>：当判断语句为真时无变化，当表达式为假时中止程序，并给出错误提示。</li></ol><h2 id="实用代码"><a href="#实用代码" class="headerlink" title="实用代码"></a>实用代码</h2><ol><li>如果题目要求文件提交，但禁止重定向：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">FILE *fin, *fout;<span class="hljs-comment">// c</span><br>fin=<span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;data.in&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br>fout=<span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;data.out&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>);<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">fscanf</span>(fin, <span class="hljs-string">&quot;%d&quot;</span>, &amp;x) != EOF)<br><span class="hljs-built_in">fprintf</span>(fout, <span class="hljs-string">&quot;%d&quot;</span>, x);<br><span class="hljs-built_in">fclose</span>(fin);<br><span class="hljs-built_in">fclose</span>(fout);<br></code></pre></td></tr></table></figure><blockquote><p>在比赛前先了解是使用标准输入输出（即标准I/O，用键盘读写）还是文件输入输出。如果是文件输入输出，是否禁止用重定向的方式访问文件</p></blockquote><ol><li>如果允许重定向：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x) != EOF) <span class="hljs-comment">// 这里也可以换成 cin &gt;&gt; x</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, x);<span class="hljs-comment">// 这里也可以换成 cout &lt;&lt; x</span><br><span class="hljs-built_in">fclose</span>(stdin);<br><span class="hljs-built_in">fclose</span>(stdout);<br></code></pre></td></tr></table></figure><ol><li><p>交换两数：<code>a^=b^=a^=b;</code></p></li><li><p>三整数排序：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(a&gt;b) <span class="hljs-built_in">swap</span>(a,b); <span class="hljs-comment">// 执行完a≤b</span><br><span class="hljs-keyword">if</span>(a&gt;c) <span class="hljs-built_in">swap</span>(a,c); <span class="hljs-comment">// 执行完a≤c，且a≤b依然成立</span><br><span class="hljs-keyword">if</span>(b&gt;c) <span class="hljs-built_in">swap</span>(b,c); <span class="hljs-comment">// 执行完a≤b≤c</span><br></code></pre></td></tr></table></figure><ol><li><p>四舍五入：<code>floor(x+0.5)</code>，此时等于 1 的区间为 <code>[0.5, 1.5)</code></p><ul><li><p>注意，小数部分为 0.5 数可能受到浮点误差的影响，因为计算机中可能存了 0.49999。</p></li><li><p>并且 <code>floor</code> 函数返回值是 double 型，要强转或赋值给 int 型。</p></li></ul></li><li>简单求无理数：<code>const double pi = acos(-1.0)</code>，注意三角函数使用弧度制。类似的还有 <code>const double e = exp(1.0)</code>。</li><li>交错输出：<code>printf(&quot;%d&quot;, q?a:b); q=!q;</code></li><li>更新最值：<code>ans=max(ans,dfs(i,j));</code></li><li>初始化某个<strong>数组</strong>为正无穷：<code>memset(a,0x3f,sizeof(a));</code>，比直接用 <code>0x7fffffff</code> 好，不容易加法溢出。同理初始化为负无穷用 <code>memset(a,0xcf,sizeof(a));</code><ul><li>在 LeetCode 中如果用 vector 初始化，可以用 <code>vector&lt;int&gt; a(n, INT_MAX)</code>，同理还有 <code>INT_MIN</code> 常量，这是在 limits.h 头文件中定义的最大最小值，分别是 2147483647 和 -2147483648（<code>-INT_MAX-1</code>）。</li></ul></li><li>数组实际长度：<code>sizeof(a)/sizeof(单位)</code>，前者仅仅是整个数组占内存大小，必须除以单位才能得到数组的实际长度。<ul><li>注意这里的 <code>a</code> 是数组名，但如果用指针指向数组，<code>sizeof(指针)</code> 得到的却是指针的长度，这是数组名和指针的一大区别。</li><li>在 32 位 (x86) 系统中，指针长度为 4，在 64 位 (x64) 系统中，指针长度为 8。</li></ul></li></ol><h2 id="C-vs-C"><a href="#C-vs-C" class="headerlink" title="C vs. C++"></a>C vs. C++</h2><h3 id="版本比较"><a href="#版本比较" class="headerlink" title="版本比较"></a>版本比较</h3><ul><li>在 C89 中不允许在 <code>for</code> 循环中 <code>int i=0</code>，但 C99 后和 C++ 都可以。</li><li>在 C99 中，<strong>double 的输出</strong>必须用 <code>%f</code>，输入要用 <code>%lf</code>，但 C89 和 C++ 中都可以全用 <code>%lf</code>，所以尽量用 C++。</li><li>C99 中只规定了 int 至少是 16 位，但没规定具体值，好在比赛平台几乎都是 32 位，即上限 <code>2147483647</code>，这里有 10 位数，long long 最大值有 19 位数。</li><li><p>C99 用 <strong>long long</strong> 可以解决<strong>部分溢出</strong>，但是输入时要改成 <code>%lld</code>。</p><ul><li>但是在 MinGW 的 gcc 中，要把 <code>%lld</code> 改成 <code>%I64d</code>，在 VC2008 中又得改回 <code>%lld</code>。</li><li>因此如果涉及 long long 的输入输出，常用 C++ 的<strong>输入输出流</strong> <code>cin/cout</code> 或<strong>自定义</strong>的输入输出方法。</li></ul></li><li>C 中的 <code>gets(s)</code> 存在缓冲区溢出漏洞，不推荐使用，在 C11 标准中，已经被正式删除。<ul><li>使用 <code>fgets(buf, maxn, fin);</code> 替代，或者直接用 C++ 的 <code>cin&gt;&gt;s;</code>。</li><li>但是 C++ 直接流读取 string 类型会在<strong>遇到空格时停止</strong>，如果想要读取一整行包含空格的字符串，可以用 <code>getline(cin,str);</code>。</li></ul></li><li>C++ 声明数组时，可以用 const 声明的<strong>常数数组</strong>，在 C99 中是不允许的，推荐用 C++。</li></ul><h3 id="新增工具"><a href="#新增工具" class="headerlink" title="新增工具"></a>新增工具</h3><ul><li>C++ 中特有的 bool 型变量，只有 0 或 1 两种取值，用 true 和 false 表示真和假。</li><li>C 中的空指针 NULL 定义为 <code>((void *)0)</code>，使用时可以强转赋值给任意类型指针，而 C++ 不能隐式强转，因此 NULL 被定义为 <code>0</code>，引入了新的关键字 <code>nullptr</code> 来表示空指针。</li></ul><ul><li><p>C 中的 <code>qsort</code> 需要强转万能指针 <code>void*</code>，并且让 cmp 函数在 <code>a&lt;b,a=b,a&gt;b</code> 时分别返回负数、零、正数。注意 cmp 是被函数指针 <code>int (*comparator)</code> 指向的函数。一般在算法竞赛中使用 C++ STL 中的 sort 函数。</p><ul><li><p>sort 通常配合自定义 cmp 函数实现复杂排序 <code>bool cmp(T &amp;a,T &amp;b)&#123;return a&lt;b;&#125;</code>，在力扣刷题时要在函数前加上 <code>static</code>。</p></li><li><p>对于比较简短的比较函数，也可以用 <strong>Lambda 表达式</strong>直接塞进 sort 里面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 完全闭包，无外部变量</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-keyword">auto</span> &amp;a, <span class="hljs-keyword">auto</span> &amp;b)&#123;<br>    <span class="hljs-keyword">return</span> a &lt; b;<br>&#125;);<br><span class="hljs-comment">// 捕捉闭包外的变量，&amp;hash 表示引用捕捉指定变量，也可以只用 &amp; b</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [&amp;hash](<span class="hljs-keyword">auto</span> &amp;a, <span class="hljs-keyword">auto</span> &amp;b)&#123;<br>    <span class="hljs-keyword">if</span>(hash[a] == hash[b]) <span class="hljs-keyword">return</span> a &gt; b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> hash[a] &lt; hash[b];<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>C++ 中可以用 C 的类型强转：<code>(ll)a</code> 或 <code>ll(a)</code>，此外还新增了四种强转方法，用于类、结构体的强转。最基本的用法是 <code>static_cast&lt;long long&gt;</code>，效果和 C 的类似。</p></li></ul><h3 id="全新特性"><a href="#全新特性" class="headerlink" title="全新特性"></a>全新特性</h3><ul><li>C++ 中最重要的特点就是「<strong>函数传引用调用</strong>」，例如 <code>void swap2(int&amp;a, int&amp;b)</code>，不必再传指针调用，更方便快捷。对于字符串、长数组可以<strong>节省大量时间</strong>，且可以直接在函数内修改原参数。<ul><li>不过一旦使用 <code>&amp;</code> 入参就<strong>不能为常量</strong>，如 <code>func(1)</code>。此时只能使用 <code>const auto&amp; a</code> 传参，这样<strong>速度更快</strong>，但是<strong>限制了函数内修改参数</strong>。</li></ul></li><li>C++ 中除了 struct 还有 class，工程中，一般用 struct 定义纯数据的类型，用 class 定义复杂行为的类型，二者最主要的区别是<strong>访问权限和继承方式</strong>不同。但算法竞赛中还是常用 struct 来定义结构体，因为 C++ 的结构体还可以定义<strong>成员函数</strong>、<strong>构造函数</strong>等。<ul><li>拥有构造函数的结构体，可以通过 <code>T *a = new T(10);</code> 调用，得到一个指向结构体的指针，在力扣刷题用。</li><li>此外也可以直接调用 <code>T a(10);</code> 或 <code>T a = T(10);</code> 或 <code>T b = a;</code>，在洛谷刷题比较常用。</li></ul></li><li>C++ 中可以重载运算符，实现结构体之间的四则运算和输入输出。例如：<ul><li><code>T operator +(const T &amp;A) const&#123; return ...;&#125;</code> 在结构体内重载加法运算；</li><li><code>T operator +(const T &amp;A, const T &amp;B)&#123; return ...;&#125;</code> 在结构体外重载加法运算；</li><li><code>ostream&amp; operator &lt;&lt; (ostream &amp;out, const T&amp; p)&#123; out &lt;&lt; ...; return out;&#125;</code> 在结构体外重载输出流；</li></ul></li><li>C++ 中具有<strong>泛型、模板</strong>的概念，即 <code>template&lt;typename T&gt;</code>，可以实现<strong>函数端口参数的自适应</strong>，如各种类型数组的求和，甚至结构体数组的求和（需要重载加法）。</li></ul><h2 id="算法时间复杂度选择"><a href="#算法时间复杂度选择" class="headerlink" title="算法时间复杂度选择"></a>算法时间复杂度选择</h2><p>一般 ACM 或者笔试题的时间限制是 1 秒或 2 秒。在这种情况下，C++ 代码中的操作次数控制在 $10^7 \sim 10^8$ 为最佳。</p><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p><div class="table-container"><table><thead><tr><th style="text-align:center">数据范围</th><th style="text-align:center">时间复杂度</th><th style="text-align:center">算法</th></tr></thead><tbody><tr><td style="text-align:center">$n \leq 30$</td><td style="text-align:center">$O(n!) \;\; O\left(2^{n}\right)$</td><td style="text-align:center">DFS+剪枝、状态压缩 DP</td></tr><tr><td style="text-align:center">$n \leq 100$</td><td style="text-align:center">$O\left(n^{3}\right)$</td><td style="text-align:center">Floyd、DP、高斯消元</td></tr><tr><td style="text-align:center">$n \leq 1000$</td><td style="text-align:center">$O\left(n^{2}\right) \;\; O\left(n^{2} \log n\right)$</td><td style="text-align:center">DP、二分、朴素版 Dijkstra、朴素版 Prim、Bellman-Ford</td></tr><tr><td style="text-align:center">$n \leq 10000$</td><td style="text-align:center">$O(n\sqrt{n})$</td><td style="text-align:center">块状链表、分块</td></tr><tr><td style="text-align:center">$n \leq 100000$</td><td style="text-align:center">$O(n \log n)$</td><td style="text-align:center">各种 sort、线段树、树状数组、set/map、heap、拓扑排序、Dijkstra+heap、Prim+heap、Kruskal、二分、树链剖分</td></tr><tr><td style="text-align:center">$n \leq 10^{6}$</td><td style="text-align:center">$O(n)$，常数较小的 $O(n \log n)$ 算法</td><td style="text-align:center">单调队列、hash、双指针、并查集、KMP<br>常数比较小的 $O(n \log n)$ 做法：sort、树状数组、heap、Dijkstra</td></tr><tr><td style="text-align:center">$n \leq 10^{7}$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">双指针扫描、KMP、差分、前缀和、离散化</td></tr><tr><td style="text-align:center">$n \leq 10^{9}$</td><td style="text-align:center">$O(\sqrt{n})$</td><td style="text-align:center">判断质数</td></tr><tr><td style="text-align:center">$n \leq 10^{18}$</td><td style="text-align:center">$O(\log n)$</td><td style="text-align:center">最大公约数、快速幂</td></tr><tr><td style="text-align:center">$n \leq 10^{1000}$</td><td style="text-align:center">$O\left((\log n)^{2}\right)$</td><td style="text-align:center">高精度加减乘除</td></tr><tr><td style="text-align:center">$n \leq 10^{100000}$</td><td style="text-align:center">$O(\log k \times \log \log k)$，$k$ 表示位数</td><td style="text-align:center">高精度加减、FFT/NTT</td></tr></tbody></table></div><h2 id="IDE-代码模板"><a href="#IDE-代码模板" class="headerlink" title="IDE 代码模板"></a>IDE 代码模板</h2><p>ACM 模式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X first</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Y second</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lb(x) ((x) &amp; (-x))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem(a,b) memset(a,b,sizeof(a))</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> db;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-keyword">int</span>&gt; vi;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">int</span> n,m,k;<br><span class="hljs-keyword">int</span> dp[maxn][maxn], a[maxn][maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>力扣人工补全：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// int long double bool char string void auto </span><br><span class="hljs-comment">// vector stack queue deque pair map set </span><br><span class="hljs-comment">// unordered_map unordered_set priority_queue</span><br><span class="hljs-comment">// multimap multiset hash seen clear</span><br><span class="hljs-comment">// front back push_back insert erase</span><br><span class="hljs-comment">// make_pair first second push pop top</span><br><span class="hljs-comment">// lower_bound upper_bound sort find count</span><br><span class="hljs-comment">// reverse swap substr cout endl max min</span><br><span class="hljs-comment">// for while if else continue break return </span><br><span class="hljs-comment">// size const operator begin end iterator</span><br><span class="hljs-comment">// nullptr sizeof new INT_MAX INT_MIN ch str</span><br><span class="hljs-comment">// idx col row left right ans res flag len</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>算法入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Uplift Recommendation 论文汇总</title>
    <link href="/Uplift-2.html"/>
    <url>/Uplift-2.html</url>
    
    <content type="html"><![CDATA[<p>上一节介绍了 Uplift 在因果推断、推荐系统中的相关概念，展开介绍了几种 Uplift 的基础模型和评估指标。本文继续聊聊 Uplift 近几年的发展。</p><p>本文综合考虑时间跨度、论文动机等因素，将相关论文分为若干类，包括 Uplift Modeling 理论的发展、Uplift Recommendation 的发展以及未来的趋势。</p><h2 id="探索：增益模型理论的发展"><a href="#探索：增益模型理论的发展" class="headerlink" title="探索：增益模型理论的发展"></a>探索：增益模型理论的发展</h2><p><strong>Using Control Groups to Target on Predicted Lift: Building and Assessing Uplift Models</strong>, 2007：</p><ul><li>提出 Two-Learner 的 Uplift Model 架构，同时提出了 Qini Curve 指标。</li></ul><p><strong>Decision Trees for Uplift Modeling</strong>, ICDM 2010：</p><ul><li>基于 Decision Tree 的 Uplift Model 架构。</li></ul><p><strong>Real-World Uplift Modelling with Significance-Based Uplift Trees</strong>, 2011：</p><ul><li>基于 Decision Tree 的 Uplift Model 架构。</li></ul><p><strong>Decision Trees for Uplift Modeling with Single and Multiple Treatments</strong>, KAIS 2012：</p><ul><li>基于 Decision Tree 的 Uplift Model 架构。</li></ul><p><strong>Uplift Modeling for Clinical Trial Data</strong>, ICML 2012：</p><ul><li>基于标签转换模型的 Uplift Model 架构。</li></ul><p><strong>A Literature Survey and Experimental Evaluation of the State-of-the-Art in Uplift Modeling: A Stepping Stone Toward the Development of Prescriptive Analytics</strong>, Big Data 2018：</p><ul><li>综述，提出了 Qini Coefficient 基尼系数 AUUC。</li></ul><p><strong>Uplift Modeling with Multiple Treatments and General Response Types</strong>, SIAM 2017：</p><ul><li>基于 Random Forest 的 Uplift Model 架构。</li></ul><h2 id="进入推荐领域：从响应到增益"><a href="#进入推荐领域：从响应到增益" class="headerlink" title="进入推荐领域：从响应到增益"></a>进入推荐领域：从响应到增益</h2><p><strong>Recommendation Systems with Purchase Data</strong>, JMR 2008：</p><ul><li><p>过去的响应模型倾向于推荐给用户购买概率较高的那一个，而本文认为「营销行为的选择应该基于对行为的预期反应」，首次提出「推荐决定不仅应基于购买概率，而且还应基于<strong>购买概率对推荐行动的敏感性</strong>」。具备了 Uplift Model 的雏形。</p></li><li><p>其他贡献：对一元数据进行建模，将购买行为看作是两个变量的叠加：知晓 Awareness、满意 Satisfaction。而不购买可能是因为不知晓，也可能是是因为知晓但不满意。使用两种数据集：自我发起的购买数据、推荐响应数据。</p></li></ul><p><strong>Estimating the Causal Impact of Recommendation Systems from Observational Data</strong>, EC 2015：</p><ul><li>过去用随机实验来消除 Confonuder 的方法代价过高（时间成本、用户反感），本文尝试直接从纯观测数据中获得因果效应。通过计数焦点产品和被推荐产品之间的「访问推荐驱动的流量」和「一段时间内对单个页面的总访问量」，将被推荐产品的点击拆分为「<strong>因果点击</strong>」和「<strong>便利点击</strong>」。所谓因果点击就是纯粹因为推荐造成的点击，而便利点击则是哪怕没有推荐用户也会去主动搜索的点击。</li></ul><p><strong>The Effect of Recommendations on Network Structure</strong>, UMAP 2016：</p><ul><li>介绍社交网络的两种常用推荐策略（基于内容的协同过滤、朋友之友算法）在图结构下的 Rich Get Richer 现象，即人们更有可能对受欢迎用户的推荐做出积极回应，进一步放大了知名人士的累积优势。文中简短地提及了「人们有可能早就对被推荐者感兴趣」的现象，这导致<strong>推荐效应的高估</strong>。</li></ul><p><strong>Modeling Individual Users’ Responsiveness to Maximize Recommendation Impact</strong>, WWW 2016：</p><ul><li>对推荐的反应可能取决于用户的类型，本文对用户属性（年龄、购物车大小、购买记录）和商品属性（展示时长、周销量）建模，提出了一个包含<strong>响应差异</strong>的购买预测模型。最后发现推荐效果和根据推荐日志建模的效果几乎相当，有助于克服推荐日志不足的冷启动（Cold-Start）问题。</li></ul><h2 id="完善：增益模型的评估、优化"><a href="#完善：增益模型的评估、优化" class="headerlink" title="完善：增益模型的评估、优化"></a>完善：增益模型的评估、优化</h2><p><strong>Causal Embeddings for Recommendation</strong>, RecSys 2018：</p><ul><li>领域自适应（Domain Adaptation）是另一种反事实的学习方法，适用于推荐系统。提出了 <strong>CausE</strong> 模型。</li></ul><p><strong>Uplift-based evaluation and optimization of recommenders</strong>, RecSys 2019：</p><ul><li>首次对 Uplift 模型的评估、优化进行定义。在评估中引入<strong>用户四象限、ATE、IPS、SNIPS</strong>，比传统的基于 Precision 的评估方法更能衡量模型；在优化中使用已有的购买和推荐日志作为<strong>现实参照</strong>，分别用<strong>逐点抽样和成对抽样</strong>方法得到两种 Loss 训练的模型。提出了 <strong>ULRMF</strong> 和 <strong>ULBPR</strong> 模型。</li></ul><p><strong>Action-Triggering Recommenders: Uplift Optimization and Persuasive Explanation</strong>, ICDMW 2019：</p><ul><li>这篇文章是前文的补充，描述的优化方法和上文一致，此外还补充了一个新任务：<strong>在推荐商品后解释推荐的原因</strong>。这是为了进一步帮助用户决策，唤起用户对商品的兴趣。过去对推荐的解释生成有四个维度：Neighbor（基于相似用户）、Influence（基于消费历史）、Demographic（基于用户画像）、Content（基于商品内容）。本文提出用「User-Item-Context」的三元匹配来对<strong>语境上下文</strong>进行解释。</li><li>有点 Multi-task Learning 的感觉，原文只是优化了三元匹配，是否能当成<strong>自然语言生成</strong>任务来做呢？</li></ul><p><strong>Free Lunch! Retrospective Uplift Modeling for Dynamic Promotions Recommendation within ROI Constraints</strong>, RecSys 2020：</p><ul><li>从 ROI 角度切入，只有当促销活动带来的增益能弥补促销的额外成本时，促销才能继续。而有的用户需要有促销才会购买，有的用户即使没有促销也会购买，对后者发放促销会带来不必要的开销，因此<strong>识别目标群体</strong>（可说服者、自愿购买者）。值得一提的是，本文提出用<strong>背包问题</strong>对 ROI <strong>受限</strong> CATE 进行最大化，最终用贪心算法解决。</li></ul><p><strong>Online Evaluation Methods for the Causal Effect of Recommendations</strong>, RecSys 2021：</p><ul><li>将过去用于信息检索的交织列表（Interleaving Method）用于两种推荐模型的因果效应的比较，解决 A/B 测试流量不足的问题。提出了等概率交织（EPI-RCT）、因果平衡交织（<strong>CBI-RCT</strong>）、结合逆倾向评分的因果平衡交织（CBI-IPS）模型。</li></ul><p><strong>Causality-Aware Neighborhood Methods for Recommender Systems</strong>, 《Advances in Information Retrieval》2020：</p><ul><li>过去的 IPS 方法容易受到高方差的影响（不同用户群体的真实占比不同），而匹配估计器（Matching Estimator）是一种选取 A/B 测试人群的方法，其通过<strong>计算协变量相似度</strong>（用户特征、购买记录）得出<strong>实验组和控制组人群</strong>，不依赖倾向性，不会有方差问题。本文结合了协同过滤中的近邻方法（User-based 和 Item-based）得到相似群体，利用其平滑单个样本的噪声，得到一种估计因果效应的方法。提出了 <strong>CUBN</strong> 和 <strong>CIBN</strong> 模型。</li></ul><p><strong>Unbiased Learning for the Causal Effect of Recommendation</strong>, RecSys 2020：</p><ul><li>提出另一种无偏学习框架 <strong>DLCE</strong>，还是针对使用 IPS 的方差问题，首先构造无偏估计器对指标进行排序。然后对具有倾向性封顶的估计量进行经验风险最小化，减少了有限训练样本下的方差。</li></ul><h2 id="更进一步：强化学习、协同过滤"><a href="#更进一步：强化学习、协同过滤" class="headerlink" title="更进一步：强化学习、协同过滤"></a>更进一步：强化学习、协同过滤</h2><p><strong>Partially observable environment estimation with uplift inference for reinforcement learning based recommendation</strong>, ML 2021：</p><ul><li>将隐藏变量视为一种隐藏策略，提出了一种部分观测多智能体环境估计方法 POMEE 来学习部分观测环境。提出一种强化学习框架 DUIN 用来学习每个动作的 Uplift 效应。</li></ul><p><strong>CausCF: Causal Collaborative Filtering for Recommendation Effect Estimation</strong>, CIKM 2021：</p><ul><li>借鉴协同过滤技术，本文认为相似的用户不仅对物品有相似的品味，而且在推荐下也有<strong>相似的因果效应</strong>。以此提出了 CasuCF 模型，将交互矩阵扩展为具有 User、Item 和 Treatment 维度的三维张量，通过三者的成对内积来预测交互概率，User 和 Item 之间的内积说明了用户对商品的偏好。</li></ul><h2 id="未来趋势"><a href="#未来趋势" class="headerlink" title="未来趋势"></a>未来趋势</h2><ul><li>更复杂的干预：连续干预、多策略干预的建模（例如多种面额优惠券的组合），对应更广泛的业务场景，当然数据集样本也会更稀疏；</li><li>更丰富的任务：结合多任务学习来增强模型性能，例如前文提及的推荐语生成，可以和 NLP 任务结合；</li><li>更有远见的模型：现实中的营销往往是常态化、持续化的，用户的心智可能会随着年龄、职业的变化而变化，因此有必要建立长期模型；</li><li>更优雅的测试方式：目前已有的 RCT 测试存在的大量问题有待解决，交织列表的提出就是一个有效的尝试；</li><li>更多的使用场景：例如政治营销（针对摇摆者精准投送正面、负面新闻以改变总统大选的结果）、医疗效果评估等等。</li></ul>]]></content>
    
    
    <categories>
      
      <category>科研札记</category>
      
      <category>推荐系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RecSys</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈 Uplift Modeling</title>
    <link href="/Uplift-1.html"/>
    <url>/Uplift-1.html</url>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Uplift 本意为「上升；抬起；提振」，在<strong>因果推断</strong>中引申为「<strong>某种干预对于个体状态或行为的因果效应</strong>」。在推荐系统领域中，<strong>增益模型</strong>（Uplift Model）用于预测「<strong>干预后的增量反馈价值</strong>」，可以表达为：</p><script type="math/tex; mode=display">\mathrm{Lift}=P\left( \mathrm{State}\mid w\,\,\mathrm{Treatment} \right) -P\left( \mathrm{State}\mid w/o\,\,\mathrm{Treatment} \right)</script><p>增益模型的落地价值体现在「智能化营销」领域，用于衡量和预测营销干预带来的「增量提升」，把营销预算投入在<strong>说服型</strong>（Persuadables）用户上，不浪费在<strong>确认型</strong>（Sure Things）和<strong>沉睡型</strong>（Lost Causes）用户上，避免对<strong>勿扰型</strong>（Sleeping Dogs）用户产生反效果<sup><a href="#fn_2" id="reffn_2">2</a></sup>：</p><p><img src="/img/blog/Uplift-1-images/Four-Class-Users.png" alt="营销模型的四类用户" width=40% /></p><p>与之对应的是<strong>响应模型</strong>（Response Model），其目标是预测「<strong>干预后的个体状态或行为</strong>」，这是一个相关性分析问题（而不是因果推断问题），因此会导致我们无法区别自然转化人群。在营销领域，响应模型可以用于估计用户<strong>看过广告后的购买率</strong>，但增益模型是估计用户<strong>因为广告而购买</strong>的概率，帮助精准寻找营销敏感人群。响应模型可以表达为：</p><script type="math/tex; mode=display">\mathrm{Outcome}=P\left( \mathrm{State}\mid w\,\,\mathrm{Treatment} \right)</script><p>用一个实际的营销案例来说明，假设此刻有两类等量的用户群体<sup><a href="#fn_3" id="reffn_3">3</a></sup>：</p><div class="table-container"><table><thead><tr><th style="text-align:center">User</th><th style="text-align:center">有广告 CVR</th><th style="text-align:center">无广告 CVR</th><th style="text-align:center">Uplift</th></tr></thead><tbody><tr><td style="text-align:center">用户群体 1</td><td style="text-align:center">$0.8\%$</td><td style="text-align:center">$0.2\%$</td><td style="text-align:center">$0.6\%$</td></tr><tr><td style="text-align:center">用户群体 2</td><td style="text-align:center">$2.0\%$</td><td style="text-align:center">$1.7\%$</td><td style="text-align:center">$0.3\%$</td></tr></tbody></table></div><p>在传统响应模型中，我们可能会向第二类用户投放广告，因为其转化最高。但是在增益模型中，除了<strong>广告曝光转化率</strong>之外，我们还能知道这两类用户群体在没有广告触达情况下的<strong>自然转化率</strong>，从而推算出广告所带来的增量。按照这个逻辑，我们更应该向第一类用户投放广告。</p><p><img src="/img/blog/Uplift-1-images/Model-Diff.png" alt="两种模型推荐的关注点不同" width=50% /></p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="因果推断-Causal-Inference"><a href="#因果推断-Causal-Inference" class="headerlink" title="因果推断 | Causal Inference"></a>因果推断 | Causal Inference</h3><blockquote><p>机器学习不过是在拟合数据和概率分布曲线，而变量的内在因果关系并未得到足够的重视。如果要真正解决科学问题，甚至开发真正意义上的智能机器，因果关系是必然要迈过的一道坎。<sup><a href="#fn_1" id="reffn_1">1</a></sup></p></blockquote><ul><li><p>伪相关性（Spurious Correlation）：深度学习模型能拟合出数据的<strong>关联关系</strong>，但不能得到<strong>因果关系</strong>。产生统计关联性有<strong>四种情况</strong>，而其中两种则是伪相关的。伪相关会造成<strong>偏倚</strong>（Bias），例如「巧克力销量与诺贝尔奖」的故事，显然二者并没有因果关系。</p><p><img src="/img/blog/Uplift-1-images/Correlation.png" alt="产生统计关联性的四种情况" width=50% /></p></li><li><p>混杂（Confounding）：在上述例子中，$X$ 和 $Y$ 的<strong>共因</strong>也被称为<strong>混杂因子</strong>（Confounder），而当<strong>伪相关性和真正的因果关系混合</strong>在一起时，就产生了「混杂、有偏」的情形：</p><p><img src="/img/blog/Uplift-1-images/Confounding.png" alt="混杂的基本情形" width=40% /></p></li><li><p>消除混杂：一种消除混杂的方法叫<strong>后门准则</strong>（Backdoor Criterion）。所谓「<strong>后门路径</strong>」就是第一种伪相关的情况，如果我们有足够的数据能够将所有 $X$ 和 $Y$ 之间的后门路径全部<strong>阻断</strong>（Separation），就可以识别其因果关系。所谓「阻断」，即给混杂因子<strong>赋予定值</strong>，以这个变量为条件（Conditioning on），缩小到样本的<strong>子集</strong>后分类讨论。</p></li></ul><p><img src="/img/blog/Uplift-1-images/Backdoor.png" alt="后门准则" width=40%  /></p><ul><li>干预（Treatment/Intervention）：意为对<strong>原始的数据分布</strong>加以改变，不同于以变量为条件选取子集，而是直接<strong>删除所有指向该变量的边</strong>，并直接赋予该变量新的值。在新的模型中检验相关性时，我们就可以发现该变量与目标变量是否真的存在因果关系了。</li></ul><p><img src="/img/blog/Uplift-1-images/Intervention.png" alt="干预" width=40% /></p><ul><li><p>反事实推断（Counterfactual inference）：基于数据对<strong>外生变量</strong> $U$（未观测的变量）进行估算，利用干预改变模型 $M_x$（删除所有指向 $X$ 的箭头），赋予 $X$ 反事实假设，根据估算的外生变量 $U$ 和新模型 $M_x$ 来计算 $Y$。</p><blockquote><p>例如：我们收集到一个事实（用户 A 没收到广告时不会购买），要想知道「收到广告」和「购买」之间是否有因果关系，那我们就需要一个反事实（用户 A 收到广告时会怎么样），但这个数据是不存在的。若想对其进行反事实推理，就要删除所有指向「收到广告」的箭头，包括其他所有特征变量，再对「收到广告」这个变量进行干预。</p><p>此时有一个很重要的「<strong>独立假设</strong>」：若用 $Y_1$ 表示收到广告后的购买率，$Y_0$ 表示没收到广告的购买率，$T$ 表示我们的干预，则有 $(Y_1,Y_0) \bot T$，即二者独立。这似乎很难理解，难道不是 $Y_t$ 不是跟 $T=t$ 有关吗？然而，不管我们是否推送广告，结果 $Y_1,Y_0$ 永远是存在的，只是我们需要用 $T=t$ 来选择「观测」其中的一种，并不会影响其具体的值。</p></blockquote></li><li><p>整体因果效应（Averaged Treatment Effect, ATE）：<strong>一个个体不可能同时使用试验组和对照组的方法分别干预</strong>，因此我们只能构建两组非常相似的群组，在相似的群组里进行不同的干预，从而达到反事实推理的目的。在上述「独立假设」下，我们两组的观测结果之差就得到 $\mathrm{ATE}$：</p></li></ul><script type="math/tex; mode=display">\begin{aligned}    \tau &=\mathbb{E} \left[ Y_1-Y_0 \right] =\mathbb{E} \left[ Y_1 \right] -\mathbb{E} \left[ Y_0 \right]\\    &=P \left[ Y_1\mid T=1 \right] -P \left[ Y_0\mid T=0 \right]\\    &=P \left[ Y\mid T=1 \right] -P \left[ Y\mid T=0 \right]\\\end{aligned}</script><ul><li><p>随机控制试验（Randomized Controlled Trials, RCT）：俗称线上 A/B 测试。为了计算 $\mathrm{ATE}$，需要将用户群体进行<strong>随机分流</strong>，实验组施加干预，测试组保持原先策略。由于<strong>完全随机</strong>，实验组和对照组的样本在<strong>分布上是一致的</strong>，因此满足前文提及的「独立假设」，可以直接计算 $\mathrm{ATE}$。</p></li><li><p>倾向性评分法（Propensity Score Method，PSM）：在工业界中，做随机实验都会存在一定成本，甚至会引起客户流失，且<strong>大多数时候无法完全随机</strong>，因此也就没办法去准确估计<strong>无偏</strong>的 $\mathrm{ATE}$。此时实验组和对照组的样本分布存在差异，$Y$ 和 $T$ 不再独立使得 $E\left[ Y_1 \right] \ne E\left[ Y_1\mid T=1 \right]$，而倾向评分就是用来用来估计「在<strong>给定混杂因子</strong>的情况下，目标被施加干预」的概率，对概率大的施加一个小的权重，对概率小的施加一个大的权重，用来<strong>消除偏倚</strong>。</p><blockquote><p>例如：我们想知道「优惠券的领取」对「购买某商品」的因果效应，于是进行随机控制试验。理想情况下，我们会得到 A 和 B 两组非常相似的群体（性别比例、年龄分布等），其中 A 组「领取优惠券」而 B 组「未领取优惠券」。然而干预因素（发放优惠券）的分配通常不受人为控制：假设女性用户群体可能更热衷于逛淘宝因此领到优惠券的概率更大，则两个组在「性别」这一特征上并不均衡可比，因此<strong>无法删除混杂因子指向的边</strong>。</p><p>此时我们就需要用到 PSM 来尽可能消除「性别」带来的偏倚。两种常用的倾向性评分方法是<strong>近邻匹配</strong>（Collaborative Matching, CM）和<strong>逆倾向评分加权</strong>（Inverse Propensity Score Weighting, IPSW）。<sup><a href="#fn_4" id="reffn_4">4</a></sup></p></blockquote></li></ul><h3 id="推荐系统与智能营销"><a href="#推荐系统与智能营销" class="headerlink" title="推荐系统与智能营销"></a>推荐系统与智能营销</h3><ul><li>点击率（Click Through Rate, CTR）：反映了展品对客户的吸引，具体公式：$\mathrm{CTR}=点击量/展现量$。</li><li>转化率（Conversion Rate, CVR）：用户点击展品到注册、付费的转化率，具体公式：$\mathrm{CVR}=转化量/点击量$。</li><li>投资回报率（Return On Investment, ROI）：具体公式：$\mathrm{ROI}=总利润/总投资$。</li><li>离散干预和连续干预（Treatment）：在营销领域，离散干预可以类比「发不发优惠券」，连续干预可以类比「优惠券的面额」或者「多种优惠券的组合」。现阶段连续干预是推荐系统领域的重大挑战。</li><li>协同过滤（Collaborative Filtering）：在推荐系统中常用的一种技术，通过收集用户偏好信息，再去寻找<strong>相似的商品或者用户群体</strong>产生推荐（Item-based 和 User-based）。此外，还有诸如矩阵分解模型、神经网络模型等基于模型的方法。</li><li>交织列表（Interleaving List）：一种在线评估推荐系统的方法，在信息检索领域最先提出。由于 A/B 测试存在的问题（用于测试的流量不足、重度用户在各组占比不同造成偏倚），使用 Interleaving 则无需分组，只需对所有用户投放一个交织列表，该列表包含<strong>两个要比较的模型</strong>推荐的结果，通过用户点击哪个多就可以看出哪个模型好。</li></ul><h2 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h2><h3 id="Two-Learner"><a href="#Two-Learner" class="headerlink" title="Two-Learner"></a>Two-Learner</h3><p>Two-Learner 是基于双模型的<strong>差分响应模型</strong>（Differential Response Model），对实验组（有干预）和对照组（无干预）的购买行为进行分别建模，然后用训练所得两个模型分别对待测用户的购买行为进行预测，本质是<strong>响应模型</strong><sup><a href="#fn_2" id="reffn_2">2</a></sup>。</p><p><img src="/img/blog/Uplift-1-images/Two-Learner.png" alt="Two-Learner" width=30% /></p><p>此时一个样本用户可得出两种情况下各自的购买行为预测值。这两个预测值之差就是我们想要的 $\mathrm{ATE}$。这种建模方法较简单且易于理解，可以直接用回归、GBDT 等模型实现。然而，Two-Learner 也存在一些局限性：</p><ul><li>对照组和实验组分别建模，两个模型完全隔离，两个模型容易有<strong>累积误差</strong>；</li><li>其次建模的目标是 Response 而不直接是 Uplift，因此模型对 Uplift 的预测能力较有限；</li><li>干预策略只能是<strong>离散值</strong>（一种干预对应一个模型），更不能是连续变量。</li></ul><h3 id="Single-Learner"><a href="#Single-Learner" class="headerlink" title="Single-Learner"></a>Single-Learner</h3><p>Single-Learner 在 Two-Learner 的基础上，将对照组和实验组<strong>数据放在一起建模</strong>，将实验分组（<strong>干预与否</strong>）作为一个单独特征，和其他特征一起输入模型中对用户购买行为进行建模。模型的输出是一个条件值，使用其进行预测时，需要计算该样本<strong>分别进入实验组和对照组</strong>预测两次，将差异作为对 $\mathrm{ATE}$ 的估计。</p><p><img src="/img/blog/Uplift-1-images/S-Learner.png" alt="Single-Learner" width=40% /></p><p>比起 Two-Learner 的优势在于：</p><ul><li>训练样本共用可以使单个模型学习更加充分，单模型也可以避免双模型打分<strong>累积误差</strong>较大的问题；</li><li>模型可以支持干预项为<strong>多策略及连续变量</strong>的建模，实用性较强。</li></ul><p>然而，Single-Learner 在本质上依然还是对 Response 建模，只是分成了两次输出，对 Uplift 的预测还是比较间接<sup><a href="#fn_2" id="reffn_2">2</a></sup>。</p><h3 id="标签转换模型"><a href="#标签转换模型" class="headerlink" title="标签转换模型"></a>标签转换模型</h3><p>标签转换模型（Class Transformation Method）既可以将实验组与对照组数据打通，同时又是直接对 $\mathrm{ATE}$ 进行预测，其核心思想是将实验组和控制组样本<strong>直接混合</strong>并附加新的标签 $Z$ 满足：</p><ul><li>当用户在实验组（发券）且用户最终购买时，$Z=1$</li><li>当用户在对照组（无干预）且用户最终未购买时，$Z=1$</li><li>当用户在实验组（发券）且用户最终未购买时，$Z=0$</li><li>当用户在对照组（无干预）且用户最终购买时，$Z=0$</li></ul><p>可以证明，$P\left(Z=1\mid T_i\right)$ 和 $\mathrm{ATE}$ 是线性正相关的，且当实验组与控制组样本比例为 $1:1$ 时：</p><script type="math/tex; mode=display">\tau = 2 P\left(Z=1\mid T_i\right) - 1</script><p>假设干预策略 $T$ 与用户相互独立（满足前文的「<strong>独立假设</strong>」），则同理 $T \bot \boldsymbol{X}$，$\boldsymbol{X}$ 为所有协变量之和，则有：</p><script type="math/tex; mode=display">\begin{aligned}    P(Z=1\mid \boldsymbol{X})&=P(Z=1\mid \boldsymbol{X},T=1)P(T=1\mid \boldsymbol{X})+P(Z=1\mid \boldsymbol{X},T=0)P(T=0\mid \boldsymbol{X})\\    &=P(Y=1\mid \boldsymbol{X},T=1)P(T=1\mid \boldsymbol{X})+P(Y=0\mid \boldsymbol{X},T=0)P(T=0\mid \boldsymbol{X})\\    &=P^T(Y_1\mid \boldsymbol{X})P(T=1)+P^C(Y_0\mid \boldsymbol{X})P(T=0)\\\end{aligned}</script><p>在 RCT 实验中，当实验组与控制组样本比例为 $1:1$ 时，$P(T=0)=P(T=1)=\frac{1}{2}$，即一个用户被分在两个组的概率是相等的，则有：</p><script type="math/tex; mode=display">\begin{aligned}    2P(Z=1\mid \boldsymbol{X})&=P^T(Y_1\mid \boldsymbol{X})+P^C(Y_0\mid \boldsymbol{X})\\    &=P^T(Y_1\mid \boldsymbol{X})+1-P^C(Y_0\mid \boldsymbol{X})\\\end{aligned}</script><h3 id="决策树建模"><a href="#决策树建模" class="headerlink" title="决策树建模"></a>决策树建模</h3><p>对于 Uplift 直接建模的方式除了上述标签转换的方式外，还有一种就是通过修改已有的学习学习器结构直接对 Uplift 进行建模，比如修改 LR、KNN、SVM 等，比较流行的就是修改<strong>决策树模型</strong>的特征分裂方法<sup><a href="#fn_3" id="reffn_3">3</a></sup>。</p><p>传统决策树模型的分裂过程中，常用的指标是<strong>信息增益或信息增益比</strong>，其本质是希望通过特征分裂后下游正负样本的分布更加悬殊，即类别纯度变得更高。</p><script type="math/tex; mode=display">\Delta _{\mathrm{gain}}=\mathrm{info}_{\mathrm{after-split}}(D)-\mathrm{info}_{\mathrm{before-split}}(D)</script><p>同理这种思想也可以引入到 Uplift Model 建模过程，我们希望通过特征分裂后能够把 Uplift 更高和更低的两群人<strong>更好地区分开</strong>。</p><script type="math/tex; mode=display">\Delta _{\mathrm{gain}}=D_{\mathrm{after-split}}\left( P^T,P^C \right) -D_{\mathrm{before-split}}\left( P^T,P^C \right)</script><p>其中 $D$ 的衡量可以基于 KL 散度、欧式距离、卡方距离等。</p><h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><h3 id="Uplift-十分位柱状图"><a href="#Uplift-十分位柱状图" class="headerlink" title="Uplift 十分位柱状图"></a>Uplift 十分位柱状图</h3><p>将测试集预测出的用户按照 Uplift Score 由高到低平均分为 10 组，即依次选取 Top 10%、Top 20% 直到 Top 100% 共<strong>十个区间</strong>内的用户，分别求每个区间内 Uplift Score 的<strong>均值</strong>。绘制出如下的十分位柱状图：</p><p><img src="/img/blog/Uplift-1-images/Bar.png" alt="十分位柱状图" width=80% /></p><p>通过观察正负柱子的长短、占比、分布，可以直观地观察到该模型<strong>预测</strong>的营销增益。如果保留用户区间不变，将每个区间内的 <strong>Groud Truth Uplift Score</strong> 的均值拿来绘图，则得到的图不一定是有序的柱子。</p><h3 id="累计增益曲线-Qini-Curve"><a href="#累计增益曲线-Qini-Curve" class="headerlink" title="累计增益曲线 | Qini Curve"></a>累计增益曲线 | Qini Curve</h3><p>计算十分位中<strong>累计用户</strong>的 Qini 系数，将坐标点连接起来，得到一条<strong>累计增益曲线</strong>。Qini 系数公式如下：</p><script type="math/tex; mode=display">Q(\phi)=\frac{n_{t, y=1}(\phi)}{N_{t}}-\frac{n_{c, y=1}(\phi)}{N_{c}}</script><p>其中：</p><ul><li>$\phi$ 是按照 Uplift Score 由高到低排序的用户数量占该组用户数量的比例，$\phi=0.3$ 代表验组或对照组中 Top 30% 的所有用户；</li><li>$n_{t, y=1}(\phi)$ 表示在 Top $\phi$ 用户中，实验组中预测结果为购买的用户数量；同理 $n_{c, y=1}(\phi)$ 表示对照组预测结果为购买的用户数量；</li><li>$N_t$ 和 $N_c$ 则分别代表实验组和对照组总用户样本数。</li></ul><p><img src="/img/blog/Uplift-1-images/Qini-Curve.png" alt="预测的累计增益曲线" width=70% /></p><p>上图中，橙色线是随机曲线（代表<strong>随机向人群发放优惠券</strong>的增益），Qini 曲线则代表<strong>有针对性地向特定人群发放优惠券</strong>的增益。</p><p>将上图两条曲线作差，可以看到当横轴为 Top 40% 时，Qini 曲线与随机曲线之间距离最大，对应的的纵轴大约是 0.037，这意味着对 Top 40% 用户发放优惠券可以获得<strong>最大收益</strong>，这部分用户也就是我们需要对其进行营销干预的 <strong>Persuadable</strong> 人群。相反，如果采用随机发放策略，需要发出 80% 的量才能达到<strong>同等效果</strong>，大大节约成本。</p><blockquote><p>理论上 Qini 曲线是不应该出现「先下降后上升」的，但是由于模型可能将用户<strong>分类到错误区间</strong>，因此用 Groud Truth 绘制时可能会有所下降。利用 Groud Truth 的真实区间绘制的图应当是一个光滑的「先上升后下降」曲线，例如下图。</p></blockquote><p><img src="/img/blog/Uplift-1-images/Qini-Curve-2.png" alt="真实的累计增益曲线" width=50% /></p><p>实际应用中，$\phi$ 的取值越连续，刻画的曲线就越精确平滑，甚至能精确找出 <strong>Sleeping Dog</strong> 人群。</p><blockquote><p>当实验组和对照组用户数量不平衡，为避免指标失真，会采用另一种累积增益曲线;</p><script type="math/tex; mode=display">G(\phi)=\left(\frac{n_{t, y=1}(\phi)}{n_{t}(\phi)}-\frac{n_{c, y=1}(\phi)}{n_{c}(\phi)}\right)\left(n_{t}(\phi)+n_{c}(\phi)\right)</script></blockquote><h3 id="AUUC"><a href="#AUUC" class="headerlink" title="AUUC"></a>AUUC</h3><p>计算 Qini 曲线和<strong>横坐标轴</strong>之间的面积，称为 Area Under the Uplift Curve，也称为<strong>基尼系数</strong>（Qini Coefficient）。该面积越大越好，表示模型结果远超随机选择结果。</p><p><img src="/img/blog/Uplift-1-images/AUUC.png" alt="AUUC" width=50% /></p><p>需要注意的是，AUUC <strong>仅用于评价模型</strong>，对选取哪些用户发放优惠券并无指导意义。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote id="fn_1"><sup>1</sup>. <a href="https://www.zhihu.com/column/c_1217887302124773376">《因果关系之梯》望止洋 - 知乎专栏</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. <a href="http://www.woshipm.com/marketing/5117249.html">《该把优惠券发送给哪些用户？一文读懂 Uplift 模型》赵小洛</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. <a href="https://cloud.tencent.com/developer/article/1620903">【实践案例分享】阿里文娱智能营销增益模型 ( Uplift Model ) 技术实践，木东居士 - 腾讯云</a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. <a href="https://cloud.tencent.com/developer/article/1759064">倾向性评分法（propensity score method，PSM） - 腾讯云</a><a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote>]]></content>
    
    
    <categories>
      
      <category>科研札记</category>
      
      <category>推荐系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RecSys</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python笔记 #4 常用标准库和第三方库</title>
    <link href="/Python-Note-4.html"/>
    <url>/Python-Note-4.html</url>
    
    <content type="html"><![CDATA[<p>除了前面提及的的数据分析第三方库，Python 中也自带了许多有用的标准库，提供了一系列基础接口。此外本文还将介绍一些项目中常用的第三方库，更多细节可以在<strong>交互式窗口</strong>中输入 <code>dir(xx)</code> 和 <code>help(xx)</code> 检索。</p><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><p>标准库通常与 Python 发行版捆绑安装，其提供的组件涉及范围十分广泛，此处仅介绍常用库。</p><p>导入标准库时建议使用 <code>import os</code> 风格而非 <code>from os import *</code>，这样在调用的时候就可以用 <code>os.open()</code>，避免覆盖内置的函数 <code>open()</code>。</p><h3 id="os-操作系统接口"><a href="#os-操作系统接口" class="headerlink" title="os 操作系统接口"></a>os 操作系统接口</h3><p>Python 中与操作系统交互的标准库，可以完成目录管理、进程管理、调度器接口等操作。</p><p>最经常用于创建目录，因为使用 <code>open</code> 函数写文件时，如果没有对应的<strong>目录</strong>则不能自动创建文件。使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-comment"># path 是字符串，可以是绝对路径，也可以是当前目录相对路径</span><br>os.mkdir(path)  <span class="hljs-comment"># 创建一级目录</span><br>os.makedirs(path)  <span class="hljs-comment"># 创建多级目录</span><br></code></pre></td></tr></table></figure><p>此外，os 模块还能在脚本中直接使用终端命令，只需要 <code>os.command(&quot; &quot;)</code> 就能执行，常用于批量使用复杂命令。</p><h3 id="time-时间访问和转换"><a href="#time-时间访问和转换" class="headerlink" title="time 时间访问和转换"></a>time 时间访问和转换</h3><p>Python 中处理时间的标准库，提供系统级精确计时功能（可以用于程序性能分析）。其主要功能分为三块：时间获取、时间格式化、程序计时，这里介绍计时相关内容。</p><ul><li><code>sleep(s)</code>： <code>s</code> 为休眠时间，单位秒，可以是浮点数。</li><li><code>perf_counter()</code>：返回一个 CPU 级别的精确时间计数值，单位为秒。</li></ul><p>后者的使用由于<strong>计数器起点</strong>不确定，<strong>连续调用求差值</strong>才有意义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>arr = np.arange(<span class="hljs-number">100000000</span>)<br>start = time.perf_counter()<span class="hljs-comment"># 计数器起点</span><br>arr = arr * <span class="hljs-number">2</span><br>end = time.perf_counter()<span class="hljs-comment"># 计数器终点</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;numpy time cost: %.3f s&#x27;</span> % (end - start))<br></code></pre></td></tr></table></figure><h3 id="logging-日志记录"><a href="#logging-日志记录" class="headerlink" title="logging 日志记录"></a>logging 日志记录</h3><p>Python 中自带的日志模块，基本使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><br>logger = logging.getLogger(__name__)  <span class="hljs-comment"># 以当前文件名实例化 logger 记录器</span><br>logging.basicConfig(level=logging.INFO,<br>                    <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;[%(asctime)s]====== %(message)s ======&#x27;</span>,<br>                    datefmt=<span class="hljs-string">&#x27;%a, %d %b %Y %H:%M:%S&#x27;</span>,<br>                    filename=<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;Model_name&#125;</span>.log&#x27;</span>)  <span class="hljs-comment"># 简单配置日志级别与格式</span><br><br><span class="hljs-comment"># 具体用法，在代码中插入如下 message，常用 f-string</span><br>logging.debug(<span class="hljs-string">&#x27;This is a debug message&#x27;</span>)<br>logging.info(<span class="hljs-string">&#x27;This is a info message&#x27;</span>)<br>logging.warn(<span class="hljs-string">&#x27;This is a warn message&#x27;</span>)<br>logging.error(<span class="hljs-string">&#x27;This is a error message&#x27;</span>)<br>logging.critical(<span class="hljs-string">&#x27;This is a critical message&#x27;</span>) <br></code></pre></td></tr></table></figure><p>所谓日志级别，就是日志中只关注<strong>大于设定级别</strong>的内容：</p><div class="table-container"><table><thead><tr><th style="text-align:center">级别</th><th style="text-align:center">何时使用</th></tr></thead><tbody><tr><td style="text-align:center">DEBUG</td><td style="text-align:center">详细信息，调试时对所有问题感兴趣</td></tr><tr><td style="text-align:center">INFO</td><td style="text-align:center">事情按预期工作，训练模型<strong>最常用</strong></td></tr><tr><td style="text-align:center">WARNING</td><td style="text-align:center">可能的意外，但仍能工作</td></tr><tr><td style="text-align:center">ERROR</td><td style="text-align:center">错误，软件已不能执行一些功能</td></tr><tr><td style="text-align:center">CRITICAL</td><td style="text-align:center">严重错误，软件已不能继续运行</td></tr></tbody></table></div><blockquote><p>这里也可以换用暴力点的输出日志方法，直接用 Linux 的管道加 <code>tee -a</code> 命令，将所有输出流复制到文件中。</p></blockquote><h3 id="glob-文件名模式匹配"><a href="#glob-文件名模式匹配" class="headerlink" title="glob 文件名模式匹配"></a>glob 文件名模式匹配</h3><p>Python 中用于查询符合特定规则的文件路径名的标准库，不用遍历整个目录判断每个文件是不是符合。使用 <code>glob.glob(&#39;路径&#39;)</code> 调用，返回一个符合条件的路径字符串的 List 结构，支持通配符 <code>*</code>、<code>**</code>、<code>?</code>、<code>[]</code>，具体用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> glob.glob(<span class="hljs-string">&#x27;dir/*&#x27;</span>):<br>    <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># * 遍历 dir 目录，但不会递归遍历子目录</span><br><br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> glob.glob(<span class="hljs-string">&#x27;dir/*/*&#x27;</span>):<br>    <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># * 不会递归到子目录，因此只能手动指定</span><br><br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> glob.glob(<span class="hljs-string">&#x27;dir/**&#x27;</span>, recursive=<span class="hljs-literal">True</span>):<br>    <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># ** 遍历 dir 下所有内容，包括子目录</span><br><br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> glob.glob(<span class="hljs-string">&#x27;dir/file?.txt&#x27;</span>):<br>    <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># ? 匹配任何单个的字符</span><br><br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> glob.glob(<span class="hljs-string">&#x27;dir/*[0-9].txt&#x27;</span>):<br>    <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># [] 匹配指定范围内的单个字符</span><br></code></pre></td></tr></table></figure><p>注意：<code>*</code> 通配符默认不匹配以 <code>.</code> 开始的文件，如 <code>.config</code>，如果有这类文件，则需要显式标注点号。</p><h3 id="csv-文件读写"><a href="#csv-文件读写" class="headerlink" title="csv 文件读写"></a>csv 文件读写</h3><p>Python 中用来读取 CSV 文件的标准库，一个 CSV 文件经常包含若干行，每行包含若干列，列和列之前通常<strong>使用逗号分隔</strong>。其内部实现了一个 reader 类和 writer 类，用于读写序列化的数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> csv<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;some.csv&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, newline=<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    reader = csv.reader(f)<br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader:<br>        <span class="hljs-built_in">print</span>(row)  <span class="hljs-comment"># 每一个 row 是一个 List&lt; Str &gt;</span><br>        <br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;some.csv&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, newline=<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    reader = csv.DictReader(f)<br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader:<br>        <span class="hljs-built_in">print</span>(row)  <span class="hljs-comment"># 每一个 row 是一个 Dict&lt; &#x27;Str&#x27;:&#x27;Str&#x27; &gt;，需要每列单元格有标题（列头）</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;some.csv&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, newline=<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    writer = csv.writer(f)<br>    writer.writerows(data)  <span class="hljs-comment"># 可以是 List&lt; Str &gt; 或 List&lt; List&lt; Str &gt; &gt;</span><br></code></pre></td></tr></table></figure><p>注意：如果没有指定 <code>newline=&#39;&#39;</code>，则嵌入引号中的换行符将无法正确解析，并且在写入时，使用 <code>\r\n</code> 换行的平台会有多余的 <code>\r</code> 写入。由于 csv 模块会执行自己的换行符处理，因此指定 <code>newline=&#39;&#39;</code> 应该总是安全的。</p><blockquote><p>csv 库的功能大部分被 pandas 所包含，如果结构化处理数据的需求，推荐直接用 pandas 的 csv 读写函数。</p></blockquote><h3 id="argparse-命令行参数解析"><a href="#argparse-命令行参数解析" class="headerlink" title="argparse 命令行参数解析"></a>argparse 命令行参数解析</h3><p>Python 中用于解析命令行参数和选项的标准库。在复现较大型项目时，通常由工具脚本调用命令行参数，这些参数以链表形式存储于 sys 模块的 argv 变量，直接处理较为麻烦，因此有了该标准库。使用模板如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> argparse<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_args</span>():</span><br>    <span class="hljs-comment"># 声明一个解析对象，以及当 -h 或参数出错时会打印的信息</span><br>    parser = argparse.ArgumentParser(description=<span class="hljs-string">&quot;You should add those parameter!&quot;</span>)  <br><br>    <span class="hljs-comment"># 罗列所需参数，下面给出常见例子</span><br>    parser.add_argument(<span class="hljs-string">&quot;--path&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, required=<span class="hljs-literal">True</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;The path of file&quot;</span>)<br>    parser.add_argument(<span class="hljs-string">&quot;--input_num&quot;</span>, <span class="hljs-string">&quot;-n&quot;</span>, default=<span class="hljs-number">50</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>)<br>    parser.add_argument(<span class="hljs-string">&quot;--class&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, choices=[<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>])<br>    <br>    <span class="hljs-comment"># 解析参数并返回</span><br>    args = parser.parse_args()        <br>    <span class="hljs-keyword">return</span> args<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    my_args = read_args()<br>    <span class="hljs-built_in">print</span>(my_args.path)  <br></code></pre></td></tr></table></figure><h3 id="re-正则表达式"><a href="#re-正则表达式" class="headerlink" title="re 正则表达式"></a>re 正则表达式</h3><p>Python 中正则表达式匹配的标准库。模式和被搜索的字符串既可以是 Unicode 字符串（str） ，也可以是 8 位字节串（byte），但必须一致。</p><p>关于正则表达式的语法此处不过多介绍，仅给出一些示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> re<br><span class="hljs-meta">&gt;&gt;&gt; </span>re.findall(<span class="hljs-string">r&#x27;\bf[a-z]*&#x27;</span>, <span class="hljs-string">&#x27;which foot or hand fell fastest&#x27;</span>)<br>[<span class="hljs-string">&#x27;foot&#x27;</span>, <span class="hljs-string">&#x27;fell&#x27;</span>, <span class="hljs-string">&#x27;fastest&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>re.sub(<span class="hljs-string">r&#x27;(\b[a-z]+) \1&#x27;</span>, <span class="hljs-string">r&#x27;\1&#x27;</span>, <span class="hljs-string">&#x27;cat in the the hat&#x27;</span>)<br><span class="hljs-string">&#x27;cat in the hat&#x27;</span><br></code></pre></td></tr></table></figure><p>注意：若只需要简单的功能，应该首先考虑字符串方法，如 <code>.replace()</code>、<code>.split()</code> 等，更易于阅读和调试。</p><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><p>第三方库通常需要 <code>pip install</code>，建议安装在虚拟环境中，按需取用。</p><h3 id="pipreqs-依赖安装"><a href="#pipreqs-依赖安装" class="headerlink" title="pipreqs 依赖安装"></a>pipreqs 依赖安装</h3><p>当我们写好一个 Python 项目之后，如果要开源代码，为了让别人能快速运行项目，一般可以提供一个 <code>requirements.txt</code> 的，用以配置环境。</p><p><code>pipreqs</code> 是用于自动生成上述文件的一个第三方库，使用 <code>pip install pipreqs</code> 安装，进入<strong>项目根目录</strong>，执行 <code>pipreqs ./</code> 即可。如果出现编码错误，可以指定编码方式解决：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">pipreqs ./ -<span class="hljs-literal">-encoding</span> utf<span class="hljs-literal">-8</span><br></code></pre></td></tr></table></figure><p>其他人则可以使用以下命令配置环境：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">pip install <span class="hljs-literal">-r</span> requirements.txt<br></code></pre></td></tr></table></figure><h3 id="codecs-编码转换"><a href="#codecs-编码转换" class="headerlink" title="codecs 编码转换"></a>codecs 编码转换</h3><p><code>codec</code> 意为字符的编解码器（Encoder&amp;Decoder），Python 对多国语言的处理是支持的很好的，它可以处理现在任意编码的字符。在作字符转换时，Python 会借助于内部的编码（Unicode），转换的过程是这样的：<code>原有编码 -&gt; 内部编码 -&gt; 目的编码</code>。而这个转换的过程就需要用到编解码器。</p><p>一种基本的用法是通过 <code>lookup</code> 获取特定的编码器，再用其与 Unicode 进行转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> codecs<br><span class="hljs-meta">&gt;&gt;&gt; </span>codec1 = codecs.lookup(<span class="hljs-string">&quot;utf-8&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-string">&quot;你好&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = codec1.encode(a)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(b)<br>(<span class="hljs-string">b&#x27;\xe4\xbd\xa0\xe5\xa5\xbd&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment"># 其中 2 为 len(a)</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>c = codec1.decode(b[<span class="hljs-number">0</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(c)<br>(<span class="hljs-string">&#x27;你好&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment"># 其中 6 为 len(b[0])</span><br></code></pre></td></tr></table></figure><p>另一种更常用的用法是对<strong>文件</strong>字符编码的处理，常用于数据处理任务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> codecs<br><span class="hljs-comment"># 使用 codecs 自带的 open 读取文件，指定编码方式</span><br>file = codecs.<span class="hljs-built_in">open</span>(path, encoding=<span class="hljs-string">&#x27;latin-1&#x27;</span>).readlines()<br></code></pre></td></tr></table></figure><h3 id="json-文件读写"><a href="#json-文件读写" class="headerlink" title="json 文件读写"></a>json 文件读写</h3><p>JSON（JavaScript Object Notation）是一种轻量级的<strong>数据交换格式</strong>，采用完全独立于语言的文本格式，但格式类似 C 系语言。易于人阅读和编写，同时也易于机器解析和生成（一般用于提升网络传输速率）。</p><p> Python 中的 List、Dict 最常用于 json 文件的转换，在此前要先将数据类型转为字符串 Str。json 模块提供了四个功能：</p><ul><li><code>dumps</code>：把数据类型转换成字符串</li><li><code>dump</code>：把数据类型转换成字符串并存储在文件中</li><li><code>loads</code>：把字符串转换成数据类型</li><li><code>load</code>：把文件打开从字符串转换成数据类型</li></ul><p>基本使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><br>test_dict = &#123;<span class="hljs-string">&#x27;bigberg&#x27;</span>: [<span class="hljs-number">7600</span>, &#123;<span class="hljs-number">1</span>: [[<span class="hljs-string">&#x27;iPhone&#x27;</span>, <span class="hljs-number">6300</span>], [<span class="hljs-string">&#x27;Bike&#x27;</span>, <span class="hljs-number">800</span>], [<span class="hljs-string">&#x27;shirt&#x27;</span>, <span class="hljs-number">300</span>]]&#125;]&#125;<br>json_str = json.dumps(test_dict)  <span class="hljs-comment"># dict -&gt; str</span><br>new_dict = json.loads(json_str)<span class="hljs-comment"># str -&gt; dict</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;../config/record.json&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    json.dump(new_dict,f)<span class="hljs-comment"># dict -&gt; str -&gt; json</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;../config/record.json&quot;</span>,<span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> load_f:<br>    load_dict = json.load(load_f)  <span class="hljs-comment"># json -&gt; str -&gt; dict</span><br></code></pre></td></tr></table></figure><p>此外，还有一种 jsonl 文件，一行为一条记录或数据，可以用作<strong>日志文件</strong>或<strong>数据集</strong>，支持用 json 操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">data = []<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;input.jsonl&quot;</span>,<span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    data_in = f.readlines()    <span class="hljs-comment"># jsonl -&gt; list[str]</span><br>    <span class="hljs-keyword">for</span> obj <span class="hljs-keyword">in</span> data_in:<br>        data.append(json.loads(obj))  <span class="hljs-comment"># list[str] -&gt; list[dict]</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;output.jsonl&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-keyword">for</span> obj <span class="hljs-keyword">in</span> data:<br>    f.write(json.dumps(obj) + <span class="hljs-string">&#x27;\n&#x27;</span>)  <span class="hljs-comment"># list[dict] -&gt; list[str] -&gt; jsonl</span><br>        <span class="hljs-comment"># 这里的 \n 不可缺少，因为 write 不会自动换行</span><br></code></pre></td></tr></table></figure><h3 id="jsonlines-文件读写"><a href="#jsonlines-文件读写" class="headerlink" title="jsonlines 文件读写"></a>jsonlines 文件读写</h3><p>当然，上述操作也可以使用专门的 jsonl 处理模块替代：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> jsonlines<br><br>data = []<br><span class="hljs-keyword">with</span> jsonlines.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;input.jsonl&#x27;</span>) <span class="hljs-keyword">as</span> reader:<br>    <span class="hljs-keyword">for</span> obj <span class="hljs-keyword">in</span> reader:<span class="hljs-comment"># 隐含 jsonl -&gt; str -&gt; dict</span><br>        data.append(obj)   <span class="hljs-comment"># -&gt; list[dict]</span><br>        <br><span class="hljs-keyword">with</span> jsonlines.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;output.jsonl&#x27;</span>, mode=<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> writer:<br>    <span class="hljs-keyword">for</span> obj <span class="hljs-keyword">in</span> data:<span class="hljs-comment"># -&gt; dict</span><br>    writer.write(obj)  <span class="hljs-comment"># 隐含 dict -&gt; str -&gt; jsonl，自动换行</span><br></code></pre></td></tr></table></figure><h3 id="pprint-美化输出"><a href="#pprint-美化输出" class="headerlink" title="pprint 美化输出"></a>pprint 美化输出</h3><p>全称 Pretty Print，用于替代原来的 <code>print()</code> 函数，主要用于打印复杂的数据结构对象，例如多层嵌套的列表、元组和字典等。常用于<strong>多层嵌套的内容</strong>（例如复杂的 json 文件），或者有<strong>超多的元素</strong>（例如在列表中存了很多 URL 链接）。功能有：</p><ul><li>设置合适的行宽度，作适当的换行；</li><li>设置打印的缩进、层级，进行格式化打印；</li><li>判断对象中是否有无限循环，并优化打印内容。</li></ul><p>基本使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pprint <span class="hljs-keyword">import</span> pprint<br><span class="hljs-comment"># 完整接口：pprint(object, stream=None, indent=1, width=80, depth=None, compact=False)</span><br>pprint(json.loads(sample_file[<span class="hljs-number">0</span>]))<br></code></pre></td></tr></table></figure><h3 id="PIL-图像处理"><a href="#PIL-图像处理" class="headerlink" title="PIL 图像处理"></a>PIL 图像处理</h3><p>全称 Python Imaging Library，有时也称 pillow，使用 <code>pip install pillow</code> 安装。支持众多图像格式，可用于执行裁剪、大小调整、旋转、滤镜效果等操作，引入时通常使用 <code>from PIL import Image</code>。</p><p>基本使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><br><span class="hljs-comment"># 打开、显示、保存，以及图像的三个属性：模式（RGB，L）、大小（像素）、格式</span><br>image = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;input.jpg&#x27;</span>)<br>image.show()<br>image.save(<span class="hljs-string">&#x27;output.jpg&#x27;</span>)<br><span class="hljs-built_in">print</span>(image.mode, image.size, image.<span class="hljs-built_in">format</span>)  <span class="hljs-comment"># RGB (481, 321) JPEG</span><br><br>grey_image = image.convert(<span class="hljs-string">&#x27;L&#x27;</span>)  <span class="hljs-comment"># 从 RGB 转为 L 灰度图像</span><br>grey_image.show()<br><br>r, g, b = image.split()  <span class="hljs-comment"># 彩色图像可以分离出 R、G、B 通道，每个通道都是一个图像</span><br>im = Image.merge(<span class="hljs-string">&#x27;RGB&#x27;</span>, (b, g, r))  <span class="hljs-comment"># 按照一定的顺序再合并成彩色图像</span><br></code></pre></td></tr></table></figure><p>支持对图像整体、局部进行像素级操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">box = (<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>)  <span class="hljs-comment"># 设置一个四元组裁剪框</span><br>region = image.crop(box)  <span class="hljs-comment"># 减除</span><br>region = region.transpose(Image.ROTATE_180)  <span class="hljs-comment"># 旋转 180 度</span><br>image.paste(region, box)  <span class="hljs-comment"># 粘贴</span><br><br>im = image.resize((<span class="hljs-number">300</span>, <span class="hljs-number">300</span>))  <span class="hljs-comment"># 使用插值算法缩放</span><br>im = image.rotate(<span class="hljs-number">45</span>)  <span class="hljs-comment"># 逆时针旋转 45 度</span><br>im = image.transpose(Image.FLIP_LEFT_RIGHT) <span class="hljs-comment"># 左右翻转</span><br>im = image.transpose(Image.FLIP_TOP_BOTTOM) <span class="hljs-comment"># 上下翻转</span><br><br>im = image.point(<span class="hljs-keyword">lambda</span> i: i * <span class="hljs-number">1.2</span>) <span class="hljs-comment"># 对每个像素值乘以 1.2</span><br>im = image.point(<span class="hljs-keyword">lambda</span> i: i &gt; <span class="hljs-number">128</span> <span class="hljs-keyword">and</span> <span class="hljs-number">255</span>) <span class="hljs-comment"># 二值化，利用 and 短路</span><br></code></pre></td></tr></table></figure><p>还支持与 Numpy 的交互，用于手动实现图像处理算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">array = np.array(image)<br><span class="hljs-built_in">print</span>(array.shape) <span class="hljs-comment">#(321, 481, 3)</span><br>i = Image.fromarray(array)<br></code></pre></td></tr></table></figure><p>注意，PIL 只能完成基础的图像处理，更高端的操作还得用到 OpenCV 的 cv2 模块，例如：仿射变换、基本绘制、随机变化等。</p>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>科研常用网站合集</title>
    <link href="/Awesome-Sites.html"/>
    <url>/Awesome-Sites.html</url>
    
    <content type="html"><![CDATA[<p>记录科研常用网站，包括：论文检索、代码检索、学者信息、论文写作、科研论坛、截稿日期、电子书。本文持续更新。</p><h2 id="Paper"><a href="#Paper" class="headerlink" title="Paper"></a>Paper</h2><div class="table-container"><table><thead><tr><th style="text-align:center">Site</th><th style="text-align:center">Describe</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://arxiv.org/">ArXiv</a></td><td style="text-align:center">预印版论文下载，适合占坑</td></tr><tr><td style="text-align:center"><a href="https://papers.labml.ai/papers/daily">Daliy Papers</a></td><td style="text-align:center">近期<strong>热点论文</strong>追踪，没事看看</td></tr><tr><td style="text-align:center"><a href="https://github.com/">GitHub</a></td><td style="text-align:center">偶尔会有好心人放出领域论文集</td></tr><tr><td style="text-align:center"><a href="https://www.paperdigest.org/">Paper Digest</a></td><td style="text-align:center">快速搜索<strong>领域论文</strong>、最新会议论文索引 + <strong>highlight</strong></td></tr><tr><td style="text-align:center"><a href="https://ai-paper-collector.vercel.app/">AI-Paper-Search</a></td><td style="text-align:center">国人开发的插件，支持关键词匹配 AI 顶会</td></tr><tr><td style="text-align:center"><a href="https://www.connectedpapers.com/">Connected Papers</a></td><td style="text-align:center">用<strong>连通图</strong>展示同领域论文，大小论文都适用</td></tr><tr><td style="text-align:center"><a href="https://www.semanticscholar.org/">Semantic Scholar</a></td><td style="text-align:center">查看一篇论文的<strong>被引</strong>，按次数排序</td></tr><tr><td style="text-align:center"><a href="https://ac.scmor.com/">思谋学术导航</a></td><td style="text-align:center">谷歌学术镜像与 Sci-Hub 导航</td></tr><tr><td style="text-align:center"><a href="https://xueshu.dailyheadlines.cc/">深度学术搜索</a></td><td style="text-align:center">谷歌学术镜像</td></tr><tr><td style="text-align:center"><a href="https://openaccess.thecvf.com/menu">CVF Open Access</a></td><td style="text-align:center">CV 会议论文下载</td></tr></tbody></table></div><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><div class="table-container"><table><thead><tr><th style="text-align:center">Site</th><th style="text-align:center">Describe</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://paperswithcode.com/">Papers With Code</a></td><td style="text-align:center">链接论文与仓库、数据集，部分有多个仓库</td></tr><tr><td style="text-align:center"><a href="https://github.com/">GitHub</a></td><td style="text-align:center">搜索论文标题、模型名称</td></tr><tr><td style="text-align:center"><a href="https://www.catalyzex.com/">CatalyzeX</a></td><td style="text-align:center">从下游任务查找论文和代码</td></tr><tr><td style="text-align:center"><a href="https://zenodo.org/">Zenodo</a></td><td style="text-align:center">很多论文上传模型和数据集的地方，容量 50G</td></tr></tbody></table></div><h2 id="People"><a href="#People" class="headerlink" title="People"></a>People</h2><div class="table-container"><table><thead><tr><th style="text-align:center">Site</th><th style="text-align:center">Describe</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://scholar.google.com/citations?view_op=search_authors&amp;mauthors=&amp;hl=zh-CN&amp;oi=drw">Google Scholar</a></td><td style="text-align:center">个人学术档案，但有时会出错，且引用格式老旧</td></tr><tr><td style="text-align:center"><a href="http://csrankings.org/#/index?all&amp;cn">CSRanking</a></td><td style="text-align:center">按照单位、领域查找个人，且收录个人主页</td></tr><tr><td style="text-align:center"><a href="https://dblp.org/">dblp</a></td><td style="text-align:center">仅存储文献的元数据，但收录速度快，比谷歌准，<strong>适合引用</strong></td></tr><tr><td style="text-align:center"><a href="https://www.aminer.cn/">Aminer</a></td><td style="text-align:center">用<strong>河流图</strong>展示研究兴趣演变，适合分析领域</td></tr></tbody></table></div><h2 id="Writing"><a href="#Writing" class="headerlink" title="Writing"></a>Writing</h2><div class="table-container"><table><thead><tr><th style="text-align:center">Site</th><th style="text-align:center">Describe</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://www.deepl.com/">DeepL</a></td><td style="text-align:center">比 Google 翻译更好，适合憋不出英文时用</td></tr><tr><td style="text-align:center"><a href="https://hemingwayapp.com/">Hemingway App</a></td><td style="text-align:center"><strong>快速</strong>找出语病并修改，找出 <strong>hard to read</strong> 段落</td></tr><tr><td style="text-align:center"><a href="https://quillbot.com/">QuillBot</a></td><td style="text-align:center"><strong>一键修改</strong> hard to read 段落，更地道但意思会变</td></tr><tr><td style="text-align:center"><a href="https://www.grammarly.com/">Grammarly</a></td><td style="text-align:center">检查基本错误并替换，适合插件使用</td></tr><tr><td style="text-align:center"><a href="http://www.esoda.org/">ESODA</a></td><td style="text-align:center">爬取领域论文，优化专用选词、搭配</td></tr><tr><td style="text-align:center"><a href="https://linggle.com/">Linggle</a></td><td style="text-align:center">查找搭配神器，支持 <code>n.</code> <code>_</code> <code>?</code> <code>/</code> 语法</td></tr><tr><td style="text-align:center"><a href="https://books.google.com/ngrams">Books Ngram Viewer</a></td><td style="text-align:center">用 N-gram 检查两个搭配谁的使用率更高</td></tr></tbody></table></div><h2 id="Forum"><a href="#Forum" class="headerlink" title="Forum"></a>Forum</h2><div class="table-container"><table><thead><tr><th style="text-align:center">Site</th><th style="text-align:center">Describe</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://towardsdatascience.com/">Towards Data Science</a></td><td style="text-align:center">数据科学领域的 CSDN，文章质量高</td></tr><tr><td style="text-align:center"><a href="https://www.techbeat.net/">TechBeat</a></td><td style="text-align:center">中文 AI 论坛，有大量 Talk 发布</td></tr></tbody></table></div><h2 id="Deadline"><a href="#Deadline" class="headerlink" title="Deadline"></a>Deadline</h2><div class="table-container"><table><thead><tr><th style="text-align:center">Site</th><th style="text-align:center">Describe</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://aideadlin.es/?sub=ML,CV,CG,NLP,RO,SP,DM">AI Conference DDL</a></td><td style="text-align:center">人工智能领域会议截稿日期</td></tr><tr><td style="text-align:center"><a href="https://sec-deadlines.github.io/">Security and Privacy DDL</a></td><td style="text-align:center">安全领域会议截稿日期</td></tr><tr><td style="text-align:center"><a href="https://ddl.yanlin.info/?sub=">CS Conference DDL</a></td><td style="text-align:center">比前两者多了一些领域</td></tr><tr><td style="text-align:center"><a href="https://ccfddl.github.io/">CCF DDL</a></td><td style="text-align:center">比前者多标注了 CCF 推荐</td></tr><tr><td style="text-align:center"><a href="http://123.57.137.208/ccf/ccf-8.jsp">Call4Paper</a></td><td style="text-align:center">CCF 推荐列表 + 截稿日期（包括已结束）&lt;/br&gt; 偶尔不准</td></tr></tbody></table></div><h2 id="Book"><a href="#Book" class="headerlink" title="Book"></a>Book</h2><div class="table-container"><table><thead><tr><th style="text-align:center">Site</th><th style="text-align:center">Describe</th></tr></thead><tbody><tr><td style="text-align:center"><a href="http://libgen.rs/">Library Genesis</a></td><td style="text-align:center">国外电子书、论文检索</td></tr><tr><td style="text-align:center"><a href="https://zh.z-lib.org/">Z-library</a></td><td style="text-align:center">国内外电子书检索</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>科研札记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Research</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习笔记 #4 服务器环境配置</title>
    <link href="/Linux-Note-4.html"/>
    <url>/Linux-Note-4.html</url>
    
    <content type="html"><![CDATA[<p>上一节 <a href="https://hwcoder.top/Linux-Note-3">Linux学习笔记 #3 连接远程服务器</a> 中，介绍了远程控制 Linux 服务器的情景。假设我们已经完成了初次 SSH 鉴权，以下内容为<strong>后续</strong>的操作。</p><p>当新用户登录服务器时，会默认在 <code>/home/user</code> 目录下，此时这里只有配置好的 <code>.ssh</code> 目录。用户目录下的所有配置<strong>仅会与用户个人绑定</strong>，包括 Python、Conda、Git、Bash 等环境，所以此时我们需要一一配置。</p><blockquote><p><code>/home/user</code> 目录通常空间有限，因此对于<strong>开放权限较高</strong>的私人服务器，用户目录只用于存放个人使用的配置文件。而工程以及大文件则会存放在另外的 <code>/data/user</code> 目录下，以节省服务器的存储空间。下面我们称 <code>/home/user</code> 目录为 <code>~</code>。</p></blockquote><h2 id="Anaconda-环境"><a href="#Anaconda-环境" class="headerlink" title="Anaconda 环境"></a>Anaconda 环境</h2><p>首先需要安装 Anaconda 环境，使用 <code>wget</code> 命令从清华镜像源下载（该命令由 Unix 自带），不需要下载最新版（这里选用的版本仅支持到 Py3.8）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2020.02-Linux-x86_64.sh</span><br></code></pre></td></tr></table></figure><p>下载完成后，当前目录下就会出现 <code>.sh</code> 脚本形式的安装包，输入以下命令运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> bash ./Anaconda3-2020.02-Linux-x86_64.sh</span><br></code></pre></td></tr></table></figure><p>一路 Enter 确定，最后输入 yes，安装后可用 <code>conda -V</code> 查看版本。如果这里提示无法识别命令，参考接下来的做法即可。</p><h3 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h3><p>在 <code>~</code> 目录下，还有一个 <code>.bashrc</code> 文件，对于大部分 Unix 系统，Bash 是作为默认终端被安装的。你对 bashrc 所做的任何修改将在<strong>下一次启动终端</strong>时生效。如果你想立刻生效的话，运行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">source</span> ~/.bashrc</span><br></code></pre></td></tr></table></figure><p>此时会发现用户名前面就会有一个 <code>(base)</code>，表示现在处于<strong>基础环境</strong>中。Conda 集成了 Python 发行版，同时可以对 Python 虚拟环境进行管理，常用的命令有：</p><ul><li><code>conda create -n &lt;环境名&gt; python=&lt;版本&gt;</code>：创建 conda 环境。</li><li><code>conda create -n &lt;环境名&gt; --file &lt;this file&gt;</code>：创建 conda 环境并指定 requirement.txt 路径配置。</li><li><code>conda create -n &lt;新环境名&gt; --clone &lt;旧环境名&gt;</code>：复制原有 conda 环境。</li><li><code>conda env list</code> 或 <code>conda info -e</code>：查看现有的 conda 环境。</li><li><code>conda activate &lt;环境名&gt;</code>：切换 conda 环境。</li><li><code>conda deactivate</code>：关闭虚拟环境。</li><li><code>conda remove -n &lt;环境名&gt;</code>：删除环境。</li></ul><p>良好的环境管理习惯有益于在同一机器上运行多个深度学习框架而相互之间不会影响，用户创建的环境会被保存在 <code>~/anaconda3/env/xxx</code>，需要时可以直接拷贝。</p><h3 id="CUDA-环境与-PyTorch"><a href="#CUDA-环境与-PyTorch" class="headerlink" title="CUDA 环境与 PyTorch"></a>CUDA 环境与 PyTorch</h3><p>安装完 Anaconda 后，我们就能使用 <code>pip</code> 和 <code>conda</code> 两种包管理器了（此前只能用 Linux 自带的 <code>apt</code>）。</p><blockquote><p>在服务器里，我们只推荐用 <code>conda</code> 安装 <code>cudatoolkit</code>、<code>cudnn</code> 以及 <code>jupyter</code> 相关的包，其他包建议用 <code>pip</code> 进行安装。</p></blockquote><p>这里建议使用 11.1 版本的 CUDA 环境，使用 <code>conda</code> 在 <code>conda-forge</code> 源下进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> conda install -c conda-forge cudatoolkit=11.1 cudnn</span> <br></code></pre></td></tr></table></figure><p>安装在<strong>基本环境</strong>后，可以使用 <code>nvcc -V</code> 查看 CUDA 版本。</p><blockquote><p>有的服务器不装 CUDA 也能使用 GPU，是因为 Nvidia 显卡自带了驱动，如果使用 <code>nvidia-smi</code> 命令可以查看显卡状态则说明自带驱动（上方会注明驱动版本、CUDA 版本，但此时<strong>可能</strong>用不了 <code>nvcc</code> 命令）。</p><p>初次登录可以先测试 <code>nvidia-smi</code>，否则就需要手动安装 N 卡驱动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> sudo add-apt-repository ppa:graphics-drivers/ppa  <span class="hljs-comment"># 把显卡驱动加入PPA</span></span><br><span class="hljs-meta">$</span><span class="bash"> ubuntu-drivers devices  <span class="hljs-comment"># 查找当前设备适合的驱动版本</span></span><br><span class="hljs-meta">$</span><span class="bash"> sudo apt-get install nvidia-driver-418  <span class="hljs-comment"># 安装对应版本</span></span><br></code></pre></td></tr></table></figure></blockquote><h3 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h3><p>使用 <code>pip</code> 进行安装时，建议安装在<strong>虚拟环境</strong>中，特别是一些<strong>不常用</strong>的包。如果下载过慢或失败，可以使用清华源进行下载，使用以下命令在<strong>个人配置</strong>中更新及换源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> pip install -U pip -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="hljs-meta">$</span><span class="bash"> pip config <span class="hljs-built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></code></pre></td></tr></table></figure><p>如果不方便换源，临时使用的方法为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> pip install &lt;package&gt; -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></code></pre></td></tr></table></figure><p>这里以 PyTorch 为例，我们将其装在<strong>虚拟环境</strong>中，使用以下命令，不同库之间用<strong>空格隔开</strong>可一并安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> pip install torch torchvision torchaudio</span><br></code></pre></td></tr></table></figure><blockquote><p>为什么 PyTorch 不要装在基本环境？因为安装高版本的 PyTorch 时会自动替换 Numpy 等依赖库至相应版本。而这些自动替换的基础库很有可能与其他高级库产生不匹配的冲突，导致原先功能无法正常使用，也就是原先的运行环境会被污染。此外这样也便于虚拟环境的拷贝。</p></blockquote><p>成功安装后可以在命令行里打开 Python 测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch<br><span class="hljs-meta">&gt;&gt;&gt; </span>torch.__version__<br><span class="hljs-meta">&gt;&gt;&gt; </span>torch.cuda.is_available()<br><span class="hljs-meta">&gt;&gt;&gt; </span>torch.cuda.device_count()<br><span class="hljs-meta">&gt;&gt;&gt; </span>torch.tensor([<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>]).cuda()<br><span class="hljs-comment"># 1.9.1+cu11.1</span><br><span class="hljs-comment"># True</span><br><span class="hljs-comment"># 4</span><br><span class="hljs-comment"># tensor([1., 2.], device=&#x27;cuda:0&#x27;)</span><br></code></pre></td></tr></table></figure><p>下面列举需要安装在<strong>基本环境</strong>中的常用库，安装方法同上：</p><ul><li><code>gpustat</code>：用于查看动态查看 GPU 状态（需要 Nvidia 驱动），<code>watch -n1 -c gpustat --color</code>。</li><li><code>ipdb</code>：用于简易的断点调试，可以看做 <code>pdb</code> 的升级版，<code>python -m ipdb main.py</code>。</li></ul><h3 id="Notebook"><a href="#Notebook" class="headerlink" title="Notebook"></a>Notebook</h3><p>有时候需要在远程服务器中使用 Jupyter Notebook，就需要先在远程安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ conda install -c conda-forge jupyter notebook<br></code></pre></td></tr></table></figure><p>之后就可以在远程启动 Jupyter 服务，内核放在远程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ jupyter notebook --port=8889<br></code></pre></td></tr></table></figure><p>启动后会获得服务的 URL 地址，这个地址可以在本地用浏览器直接打开，也可以在 VSCode 中安装 Jupyter 插件后打开。</p><h2 id="个人配置"><a href="#个人配置" class="headerlink" title="个人配置"></a>个人配置</h2><p>如果这个服务器需要<strong>长期使用</strong>，那么进行下面的配置就很有必要。以下大部分内容需要用 <code>apt</code> 包管理器安装，因此需要获取 <code>sudo</code> 临时<strong>管理员权限</strong>，如果没有可以向管理员申请。</p><h3 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h3><p>安装 Git 后，在 <code>~</code> 下就会存在一个 <code>.gitconfig</code> 或 <code>.config/git/config</code> 的文件，如果没有则需自行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> sudo apt-get install git -y  <span class="hljs-comment"># -y 表示默认 yes</span></span><br></code></pre></td></tr></table></figure><p>在服务器里配置 Git 有三层，每层的配置（系统 <code>--system</code> 、全局 <code>--global</code>、仓库 <code>--local</code>）都会<strong>覆盖掉上一层次</strong>的配置，这里要修改 <code>~</code> 下的<strong>个人配置</strong>，则需要用到 <code>--global</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 替换成个人信息！</span><br>$ git config --global user.name <span class="hljs-string">&quot;hewei2001&quot;</span><br>$ git config --global user.email <span class="hljs-string">&quot;631670924@qq.com&quot;</span><br><span class="hljs-comment"># 常用的指令可以取 alias 别名</span><br>$ git config --global alias.showlog <span class="hljs-string">&quot;log --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit --date=relative&quot;</span><br></code></pre></td></tr></table></figure><p>如果需要建立远程 SSH 鉴权，使用以下命令打印出<strong>公钥</strong>，手动复制到 GitHub 上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="hljs-string">&quot;631670924@qq.com&quot;</span>  <span class="hljs-comment"># 生成</span></span><br><span class="hljs-meta">$</span><span class="bash"> cat ~/.ssh/id_rsa.pub  <span class="hljs-comment"># 打印</span></span><br><span class="hljs-meta">$</span><span class="bash"> ssh -T git@github.com  <span class="hljs-comment"># 测试</span></span><br></code></pre></td></tr></table></figure><h3 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h3><p>首先检查<strong>服务器可用终端</strong>是否包含 <code>zsh</code>，如果有直接切换，并安装<strong>插件管理器</strong> <code>oh-my-zsh</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> cat /etc/shells  <span class="hljs-comment"># 打印可用终端，看有没有 /bin/zsh</span></span> <br><span class="hljs-meta">$</span><span class="bash"> chsh -s /bin/zsh</span> <br><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class="hljs-meta">$</span><span class="bash"> cp ~/.zshrc ~/.zshrc.bak  <span class="hljs-comment"># 备份原配置</span></span><br><span class="hljs-meta">$</span><span class="bash"> cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">source</span> ~/.zshrc</span><br></code></pre></td></tr></table></figure><p>如果没有自带 <code>zsh</code>，完成以下几步后，就可以成功安装二者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> sudo apt-get install zsh -y</span><br><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class="hljs-meta">$</span><span class="bash"> cp ~/.zshrc ~/.zshrc.bak  <span class="hljs-comment"># 备份原配置</span></span><br><span class="hljs-meta">$</span><span class="bash"> cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br><span class="hljs-meta">$</span><span class="bash"> chsh -s /bin/zsh  <span class="hljs-comment"># 切换终端</span></span><br></code></pre></td></tr></table></figure><blockquote><p>如果执行第一步时无 <code>sudo</code> 权限，则需要自行安装资源包及依赖，参考：<a href="https://www.cnblogs.com/XiiX/p/14618799.html">Linux 以非 root 用户安装 zsh</a>。</p></blockquote><p>重启系统，此时已经进入新的 <code>zsh</code> 终端，下载将要用到的主题和插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 主题 powerlevel10k</span><br>$ git <span class="hljs-built_in">clone</span> --depth=1 https://gitee.com/romkatv/powerlevel10k.git <span class="hljs-variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/themes/powerlevel10k<br><span class="hljs-comment"># 两个插件</span><br>$ git <span class="hljs-built_in">clone</span> --depth=1 https://github.com/zsh-users/zsh-autosuggestions <span class="hljs-variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions<br>$ git <span class="hljs-built_in">clone</span> --depth=1 https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="hljs-variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting<br></code></pre></td></tr></table></figure><p>打开 <code>.zshrc</code>，<strong>手动修改</strong>以下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 主题，如果要用自带的主题推荐 bira</span><br>ZSH_THEME=<span class="hljs-string">&quot;powerlevel10k/powerlevel10k&quot;</span><br><span class="hljs-comment"># 插件</span><br>plugins=(git <br> tmux <br> z <br> extract <br> zsh-autosuggestions<br> zsh-syntax-highlighting)<br></code></pre></td></tr></table></figure><p><code>oh-my-zsh</code> 自带的插件定义了常用的别名，可以用 <code>alias</code> 命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># git 相关</span><br>gaa = git add --all <br>gcmsg = git commit -m <br>ga = git add <br>gst = git status <br>gp = git push<br><span class="hljs-comment"># tmux 相关</span><br>tl = tmux list-sessions<br>tkss = tmux kill-session -t<br>ta = tmux attach -t<br>ts = tmux new-session -s<br></code></pre></td></tr></table></figure><p>下面是部分自带的插件、需要手动安装的插件介绍：</p><ul><li><code>z</code>：在常用目录之间<strong>直接跳转</strong>，使用 <code>z &lt;dir_name&gt;</code>。</li><li><code>extract</code>：<strong>一键解压</strong>各种形式压缩包，使用 <code>x &lt;file_name&gt;</code>。</li><li><code>gitignore</code>：一键生成 gitignore 模板，使用 <code>gi python &gt; .gitignore</code>。</li><li><code>cpv</code>：带进度条复制文件，使用 <code>cpv &lt;a&gt; &lt;b&gt;</code>。</li><li><code>colored-man-pages</code>：带颜色的 <code>man</code> 菜单。</li><li><p><code>sudo</code>：上一条命令忘记加 <code>sudo</code>，双击 <code>ESC</code> 就会自动加上。</p></li><li><p><code>zsh-autosuggestions</code>：<strong>命令补全</strong>插件，需要手动安装。</p></li><li><code>zsh-syntax-highlighting</code>：<strong>命令高亮</strong>插件，需要手动安装。</li></ul><blockquote><p>之前在 <code>.bashrc</code> 里的一些配置也要搬过来，主要有 <strong>Conda 环境的路径配置</strong>和一些 alias，配置完成后使用 <code>source ~/.zshrc</code> 命令<strong>重启终端</strong>即可。之后会进入主题的引导设置，如果想重新配置可以输入 <code>p10k configure</code> 命令。</p></blockquote><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>加载预训练模型时，总是不可避免地要去访问国外下载源，而部署在国内网络的服务器则无能为力。此时就需要在主机使用 VPN，通过「<strong>反向代理</strong>」的方法让服务器也能使用到主机的 VPN。</p><p>在<strong>本机</strong>终端输入以下命令，并保持终端开启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh -NR 12306:localhost:7890 hewei@10.249.xx.xxx<br><span class="hljs-comment"># 其中 12306 可以是任意端口，7890 则必须改成 VPN 的代理端口！</span><br></code></pre></td></tr></table></figure><p>在<strong>服务器</strong>终端输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">export</span> http_proxy=http://127.0.0.1:12306/<br>$ <span class="hljs-built_in">export</span> https_proxy=http://127.0.0.1:12306/<br><span class="hljs-comment"># 其中 12306 必须和 前述端口 一致！</span><br></code></pre></td></tr></table></figure><p>完成后，可以使用 <code>wget google.com</code> 测试是否成功。为了方便在服务器开启服务，可以在 <code>~./zshrc</code> 中加上别名:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">alias</span> proxyon=<span class="hljs-string">&#x27;export http_proxy=http://127.0.0.1:12306 https_proxy=http://127.0.0.1:12306 &amp;&amp; echo Proxy On!&#x27;</span></span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">alias</span> proxyoff=<span class="hljs-string">&#x27;unset http_proxy https_proxy &amp;&amp; echo Proxy Off!&#x27;</span></span><br></code></pre></td></tr></table></figure><blockquote><p>如果上述方法行不通，除了用本机下载预训练模型后 <code>scp</code> 到服务器，还可尝试此方案：<a href="https://zhuanlan.zhihu.com/p/475260268">如何优雅的下载 huggingface-transformers 模型</a>。</p></blockquote><h2 id="一键配置"><a href="#一键配置" class="headerlink" title="一键配置"></a>一键配置</h2><p>下面对于<strong>临时使用的命令</strong>进行汇总，由 Shell 脚本的形式一键执行。只需在 <code>/home/user</code> 目录下新建一个 <code>hello.sh</code> 文件，输入以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2020.02-Linux-x86_64.sh<br>bash Anaconda3-2020.02-Linux-x86_64.sh<br><span class="hljs-built_in">source</span> .bashrc<br><br>conda install -c conda-forge cudatoolkit=11.1 cudnn<br><br>pip install -U pip -i https://pypi.tuna.tsinghua.edu.cn/simple<br>pip config <span class="hljs-built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple<br>pip install gpustat<br>pip install ipdb<br><br><span class="hljs-comment"># 别名配置</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;alias gpus=&#x27;watch -n1 -c gpustat --color&#x27;&quot;</span> &gt;&gt; ~/.bashrc<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;alias ca=&#x27;conda activate&#x27;&quot;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;alias cda=&#x27;conda deactivate&#x27;&quot;</span> &gt;&gt; ~/.bashrc<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;alias proxyon=&#x27;export http_proxy=http://127.0.0.1:12306 https_proxy=http://127.0.0.1:12306 &amp;&amp; echo Proxy On!&#x27;&quot;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;alias proxyoff=&#x27;unset http_proxy https_proxy &amp;&amp; echo Proxy Off!&#x27;&quot;</span> &gt;&gt; ~/.bashrc<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;alias tl=&#x27;tmux list-sessions&#x27;&quot;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;alias tkss=&#x27;tmux kill-session -t&#x27;&quot;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;alias ta=&#x27;tmux attach -t&#x27;&quot;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;alias ts=&#x27;tmux new-session -s&#x27;&quot;</span> &gt;&gt; ~/.bashrc<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;alias ll=&#x27;ls -alF&#x27;&quot;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;alias la=&#x27;ls -A&#x27;&quot;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;alias l=&#x27;ls -CF&#x27;&quot;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;alias ls=&#x27;ls --color=tty&#x27;&quot;</span> &gt;&gt; ~/.bashrc<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;alias cd..=&#x27;cd ..&#x27;&quot;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;alias md=&#x27;mkdir -p&#x27;&quot;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;alias rd=rmdir&quot;</span> &gt;&gt; ~/.bashrc<br><br><span class="hljs-built_in">source</span> .bashrc<br><br><span class="hljs-comment"># git 配置，替换成自己的</span><br>git config --global user.name <span class="hljs-string">&quot;hewei2001&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;631670924@qq.com&quot;</span><br></code></pre></td></tr></table></figure><p>在命令行中执行 <code>bash hello.sh</code>。</p>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ML学习笔记 #7 神经网络：反向传播</title>
    <link href="/ML-Note-7.html"/>
    <url>/ML-Note-7.html</url>
    
    <content type="html"><![CDATA[<p>上一节介绍了神经网络模型可以利用前向传播做预测，并引入了一系列符号来描述神经网络模型：</p><blockquote><ul><li>$x_i$ 表示输入层的第 $i$ 个输入特征，其中 $x_0$ 偏置项省略；</li><li>$a^{(j)}_i$ 表示第 $j$ 层的第 $i$ 个激活单元，其中 $a_0^{(j)}$ 偏置单元省略；</li><li>$s_j$ 表示第 $j$ 层的神经元数量（<strong>不包含偏置项</strong>），$\hat a^{(j)}\in\mathbb R^{s_j+1}$ 表示<strong>加上偏置项</strong>后的 $a^{(j)}$；</li><li>$\Theta^{(j)}\in\mathbb R^{s_{j+1}\times(s_j+1)}$ 表示第 $j$ 层到第 $j+1$ 层的<strong>权重矩阵</strong>，$\Theta$ 表示所有权重矩阵的<strong>集合</strong>。</li></ul></blockquote><p>其中的权重参数，与前面的回归问题类似，需要通过最小化代价函数来逼近。</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>为了描述代价函数，我们引入新的符号：</p><ul><li>$L$ 表示神经网络的<strong>层数</strong>，包含输入层、隐藏层、输出层，因此共有 $L-1$ 次传播；</li><li>$K\geqslant 3$ 表示多分类问题的<strong>类别数</strong>，相应的有 $s_L = K,\;\;h_{\Theta}(x)\in\mathbb R^{K}$；</li><li>$h_\Theta(x^{(i)})\in\mathbb R^K$，表示从第 $i$ 个样本经过神经网络得到的<strong>输出</strong>结果，$h_\Theta(x^{(i)})_k$ 表示其第 $k$ 维。</li></ul><p>回顾正则化逻辑回归中的<strong>交叉熵代价函数</strong>：</p><script type="math/tex; mode=display">J(\theta)=-\frac{1}{m}\sum_{i=1}^m{\left[ y^{\left( i \right)}\ln \left( h_{\theta}\left( x^{\left( i \right)} \right) \right) +\left( 1-y^{\left( i \right)} \right) \ln \left( 1-h_{\theta}\left( x^{\left( i \right)} \right) \right) \right]}+\frac{\lambda}{2m}\sum_{j=1}^n{\theta _{j}^{2}}\\</script><p>在神经网络中，我们沿用交叉熵代价函数而不是均方误差，原因如下：</p><ol><li>我们使用了 $\text{sigmoid}$ 函数作为激活函数引入非线性，其单增 $S$ 形曲线使其在 $y=0$ 和 $1$ 附近导数较小；</li><li>通常我们会<strong>随机初始化参数</strong>后进行梯度下降，如果使用<strong>均方误差代价函数</strong>，对 $\theta$ 求偏导后含有 $\text{sigmoid}$ 的<strong>导数项</strong>，会使前期的梯度下降十分缓慢；</li><li>如果使用交叉熵代价函数，则求偏导后不含 $\text{sigmoid}$ 的导数项，前期收敛更快。</li></ol><p>具体地，对于一个 $K$ 分类的神经网络而言，可以看作是 $K$ 个二分类的<strong>交叉熵代价函数之和</strong>： </p><script type="math/tex; mode=display">J(\Theta )=-\frac{1}{m}\left[ \sum_{i=1}^m{\sum_{k=1}^K{y_{k}^{(i)}}}\ln \left( h_{\Theta}(x^{(i)})_k \right) +(1-y_{k}^{(i)})\ln \left( 1-h_{\Theta}(x^{(i)})_k \right) \right] +\frac{\lambda}{2m}\sum_{l=1}^{L-1}{\sum_{i=1}^{s_l}{\sum_{j=1}^{s_{l+1}}{\left( \Theta _{ji}^{(l)} \right) ^2}}}</script><p>注意这里有一个符号混用的地方：上标 $^{(i)}$ 在 $x^{(i)}$ 和 $y^{(i)}$ 中表示第 $i$ 个数据的输入（$\in\mathbb R^{n+1}$）和输出（$\in\mathbb R^{K}$），但是在 $\Theta^{(l)}$ 中表示第 $l$ 层的 $\Theta$（$\in \mathbb R^{s_{l+1}\times (s_l+1)}$）. </p><h2 id="反向传播算法-Back-Propagation"><a href="#反向传播算法-Back-Propagation" class="headerlink" title="反向传播算法 | Back Propagation"></a>反向传播算法 | Back Propagation</h2><p>现在我们的目标就是最小化代价函数 $J(\Theta)$，并找到使之最小的参数 $\Theta$，我们仍使用梯度下降法解决最小化问题（尽管 $J(\Theta)$ 可能为非凸函数）。因此需要计算梯度 $\begin{aligned} \frac{\partial J}{\partial \Theta_{ji}^{(l)}} \end{aligned}$，而计算的关键就是「<strong>反向传播</strong>」：从输出层开始逐层向前计算。</p><blockquote><p>为什么需要「反向传播」？我们知道梯度反映的是 $J$ 在 $\Theta_{ji}^{(l)}$ 方向的变化率，即：当参数发生微小增量时，代价函数的增量。对于前几层网络，参数的增量需要经过多层<strong>全连接</strong>传播，才会影响到输出（代价函数）。</p><p>如果我们从输入层开始计算每个参数的梯度，则每个参数都要<strong>依赖</strong>其后续路径的传播，每个参数的计算都要先算一遍后续路径的梯度。而如果从输出层开始逐层向前计算并存储了梯度，则<strong>解耦</strong>了依赖关系，前一层可以利用后一层的计算结果。有点类似「动态规划」中「递归求解子问题」的思想。</p></blockquote><h3 id="数学推导：问题转化"><a href="#数学推导：问题转化" class="headerlink" title="数学推导：问题转化"></a>数学推导：问题转化</h3><p>为了推导方便，先假设只有一组数据 $(x,y)$，这样可以省去上标和求和的麻烦。并且令 $\lambda = 0$ 省略正则化项，等到最后的偏导结果再加上。</p><p>我们首先对第 $l+1$ 层的第 $j$ 个神经元（<strong>偏置单元除外</strong>）定义一个 $\text{delta}$ 误差：</p><script type="math/tex; mode=display">\delta_j^{(l+1)}=\frac{\partial J}{\partial z_j^{(l+1)}}</script><p>其中 $z_j^{(l+1)}=\sum\limits_{k=0}^{s_{l}}\Theta^{(l)}_{jk}a^{(l)}_{k}$，即 $a_j^{(l+1)}$ 神经元取 $\text{sigmoid}$ 激活前的输出值。换句话说，$a^{(l+1)}_j=g\left(z_j^{(l+1)}\right)$。</p><p>于是根据<strong>链式求导法则</strong>，我们有：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial \Theta^{(l)}_{ji}}=\frac{\partial J}{\partial z_j^{(l+1)}}\cdot\frac{\partial z_j^{(l+1)}}{\partial\Theta_{ji}^{(l)}}=\delta_j^{(l+1)}a_i^{(l)}</script><p>写作矩阵形式：</p><script type="math/tex; mode=display">\boxed{\Delta ^{\left( l \right)}=\delta ^{\left( l+1 \right)}\cdot \left( a^{\left( l \right)} \right) ^T}\tag{1}</script><p>显然，一旦求出当前层的 $\text{delta}$ 误差，那么<strong>传入</strong>当前层的各参数的梯度也可求出。所以现在<strong>问题转化</strong>为求解 $\delta^{(l+1)}$。</p><h3 id="数学推导：输出层误差"><a href="#数学推导：输出层误差" class="headerlink" title="数学推导：输出层误差"></a>数学推导：输出层误差</h3><p>既然要递归求解子问题，首先就是要算输出层，即 $\delta_j^{(L)}$：</p><script type="math/tex; mode=display">\begin{aligned}    \delta _{j}^{\left( L \right)}&=\frac{\partial J}{\partial z_{j}^{\left( L \right)}}=\frac{\partial J}{\partial a_{j}^{\left( L \right)}}\cdot \frac{\partial a_{j}^{\left( L \right)}}{\partial z_{j}^{\left( L \right)}}\\    &=\frac{\partial J}{\partial a_{j}^{\left( L \right)}}\cdot g'\left( z_{j}^{\left( L \right)} \right)\\    &=-\left( \frac{y_j}{a_{j}^{\left( L \right)}}-\frac{1-y_j}{1-a_{j}^{\left( L \right)}} \right) \cdot \left( a_{j}^{\left( L \right)}\left( 1-a_{j}^{\left( L \right)} \right) \right)\\    &=a_{j}^{\left( L \right)}-y_j\\\end{aligned}</script><p>写作矩阵形式：</p><script type="math/tex; mode=display">\boxed{\delta^{(L)}=a^{(L)}-y}\tag{2}</script><blockquote><p> 此处推导过程的一些注释：</p><p>关于第二行，请注意：$a^{\left( L \right)}=g\left( z^{\left( L \right)} \right) $；</p><p>关于第三行，请注意 $\text{sigmoid}$ 函数的性质：$g’(z)=g(z)(1-g(z))$；</p><p>以及第三行偏导项的计算，请注意 $a^{(L)}=h_\Theta(x)$，所以 $J(\Theta)$ 在现在的假设条件下可以写作：</p><script type="math/tex; mode=display">J(\Theta)=-\left[\sum_{k=1}^Ky_k\ln(a^{(L)}_k)+(1-y_k)\ln(1-a_k^{(L)})\right]</script></blockquote><h3 id="数学推导：隐藏层误差"><a href="#数学推导：隐藏层误差" class="headerlink" title="数学推导：隐藏层误差"></a>数学推导：隐藏层误差</h3><p>下面计算第 $l$ 层（$2\leqslant l&lt;L$）的 $\delta_j^{(l)}$：</p><script type="math/tex; mode=display">\begin{aligned}    \delta _{j}^{\left( l \right)}&=\frac{\partial J}{\partial z_{j}^{\left( l \right)}}\\    &=\frac{\partial J}{\partial z^{\left( l+1 \right)}}\cdot \frac{\partial z^{\left( l+1 \right)}}{\partial a_{j}^{\left( l \right)}}\cdot \frac{\partial a_{j}^{\left( l \right)}}{\partial z_{j}^{\left( l \right)}}\\    &={\delta ^{\left( l+1 \right)}}^T\cdot \Theta _{\cdot ,j}^{\left( l \right)}\cdot g'\left( z_{j}^{\left( l \right)} \right)\\    &={\delta ^{\left( l+1 \right)}}^T\cdot \Theta _{\cdot ,j}^{\left( l \right)}\cdot \left( a_{j}^{\left( l \right)} \left( 1-a_{j}^{\left( l \right)} \right) \right)\\\end{aligned}</script><p>观察式子的前半部分，可以看出下一层所有结点的 $\text{delta}$ 误差均会影响当前层的任一结点，而影响则是通过该结点<strong>链出</strong>的权重参数反向传播。</p><p>转置后，写作矩阵形式：</p><script type="math/tex; mode=display">\boxed{\delta ^{\left( l \right)}=\left( {\Theta ^{\left( l \right)}}^T\delta ^{\left( l+1 \right)} \right) \odot \left( a^{\left( l \right)}\odot \left( 1-a^{\left( l \right)} \right) \right) }\tag{3}</script><p>其中 $\odot$ 表示 Hadmard 积，即两个向量对应位置相乘。</p><h3 id="步骤总结"><a href="#步骤总结" class="headerlink" title="步骤总结"></a>步骤总结</h3><p>以上是对一组数据的推导，我们得到了三个重要的结果 $(1)(2)(3)$：</p><script type="math/tex; mode=display">\boxed{\begin{aligned}    \Delta ^{\left( l \right)}&=\delta ^{\left( l+1 \right)}\cdot \left( a^{\left( l \right)} \right) ^T&&1\leqslant l<L\\    \delta ^{\left( L \right)}&=a^{\left( L \right)}-y\\    \delta ^{\left( l \right)}&=\left( {\Theta ^{\left( l \right)}}^T\delta ^{\left( l+1 \right)} \right) \odot \left( a^{\left( l \right)}\odot \left( 1-a^{\left( l \right)} \right) \right) &&2\leqslant l<L\\\end{aligned}}</script><p>而 $m$ 组数据只需要在一些地方进行累加即可。设数据集为 $\left\{ \left( x^{\left( i \right)},y^{\left( i \right)} \right) \mid 1\leqslant i\leqslant m \right\}$，则反向传播算法的步骤如下：</p><ol><li><p>所有 $\Delta^{(l)}$ 置零；</p></li><li><p>遍历数据集，设当前数据为 $(x^{(i)},y^{(i)})$：</p><ol><li>以 $x^{(i)}$ 为输入做前向传播，得到输出 $a^{(L)}$；</li><li>公式 $(2)$ 计算输出层误差，公式 $(3)$ 计算隐藏层误差；</li><li>公式 $(1)$ 更新各层的 $\Delta^{(l)}$ 矩阵，进行<strong>累加</strong>：$\Delta^{(l)}:=\Delta^{(l)}+\delta ^{\left( l+1 \right)}\cdot \left( a^{\left( l \right)} \right)^T$；</li></ol></li><li><p>计算 $D$ 矩阵，对偏置项以外的参数进行<strong>正则化</strong>：</p><script type="math/tex; mode=display">D_{ij}^{(l)}:=\begin{cases}    \frac{1}{m}\left( \Delta _{ij}^{(l)}+\lambda \Theta _{ij}^{(l)} \right)&        \mathrm{if}\; j\ne 0\\    \frac{1}{m}\Delta _{ij}^{(l)}&        \mathrm{if}\; j=0\\\end{cases}</script><p>这就是最终的梯度矩阵：$\begin{aligned}\frac{\partial J}{\partial \Theta_{ij}^{(l)}}=D^{(l)}_{ij}\end{aligned}$。</p></li></ol><p>现在，我们可以用 $D_{ij}^{(l)}$ 做一次梯度下降了，整个步骤称为<strong>一代</strong>（<strong>epoch</strong>）。注意，我们的参数 $\Theta^{(l)}$ 应该初始化为 $[-\epsilon,\epsilon]$ 中的<strong>随机值</strong>。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="参数展开-Unrolling-Parameters"><a href="#参数展开-Unrolling-Parameters" class="headerlink" title="参数展开 | Unrolling Parameters"></a>参数展开 | Unrolling Parameters</h3><p>实现过程中，由于每一层都有一个 $\Theta^{(l)}$ 和 $D^{(l)}$ 矩阵，总共有 $2 \times L$ 个矩阵，为了方便存储和计算，我们最好都转换为向量，并将各层的向量拼接成一个长向量。这样做可以方便调用封装好的高级优化函数接口，如 <code>fminunc</code> 或 <code>scipy.optimize.minimize</code>。</p><p>同样，函数输出的结果向量也可以通过 <code>reshape</code> 转为矩阵，再应用于前向传播。</p><h3 id="梯度检验-Gradient-Checking"><a href="#梯度检验-Gradient-Checking" class="headerlink" title="梯度检验 | Gradient Checking"></a>梯度检验 | Gradient Checking</h3><p>当我们为一个较为复杂的模型（例如神经网络）实现梯度下降算法时，可能会出现一些不易察觉的错误，导致虽然代价看上去在不断减小，但最终的结果可能并不是最优解，误差可能高出一个量级。</p><p>为了避免这样的问题，可采取<strong>梯度的数值检验</strong>方法（Numerical Gradient Checking）：通过数值计算得到梯度的近似值，再和反向传播的结果比对，检验是否接近。</p><p>在任意一代计算后，得到一组 $\theta$ 向量及 $D$ 矩阵，通过<strong>差商</strong>近似 $J(\theta)$ 的各偏导：</p><script type="math/tex; mode=display">\frac{\partial}{\partial \theta_k}J(\theta)\approx\frac{J(\theta_1,\cdots,\theta_k+\epsilon,\cdots,\theta_n)-J(\theta_1,\cdots,\theta_k-\epsilon,\cdots,\theta_n)}{2\epsilon}</script><p>其中，$\epsilon$ 是非常小的常数，为了避免计算误差，通常选取 $10^{-4}$。现在我们可以比较这些偏导估计值与对应位置 $D_{ij}^{(l)}$ 的值，它们应该非常接近。</p><p>注意：梯度检验耗时巨大，<strong>复杂度远大于反向传播</strong>，一旦验证了神经网络反向传播的代码正确后，不应进行梯度检验（删掉 or 注释掉）。</p><h3 id="参数随机初始化"><a href="#参数随机初始化" class="headerlink" title="参数随机初始化"></a>参数随机初始化</h3><p>前文我们提到参数 $\Theta^{(l)}$ 应该初始化为 $[-\epsilon,\epsilon]$ 中的<strong>随机值</strong>，而不是简单初始化为<strong>全零</strong>。如果将 $\Theta^{(l)}$ 初始化为全零，则下一层的 $z^{(l+1)}$ 也为全零，则 $a^{(l+1)}$ 就全为 $0.5$，且所有隐藏层都会得到这个结果；与此同时，反向传播公式 $(3)$ 中，由输出层到隐藏层时 $\text{delta}$ 误差也会清零。这将导致网络无法传播！</p><p>那么，如果将参数 $\Theta^{(l)}$ 全都初始化为同一个<strong>非零常量</strong>呢？由于全连接，同一层的 $a^{(l+1)}$ 将为相同值；在反向传播公式 $(3)$ 中，由输出层到隐藏层时 $\text{delta}$ 误差也会变成相同值，则所有的 $D^{(l)}$ 矩阵也为常数矩阵，参数 $\Theta^{(l)}$ 将再次被更新为新的相同常量。这样下去所有的激活单元都成了摆设，因为每一层都在重复计算着相同特征。</p><blockquote><p>上述问题也被称为<strong>对称权重</strong>问题（Symmetric Weights），解决方法就是随机初始化，实现时可以将 $[0,1]$ 的随机数映射到 $[-\epsilon,\epsilon]$，这里的 $\epsilon$ 与梯度检验中的<strong>无关</strong>。</p><p>实际应用中 $\epsilon$ 的选取，通常与 $\Theta^{(l)}$ 前后两层的<strong>神经元个数</strong>有关，一种常用的有效的取值是：</p><script type="math/tex; mode=display">\epsilon ^{\left( l \right)}=\frac{\sqrt{6}}{\sqrt{s^{\left( l \right)}+s^{\left( l+1 \right)}}}</script></blockquote><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>下面以 <a href="https://www.coursera.org/">Coursera</a> 上的多分类数据集 <code>ex4data1.mat</code> 为例，这是一个手写数字的数据集，与上一节的数据集类似。共 $5000$ 组数据，每组数据输入是一个由 $20\times20$ 灰度矩阵压缩而来的 $400$ 维向量，输出是 $0$ 到 $9$ 之间的整数。</p><p>题目还提供一组训练好的权重参数 <code>ex4weight.mat</code>，用以检验前向传播和代价函数的正确性，此处跳过。采用题目推荐的网络层数 $L=3$，则输入层有 $401$ 个单元（含偏置项），隐藏层有 $26$ 个单元（含偏置项） ，输出层有 $10$ 个单元（独热编码）。</p><p>先进行预处理，包括数据预处理、随机初始化参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> scipy.io <span class="hljs-keyword">as</span> scio<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> classification_report<br><br><span class="hljs-comment"># load data</span><br>data = scio.loadmat(<span class="hljs-string">&#x27;ex4data1.mat&#x27;</span>)<br>X = data[<span class="hljs-string">&#x27;X&#x27;</span>] <span class="hljs-comment"># (5000, 400), 这里不转置</span><br>y = data[<span class="hljs-string">&#x27;y&#x27;</span>].flatten()<span class="hljs-comment"># (5000, )</span><br>y[y==<span class="hljs-number">10</span>] = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># parameter</span><br>(m, n) = (<span class="hljs-number">5000</span>, <span class="hljs-number">401</span>)<br>L = <span class="hljs-number">3</span>  <span class="hljs-comment"># layer of network</span><br>s = [<span class="hljs-number">0</span>, <span class="hljs-number">400</span>, <span class="hljs-number">25</span>, <span class="hljs-number">10</span>] <span class="hljs-comment"># size of each layer</span><br>lmd = <span class="hljs-number">1</span> <span class="hljs-comment"># for regularization</span><br>alpha = <span class="hljs-number">0.1</span><br>num_iters = <span class="hljs-number">5000</span><br><span class="hljs-comment">#J_history = []</span><br><br><span class="hljs-comment"># One-hot encoder</span><br>Y = np.zeros((m, s[L]))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>Y[i][y[i]] = <span class="hljs-number">1</span><br><br><span class="hljs-comment"># random init Theta, (25, 401) (10, 26)</span><br>Theta = [<span class="hljs-literal">None</span>] * L<br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, L):<br>Theta[l] = np.random.rand(s[l+<span class="hljs-number">1</span>], s[l]+<span class="hljs-number">1</span>)<br>eps = np.sqrt(<span class="hljs-number">6</span>) / np.sqrt(s[l+<span class="hljs-number">1</span>] + s[l])<br>Theta[l] = Theta[l] * <span class="hljs-number">2</span> * eps - eps<br></code></pre></td></tr></table></figure><p>再实现前向传播与代价函数计算，代价函数这里用于绘图、梯度检验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sigmoid</span>(<span class="hljs-params">z</span>):</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + np.exp(-z))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forwardProp</span>():</span><br>a = [<span class="hljs-literal">None</span>] * (L+<span class="hljs-number">1</span>)<br><span class="hljs-comment"># input layer</span><br>a[<span class="hljs-number">1</span>] = np.c_[np.ones(m), X] <span class="hljs-comment"># (5000, 401)</span><br><span class="hljs-comment"># hidden layer</span><br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, L):<br>a[l] = sigmoid(a[l-<span class="hljs-number">1</span>] @ Theta[l-<span class="hljs-number">1</span>].T)<span class="hljs-comment"># (5000, 25)</span><br>a[l] = np.c_[np.ones(m), a[l]]<span class="hljs-comment"># (5000, 26)</span><br><span class="hljs-comment"># output layer</span><br>a[L] = sigmoid(a[L-<span class="hljs-number">1</span>] @ Theta[L-<span class="hljs-number">1</span>].T)<span class="hljs-comment"># (5000, 10)</span><br><span class="hljs-keyword">return</span> a<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">J</span>(<span class="hljs-params">a_L</span>):</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">a_L : output layer animation, (m, s[L])</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>res = - (<span class="hljs-number">1</span> / m) * np.<span class="hljs-built_in">sum</span>(Y * np.log(a_L) + (<span class="hljs-number">1</span>-Y) * np.log(<span class="hljs-number">1</span>-a_L))<br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, L):<br>res += lmd / (<span class="hljs-number">2</span> * m) * np.<span class="hljs-built_in">sum</span>(np.power(Theta[l][:, <span class="hljs-number">1</span>:], <span class="hljs-number">2</span>))<br><span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>实现反向传播算法，注意这里<strong>偏置单元</strong>的 $\text{delta}$ 误差没有意义，算出的值要忽略：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backProp</span>():</span><br><span class="hljs-comment"># init Delta -&gt; 0, should be (s_&#123;l+1&#125;, s_l + 1)</span><br>Delta = [<span class="hljs-literal">None</span>] * L<br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, L):<br>Delta[l] = np.zeros((s[l+<span class="hljs-number">1</span>], s[l]+<span class="hljs-number">1</span>))<br><span class="hljs-comment"># init delta, should be (s_l, )</span><br>delta = [<span class="hljs-literal">None</span>] * (L+<span class="hljs-number">1</span>)<br><span class="hljs-comment"># step 1</span><br>a = forwardProp()<br><span class="hljs-comment">#J_history.append(J(a[L]))</span><br><span class="hljs-comment"># step 2</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>delta[L] = a[L][i, :] - Y[i, :]  <span class="hljs-comment"># 降维成 (s_L, )</span><br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(L-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>delta[l] = ((Theta[l].T @ delta[l+<span class="hljs-number">1</span>]) * (a[l][i, :] * (<span class="hljs-number">1</span> - a[l][i, :])))[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, L):<br>Delta[l] += delta[l+<span class="hljs-number">1</span>][:,np.newaxis] @ a[l][i:i+<span class="hljs-number">1</span>, :]  <span class="hljs-comment"># 升维成 (s_l, 1)</span><br><span class="hljs-comment"># step 3</span><br>D = [<span class="hljs-literal">None</span>] * L  <span class="hljs-comment"># init D, same as Delta</span><br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, L):<br>D[l] = (<span class="hljs-number">1</span> / m) * (Delta[l] + lmd * np.c_[np.zeros(s[l+<span class="hljs-number">1</span>]), Theta[l][:, <span class="hljs-number">1</span>:]])<br><span class="hljs-keyword">return</span> D<br></code></pre></td></tr></table></figure><p>实现梯度下降算法并检验结果，大约耗时 20 分钟：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Gradient Descent</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, num_iters):<br><span class="hljs-built_in">print</span>(i)<br>D = backProp()<br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, L):<br>Theta[l] -= alpha * D[l]<br><br><span class="hljs-comment"># Prediction，调库生成混淆矩阵</span><br>y_pred = np.argmax(forwardProp()[L], axis=<span class="hljs-number">1</span>)<span class="hljs-comment"># (5000, )</span><br><span class="hljs-built_in">print</span>(classification_report(y, y_pred, digits=<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><p>如果要进行梯度检验，只需要将下述函数插入到 <code>D = backProp()</code> 后即可，正式训练时删去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Gradient Check</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gradCheck</span>():</span><br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, L):<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s[l+<span class="hljs-number">1</span>]):<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s[l]+<span class="hljs-number">1</span>):<br>Theta[l][i, j] -= <span class="hljs-number">0.0001</span><br>J1 = J(forwardProp()[L])<br>Theta[l][i, j] += <span class="hljs-number">0.0002</span><br>J2 = J(forwardProp()[L])<br>Theta[l][i, j] -= <span class="hljs-number">0.0001</span><br><span class="hljs-built_in">print</span>(D[l][i, j], (J2 - J1) / <span class="hljs-number">0.0002</span>)<br></code></pre></td></tr></table></figure><p>5000 轮次后，最终的预测结果如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache">              <span class="hljs-attribute">precision</span>    recall  f<span class="hljs-number">1</span>-score   support<br><br>           <span class="hljs-attribute">0</span>      <span class="hljs-number">0</span>.<span class="hljs-number">950</span>     <span class="hljs-number">0</span>.<span class="hljs-number">984</span>     <span class="hljs-number">0</span>.<span class="hljs-number">967</span>       <span class="hljs-number">500</span><br>           <span class="hljs-attribute">1</span>      <span class="hljs-number">0</span>.<span class="hljs-number">946</span>     <span class="hljs-number">0</span>.<span class="hljs-number">978</span>     <span class="hljs-number">0</span>.<span class="hljs-number">962</span>       <span class="hljs-number">500</span><br>           <span class="hljs-attribute">2</span>      <span class="hljs-number">0</span>.<span class="hljs-number">944</span>     <span class="hljs-number">0</span>.<span class="hljs-number">914</span>     <span class="hljs-number">0</span>.<span class="hljs-number">929</span>       <span class="hljs-number">500</span><br>           <span class="hljs-attribute">3</span>      <span class="hljs-number">0</span>.<span class="hljs-number">921</span>     <span class="hljs-number">0</span>.<span class="hljs-number">914</span>     <span class="hljs-number">0</span>.<span class="hljs-number">918</span>       <span class="hljs-number">500</span><br>           <span class="hljs-attribute">4</span>      <span class="hljs-number">0</span>.<span class="hljs-number">948</span>     <span class="hljs-number">0</span>.<span class="hljs-number">940</span>     <span class="hljs-number">0</span>.<span class="hljs-number">944</span>       <span class="hljs-number">500</span><br>           <span class="hljs-attribute">5</span>      <span class="hljs-number">0</span>.<span class="hljs-number">919</span>     <span class="hljs-number">0</span>.<span class="hljs-number">904</span>     <span class="hljs-number">0</span>.<span class="hljs-number">911</span>       <span class="hljs-number">500</span><br>           <span class="hljs-attribute">6</span>      <span class="hljs-number">0</span>.<span class="hljs-number">949</span>     <span class="hljs-number">0</span>.<span class="hljs-number">964</span>     <span class="hljs-number">0</span>.<span class="hljs-number">956</span>       <span class="hljs-number">500</span><br>           <span class="hljs-attribute">7</span>      <span class="hljs-number">0</span>.<span class="hljs-number">950</span>     <span class="hljs-number">0</span>.<span class="hljs-number">942</span>     <span class="hljs-number">0</span>.<span class="hljs-number">946</span>       <span class="hljs-number">500</span><br>           <span class="hljs-attribute">8</span>      <span class="hljs-number">0</span>.<span class="hljs-number">935</span>     <span class="hljs-number">0</span>.<span class="hljs-number">924</span>     <span class="hljs-number">0</span>.<span class="hljs-number">930</span>       <span class="hljs-number">500</span><br>           <span class="hljs-attribute">9</span>      <span class="hljs-number">0</span>.<span class="hljs-number">926</span>     <span class="hljs-number">0</span>.<span class="hljs-number">924</span>     <span class="hljs-number">0</span>.<span class="hljs-number">925</span>       <span class="hljs-number">500</span><br><br>    <span class="hljs-attribute">accuracy</span>                          <span class="hljs-number">0</span>.<span class="hljs-number">939</span>      <span class="hljs-number">5000</span><br>   <span class="hljs-attribute">macro</span> avg      <span class="hljs-number">0</span>.<span class="hljs-number">939</span>     <span class="hljs-number">0</span>.<span class="hljs-number">939</span>     <span class="hljs-number">0</span>.<span class="hljs-number">939</span>      <span class="hljs-number">5000</span><br><span class="hljs-attribute">weighted</span> avg      <span class="hljs-number">0</span>.<span class="hljs-number">939</span>     <span class="hljs-number">0</span>.<span class="hljs-number">939</span>     <span class="hljs-number">0</span>.<span class="hljs-number">939</span>      <span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ML学习笔记 #6 神经网络基础</title>
    <link href="/ML-Note-6.html"/>
    <url>/ML-Note-6.html</url>
    
    <content type="html"><![CDATA[<p>回顾之前学的模型，无论是线性回归还是逻辑回归都有一个缺点，即：当<strong>特征太多</strong>时，计算的负荷会非常大。而有时候，我们又希望用高次多项式来拟合更复杂的情形，此时特征数更是成倍增长。</p><p>在计算机视觉（Computer Vision）领域，数据的输入往往是一张张由像素（pixel）构成的图片。一张 $50\times50$ 的图片中包含 $2500$ 个像素点，如果算上 RGB 色值则有 $7500$ 个特征，更别提包含平方、立方项特征的<strong>非线性假设</strong>了。而神经网络则是适合学习复杂的非线性假设的一类算法。</p><h2 id="神经网络-Neural-Network"><a href="#神经网络-Neural-Network" class="headerlink" title="神经网络 | Neural Network"></a>神经网络 | Neural Network</h2><p>神经网络起源于科学家对人脑神经元的模拟，早期应用十分广泛，后来由于计算量过大而逐渐没落，直到近些年硬件的增强，大规模的神经网络才得以训练和应用。</p><h3 id="神经元模型-Neuron-Model"><a href="#神经元模型-Neuron-Model" class="headerlink" title="神经元模型 | Neuron Model"></a>神经元模型 | Neuron Model</h3><p>神经网络模型建立在许多神经元之上，每个神经元也被称为<strong>激活单元</strong>（Activation unit），它采纳一些特征作为<strong>输入</strong>（input），并且根据本身的模型提供一个<strong>输出</strong>（output）。神经网络就是大量神经元相互连接形成的一个网络。</p><p><img src="/img/blog/ML-Note-6-images/Neuron-Model.png" alt="单个神经元模型" width=40% /></p><p>激活单元（图中黄色结点）就是一个<strong>函数</strong>，根据若干输入信息 $x=(x_0,x_1,\cdots,x_n)^T$ 以及其权重 $\theta=(\theta_0,\theta_1,\cdots,\theta_n)^T$，得到一个输出信息 $h_\theta(x)$，即：</p><script type="math/tex; mode=display">h_\theta(x)=f(\theta, x)</script><p>$h_\theta(x)$ 也称作<strong>激活函数</strong>（Activation Function），一般可以采取 $\text{sigmoid}$ 函数 $h_\theta(x)=g(\theta^Tx)=\frac{1}{1+e^{-\theta^Tx}}$.</p><blockquote><p> 注：上图省略了 $x_0\equiv 1$ 这一<strong>偏置项</strong>（Bias unit），偏置项不仅可以是<strong>输入层</strong>的人为特征，也可以是<strong>隐藏层</strong>的一个常量单元 $a_0 \equiv 1$。</p><p>为什么 $\text{sigmoid}$ 函数可以作为激活函数？事实上激活函数有很多种，他们的共同特点都是引入了<strong>非线性假设</strong>。早期的神经网络使用 $\text{sigmoid}$ 的原因还有：输出可映射到 Bernoulli 分布，可以作为概率解决分类问题；求导计算方便。</p></blockquote><h3 id="网络的表示-Presentation"><a href="#网络的表示-Presentation" class="headerlink" title="网络的表示 | Presentation"></a>网络的表示 | Presentation</h3><p>神经网络是许多神经元按照不同层级组织起来的网络。第一层被称作<strong>输入层</strong>（Input Layer），最后一层被称作<strong>输出层</strong>（Output Layer），中间其他层被称作<strong>隐藏层</strong>（Hidden Layer），意味着「不可见」。隐藏层和输出层具备激活函数功能，而输入层仅仅是特征的拷贝。</p><p><img src="/img/blog/ML-Note-6-images/Neural-Network.png" alt="多层神经元组成的神经网络" width=50% /></p><ul><li>$x_i$ 表示输入层的第 $i$ 个输入特征，其中 $x_0$ 偏置项省略；</li><li>$a^{(j)}_i$ 表示第 $j$ 层的第 $i$ 个激活单元，其中 $a_0^{(j)}$ 偏置单元省略；</li><li>$s_j$ 表示第 $j$ 层的神经元数量（<strong>不包含偏置项</strong>），$\hat a^{(j)}\in\mathbb R^{s_j+1}$ 表示<strong>加上偏置项</strong>后的 $a^{(j)}$；</li><li>$\Theta^{(j)}\in\mathbb R^{s_{j+1}\times(s_j+1)}$ 表示第 $j$ 层到第 $j+1$ 层的<strong>权重矩阵</strong>，$\Theta$ 表示所有权重矩阵的<strong>集合</strong>。</li></ul><p>所以，由上图我们可以列出：</p><script type="math/tex; mode=display">\begin{aligned}a_{0}^{(2)}&\equiv 1\\a_{1}^{(2)}&=g\left(\Theta _{10}^{(1)}+\Theta _{11}^{(1)}x_1+\Theta _{12}^{(1)}x_2+\Theta _{13}^{(1)}x_3\right)\\a_{2}^{(2)}&=g\left(\Theta _{20}^{(1)}+\Theta _{21}^{(1)}x_1+\Theta _{22}^{(1)}x_2+\Theta _{23}^{(1)}x_3\right)\\a_{3}^{(2)}&=g\left(\Theta _{30}^{(1)}+\Theta _{31}^{(1)}x_1+\Theta _{32}^{(1)}x_2+\Theta _{33}^{(1)}x_3\right)\\h_{\Theta}(x)=a_{1}^{(3)}&=g\left(\Theta _{10}^{(2)}+\Theta _{11}^{(2)}a_{1}^{(2)}+\Theta _{12}^{(2)}a_{2}^{(2)}+\Theta _{13}^{(2)}a_{3}^{(2)}\right)\end{aligned}</script><p>简写作矩阵形式，可得到<strong>前向传播</strong>（Forward Propagation）公式：</p><script type="math/tex; mode=display">a^{(j+1)}=g\left(\Theta^{(j)}\hat a^{(j)}\right)</script><p>是不是像极了逻辑回归 $h_\theta(x)=g\left(\theta^Tx\right)$，只不过特征 $x$ 换成了上一层 $\hat a^{(j)}$，假说 $h_\theta(x)$ 变成了当前层 $a^{(j+1)}$。当然，由于每一层的关联性，最终的假说 $h_{\Theta}(x)$ 依旧是特征 $x$ 的<strong>非线性组合</strong>。</p><p>而随着每一层的深入，特征会变得越来越「<strong>抽象</strong>」，这些新特征远比单纯 $x$ 的多项式来得强大，也能更好的预测数据。这就是神经网络相比于逻辑回归和线性回归的优势。</p><blockquote><p>有的地方会把偏置项对应的<strong>偏置向量</strong> $b^{(j)}=\Theta_{i0}^{(j)}\in\mathbb R^{s_{j+1}}$ 单独拿出来，使得 $\Theta^{(j)}\in\mathbb R^{s_{j+1}\times s_j}$，以求形式的统一：</p><script type="math/tex; mode=display">a^{(j+1)}=g\left(\Theta^{(j)}a^{(j)}+b^{(j)}\right)</script></blockquote><h3 id="实现逻辑门"><a href="#实现逻辑门" class="headerlink" title="实现逻辑门"></a>实现逻辑门</h3><p>神经网络与逻辑门有何种联系？我们知道 $\text{sigmoid}$ 函数具有将数值映射到 $0$ 和 $1$ 的能力，而逻辑门也是类似。那么就可以把逻辑门看作一个简化的<strong>二分类</strong>问题，用神经网络对其训练。通过这个例子能够直观地理解神经网络中参数的作用，首先来看最简单的<strong>与门</strong> $\text{AND}$：</p><p><img src="/img/blog/ML-Note-6-images/AND.png" alt="与门的实现" width=40% /></p><p>考虑一个输入层有 $2$ 个特征且取值 $x_1,x_2\in\{0,1\}$、输出层有 $1$ 个神经元且取值 $h_\theta(x)\in\{0,1\}$ 的神经网络。如果我们将权重参数设置为：$\Theta ^{(1)}=\left( -30,20,20 \right) $，那么我们有：</p><div class="table-container"><table><thead><tr><th style="text-align:center">输入 1</th><th style="text-align:center">输入 2</th><th style="text-align:center">输出</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">$g(-30)\approx 0$</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">$g(-10)\approx 0$</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">$g(-10)\approx 0$</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">$g(10)\approx 1$</td></tr></tbody></table></div><p>这样实现了一个与门的功能，同理，或门 $\text{OR}$、非门 $\text{NOT}$ 也可以用两层网络（<strong>一个激活单元</strong>）实现。但是<strong>异或门</strong> $\text{XOR}$ 和<strong>同或门</strong> $\text{XNOR}$ 则需要三层网络——由数理逻辑知，$\text{XOR}$ 可以表示成前三者的组合 $\left( \lnot x_1 \land x_2 \right) \lor \left(x_1\land \lnot x_2 \right) $，那么就可以用<strong>三个激活单元</strong>实现异或。</p><p>同时，我们也可以发现，与前三种逻辑门不同，仅用一条直线是无法画出 $\text{XOR}$ 决策边界的：</p><p><img src="/img/blog/ML-Note-6-images/boundary.png" alt="逻辑门的决策边界" width=60% /></p><p>这也意味着：需要更复杂的特征（更深层的网络）来表达更高级的模型。</p><h3 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h3><p>在介绍 <a href="https://hwcoder.top/ML-Note-4">逻辑回归</a> 时，我们曾说对于多分类问题，可以实现多个标准的逻辑回归分类器，每个分类器的输出作为「<strong>属于某类</strong>」的概率，取其最大值作为预测结果即可。</p><p>在神经网络中，输出层的<strong>每一个神经元</strong>也可以视为<strong>一个逻辑回归分类器</strong>，对于 $K\geqslant 3$ 个类的问题（$K=2$ 时用一个神经元即可），最终可以得到 $h_{\Theta}(x)\in\mathbb R^{K}$ 的<strong>预测向量</strong>，取其最大值作为预测结果即可。</p><p><img src="/img/blog/ML-Note-6-images/multiclass.png" alt="K=4的多分类问题" width=60% /></p><p>同理，在训练时也需要把标签 $y^{\left( i \right)}$ 用<strong>独热</strong>（One-Hot）编码为向量 $y^{\left( i \right)}=\left( 0,0,1,0 \right) ^T$ 的形式，仅有对应类的预测值为 $1$，再通过反向传播从输出层开始计算。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面以 <a href="https://www.coursera.org/">Coursera</a> 上的多分类数据集 <code>ex3data1.mat</code> 为例，这是一个手写数字的数据集。本节中忽略训练过程，使用题目提供的权重参数 <code>ex3weight.mat</code> 作预测。</p><p>给定的数据为 <code>.mat</code> 格式，是 Matlab 数据<strong>二进制存储</strong>的标准格式，在 Matlab 交互窗中输入 <code>save xxx</code> 即可保存所有变量到 <code>xxx.mat</code> 文件中。Python 中使用 <strong>SciPy</strong> 的 <code>loadmat</code> 方法可以读入数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> scipy.io <span class="hljs-keyword">as</span> scio<br><span class="hljs-comment"># 导入 .mat 文件需要用到 scipy.io 模块，专门用于和 Matlab 交互</span><br>data = scio.loadmat(<span class="hljs-string">&#x27;ex3data1.mat&#x27;</span>)<br><span class="hljs-built_in">print</span>(data)<br><span class="hljs-built_in">print</span>(data[<span class="hljs-string">&#x27;X&#x27;</span>].shape)<br><span class="hljs-built_in">print</span>(data[<span class="hljs-string">&#x27;y&#x27;</span>].shape)<br></code></pre></td></tr></table></figure><p>读取的文件在 Python 中以<strong>字典</strong>存储，将其打印出来为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">&#x27;__header__&#x27;</span>: <span class="hljs-string">b&#x27;MATLAB 5.0 MAT-file, Platform: GLNXA64, Created on: Sun Oct 16 13:09:09 2011&#x27;</span>,<br> <span class="hljs-string">&#x27;__version__&#x27;</span>: <span class="hljs-string">&#x27;1.0&#x27;</span>,<br> <span class="hljs-string">&#x27;__globals__&#x27;</span>: [],<br> <span class="hljs-string">&#x27;X&#x27;</span>: array([[<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, ..., <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],<br>        [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, ..., <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],<br>        [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, ..., <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],<br>        ...,<br>        [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, ..., <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],<br>        [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, ..., <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],<br>        [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, ..., <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>]]),<br> <span class="hljs-string">&#x27;y&#x27;</span>: array([[<span class="hljs-number">10</span>],<br>        [<span class="hljs-number">10</span>],<br>        [<span class="hljs-number">10</span>],<br>        ...,<br>        [ <span class="hljs-number">9</span>],<br>        [ <span class="hljs-number">9</span>],<br>        [ <span class="hljs-number">9</span>]], dtype=uint8)&#125;<br>(<span class="hljs-number">5000</span>, <span class="hljs-number">400</span>)<br>(<span class="hljs-number">5000</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>文件中一共有 $5000$ 个样本，每个样本的输入是一个长为 $400$ 的向量，由 $20\times 20$ 的<strong>灰度矩阵</strong>压缩而来；输出是一个数字，表示样本图像代表的数字。</p><blockquote><p>注意：为了更好地兼容 Octave/Matlab 索引（其中没有零索引），数字 $0$ 被标记为了 $10$，使用时可以把 $10$ 换回成 $0$，但题目给的 <code>ex3weight.mat</code> 没有考虑转换；另外，数据是按列压缩的，还原回 $20\times20$ 的矩阵后其实转置了一下，这里提前转置回去方便后续编码，但题目给的 <code>ex3weight.mat</code> 也没有考虑。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">data = scio.loadmat(<span class="hljs-string">&#x27;ex3data1.mat&#x27;</span>)<br><span class="hljs-comment"># 获取字典键 &#x27;X&#x27;，对每行的 20x20 矩阵先转置处理，再恢复成向量</span><br>X = data[<span class="hljs-string">&#x27;X&#x27;</span>]<br>X = np.transpose(X.reshape((<span class="hljs-number">5000</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>)), [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]).reshape(<span class="hljs-number">5000</span>, <span class="hljs-number">400</span>)<br><span class="hljs-comment"># 获取字典键 &#x27;y&#x27;，展开成一维，将标签 ‘10’ 转换为 ‘0’</span><br>y = data[<span class="hljs-string">&#x27;y&#x27;</span>].flatten()<br>y[y==<span class="hljs-number">10</span>] = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>现在我们随机挑选 $100$ 个图像显示出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_100_image</span>(<span class="hljs-params">X</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot; sample 100 image and show them</span><br><span class="hljs-string">    X : (5000, 400)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    sample_idx = np.random.choice(np.arange(X.shape[<span class="hljs-number">0</span>]), <span class="hljs-number">100</span>)<br>    sample_images = X[sample_idx, :]  <span class="hljs-comment"># 100x400</span><br><br>    fig, ax_array = plt.subplots(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, sharey=<span class="hljs-literal">True</span>, sharex=<span class="hljs-literal">True</span>, figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>))<br><br>    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>            ax_array[r, c].matshow(sample_images[<span class="hljs-number">10</span> * r + c].reshape((<span class="hljs-number">20</span>, <span class="hljs-number">20</span>)),<br>                                   cmap=matplotlib.cm.binary)<br>            plt.xticks(np.array([]))<br>            plt.yticks(np.array([]))<br><br>plot_100_image(X)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/img/blog/ML-Note-6-images/100.png" alt="随机挑选100张图像" width=40% /></p><p>下面搭建神经网络，利用已知的 $\Theta$ 实现前向传播预测：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> scipy.io <span class="hljs-keyword">as</span> scio<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> classification_report<br><br><span class="hljs-comment"># load data</span><br>data = scio.loadmat(<span class="hljs-string">&#x27;ex3data1.mat&#x27;</span>)<br>X = data[<span class="hljs-string">&#x27;X&#x27;</span>] <span class="hljs-comment"># (5000, 400)</span><br>y = data[<span class="hljs-string">&#x27;y&#x27;</span>].flatten()<span class="hljs-comment"># (5000, )</span><br>(m, n) = (<span class="hljs-number">5000</span>, <span class="hljs-number">401</span>)<br><br><span class="hljs-comment"># load weight</span><br>weight = scio.loadmat(<span class="hljs-string">&#x27;ex3weights.mat&#x27;</span>)<br>Theta1 = weight[<span class="hljs-string">&#x27;Theta1&#x27;</span>] <span class="hljs-comment"># (25, 401)</span><br>Theta2 = weight[<span class="hljs-string">&#x27;Theta2&#x27;</span>] <span class="hljs-comment"># (10, 26)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sigmoid</span>(<span class="hljs-params">z</span>):</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + np.exp(-z))<br><br><span class="hljs-comment"># Feed Forward Prediction</span><br>a1 = np.c_[np.ones(m), X].T  <span class="hljs-comment"># (401, 5000)</span><br>a2 = sigmoid(Theta1 @ a1) <span class="hljs-comment"># (25, 5000)</span><br>a2 = np.r_[np.ones((<span class="hljs-number">1</span>, m)), a2]<span class="hljs-comment"># (26, 5000)</span><br>a3 = sigmoid(Theta2 @ a2)<span class="hljs-comment"># (10, 5000)</span><br><br>y_pred = np.argmax(a3, axis=<span class="hljs-number">0</span>) + <span class="hljs-number">1</span><span class="hljs-comment"># (5000, )</span><br><br><span class="hljs-comment"># evaluation, 调库生成混淆矩阵</span><br><span class="hljs-built_in">print</span>(classification_report(y, y_pred, digits=<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><p>调用 SciKit-Learn 库中的 <code>metrics</code>，生成 <a href="https://hwcoder.top/IR-Note-5">精度和召回率</a>，预测结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">              precision    recall  f1-score   support<br><br>           1      0.968     0.982     0.975       500<br>           2      0.982     0.970     0.976       500<br>           3      0.978     0.960     0.969       500<br>           4      0.970     0.968     0.969       500<br>           5      0.972     0.984     0.978       500<br>           6      0.978     0.986     0.982       500<br>           7      0.978     0.970     0.974       500<br>           8      0.978     0.982     0.980       500<br>           9      0.966     0.958     0.962       500<br>          10      0.982     0.992     0.987       500<br><br>    accuracy                          0.975      5000<br>   macro avg      0.975     0.975     0.975      5000<br>weighted avg      0.975     0.975     0.975      5000<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ML学习笔记 #5 过拟合与正则化</title>
    <link href="/ML-Note-5.html"/>
    <url>/ML-Note-5.html</url>
    
    <content type="html"><![CDATA[<p>在介绍多元线性回归时，我们知道线性回归并不适用于所有情形，因此可以人为构造<strong>高阶项</strong>并将其当作一个新的特征来使用，从而达到拟合非线性数据的目的，即<strong>多项式回归</strong>（Polynomial Regression）。</p><p>与此同时，由<strong>多项式插值</strong>的原理可知，我们可以构造一个唯一的 $m-1$ 次多项式，使其完美地经过 $m$ 个样本点：</p><script type="math/tex; mode=display">L_{n}(x)=\sum_{i=0}^{n} f\left(x_{i}\right) l_{i}(x)=\sum_{i=0}^{n} f\left(x_{i}\right) \prod_{j=0 \atop j \neq i}^{n} \frac{x-x_{j}}{x_{i}-x_{j}}</script><p>上式即为 Lagrange 插值公式，$f(x_i)$ 是每个样本的函数值。但这样得到的结果会是好的拟合吗？</p><h2 id="过拟合-Over-Fitting"><a href="#过拟合-Over-Fitting" class="headerlink" title="过拟合 | Over-Fitting"></a>过拟合 | Over-Fitting</h2><p>所谓过拟合，一般是指过度在训练集上进行优化，进而损害了测试集上的<strong>泛化能力</strong>（generalize）的现象，具有<strong>高方差</strong>（high variance），对输入的变化更敏感。与之对应的概念是<strong>欠拟合</strong>（Under-Fitting），不能很好地适应训练集，使得算法具有<strong>高偏差</strong>（high bias）。</p><p>下图就是一个典型的回归案例：</p><p><img src="/img/blog/ML-Note-5-images/polynomial-case.png" alt="多项式回归" width=70% /></p><p>分类案例中也存在这样的问题：</p><p><img src="/img/blog/ML-Note-5-images/classification-case.png" alt="逻辑回归" width=70% /></p><p>解决过拟合的方法有很多，我将其分为三个层面：</p><ul><li>从模型层面，可以通过 Early Stop、L1/L2 Regularization、Batchnorm、Dropout 等方法；</li><li>从特征层面，可以丢弃一些不能帮助我们正确预测的特征，通过手工筛选或 PCA 等降维方法；</li><li>从数据层面，可以获取更大的数据集，也可以进行数据增强（Data Augmentation），通过一定规则来扩充数据。</li></ul><h2 id="正则化-Regularization"><a href="#正则化-Regularization" class="headerlink" title="正则化 | Regularization"></a>正则化 | Regularization</h2><p>正则化是一种能够<strong>保留所有特征</strong>（不必降维而丢失信息）的有效解决过拟合的方法。其思想是在损失函数上加上某些规则（限制），限制参数的解空间，从而减少求出过拟合参数的可能性。</p><p>仍然以多项式回归为例，如果我们的假设函数为：$h_\theta(x)=\theta_0+\theta_1x+\theta_2x^2+\theta_3x^3+\theta_4x^4$，其中的高阶项 $\theta_3,\theta_4$ 导致了过拟合问题，那么我们自然希望 $\theta_3$ 和 $\theta_4$ 越小越好。此时，我们只需要对代价函数做出一点修改：</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}\left[\sum\limits_{i=1}^m\left(h_\theta(x^{(i)})-y^{(i)}\right)^2+1000\theta_3^2+10000\theta_4^2\right]</script><p>这样当 $J(\theta)$ 取得极值时，$\theta_3$ 和 $\theta_4$ 都接近于 $0$，我们也就达到了目的。一般地，我们并不知道究竟应该对哪些参数做出「<strong>惩罚</strong>」，所以我们设代价函数为：</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{m}\sum_{i=1}^m\text{Cost}\left(h_\theta(x^{(i)})-y^{(i)}\right)+\frac{\lambda}{2m}\sum_{j=1}^n\theta_j^2</script><p>其中，$\lambda$ 是<strong>正则化参数</strong>，$\lambda\sum\limits_{j=1}^n\theta_j^2$ 是<strong>正则化项</strong>。即我们对<strong>除了 $\theta_0$ 以外</strong>的参数都做「惩罚」，使得曲线更加光滑。如果 $\lambda$ 很大，意味着正则化项占主要地位，有可能导致所有的 $\theta_j$ 都太小了而欠拟合；如果 $\lambda$ 很小，意味着损失函数占主要地位，就有可能过拟合。因此选取合适的正则化参数 $\lambda$ 是非常重要的，通常要建立<strong>验证集</strong>进行网格搜索。</p><blockquote><p>为什么不对 $\theta_0$ 正则化？因为 $\theta_0$ 是人为设置的偏置项，对于<strong>输入的变化</strong>（训练集 or 测试集）是不敏感的，不对模型的<strong>方差</strong>产生贡献，即使发生了过拟合，那也与 $\theta_0$ 无关。</p><p>此外，根据正则项的形式，又可分为：二次正则项、一般正则项。<strong>二次正则项</strong>即为前文提到的形式，更一般的形式为 $\lambda \sum_{j=1}^n{\left| \theta _j \right|^q}$，当 $q$ 取不同值<strong>等高线图</strong>的形状为：</p><p><img src="/img/blog/ML-Note-5-images/Dq.png" alt="正则项的边缘直观表示" width=70% /></p><p>从几何空间上来看，损失函数的碗状曲面和正则化项的曲面叠加之后，就是我们要求极值的曲面。特别地，当 $q=1$ 时，称其为 <strong>L1</strong> 正则化，也叫 <strong>Lasso 回归</strong>；当 $q=2$ 时，称其为 <strong>L2</strong> 正则化，也叫<strong>岭回归</strong>。L2 由于其处处可微的特性，在实际中更常用。</p></blockquote><h3 id="线性回归的正则化"><a href="#线性回归的正则化" class="headerlink" title="线性回归的正则化"></a>线性回归的正则化</h3><p>线性回归的含有正则化项的代价函数为：</p><script type="math/tex; mode=display">\begin{aligned}    J(\theta )&=\frac{1}{2m}\left[ \sum_{i=1}^m{\left( h_{\theta}(x^{(i)})-y^{(i)} \right) ^2}+\lambda \sum_{j=1}^n{\theta _{j}^{2}} \right]\\    &=\frac{1}{2m}\left[ \sum_{i=1}^m{\left( \theta ^Tx^{(i)}-y^{(i)} \right) ^2}+\lambda \sum_{j=1}^n{\theta _{j}^{2}} \right]\\\end{aligned}</script><p>对其求导：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial \theta_j}=\frac{1}{m}\sum_{i=1}^m\left(\theta^Tx^{(i)}-y^{(i)}\right)x^{(i)}_j+[j\neq 0]\frac{\lambda}{m}\theta_j,\quad j=0,1,\cdots,n</script><p>所以梯度下降时，整个迭代更新过程为：</p><script type="math/tex; mode=display">\begin{aligned}    \theta _0:&=\theta _0-\alpha \frac{\partial J}{\partial \theta _j}\\    &=\theta _0-\alpha \frac{1}{m}\sum_{i=1}^m{\left( \theta ^Tx^{(i)}-y^{(i)} \right)}x_{0}^{(i)}\\    \theta _j:&=\theta _j-\alpha \frac{\partial J}{\partial \theta _j}\\    &=\theta _j-\alpha \left[ \frac{1}{m}\sum_{i=1}^m{\left( \theta ^Tx^{(i)}-y^{(i)} \right)}x_{j}^{(i)}+\frac{\lambda}{m}\theta _j \right]\\    &=\theta _j\left( 1-\alpha \frac{\lambda}{m} \right) -\alpha \frac{1}{m}\sum_{i=1}^m{\left( \theta ^Tx^{(i)}-y^{(i)} \right)}x_{j}^{(i)},\quad j=1,\cdots ,n\\\end{aligned}</script><p>相当于每次迭代先将参数 $\theta_j$ 缩小一点，再做原来的梯度下降。除了梯度下降，我们还可以直接用正规方程，即在数学上解它。为了记号的方便，我们先<strong>假定</strong>对 $\theta_0$ 也进行「惩罚」。首先将 $J(\theta)$ 写作<strong>矩阵形式</strong>：</p><script type="math/tex; mode=display">\begin{aligned}    J(\theta )&=\frac{1}{2m}\left[ \left( X\theta -y \right) ^T\left( X\theta -y \right) +\lambda \theta ^T\theta \right]\\    &=\frac{1}{2m}\left[ \theta ^TX^TX\theta -\theta ^TX^Ty-y^TX\theta +y^Ty+\lambda \theta ^T\theta \right]\end{aligned}</script><p>再用 <a href="https://hwcoder.top/ML-Note-3">矩阵的求导法则</a>，然后令</p><script type="math/tex; mode=display">\frac{\partial J}{\partial \theta}=\frac{1}{m}\left[X^TX\theta-X^Ty+\lambda\theta\right]=0</script><p>则：</p><script type="math/tex; mode=display">(X^TX+\lambda)\theta=X^Ty</script><p>解得：</p><script type="math/tex; mode=display">\theta=(X^TX+\lambda)^{-1}X^Ty</script><p>现在把 $j=0$ 的特殊情况考虑进去，那么最后的结果就是：</p><script type="math/tex; mode=display">\theta =\left( X^TX+\lambda \left[ \begin{matrix}    0        &        &        &        \\    &        1        &        &        \\    &        &        \ddots    &        \\    &        &        &        1        \\\end{matrix} \right] _{n+1} \right) ^{-1}X^Ty</script><p>之前我们曾讨论过 $X^TX$ 不可逆的情形，但在加入正则化项后，只要 $\lambda &gt;0$，就<strong>一定可逆</strong>。</p><h3 id="逻辑回归的正则化"><a href="#逻辑回归的正则化" class="headerlink" title="逻辑回归的正则化"></a>逻辑回归的正则化</h3><p>逻辑回归的含有正则化项的代价函数为：</p><script type="math/tex; mode=display">\begin{aligned}    J(\theta )&=-\frac{1}{m}\sum_{i=1}^m{\left[ y^{\left( i \right)}\ln \left( h_{\theta}\left( x^{\left( i \right)} \right) \right) +\left( 1-y^{\left( i \right)} \right) \ln \left( 1-h_{\theta}\left( x^{\left( i \right)} \right) \right) \right]}+\frac{\lambda}{2m}\sum_{j=1}^n{\theta _{j}^{2}}\\    &=\frac{1}{m}\sum_{i=1}^m{\left[ y^{(i)}\ln \left( 1+e^{-\theta ^Tx^{(i)}} \right) +\left( 1-y^{(i)} \right) \ln \left( 1+e^{\theta ^Tx^{(i)}} \right) \right]}+\frac{\lambda}{2m}\sum_{j=1}^n{\theta _{j}^{2}}\\\end{aligned}</script><p>同样地，对其求导：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial \theta_j}=\frac{1}{m}\sum_{i=1}^m\left(h_\theta(x^{(i)})-y^{(i)}\right)x^{(i)}_j+[j\neq 0]\frac{\lambda}{m}\theta_j,\quad j=0,1,\cdots,n</script><p>同样地，梯度下降时，整个迭代更新过程为：</p><script type="math/tex; mode=display">\begin{aligned}    \theta _0&:=\theta _0-\alpha \frac{1}{m}\sum_{i=1}^m{\left( h_{\theta}(x^{(i)})-y^{(i)} \right)}x_{0}^{(i)}\\    \theta _j&:=\theta _j\left( 1-\alpha \frac{\lambda}{m} \right) -\alpha \frac{1}{m}\sum_{i=1}^m{\left( h_{\theta}(x^{(i)})-y^{(i)} \right)}x_{j}^{(i)},\quad j=1,\cdots ,n\\\end{aligned}</script><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>实现线性回归的正规方程解法比较简洁，构造一个 $n+1$ 阶的类单位矩阵即可。但实现梯度下降解法则会遇到一个问题：$\theta_0$ 的更新与 $\theta_j$ 不同步，需要分开计算。</p><p>下面以 <a href="https://www.coursera.org/">Coursera</a> 上的二分类数据集 <code>ex2data2.txt</code> 为例，首先看一下数据的分布，代码同上一篇：</p><p><img src="/img/blog/ML-Note-5-images/preview_scatter.png" alt="数据分布散点图"></p><p>显然，需要引入<strong>多项式特征</strong>实现高次的<strong>曲线</strong>，这里将数据的两维都扩充为 $6$ 次，形成有 $28$ 维特征的数据，沿用上一篇的矩阵运算，实现逻辑回归如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># load data, data.shape = (118, 3)</span><br>data = np.loadtxt(<span class="hljs-string">&#x27;ex2data2.txt&#x27;</span>, delimiter=<span class="hljs-string">&#x27;,&#x27;</span>)<br>(m, n) = data.shape<br>x1 = data[:, <span class="hljs-number">0</span>].reshape((m, <span class="hljs-number">1</span>))<br>x2 = data[:, <span class="hljs-number">1</span>].reshape((m, <span class="hljs-number">1</span>))<br>y = data[:, -<span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># map polynomial feature, X.shape = (118, 28)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map_feature</span>(<span class="hljs-params">x1, x2</span>):</span><br>X = np.ones(x1.size)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span> + <span class="hljs-number">1</span>):<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, i + <span class="hljs-number">1</span>):<br>X = np.c_[X, np.power(x1, i - j) * np.power(x2, j)]<br><span class="hljs-keyword">return</span> X<br><br>X = map_feature(x1, x2)<br><br><span class="hljs-comment"># parameters</span><br>alpha = <span class="hljs-number">0.01</span><br>lmd = <span class="hljs-number">1</span><br>num_iters = <span class="hljs-number">100000</span><br>theta = np.zeros(X.shape[<span class="hljs-number">1</span>])<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sigmoid</span>(<span class="hljs-params">z</span>):</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + np.exp(-z))<br><br><span class="hljs-comment"># Gradient Descent</span><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, num_iters):<br>error = sigmoid(X @ theta) - y  <span class="hljs-comment"># error.shape = (118, )</span><br>theta[<span class="hljs-number">0</span>] -= (alpha / m) * (X[:,<span class="hljs-number">0</span>].T @ error)  <span class="hljs-comment"># X.T.shape = (28, 118)</span><br>theta[<span class="hljs-number">1</span>:] = (<span class="hljs-number">1</span> - alpha * lmd / m) * theta[<span class="hljs-number">1</span>:] - (alpha / m) * (X[:,<span class="hljs-number">1</span>:].T @ error)<br><br><span class="hljs-comment"># plot scatter</span><br>pos = np.where(y == <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br>neg = np.where(y == <span class="hljs-number">0</span>)[<span class="hljs-number">0</span>]<br>plt.scatter(X[pos, <span class="hljs-number">1</span>], X[pos, <span class="hljs-number">2</span>], marker=<span class="hljs-string">&quot;o&quot;</span>, c=<span class="hljs-string">&#x27;xkcd:sky blue&#x27;</span>)<br>plt.scatter(X[neg, <span class="hljs-number">1</span>], X[neg, <span class="hljs-number">2</span>], marker=<span class="hljs-string">&quot;x&quot;</span>, c=<span class="hljs-string">&#x27;xkcd:pink&#x27;</span>)<br><br><span class="hljs-comment"># plot decision boundary</span><br>u = np.linspace(-<span class="hljs-number">1</span>, <span class="hljs-number">1.25</span>, <span class="hljs-number">50</span>)<br>v = np.linspace(-<span class="hljs-number">1</span>, <span class="hljs-number">1.25</span>, <span class="hljs-number">50</span>)<br>U, V = np.meshgrid(u, v)  <span class="hljs-comment"># 生成 50x50 网格点矩阵</span><br>z = (map_feature(U.flatten(), V.flatten()) @ theta).reshape((<span class="hljs-number">50</span>, <span class="hljs-number">50</span>))  <span class="hljs-comment"># 计算等高线</span><br>plt.contour(u, v, z, [<span class="hljs-number">0</span>], colors=<span class="hljs-string">&#x27;r&#x27;</span>)  <span class="hljs-comment"># 绘制轮廓图，取高度为 0 的点</span><br><br>plt.title(<span class="hljs-string">f&quot;lambda = <span class="hljs-subst">&#123;lmd&#125;</span>&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;Microchip Test 1&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Microchip Test 2&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>分别绘制出 $\lambda=0,1,5$ 时的决策边界图如下：</p><p><img src="/img/blog/ML-Note-5-images/lambda0.png" alt="lambda=0的决策边界"></p><p><img src="/img/blog/ML-Note-5-images/lambda1.png" alt="lambda=1的决策边界"></p><p><img src="/img/blog/ML-Note-5-images/lambda5.png" alt="lambda=5的决策边界"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ML学习笔记 #4 逻辑回归：二分类到多分类</title>
    <link href="/ML-Note-4.html"/>
    <url>/ML-Note-4.html</url>
    
    <content type="html"><![CDATA[<p>前文介绍了基本的线性回归问题，尝试预测一系列<strong>连续值</strong>属性。现在我们将介绍的分类问题则关注<strong>离散值</strong>属性的预测。</p><p>在分类问题中，我们尝试预测的结果是否属于某一个类，最基础的就是<strong>二元</strong>的分类问题（例如预测垃圾邮件、恶性肿瘤），更为复杂的则是预测<strong>多元</strong>的分类问题。</p><h2 id="二分类问题"><a href="#二分类问题" class="headerlink" title="二分类问题"></a>二分类问题</h2><p>分类问题的样本与回归问题类似，由特征和目标构成，给定数据集：</p><script type="math/tex; mode=display">\left\{\left(x^{(i)},y^{(i)}\right),\;i=1,2,\cdots,m\right\}</script><ul><li>$x^{(i)}$ 代表第 $i$ 个观察实例的 $n+1$ 维<strong>特征向量</strong> $\left(x_0^{(i)},\cdots,x_n^{(i)}\right)^T$；</li><li>$y^{(i)}\in\{0,1\}$ 代表第 $i$ 个观察实例的<strong>目标变量</strong>，在这里有 $0$ 或 $1$ 两类结果。</li></ul><p>即对于输入的自变量 $x^{(i)}$，因变量 $y^{(i)}$ 可能为 $0$ 或 $1$。其中 $0$ 表示<strong>负向类</strong>（negative class），$1$ 表示<strong>正向类</strong>（positive class）。</p><blockquote><p>我们不对「正向」和「负向」加以特殊区分，但在实际应用中「正向」通常表示「具有我们要寻找的东西」，如垃圾邮件、恶性肿瘤等。</p></blockquote><h3 id="线性回归的不足"><a href="#线性回归的不足" class="headerlink" title="线性回归的不足"></a>线性回归的不足</h3><p>首先可能会自然而然地想到用之前的线性回归来解决——用一条直线拟合结果，当预测值大于 $0.5$ 时归为正向类，反之归为负向类。</p><p>这看似合理，然而，线性回归保留了 $y^{(i)}$ 太多的「<strong>信息量</strong>」。对于某些「<strong>反常样本</strong>」，我们可能预测出一个远大于 $1$ 或者远小于 $0$ 的结果，同理，这些「反常样本」用于拟合直线时也会对其造成一定偏移，以至于正常样本被归为错误类别。</p><p><img src="/img/blog/ML-Note-4-images/linear-regression.png" alt="反常样本使得蓝线偏移" width=67% /></p><h2 id="逻辑回归-Logistic-Regression"><a href="#逻辑回归-Logistic-Regression" class="headerlink" title="逻辑回归 | Logistic Regression"></a>逻辑回归 | Logistic Regression</h2><p>线性回归和逻辑回归都属于<strong>广义线性模型</strong>（Generalized Linear Model）的特殊形式，线性模型都可用于回归问题的求解。但由于<strong>逻辑函数</strong>（Losistic Function）将结果映射到 <strong>Bernoulli 分布</strong>，因此逻辑回归更常用于分类问题。</p><h3 id="假说表示-Hypothesis-Representation"><a href="#假说表示-Hypothesis-Representation" class="headerlink" title="假说表示 | Hypothesis Representation"></a>假说表示 | Hypothesis Representation</h3><p>回忆线性回归的假设函数：$h_\theta(x)=\theta^Tx$，我们在其外套上 $\text{sigmoid}$ 函数，构造逻辑回归的假设函数为：</p><script type="math/tex; mode=display">h_\theta(x)=g\left(\theta^Tx\right)=\frac{1}{1+e^{-\theta^T x}}</script><blockquote><p>所谓 $\text{sigmoid}$ 函数（也即前面提到的<strong>逻辑函数</strong>）：</p><script type="math/tex; mode=display">g(z)=\frac{1}{1+e^{-z}}</script><p><img src="/img/blog/ML-Note-4-images/sigmoid.png" alt="sigmoid函数" width=40% /></p><p>是一个介于 $(0,1)$ 之间的单增 $S$ 形函数，其导出需要用到 GLMs 和指数分布族（The Exponential Family）的知识。</p></blockquote><p>也就是说，对于一个参数为 $\theta$ 的逻辑回归模型，输入 $x$，得到 $h_\theta(x)=\frac{1}{1+e^{-\theta^Tx}}$ 的预测值。</p><p>我们可以把这个输出值视为 $x$ 这个样本对应的 $y$ 等于 $1$ 的<strong>概率</strong>（estimated probablity），即 $h_\theta \left( x \right)=P\left( y=1|x;\theta \right)$。针对分类情形，我们可以认为如果概率 $\geqslant 0.5$，则分类为 $1$，否则分类为 $0$。 </p><h3 id="决策边界-Decision-Boundary"><a href="#决策边界-Decision-Boundary" class="headerlink" title="决策边界 | Decision Boundary"></a>决策边界 | Decision Boundary</h3><p>又根据 $\text{sigmoid}$ 函数的性质:</p><script type="math/tex; mode=display">h_\theta(x)\geqslant 0.5\iff \theta^Tx\geqslant0</script><p>所以只要 $\theta^Tx\geqslant0$，就会分类为 $1$，否则分类为 $0$；于是乎，$\theta^Tx=0$ 解出的这条「<strong>线</strong>」（对于高维情形为<strong>超平面</strong>）被称作决策边界，它将整个空间划分成两块区域（region），各自属于一个分类。</p><p>下面看两个二维情形的例子：</p><p><img src="/img/blog/ML-Note-4-images/decision-boundary-1.png" alt="线性的决策边界" width=30%/></p><p>对于上述样本点的分布，用一条直线即可划分空间，对应的假设函数为 $h_\theta(x)=g\left(\theta_0+\theta_1 x_1+\theta_2 x_2\right)$。</p><p><img src="/img/blog/ML-Note-4-images/decision-boundary-2.png" alt="多项式的决策边界" width=30%/></p><p>而对于这种分布，我们必须选择二维曲线来划分空间，即使用<strong>多项式特征</strong>来确定曲线的参数，对应的假设函数为 $h_\theta(x)=g\left(\theta_0+\theta_1 x_1+\theta_2 x_2+\theta_3 x_3^2+\theta_4 x_4^2\right)$。当然，我们也可以用更复杂的多项式曲线来划分更复杂的分布。</p><h3 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h3><p>现在，我们的任务就是从训练集中拟合逻辑回归的参数 $\theta$。仍然采用代价函数的思想——找到使代价最小的参数即可。</p><p>广义上来讲，代价函数是这样的一个函数：</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{m}\sum_{i=1}^m\text{Cost}\left(h_\theta(x^{(i)}),y^{(i)}\right)</script><p>也就是说用每个数据的估计值 $h_\theta(x^{(i)})$ 和真实值 $y^{(i)}$ 计算一个代价 $\text{Cost}\left(h_\theta(x^{(i)}),y^{(i)}\right)$，比如线性回归中这个代价就是二者差值的平方。</p><p>理论上来说，我们也可以对逻辑回归模型沿用平方误差的定义，但当我们将 ${h_\theta}\left( x \right)=\frac{1}{1+{e^{-\theta^{T}x}}}$ 代入到这样的代价函数中时，我们得到的将是一个<strong>非凸函数</strong>（non-convex function）。这意味着空间中会有许多<strong>局部最小值</strong>，使得梯度下降法难以寻找到<strong>全局最小值</strong>。</p><p>因此我们重新定义逻辑回归的<strong>代价函数</strong>：</p><script type="math/tex; mode=display">\mathrm{Cost}\left( h_{\theta}(x),y \right) =\begin{cases}    -\ln \left( h_{\theta}\left( x \right) \right)&        y=1\\    -\ln \left( 1-h_{\theta}\left( x \right) \right)&        y=0\\\end{cases}</script><p>绘制出的曲线大致呈这样：</p><p><img src="/img/blog/ML-Note-4-images/cost.png" alt="代价函数"  width=50% /></p><p>观察曲线，发现当 $y=1$（样本的真实值为 $1$）时，预测值 $h_\theta(x)$ 越接近 $1$ 则代价越小，越接近 $0$ 则代价趋于无穷。譬如在肿瘤分类中，将实际为恶性的肿瘤以百分之百的概率预测为良性，带来的后果将不可估量。</p><p>与此同时，注意到代价函数也可以<strong>简写</strong>为：</p><script type="math/tex; mode=display">\mathrm{Cost}\left( h_{\theta}\left( x \right) ,y \right) =-\left[ y\ln \left( h_{\theta}\left( x \right) \right) +\left( 1-y \right) \ln \left( 1-h_{\theta}\left( x \right) \right) \right]</script><p>它还有另外一个名称——<strong>二元交叉熵代价函数</strong>（BCE, Binary Cross-Entropy），它又蕴含着怎样的原理呢？</p><h3 id="代价函数的数学推导"><a href="#代价函数的数学推导" class="headerlink" title="代价函数的数学推导"></a>代价函数的数学推导</h3><p>首先明确什么是一个<strong>好的代价函数</strong>——当参数 $\theta$ 使得 $J(\theta)$ 取<strong>极小值</strong>时，这个 $\theta$ 也能使模型拟合效果最好。这时我们回忆起 <a href="https://hwcoder.top/PR-Note-3">极大似然估计</a> 的思想：当参数 $\theta$ 使得 $L(\theta)$ 取<strong>极大值</strong>时，这个 $\theta$ 也能使得<strong>事件组</strong>最容易发生！</p><p>前文已经提到，我们用概率解释预测值 $h_\theta(x)=P(y=1)$，于是 $1-h_\theta(x)=P(y=0)$，故：</p><script type="math/tex; mode=display">P\left( y=k \right) =\left[ h_{\theta}\left( x \right) \right] ^k\left[ 1-h_{\theta}\left( x \right) \right] ^{1-k},\quad k\in \left\{ 0,1 \right\}</script><p>而对于数据集 $\left\{\left(x^{(i)},y^{(i)}\right),\;i=1,2,\cdots,m\right\}$ 下，将其视为已发生的一个<strong>事件组</strong>，则似然函数为：</p><script type="math/tex; mode=display">L\left( \theta \right) =\prod_{i=1}^m{P}\left( y=y^{(i)} \right) =\prod_{i=1}^m{\left[ h_{\theta}\left( x^{(i)} \right) \right] ^{y^{(i)}}}\left[ 1-h_{\theta}\left( x^{(i)} \right) \right] ^{1-y^{(i)}}</script><p>取对数得到：</p><script type="math/tex; mode=display">\ln L(\theta )=\sum_{i=1}^m{\left\{ y^{(i)}\ln \left[ h_{\theta}\left( x^{(i)} \right) \right] +\left( 1-y^{(i)} \right) \ln \left[ 1-h_{\theta}\left( x^{(i)} \right) \right] \right\}}</script><p>注意到，极大似然法的目标是找到 $L(\theta)$ 或 $\ln L(\theta)$ 的极大值，而逻辑回归的目标是找到 $J(\theta)$ 的极小值，所以自然的，我们将 $\ln L(\theta)$ <strong>取反</strong>来定义 $J(\theta)$：</p><script type="math/tex; mode=display">\begin{aligned}J(\theta)&=-\frac{1}{m}\ln L(\theta)\\&=-\frac{1}{m}\sum_{i=1}^m{\left[ y^{\left(i\right)}\ln \left( h_{\theta}\left( x^{\left(i\right)} \right) \right) +\left( 1-y^{\left(i\right)} \right) \ln \left( 1-h_{\theta}\left( x^{\left(i\right)} \right) \right) \right]}\end{aligned}</script><p>其中 $\frac{1}{m}$ 对要求的 $\theta$ 没有影响，仅是取一下平均罢了。</p><blockquote><p>可以证明上述代价函数 $J(\theta)$ 会是一个<strong>凸函数</strong>，并且没有局部最优值。凸性分析的内容不在本讲的范围，但是可以证明我们所选的代价函数会给我们带来一个<strong>凸优化</strong>问题（Convex Optimization）。</p></blockquote><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>既然是凸函数，那么现在我们就可以进行梯度下降求解 $\underset{\theta}{\arg\min }J\left( \theta  \right)$ 。</p><p>为了求偏导，我们先计算：</p><script type="math/tex; mode=display">\begin{aligned}    \frac{\partial}{\partial \theta}\mathrm{Cost}\left( h_{\theta}\left( x \right) ,y \right) &=\frac{\partial}{\partial \theta}\left[ -y\ln \left( h_{\theta}\left( x \right) \right) -\left( 1-y \right) \ln \left( 1-h_{\theta}\left( x \right) \right) \right]\\    &=\frac{\partial}{\partial \theta}\left[ y\ln \left( 1+e^{-\theta ^Tx} \right) +(1-y)\ln \left( 1+e^{\theta ^Tx} \right) \right]\\    &=\frac{-yxe^{-\theta ^Tx}}{1+e^{-\theta ^Tx}}+\frac{\left( 1-y \right) xe^{\theta ^Tx}}{1+e^{\theta ^Tx}}\\    &=\frac{-yx+\left( 1-y \right) xe^{\theta ^Tx}}{1+e^{\theta ^Tx}}\\    &=\left( -y+\frac{1}{1+e^{-\theta ^Tx}} \right) x\\    &=\left( h_{\theta}\left( x \right) -y \right) x\\\end{aligned}</script><p> 于是乎，</p><script type="math/tex; mode=display">\frac{\partial J}{\partial \theta}=\frac{1}{m}\sum_{i=1}^m{\left( h_{\theta}\left( x^{\left( i \right)} \right) -y^{\left( i \right)} \right) x^{\left( i \right)}}</script><p>没错，这个偏导的形式和线性回归完全相同！不同的只是 ${h_\theta}\left( x \right)=g\left( {\theta^T}X \right)$ 的定义——多了一层 $\text{sigmoid}$ 函数，正是因此，我们不能使用正规方程直接给出<strong>解析解</strong>，而必须使用梯度下降等方法。</p><script type="math/tex; mode=display">\theta:=\theta-\alpha\cdot\frac{\partial J}{\partial \theta}</script><p>现在我们对其使用梯度下降即可。另外，在运行梯度下降算法之前，进行<strong>特征缩放</strong>依旧是非常必要的。</p><blockquote><p>除了梯度下降法，还有很多算法可以用来求解这个最优值：共轭梯度法（Conjugate Gradient）、局部优化法（Broyden fletcher goldfarb shann, BFGS）、有限内存局部优化法（LBFGS）等。</p><p>这些算法通常不需要手动选择学习率 $\alpha$，而是使用一个智能的内循环（线性搜索算法）来选择一个较好的 $\alpha$，甚至能为每次迭代选择不同的 $\alpha$。因此他们有着更优越的常数和时间复杂度，在大型机器学习项目中更加适用。</p></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面以 <a href="https://www.coursera.org/">Coursera</a> 上的二分类数据集 <code>ex2data1.txt</code> 为例，首先看一下数据的分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># load data, data.shape = (100, 3)</span><br>data = np.loadtxt(<span class="hljs-string">&#x27;ex2data1.txt&#x27;</span>, delimiter=<span class="hljs-string">&#x27;,&#x27;</span>)<br>(m, n) = data.shape<br>X = data[:, :-<span class="hljs-number">1</span>]<br>y = data[:, -<span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># preview data</span><br>pos = np.where(y == <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br>neg = np.where(y == <span class="hljs-number">0</span>)[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 返回索引</span><br>plt.scatter(X[pos, <span class="hljs-number">0</span>], X[pos, <span class="hljs-number">1</span>], marker=<span class="hljs-string">&quot;o&quot;</span>, c=<span class="hljs-string">&#x27;c&#x27;</span>)<br>plt.scatter(X[neg, <span class="hljs-number">0</span>], X[neg, <span class="hljs-number">1</span>], marker=<span class="hljs-string">&quot;x&quot;</span>, c=<span class="hljs-string">&#x27;r&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;Exam 1 score&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Exam 2 score&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/img/blog/ML-Note-4-images/preview_scatter.png" alt="数据分布散点图"></p><p>看起来用<strong>直线</strong>即可划分数据。此外，注意到如果每次都用 <code>np.sum()</code> 计算 $\sum_{i=1}^m\left(h_\theta(x^{(i)})-y^{(i)}\right)x^{(i)}_j$ 耗时较大，因此将求和化成<strong>矩阵形式</strong>：</p><script type="math/tex; mode=display">\theta :=\theta -\alpha \frac{1}{m}X^T\left( g\left( X\theta \right) -y \right)</script><p>实现逻辑回归如下，矩阵化后运行时间可缩短一半：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># load data, data.shape = (100, 3)</span><br>data = np.loadtxt(<span class="hljs-string">&#x27;ex2data1.txt&#x27;</span>, delimiter=<span class="hljs-string">&#x27;,&#x27;</span>)<br>(m, n) = data.shape<br>X = data[:, :-<span class="hljs-number">1</span>]<br>y = data[:, -<span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># normalization</span><br>X = (X - X.mean(axis=<span class="hljs-number">0</span>)) / X.std(axis=<span class="hljs-number">0</span>, ddof=<span class="hljs-number">1</span>)<br>X = np.c_[np.ones(m), X] <span class="hljs-comment"># 增加一列 1</span><br><br><span class="hljs-comment"># parameters</span><br>alpha = <span class="hljs-number">0.01</span><br>num_iters = <span class="hljs-number">10000</span><br>theta = np.zeros(n)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sigmoid</span>(<span class="hljs-params">z</span>):</span><br>    g = np.zeros(z.size)<br>    g = <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + np.exp(-z))<br>    <span class="hljs-keyword">return</span> g<br><br><span class="hljs-comment"># Gradient Descent</span><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, num_iters):<br>error = sigmoid(X @ theta) - y  <span class="hljs-comment"># error.shape = (100, )</span><br>theta -= (alpha / m) * (X.T @ error)  <span class="hljs-comment"># X.T.shape = (2, 100)</span><br><br><span class="hljs-comment"># plot decision boundary</span><br>pos = np.where(y == <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br>neg = np.where(y == <span class="hljs-number">0</span>)[<span class="hljs-number">0</span>]<br>plt.scatter(X[pos, <span class="hljs-number">1</span>], X[pos, <span class="hljs-number">2</span>], marker=<span class="hljs-string">&quot;o&quot;</span>, c=<span class="hljs-string">&#x27;c&#x27;</span>)<br>plt.scatter(X[neg, <span class="hljs-number">1</span>], X[neg, <span class="hljs-number">2</span>], marker=<span class="hljs-string">&quot;x&quot;</span>, c=<span class="hljs-string">&#x27;r&#x27;</span>)<br><br>x_plot = np.array([np.<span class="hljs-built_in">min</span>(X[:, <span class="hljs-number">1</span>]), np.<span class="hljs-built_in">max</span>(X[:, <span class="hljs-number">1</span>])])<br>y_plot = (-<span class="hljs-number">1</span> / theta[<span class="hljs-number">2</span>]) * (theta[<span class="hljs-number">1</span>] * x_plot + theta[<span class="hljs-number">0</span>])<br>plt.plot(x_plot, y_plot)<br>plt.show()<br></code></pre></td></tr></table></figure><p>得到的 $\left( \theta_0, \theta_1, \theta_2 \right)$ 结果是：[1.2677 3.0555  2.8289]，绘制出决策边界的图像为：</p><p><img src="/img/blog/ML-Note-4-images/decision_boundary.png" alt="决策边界（归一化）"></p><h2 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h2><p>在实际情形中，我们还会使用逻辑回归来解决<strong>多元</strong>的分类问题。多分类的数据集和二分类相似，区别在于<strong>目标变量</strong> $y^{(i)}$ 在这里不仅有 $0$ 或 $1$ 两类结果，还可以取 $2$、$3$ 等更多的数字。</p><p><img src="/img/blog/ML-Note-4-images/multi-class.png" alt="二分类和多分类"></p><blockquote><p>对于接下来要介绍的方法，标签数字的顺序、取法，都不会影响最终的结果。但在某些分类模型中，数值可能具有实际意义，这时候使用<strong>独热码</strong>（One-Hot）或许是更好的选择。</p></blockquote><h3 id="一对余-One-vs-Rest"><a href="#一对余-One-vs-Rest" class="headerlink" title="一对余 | One vs. Rest"></a>一对余 | One vs. Rest</h3><p>对于 $N$ 分类问题，我们可以将其转化为 $N$ 个二分类问题——只需创建 $N$ 个「<strong>伪训练集</strong>」，每个训练集中仅包含一个类作为正向类，其他 $N-1$ 个类均视为负向类。</p><p><img src="/img/blog/ML-Note-4-images/one-vs-rest.png" alt="One vs. Rest" width=60% /></p><p>接下来就可以训练 $N$ 个标准的逻辑回归分类器，将其记为：</p><script type="math/tex; mode=display">h_\theta^{\left( i \right)}\left( x \right)=P\left( y=i|x;\theta  \right) \;\; i=\left( 1,2,\cdots,N \right)</script><p>显然，每个分类器的输出都可以视为「<strong>属于某类</strong>」的概率，在预测时，我们只需要运行一遍所有分类器，然后取其最大值作为预测结果即可。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>How to Read a Paper ?</title>
    <link href="/Read-Paper.html"/>
    <url>/Read-Paper.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>Researchers spend a great deal of time reading research papers. However, this skill is rarely taugh, leading to much wasted eﬀort. <sup><a href="#fn_1" id="reffn_1">1</a></sup></p></blockquote><p>本文旨在通过学习前人的经验，形成自己的一套阅读文献的方法。</p><p>在开始阅读文献之前，首先要确定大致的研究方向，并对相关领域有<strong>一定的了解</strong>：</p><ul><li>该领域存在的价值是什么？</li><li>该领域有哪些基本概念、专有名词、Key Words？</li><li>该领域必要的 Preliminaries 有哪些？</li><li>该领域能 work 的基本原理是什么？</li><li>该领域最著名的工作、成果有哪些？</li></ul><p>以上内容大部分可以在<strong>中文博客</strong>中找到前人总结好的文章，我们要做的任务就是广泛搜集、大量阅读、形成自己的 First Impression。此外，还可以在 <a href="https://arxiv.org/">ArXiv</a>、<a href="https://github.com/">GitHub</a>、<a href="https://papers.labml.ai/papers/daily">Daliy Papers</a>、<a href="https://towardsdatascience.com/">Towards Data Science</a>、<a href="https://www.paperdigest.org/">Paper Digest</a>、<a href="https://www.connectedpapers.com/">Connected Papers</a> 等网站上找到有用的资源。</p><p>以上最好能输出<strong>第一篇</strong>自己的 Overview 博客，接下来才是真正接触文献。</p><h2 id="读什么？"><a href="#读什么？" class="headerlink" title="读什么？"></a>读什么？</h2><h3 id="初学者"><a href="#初学者" class="headerlink" title="初学者"></a>初学者</h3><p>作为一个刚踏入新领域的初学者，读文献的优先级应该是：<sup><a href="#fn_2" id="reffn_2">2</a></sup></p><ol><li>近一两年该领域<strong>有影响力</strong>的 Survey 或 Review（视领域的发展速度而异）：<strong>综述</strong>一般会将各个流派以及最先进的方法整理出来，读完后会对该领域有更深的认识，同时可以完善此前的博客。</li><li>近五年内该领域的<strong>经典著作</strong>（高引用，具有启发性的）：就算读不懂也会有很多博客讲解，并且会有 backbone 的各种源码实现，最好结合起来看，阅读的同时输出若干篇<strong>精读笔记</strong>。</li><li>经典著作引用的<strong>更经典著作</strong>（引用量达到一定量级）：时间可能会过于久远，领域也可能不完全契合，但这些文章绝对值得一看。</li><li>近两年的顶会 <strong>SOTA</strong>（有开源代码优先）：帮助你更快地掌握该领域最新的热点。同上，阅读的同时输出若干篇<strong>泛读笔记</strong>，泛读过程中对有启发的文章加以精读。</li><li>其他<strong>相近领域</strong>可能有启发的经典著作、综述。</li></ol><blockquote><p>学术圈唯 SOTA 论的风气严重，几乎每篇论文都会声称自己达到某某任务的 SOTA，筛选时更要区分 Trick 和真正的 Contribution，不要在 Trick 上花太多的时间。</p></blockquote><p>确定了优先级后，做好以下的事情：</p><ul><li>根据此前的积累，辨识并搜集有用的文献；</li><li>使用 <code>Zotero</code> 管理文献，使用 <code>Notion</code> 管理阅读；</li><li>多和导师、师兄师姐沟通，不要开局就踩坑。</li></ul><h3 id="研究者"><a href="#研究者" class="headerlink" title="研究者"></a>研究者</h3><p>如果你对当前领域已经有了较深的认识，甚至取得过一定的成果和产出，下面还有三种扩宽知识面的方法：<sup><a href="#fn_6" id="reffn_6">6</a></sup></p><p><strong>读大牛</strong>：如果他们在领域经典著作中高频出现，我们可以在 Google Scholar 主页找到更多的资料：</p><ul><li>他的从博士阶段至今的研究课题；</li><li>他的高被引经典著作、形成的写作方式；</li><li>他的研究方向变动，特别是在领域有重大突破的时间节点；</li><li>他的最新论文动态（可能指示着领域未来的热点）。</li></ul><p><strong>扫会议</strong>：最新的会议 Accepted List，扫一遍耗时略久，但可以保持对领域的清晰认识：</p><ul><li>通过关键词云，判断其他人的研究动向；</li><li>从其他人的 method 中摘取灵感。</li></ul><p><strong>追踪论文</strong>：在 Google Scholar 选择一篇你关注的文献（经典、强相关），添加引用提醒：</p><ul><li>进入文章的引用列表（cited by），点击 Create Alert，新论文引用该论文时，就会有邮件通知；</li><li>进入作者主页，点击 Create Alert，当作者维护自己的主页时（有新文章），就会有邮件通知；</li><li>有时候，论文还没发表，就已经能够通过引用关系找到该论文。</li></ul><h2 id="怎么读？"><a href="#怎么读？" class="headerlink" title="怎么读？"></a>怎么读？</h2><h3 id="一篇论文的构成"><a href="#一篇论文的构成" class="headerlink" title="一篇论文的构成"></a>一篇论文的构成</h3><p>首先要了解论文各部分的重要性：<sup><a href="#fn_3" id="reffn_3">3</a></sup></p><ol><li>Abstract：论文<strong>最重要</strong>的部分，概括问题的提出到解决，一般由导师直接把关；</li><li>Introduction：重要性<strong>仅次于摘要</strong>，内容更加易懂，带有<strong>最关键</strong>的 <strong>Figure</strong>，指出本文的 <strong>Motivation</strong> 和 <strong>Novelty</strong>；</li><li>Related Work、Background：对领域内工作的分类和总结，面对一个生涩的主题时读者则需要阅读，但通常没什么干货；</li><li>Method、Approach：论文的模型算法细节，对于<strong>理解</strong>本论文非常重要；</li><li>Experiment、Evaluation：会提出<strong>重要</strong>的 <strong>metric</strong>，results 中有会对比其他工作的 <strong>Table</strong>；</li><li>Discussion、Outlook、Conclusion：全文总结和展望，很可能会指出文章的<strong>缺陷</strong>；</li><li>Reference：论文引用的文献列表；</li><li>Appendix：部分无法放到正文中的内容，如证明和算法。</li></ol><p>综上，无论精读还是泛读，看一篇文章的<strong>正确顺序</strong>应该是：<sup><a href="#fn_7" id="reffn_7">7</a></sup></p><ol><li>Abstract &amp; Conclusion</li><li>Introduction</li><li>Figure &amp; Tables</li><li>Evaluation metric</li><li>Others（如果要精读）</li></ol><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>一篇初步完成的 Overview 博客</li><li>使用 <code>Zotero</code> 搜集整理好的文献</li><li>使用 <code>Notion</code> 创建一个 Paper To Read 的优先级 List</li><li>使用 <code>Notion</code> 创建一篇 Paper 的精读 or 泛读模板</li></ul><h3 id="泛读-Pass-1"><a href="#泛读-Pass-1" class="headerlink" title="泛读 Pass 1"></a>泛读 Pass 1</h3><p><strong>目的</strong>：在有限的时间里筛选出<strong>或许有用</strong>的论文，并<strong>简要记录</strong>在表格中</p><p><strong>顺序</strong>：</p><ol><li>Title：论文是不是跟自己目前的工作相关？</li><li>Abstract &amp; Conclusion：论文试图解决什么<strong>问题</strong>？有什么贡献？</li><li>Introduction：验证一个什么科学<strong>假设</strong>？有什么<strong>动机</strong>？</li><li>Figure &amp; Tables：解决方案之<strong>关键</strong>是什么？</li></ol><p><strong>要点</strong>：</p><ul><li>预计用时 10-15 分钟；</li><li>得出结论：这篇文章要不要继续读下去？优先级如何？</li></ul><h3 id="泛读-Pass-2"><a href="#泛读-Pass-2" class="headerlink" title="泛读 Pass 2"></a>泛读 Pass 2</h3><p><strong>目的</strong>：知道文章<strong>每一块</strong>在干什么，总结出<strong>一段泛读笔记</strong></p><p><strong>顺序</strong>：</p><ol><li>Abstract &amp; Conclusion：论文试图解决什么问题？是否是一个<strong>新的问题</strong>？有什么贡献？</li><li>Introduction：验证一个什么科学假设？有什么<strong>动机</strong>？论文<strong>到底</strong>有什么贡献？</li><li>Related Work、Background：有哪些相关研究？如何归类？</li><li>Method：解决方案之关键是什么？是 <strong>Trick</strong> 还是真正的 <strong>Contribution</strong>？</li><li>Figure：图和方法怎么<strong>对应</strong>起来？图中的<strong>细节</strong>是在干什么？值得学习的绘图技巧？</li><li>Experiment：实验是如何设计的？用于定量评估的<strong>指标</strong>和数据集是什么？</li><li>Table：作者提出的方法跟别人的方法是怎么<strong>对比</strong>的？差距在哪？</li><li>Reference：论文中多次引用、提出<strong>改进</strong>的重要文献，有哪些值得一看？</li></ol><p><strong>要点</strong>：</p><ul><li>预计一天看个几篇；</li><li>不用太注意公式特别的证明，或者一些很细节的处理；</li><li>如果还没有特别没有搞得懂在干什么，可以读作者引用的重要文献；</li><li>可以并行阅读，互相启发，加深理解；</li><li>得出结论：这篇文章值得精读吗？</li></ul><h3 id="精读"><a href="#精读" class="headerlink" title="精读"></a>精读</h3><p><strong>目的</strong>：知道文章<strong>每一句话</strong>在干什么，总结出<strong>一篇精读笔记</strong>，简要回答以下<strong>十个问题</strong><sup><a href="#fn_4" id="reffn_4">4</a></sup>：</p><ol><li>论文试图解决什么问题？这是否是一个新的问题？有什么贡献？</li><li>这篇文章要验证一个什么科学假设？有什么动机？这篇论文到底有什么贡献？</li><li>有哪些相关研究？如何归类？谁是这一课题在领域内值得关注的研究员？</li><li>论文中提到的解决方案之关键是什么？如果是<strong>自己来完成会怎么做</strong>？</li><li>论文中的实验是如何设计的？<strong>能否改进</strong>？</li><li>用于定量评估的指标和数据集是什么？代码有没有开源？<strong>能否复现</strong>？</li><li>图表和论文中的方法是怎么对应起来的？有哪些需要注意的细节？</li><li>论文中的实验及结果有没有<strong>很好地支持</strong>需要验证的科学假设？如果没有，<strong>能否改进</strong>？</li><li>论文提到的<strong>思路、模型、实现、工具、数据集</strong>，<strong>有哪些可以为我所用</strong>？</li><li>下一步呢？论文中提到的<strong>不足和拓展</strong>，有什么工作可以<strong>继续深入或跟进</strong>？</li></ol><blockquote><p>如果这篇论文足够重要，足以在组会中<strong>讨论、分享</strong>它，最好按照上面十个问题进行梳理，特别是<strong>前两个</strong>问题（介绍）和<strong>后三个</strong>问题（体会）。</p></blockquote><p><strong>要点</strong>：</p><ul><li>一天能看完一篇吗？</li><li>很多原因会造成理解不够深入甚至理解错误，需要<strong>多次阅读</strong>（如果有必要，<strong>多次讨论</strong>）来避免这类问题；</li><li>如果在阅读过程中出现了大量盲点，反思是不是 Preliminaries 的掌握不够；</li><li>学会<strong>挑刺</strong>，不能顺着作者的逻辑，要换个角度<strong>尝试去反驳</strong>它，就像审稿人一样。要能够找出这篇论文的优缺点、有哪些改进的空间，这样才能在相对成熟的研究中发现新问题。</li></ul><h2 id="后续工作"><a href="#后续工作" class="headerlink" title="后续工作"></a>后续工作</h2><p>如果此前已经有了足够的 Preliminaries，且有过一定的文献阅读经验，到这一步时大概已经过了两三个月了。</p><p>此时你已经阅读了大量文献和源码，和导师、同门进行了几次讨论，这时候还留在筐子里 ideas 很有可能是可行的，现在就需要把你的 idea 实现了。这个阶段也不必孤军奋战，可以找同组的小伙伴一起<strong>合作</strong>。</p><p>又过了一两个月，当你的 idea 基本证实有效之后，就可以开始动手写论文了。主要使用的工具为线上多人合作的 Overleaf。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote id="fn_1"><sup>1</sup>. <a href="https://web.stanford.edu/class/ee384m/Handouts/HowtoReadPaper.pdf">How to Read a Paper -Stanford</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. <a href="https://www.zhihu.com/question/21278186">科研大牛们怎么读文献？- 知乎</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. <a href="https://github.com/qiyuangong/How_to_Search_and_Read_a_Paper">How_to_Search_and_Read_a_Paper - GitHub</a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. <a href="https://readpaper.com/">专业的学术讨论社区 - ReadPaper</a><a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote><blockquote id="fn_5"><sup>5</sup>. <a href="https://www.eecs.harvard.edu/~michaelm/postscripts/ReadPaper.pdf">How to read a research paper - Harvard</a><a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a></blockquote><blockquote id="fn_6"><sup>6</sup>. <a href="https://www.studyright.net/blog/research-paper-sources/">6 Tips to Finding Research Paper Sources that Set You Apart - studyright.net</a><a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a></blockquote><blockquote id="fn_7"><sup>7</sup>. <a href="https://be.mit.edu/sites/default/files/documents/HowToReadAScientificPaper.pdf">How to Read A Scientific Paper - MIT</a><a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a></blockquote><blockquote id="fn_8"><sup>8</sup>. <a href="https://www.bilibili.com/video/BV1H44y1t75x">如何读论文【论文精读】- 李沐</a><a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a></blockquote>]]></content>
    
    
    <categories>
      
      <category>科研札记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Research</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件工程 应试笔记 #2</title>
    <link href="/Software-Engineering-2.html"/>
    <url>/Software-Engineering-2.html</url>
    
    <content type="html"><![CDATA[<p>该笔记（<strong>考点预测</strong>）是本人于哈尔滨工业大学（深圳）2021 年秋季学期「软件工程」课程的笔记。</p><p>笔记是在考前复习时扫 PPT 做的，内容偏<strong>应试风格</strong>，内容涵盖了所有考试内容（变异测试、性能测试不在考试范围，故不在此列）。主要包括：软件工程概论、软件开发过程管理、需求工程、软件设计、软件测试、软件维护。</p><p>2021 年秋季学期的简答题内容基本涵盖于本题单中（少数内容漏掉了，考完后进行了补充），整份题单按照 PPT 顺序，可用于复习过程中的<strong>查缺补漏</strong>、<strong>自我检测</strong>。</p><blockquote><p>括号内是本人的答案助记，不保证其准确性，仅供参考！</p></blockquote><h2 id="考试回忆"><a href="#考试回忆" class="headerlink" title="考试回忆"></a>考试回忆</h2><p>2021 年简答题考了题单里的 <code>6, 25, 29, 35</code>，大题考了 <code>5, 8, 9, 10</code>。判断题、选择题也基本在题单覆盖范围内，已在文中<strong>加粗</strong>。</p><p>2020 年简答题考了题单里的 <code>23, 40, 42, 45</code>，大题考了 <code>4, 5, 6, 8, 9, 10</code>。</p><h2 id="考点预测"><a href="#考点预测" class="headerlink" title="考点预测"></a>考点预测</h2><h3 id="简答考点"><a href="#简答考点" class="headerlink" title="简答考点"></a>简答考点</h3><ol><li>软件的本质特性有哪些？（复杂性、一致性、可变性、不可见性）</li><li>软件开发面临的挑战为什么会出现？（客观上、主观上）</li><li>软件工程的基本要素有哪些？（方法、工具、过程、范型）</li><li>软件开发过程的典型阶段（需求定义与分析、软件设计、软件实现、软件验证、软件运行与维护）</li><li>可以通过调整软件开发不同阶段的顺序使之适应不同的情况。（√）</li><li>五种软件开发模型（瀑布、增量、快速应用开发、<strong>快速原型开发</strong>、螺旋）及特点</li><li>软件开发管理的 4P（人员、产品、过程、项目）</li><li>列举软件项目参数估算的技术（代码行、功能点、COCOMO、用例点、故事点、机器学习）</li><li>软件项目进度如何安排？（工作量分配、任务依赖网络、关键路径分配时间、确定资源等）</li><li>功能性需求和非功能性需求的区别和举例。（描述了系统与其独立于系统实现环境之间的交互——功能上，描述了不直接关联到系统功能行为的系统的方方面面——性能上）</li><li>非功能性需求有哪些层次？（业务规则、外部接口需求、约束条件）</li><li>描述一个完整的需求工程（需求获取、需求分析、需求规格说明、需求验证）</li><li>基于场景的需求建模方法举例与说明（用户故事、用例图、活动图）</li><li>绘制一个完整的用例图的步骤（确定系统边界、识别并描述参与者、识别用例、识别通讯关联、给出用例描述、细化用例模型）</li><li>通讯关联不表示参与者和用例之间的信息流。（√）</li><li>什么是 SRS？（精确阐述 FR、NFR、限制条件，法律效力，理解和交流的手段）</li><li>传统软件工程开发方法有哪些？特点是？（功能分解法、结构化方法、信息建模法）</li><li>传统开发方法和面向对象方法有什么区别、优势？（过程抽象/实体对象，分析与设计难以对应/直接映射问题域形成良好的对应）</li><li>面向对象方法的三步骤（分析、设计、编程）</li><li>面向对象设计有哪些基本概念？（对象、类、封装、消息、泛化继承、多态）</li><li>软件设计的原则有哪些？（抽象、封装、模块化、层次化、复用）</li><li>软件体系结构的要素有哪些？（构建+连接件+约束）</li><li>软件体系结构风格（数据流风格、以数据为中心的风格、调用和返回体系结<br>构风格、面向对象体系结构风格、层次体系结构风格）</li><li>C/S+B/S 层次体系结构具有什么优点？（将二者结合起来，企业内/外有别，内部交互性增强响应速度高，外部不直接访问数据更安全）</li><li><strong>CRC 面向对象方法</strong>的具体内容（类、责任、协作）</li><li>顺序图包含哪些<strong>组件</strong>？</li><li>协作图与顺序图的异同点和适用情形。（都是交互，顺序图偏重时间顺序，协作图偏重链接关系）</li><li>活动图与状态图的异同点和适用情形。（图形差不多，状态图只有单个对象，活动图侧重多个对象交互，可以描述并行行为）</li><li><strong>软件编程</strong>除了代码实现还包含哪些内容？（程序设计、代码审查、代码重构）</li><li>代码审查有哪些形式？（桌面检查、代码走查、代码审查）</li><li>代码重构和添加新功能有什么区别？（重构不改变功能和外部行为，仅提高代码的可理解性、可扩展性等，新功能不修改既有代码，仅增加代码。二者交替进行）</li><li>软件缺陷的演化过程（错误、缺陷、故障、失效）</li><li>软件测试的两种思维是什么？（正向：验证正常、反向：假定缺陷）</li><li>软件测试有哪些局限性？（不彻底性——不能说明错误不存在、不完备性——不能完全覆盖、间接性）</li><li><strong>按照测试对象分类</strong>的软件测试类型（单元、集成、系统、验收）</li><li>单元测试需要哪些模块？（驱动、桩模块）</li><li>集成测试有哪些方法？（整体集成方式、自顶向下、自底向上的增量集成）</li><li>回归测试是什么？什么时候需要回归测试？（任何一个阶段）</li><li>自动化测试和手工测试的区别？自动化测试能替代手工测试吗？</li><li>测试用例的重要性（指导系统地测试、提高测试效率、作为检验软件的度量标准、积累和传递测试的经验）</li><li>测试用例的组成要素（测试用例值、期望结果、前缀值、后缀值）</li><li>黑盒测试与白盒测试的区别（白盒利用程序的内部逻辑、对所有逻辑路径进行测试、考虑逻辑的覆盖程度，黑盒不考虑内部逻辑、在软件接口处进行测试、考虑需求的覆盖程度）</li><li>黑盒测试用于辅助白盒测试发现其他类型错误。（√）</li><li>测试用例的评价标准（覆盖度高——黑白不一样、用例少、冗余度低、用例的缺陷定位能力高）</li><li>3 种黑盒测试方法（等价类测试、边界值测试、场景法测试）共同点都是不用考虑内部实现就可以的方法，前两中面向数据，后一种面向过程</li><li>等价类测试中等价类划分原则（分而不交、和而不变、类内等价）</li><li>「事件流」出现在了需求建模的用例模型中的用例描述里，也出现在黑盒测试的场景法测试里，一个是常规流+扩展流，一个是基本流+备选流</li><li>传统的软件开发模式和现在的软件开发模式有什么区别？（传统的侧重预见性的开发方法，如瀑布模型，但是难以预知所有的内容和风险；现在的开发方法采用弹性的管理方式，系统迭代演进来应对快速变化的需求，适应而非预测）</li><li>敏捷开发方法有哪些？（极限编程XP、Scrum开发方法）</li><li>Scrum 制品中的产品订单和迭代订单有什么区别？（产品订单是从客户角度要求实现的所有功能的列表，迭代订单是从开发技术角度的每个迭代要完成的功能列表）</li><li>软件交付工作包含哪些方面？（项目实施、客户培训、项目验收）</li><li>软件维护和软件再工程有什么区别？（软件维护是为了修改软件的缺陷或者增加新功能，软件再工程是为了避免软件本身退化对软件的一部分进行重新设计、编码和测试）</li><li>软件维护有哪些类型？有什么区别？（改正性、适应性、<strong>完善性</strong>）</li></ol><h3 id="大题考点"><a href="#大题考点" class="headerlink" title="大题考点"></a>大题考点</h3><ol><li>给定需求，写出增量模型的迭代功能、故事卡片</li><li>给定需求，画出用例图并写出用例描述（耗时）</li><li>绘制层级体系结构图（B/S 和 C/S）（耗时）</li><li>面向对象设计，写出类和类图（耗时）</li><li>结构化方法数据建模，画出 0 层和 1 层 <strong>DFD</strong> 图（耗时）</li><li>结构化方法数据建模，找出 DFD 图里的错误</li><li>过程行为建模，绘制状态图（耗时）</li><li>过程行为建模，画出<strong>顺序图</strong>（耗时）</li><li>白盒测试<strong>用例设计</strong>，要求覆盖</li><li>白盒测试基本路径，画出<strong>流图</strong>算环复杂度</li><li>黑盒测试用例设计，等价类测试：划分等价类，设计测试用例来覆盖</li><li>黑盒测试用例设计，边界值测试</li><li>黑盒测试用例设计，场景法测试</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>本科课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件工程 应试笔记 #1</title>
    <link href="/Software-Engineering-1.html"/>
    <url>/Software-Engineering-1.html</url>
    
    <content type="html"><![CDATA[<p>该笔记（<strong>思维导图</strong>）是本人于哈尔滨工业大学（深圳）2021 年秋季学期「软件工程」课程的笔记。</p><p>笔记是随着上课过程逐渐整理的，笔记内容偏<strong>应试风格</strong>，内容涵盖了所有考试内容（变异测试、性能测试不在考试范围，故不在此列）。主要包括：软件工程概论、软件开发过程管理、需求工程、软件设计、软件测试、软件维护。</p><p>「软件工程」属于「<strong>理工科中的文科</strong>」，需要<strong>记忆和辨析</strong>的概念较多，考试也不考察硬核的内容，2021 年秋季学期的考试内容大都涵盖于本笔记中，试卷的难点在于设计部分（画顺序图、数据流图），此外还有一些「坑点」，会在另一篇笔记中补充。</p><blockquote><p>图片较大，加载可能比较缓慢，推荐保存下来使用。如需分享，请注明出处！</p></blockquote><h2 id="软件工程概论"><a href="#软件工程概论" class="headerlink" title="软件工程概论"></a>软件工程概论</h2><p>主要内容包含：</p><ul><li>软件的产生与发展</li><li>软件工程基本概念</li></ul><p><img src="/img/blog/Software-Engineering-1-images/软件工程概论.png" alt="软件工程概论"></p><h2 id="软件开发过程管理"><a href="#软件开发过程管理" class="headerlink" title="软件开发过程管理"></a>软件开发过程管理</h2><p>主要内容包含：</p><ul><li>软件开发过程</li><li>软件开发管理</li></ul><p><img src="/img/blog/Software-Engineering-1-images/开发过程管理.png" alt="开发过程管理"></p><h2 id="软件需求工程"><a href="#软件需求工程" class="headerlink" title="软件需求工程"></a>软件需求工程</h2><p>主要内容包含：</p><ul><li>软件需求与需求工程</li><li>需求获取与建模</li><li>需求规格说明书（SRS）</li></ul><p><img src="/img/blog/Software-Engineering-1-images/需求工程.png" alt="需求工程"></p><h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><p>主要内容包含：</p><ul><li>软件开发与设计方法</li><li>软件体系结构设计</li><li>类、数据建模与设计</li><li>过程、行为建模与设计</li><li>物理建模与设计</li></ul><p><img src="/img/blog/Software-Engineering-1-images/软件设计.png" alt="软件设计"></p><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><p>主要内容包含：</p><ul><li>软件编程</li><li>软件测试概论</li><li>白盒测试、黑盒测试</li><li>变异测试、性能测试（不考）</li></ul><p><img src="/img/blog/Software-Engineering-1-images/软件测试.png" alt="软件测试"></p><h2 id="软件维护"><a href="#软件维护" class="headerlink" title="软件维护"></a>软件维护</h2><p>主要内容包含：</p><ul><li>敏捷开发</li><li>软件实施、维护与演化</li></ul><p><img src="/img/blog/Software-Engineering-1-images/软件维护.png" alt="软件维护"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>本科课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Everyone Has Their Own Time Zone</title>
    <link href="/Everyone-Has-A-Time-Zone.html"/>
    <url>/Everyone-Has-A-Time-Zone.html</url>
    
    <content type="html"><![CDATA[<p>一学期中最忙的时候，刚结束一堆 DDL，考完了数据库，总算有点时间更新博客了，可惜下周又是一堆 DDL。</p><p>最近的情绪比较低落，仿佛总是被一些无聊的事情推着走——无聊的考试、无聊的作业、无聊的项目、无聊的课程。</p><p>好在前段时间联系了高老师，现在可能也慢慢走上科研的正轨了？至少看见了一丝曙光。</p><hr><p>也是突然被提醒才想起这个博客原来是有分享心情的初衷，最近常常念叨一篇小短文，就分享一下叭~</p><h2 id="Everyone-Has-Their-Own-Time-Zone"><a href="#Everyone-Has-Their-Own-Time-Zone" class="headerlink" title="Everyone Has Their Own Time Zone"></a>Everyone Has Their Own Time Zone</h2><p>New York is 3 hours ahead of California,</p><p>but it does not make California slow.</p><p>Someone graduated at the age of 22,</p><p>but waited 5 years before securing a good job!</p><p>Someone became a CEO at 25,</p><p>and died at 50.</p><p>While another became a CEO at 50,</p><p>and lived to 90 years.</p><p>Someone is still single,</p><p>while someone else got married.</p><p>Obama retires at 55,</p><p>but Trump starts at 70.</p><p>Absolutely everyone in this world works based on their Time Zone.</p><p>People around you might seem to go ahead of you,</p><p>some might seem to be behind you.</p><p>But everyone is running their own RACE, in their own TIME.</p><p>Don’t envy them or mock them.</p><p>They are in their TIME ZONE, and you are in yours!</p><p>Life is about waiting for the right moment to act.</p><p>So, RELAX.</p><p>You’re not LATE.</p><p>You’re not EARLY.</p><p>You are very much ON TIME, and in your TIME ZONE Destiny set up for you.</p>]]></content>
    
    
    <categories>
      
      <category>心情随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DB课程项目-校园食堂点餐系统-开发文档</title>
    <link href="/DB-Project.html"/>
    <url>/DB-Project.html</url>
    
    <content type="html"><![CDATA[<p><img src="/img/blog/DB-Project-images/logo.png" alt="logo"></p><p><code>Date</code>：2021-11</p><p><code>Description</code>：本文档作为 2021 年秋季学期「数据库系统」课程 Project 校园食堂点餐系统的开发文档，基于 MySQL+Django 实现。</p><p><code>Reference</code>：参考了一系列 Django 入门教程，在文中相应部分有链接。</p><p><code>Code Repo</code>：<a href="https://github.com/hewei2001/campus-canteen-ordering">https://github.com/hewei2001/campus-canteen-ordering</a></p><p><code>Acknowledgement</code>：感谢 <a href="https://github.com/Yiwen-Ding">Yiwen-Ding</a> 小盆友 😭 不然不可能肝完这么多内容。</p><p><code>Copyright</code>：© 2021 Hwcoder. All rights reserved.</p><h2 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h2><p>本实验要求设计并实现一个小型数据库应用系统，实现<strong>前后台</strong>数据交互，并将<strong>数据保存</strong>在之前实验所设计的数据库中。 </p><p>由于不限语言和实现方式，同学们可能采用的方案大致有：Cpp+Qt，Python+Flask，Python+Django，Python+PyQt 等，还有其他 Java、PHP 一些我不太熟悉的方案。</p><p>本项目采用的是 Python+Django，是因为 Django 具有功能强大的脚手架和诸多开箱即用的组件，用 Django 搭建 Web 应用<strong>快速而又省力</strong>。相比于其他同学手敲 Qt 窗口，Django 自带的 Admin 已经基本把这些功能都实现了，甚至装了插件后还<strong>更美观</strong>，因此可以聚焦于前台交互的快速开发。</p><h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p>本项目是建立在之前的实验结果的基础（已经用 PowerDesigner 设计并导出了数据库到 MySQL Workbench）上，再用 Django 进行应用系统的开发的过程。</p><p>这里简单描述一下之前的实验：</p><ul><li>设计校园食堂点餐系统，要求具备功能：食堂管理、商户管理、菜品管理、订单管理、用户管理；</li><li>E-R 图至少包括 8 个实体和 7 个联系；</li><li>需要考虑关系完整性约束：主键约束、外键约束、空值约束；</li><li>设计至少 1 个视图、1 个索引、1 个触发器（在应用中不需要体现）。</li></ul><p>以及设计好的 PDM (物理数据模型)：</p><p><img src="/img/blog/DB-Project-images/PDM.png" alt="PDM" width=50% /></p><p>最终实现的功能：</p><p><img src="/img/blog/DB-Project-images/user.png" alt="user"></p><p><img src="/img/blog/DB-Project-images/admin.png" alt="admin"></p><h3 id="Django-基础"><a href="#Django-基础" class="headerlink" title="Django 基础"></a>Django 基础</h3><p>如果你之前从未接触过 Web 框架，可以先看这一篇文章：<a href="https://zhuanlan.zhihu.com/p/98788776">一杯茶的时间，上手 Django 框架开发</a>，再往下阅读。</p><p>通过这篇文章，你可以了解到：</p><ol><li>Django 环境的安装、项目初始化</li><li>项目的骨架以及各个文件的作用</li><li>Django App 的创建、各个子文件的作用</li><li>App 中 <code>views.py</code> 的编写、路由 <code>urls.py</code> 的使用</li><li>Django Template 的实现——模板生成的 HTML 文件将随数据变化</li><li>Django ORM 与数据库中的内容交互、迁移数据模型 <code>models.py</code></li><li>Django Admin 实现应用与后台管理接口、使用超级用户登录后台</li></ol><h2 id="设计文档"><a href="#设计文档" class="headerlink" title="设计文档"></a>设计文档</h2><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><p>操作系统：</p><ul><li>Windows 10</li></ul><p>开发工具：</p><ul><li><p>IDE：PyCharm Community Edition 2020.2</p></li><li><p>设计：PowerDesigner</p></li><li><p>数据库：MySQL Workbench 8.0 CE</p></li></ul><p>主要技术：</p><ul><li><p>环境：Django 3.8</p></li><li><p>前端样式：Bootstrap</p></li><li><p>后台样式：Django-SimpleUI</p></li></ul><h3 id="Django-后台开发"><a href="#Django-后台开发" class="headerlink" title="Django 后台开发"></a>Django 后台开发</h3><p>本部分参考资料有：</p><ul><li><p><a href="http://c.biancheng.net/django/">http://c.biancheng.net/django/</a></p></li><li><p><a href="https://www.liujiangblog.com/course/django/">https://www.liujiangblog.com/course/django/</a></p></li></ul><h4 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ django-admin startproject django_CCOS<br></code></pre></td></tr></table></figure><p>调整基础配置 <code>settings.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">LANGUAGE_CODE = <span class="hljs-string">&#x27;zh-Hans&#x27;</span><br>TIME_ZONE = <span class="hljs-string">&#x27;Asia/Shanghai&#x27;</span><br></code></pre></td></tr></table></figure><p>其他字段的意义可以参考：<a href="http://c.biancheng.net/view/7475.html">http://c.biancheng.net/view/7475.html</a></p><p>为了存放图片等资源，需要在 <code>settings.py</code> 中加上以下内容，：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 这个是设置静态文件夹目录的路径</span><br>STATICFILES_DIRS = (<br>    os.path.join(BASE_DIR, <span class="hljs-string">&#x27;static&#x27;</span>),<br>)<br><span class="hljs-comment"># 设置文件上传路径，图片上传、文件上传都会存放在此目录里</span><br>MEDIA_URL = <span class="hljs-string">&#x27;/media/&#x27;</span><br>MEDIA_ROOT = os.path.join(BASE_DIR, <span class="hljs-string">&#x27;media&#x27;</span>)<br></code></pre></td></tr></table></figure><p>同时，在 <code>TEMPLATES</code> 中加上如下字段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;django.template.context_processors.media&#x27;</span>,<br></code></pre></td></tr></table></figure><p>Python3 的 Django 默认的数据库类型是 sqlite，由于之前的实验做的数据库是 MySQL 的，这里进行修改 <code>settings.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">DATABASES = &#123;<br>    <span class="hljs-string">&#x27;default&#x27;</span>: &#123;<br>        <span class="hljs-string">&#x27;ENGINE&#x27;</span>: <span class="hljs-string">&#x27;django.db.backends.mysql&#x27;</span>,<br>        <span class="hljs-string">&#x27;NAME&#x27;</span>: <span class="hljs-string">&#x27;django_CCOS&#x27;</span>,  <span class="hljs-comment"># 连接的数据库</span><br>        <span class="hljs-string">&#x27;HOST&#x27;</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,    <span class="hljs-comment"># mysql的ip地址</span><br>        <span class="hljs-string">&#x27;PORT&#x27;</span>: <span class="hljs-number">3306</span>,           <span class="hljs-comment"># mysql的端口</span><br>        <span class="hljs-string">&#x27;USER&#x27;</span>: <span class="hljs-string">&#x27;root&#x27;</span>,         <span class="hljs-comment"># mysql的用户名</span><br>        <span class="hljs-string">&#x27;PASSWORD&#x27;</span>: <span class="hljs-string">&#x27;123456&#x27;</span>    <span class="hljs-comment"># mysql的密码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时还要安装第三方库，并在 <code>__init__.py</code> 中加上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymysql<br><br>pymysql.install_as_MySQLdb()<br></code></pre></td></tr></table></figure><h4 id="连接-MySQL-数据库"><a href="#连接-MySQL-数据库" class="headerlink" title="连接 MySQL 数据库"></a>连接 MySQL 数据库</h4><p>打开 MySQL Workbench，创建新数据库，<code>create database CCOS</code>。将 Powerdesigner 生成的 <code>crebas.sql</code> 打开并执行，注意要注释掉 <code>drop</code> 等语句。此时我们的数据库就建好了。</p><p>打开项目，创建三个 App：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python manage.py startapp canteen<br>$ python manage.py startapp customer<br>$ python manage.py startapp dish<br></code></pre></td></tr></table></figure><p>然后在 <code>INSTALLED_APPS</code> 中加上对应字段，注意要按顺序，否则后面的指令都会报错。</p><p>接下来要反向导入我们的数据库，在 Django 中生成 Model，参考：<a href="https://blog.csdn.net/diao1057/article/details/98472327">https://blog.csdn.net/diao1057/article/details/98472327</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python manage.py inspectdb --database default canteen shop shop_manager &gt; canteen/models.py<br>$ python manage.py inspectdb --database default customer address  &gt; customer/models.py<br>$ python manage.py inspectdb --database default dish orders comments &gt; dish/models.py<br></code></pre></td></tr></table></figure><p>导入后如果出现如下报错：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">Python Django ValueError: source <span class="hljs-built_in">code</span> <span class="hljs-keyword">string</span> cannot contain <span class="hljs-built_in">null</span> bytes<br></code></pre></td></tr></table></figure><p>很可能是因为生成的 <code>models.py</code> 的编码方式默认被改为 UTF-16 了，需要修改回 UTF-8。</p><h4 id="模型重建"><a href="#模型重建" class="headerlink" title="模型重建"></a>模型重建</h4><p>生成的 Model 不完整，还不能直接运行，据说是因为 Powerdesigner 比较拉跨。因此需要在刚刚生成的 <code>models.py</code> 中修改 <code>class</code> 的内容，并导出到数据库里，覆盖掉原来 Powerdesigner 生成的数据库。<code>class</code> 各个字段的意义参考：<a href="https://www.liujiangblog.com/course/django/95">https://www.liujiangblog.com/course/django/95</a>。</p><p>可以看到所有的属性在 <code>class</code> 中都有自己的 Field，并传入了详细的定义，下面给出一些常用字段：</p><ul><li><code>verbose_name</code>：显示名</li><li><code>choices</code>：多选框</li><li><code>upload_to</code>：图片上传路径</li><li><code>max_length</code>：最大长度</li><li><code>blank=True, null=True,</code>：可以为空</li></ul><blockquote><p>特别要注意外键属性（ForeignKey），如果外键在当前 App 内还好（跟定义顺序有关），要是在其他 App 里，则要 <code>from [其他app].models import xxx</code>。此外，外键还有一个 <code>on_delete</code> 属性，代表删除外键对本表记录的影响，参考：<a href="https://www.liujiangblog.com/course/django/96">https://www.liujiangblog.com/course/django/96</a>。</p></blockquote><p>还有 <code>class Meta</code> 部分，可以设置对整体的操作，比如 ordering 显示顺序等。注意要把之前反向导入产生的 <code>managed = False</code> 字段删除。</p><p>在每一个 <code>class</code> 下加上 Python 的一个魔法方法，用于返回实例对象的打印字符串。：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">return</span> self.title  <span class="hljs-comment"># title 换成想显示的属性</span><br></code></pre></td></tr></table></figure><p>最后的成品举例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dish</span>(<span class="hljs-params">models.Model</span>):</span><br>    dish_id = models.AutoField(primary_key=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">&#x27;菜品编号&#x27;</span>)<br>    shop = models.ForeignKey(<span class="hljs-string">&#x27;canteen.Shop&#x27;</span>, models.CASCADE, verbose_name=<span class="hljs-string">&#x27;窗口&#x27;</span>)<br>    dish_name = models.CharField(max_length=<span class="hljs-number">20</span>, verbose_name=<span class="hljs-string">&#x27;菜品名称&#x27;</span>)<br>    dish_detail = models.CharField(max_length=<span class="hljs-number">200</span>, blank=<span class="hljs-literal">True</span>, null=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">&#x27;菜品描述&#x27;</span>)<br>    dish_price = models.DecimalField(max_digits=<span class="hljs-number">5</span>, decimal_places=<span class="hljs-number">2</span>, verbose_name=<span class="hljs-string">&quot;菜品价格&quot;</span>)<br>    dish_photo = models.ImageField(upload_to=<span class="hljs-string">&#x27;image/dish&#x27;</span>, null=<span class="hljs-literal">True</span>, blank=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">&#x27;菜品照片&#x27;</span>)<br>    dish_active = models.IntegerField(choices = [(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;销售中&#x27;</span>),(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;售罄&#x27;</span>)], verbose_name=<span class="hljs-string">&#x27;菜品状态&#x27;</span>)<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        ordering = [<span class="hljs-string">&#x27;dish_id&#x27;</span>]<br>        db_table = <span class="hljs-string">&#x27;dish&#x27;</span><br>        verbose_name = <span class="hljs-string">&quot;菜品信息&quot;</span><br>        verbose_name_plural = verbose_name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.dish_name<br></code></pre></td></tr></table></figure><h4 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h4><p>运行以下命令创建迁移文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python manage.py makemigrations<br></code></pre></td></tr></table></figure><p>由于导出时会覆盖原来的 MySQL 里的数据库，会创造很多乱七八糟的表，可能会有些许报错，建议在 MySQL 重新创一个空数据库 <code>create database django_CCOS</code>，并修改 <code>settings.py</code> 中的连接。</p><p>接着我们进行数据库迁移：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python manage.py migrate<br></code></pre></td></tr></table></figure><h4 id="后台接口管理"><a href="#后台接口管理" class="headerlink" title="后台接口管理"></a>后台接口管理</h4><p>数据库迁移完成后，我们就可以创建用于登录后台管理的超级用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python manage.py createsuperuser<br></code></pre></td></tr></table></figure><p>按照提示填写用户名和密码即可。</p><p>在每个 App 下的 <code>admin.py</code> 添加后台管理接口如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><br><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Canteen, Shop, ShopManager<br><br>admin.site.register(Canteen)<br>admin.site.register(Shop)<br>admin.site.register(ShopManager)<br></code></pre></td></tr></table></figure><p>完成上述操作后，访问 <a href="localhost:8000/admin">localhost:8000/admin</a>，进入后台系统的登录页面，填入刚才设置的用户名和密码，进入后台管理页面。此时已经可以看到所有的表单，且可以完成基础的管理操作。</p><h3 id="BootStrap-前端开发"><a href="#BootStrap-前端开发" class="headerlink" title="BootStrap 前端开发"></a>BootStrap 前端开发</h3><p>完成了后台，现在来实现前端，这就需要用到 Django 的 templates 模板。首先在<strong>主目录</strong>下新建 <code>templates</code> 用于存放前端页面 html，再创建 <code>static</code> 用来存放渲染静态页面需要的 css 资源。</p><p>参考博客：<a href="https://www.cnblogs.com/qican/p/14626811.html">https://www.cnblogs.com/qican/p/14626811.html</a></p><h4 id="静态模板安装"><a href="#静态模板安装" class="headerlink" title="静态模板安装"></a>静态模板安装</h4><p>首先下载 Bootstrap：<a href="https://v3.bootcss.com/getting-started/#download">https://v3.bootcss.com/getting-started/#download</a>，下载下来后放入 <code>static</code> 文件夹（也可以直接从别人的 Django 项目中复制进来，可能样式更高级）。</p><p>修改 <code>setting.py</code>，前面已经加了 <code>static</code> 内容，现在要在 <code>TEMPLATE</code> 字典中加入如下，用以表示模板路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;DIRS&#x27;</span>: [BASE_DIR / <span class="hljs-string">&#x27;templates&#x27;</span>],<br></code></pre></td></tr></table></figure><h4 id="view-py"><a href="#view-py" class="headerlink" title="view.py"></a>view.py</h4><p>在 canteen 的 <code>view.py</code> 中写入如下内容，用以 render 数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;base.html&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><p>在 <code>templates</code> 中放入我们的 <code>base.html</code>，作为展示的首页，内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br>&#123;% load static %&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">dir</span>=<span class="hljs-string">&quot;ltr&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>校园食堂点餐系统<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% static &#x27;css/master.css&#x27; %&#125;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 此处省略首页代码，如导航栏等 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中静态资源引用了 <code>static</code> 下面的 <code>css/master.css</code>，来自 GitHub 的其他开源项目。</p><h4 id="URL-路径配置"><a href="#URL-路径配置" class="headerlink" title="URL 路径配置"></a>URL 路径配置</h4><p>修改 <code>urls.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用于 include 其他模板所在的 url</span><br><span class="hljs-keyword">from</span> django.conf.urls <span class="hljs-keyword">import</span> url, include<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;admin/&#x27;</span>, admin.site.urls),<br>    path(<span class="hljs-string">&#x27;&#x27;</span>, include(<span class="hljs-string">&#x27;canteen.urls&#x27;</span>)),<br>]<br></code></pre></td></tr></table></figure><p>由于加了 <code>canteen</code>，相应的也要在 <code>canteen/urls.py</code> 中加入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> .views <span class="hljs-keyword">import</span> index<br><br>app_name = <span class="hljs-string">&#x27;canteen&#x27;</span><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;&#x27;</span>, index),<br>]<br></code></pre></td></tr></table></figure><p>之后就可以看到首页啦，其他功能将在下一节介绍。</p><h3 id="交互功能开发"><a href="#交互功能开发" class="headerlink" title="交互功能开发"></a>交互功能开发</h3><p>要求实现的功能：食堂管理、商户管理、菜品管理、订单管理、用户管理。</p><h4 id="用户登录注册"><a href="#用户登录注册" class="headerlink" title="用户登录注册"></a>用户登录注册</h4><p>参考资料：<a href="https://www.liujiangblog.com/course/django/102">https://www.liujiangblog.com/course/django/102</a></p><p>在 <code>customer</code> 下 <code>view.py</code> 中加入用户登录的方法，其中 <code>locals()</code> 代表返回当前方法里的全部变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br><span class="hljs-keyword">from</span> .forms <span class="hljs-keyword">import</span> LoginForm, RegisterForm <span class="hljs-comment"># 导入表单，下面将介绍</span><br><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> messages<br><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Customer<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-comment"># 写注册方法</span><br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;customer/register.html&#x27;</span>, <span class="hljs-built_in">locals</span>())<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">login</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-comment"># 写登录方法</span><br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;customer/login.html&#x27;</span>, <span class="hljs-built_in">locals</span>())<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logout</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-comment"># 写登出方法</span><br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;customer/index.html&#x27;</span>, <span class="hljs-built_in">locals</span>())<br></code></pre></td></tr></table></figure><p>具体访问策略如下：</p><ul><li>未登录人员，不论是访问 index 还是 login 和 logout，全部跳转到 login 界面</li><li>已登录人员，访问 login 会自动跳转到 index 页面</li><li>已登录人员，不允许直接访问 register 页面，需先 logout</li><li>登出后，自动跳转到 login 界面</li></ul><p>于是，在主目录 <code>urls.py</code> 中加入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">path(<span class="hljs-string">&#x27;customer/&#x27;</span>, include(<span class="hljs-string">&#x27;customer.urls&#x27;</span>)),<br></code></pre></td></tr></table></figure><p>在 <code>customer/urls.py</code> 中加入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> .views <span class="hljs-keyword">import</span> index, login, register, logout<br><br>app_name = <span class="hljs-string">&#x27;customer&#x27;</span><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;&#x27;</span>, index),<br>    path(<span class="hljs-string">&#x27;login/&#x27;</span>, login),<br>    path(<span class="hljs-string">&#x27;register/&#x27;</span>, register),<br>    path(<span class="hljs-string">&#x27;logout/&#x27;</span>, logout),<br>]<br></code></pre></td></tr></table></figure><p>实现登录时，需要用到表单 form，创建 <code>cutomser/forms.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django <span class="hljs-keyword">import</span> forms<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginForm</span>(<span class="hljs-params">forms.Form</span>):</span><br>    username = forms.CharField(label=<span class="hljs-string">&quot;用户名&quot;</span>, max_length=<span class="hljs-number">128</span>, widget=forms.TextInput(attrs=&#123;<span class="hljs-string">&#x27;class&#x27;</span>: <span class="hljs-string">&#x27;form-control&#x27;</span>, <span class="hljs-string">&#x27;placeholder&#x27;</span>: <span class="hljs-string">&quot;Username&quot;</span>,<span class="hljs-string">&#x27;autofocus&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;),<br>                    error_messages=&#123;<span class="hljs-string">&#x27;required&#x27;</span>: <span class="hljs-string">&#x27;用户名不能为空&#x27;</span>,<span class="hljs-string">&#x27;min_length&#x27;</span>: <span class="hljs-string">&#x27;用户名最少为3个字符&#x27;</span>,<br>   <span class="hljs-string">&#x27;max_length&#x27;</span>: <span class="hljs-string">&#x27;用户名最不超过为20个字符&#x27;</span>&#125;,)<br>    password = forms.CharField(label=<span class="hljs-string">&quot;密码&quot;</span>, max_length=<span class="hljs-number">256</span>, widget=forms.PasswordInput(attrs=&#123;<span class="hljs-string">&#x27;class&#x27;</span>: <span class="hljs-string">&#x27;form-control&#x27;</span>,<span class="hljs-string">&#x27;placeholder&#x27;</span>: <span class="hljs-string">&quot;Password&quot;</span>&#125;))<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegisterForm</span>(<span class="hljs-params">forms.Form</span>):</span><br>    username = forms.CharField(label=<span class="hljs-string">&quot;用户名&quot;</span>, max_length=<span class="hljs-number">128</span>, widget=forms.TextInput(attrs=&#123;<span class="hljs-string">&#x27;class&#x27;</span>: <span class="hljs-string">&#x27;form-control&#x27;</span>, <span class="hljs-string">&#x27;placeholder&#x27;</span>: <span class="hljs-string">&quot;Username&quot;</span>,<span class="hljs-string">&#x27;autofocus&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;))<br>    password1 = forms.CharField(label=<span class="hljs-string">&quot;密码&quot;</span>, max_length=<span class="hljs-number">256</span>, widget=forms.PasswordInput(attrs=&#123;<span class="hljs-string">&#x27;class&#x27;</span>: <span class="hljs-string">&#x27;form-control&#x27;</span>,<span class="hljs-string">&#x27;placeholder&#x27;</span>: <span class="hljs-string">&quot;Password&quot;</span>&#125;))<br>    password2 = forms.CharField(label=<span class="hljs-string">&quot;确认密码&quot;</span>, max_length=<span class="hljs-number">256</span>, widget=forms.PasswordInput(attrs=&#123;<span class="hljs-string">&#x27;class&#x27;</span>: <span class="hljs-string">&#x27;form-control&#x27;</span>,<span class="hljs-string">&#x27;placeholder&#x27;</span>: <span class="hljs-string">&quot;Password&quot;</span>&#125;))<br>    tel = forms.CharField(label=<span class="hljs-string">&quot;电话&quot;</span>, widget=forms.TextInput(attrs=&#123;<span class="hljs-string">&#x27;class&#x27;</span>: <span class="hljs-string">&#x27;form-control&#x27;</span>, <span class="hljs-string">&#x27;placeholder&#x27;</span>: <span class="hljs-string">&quot;TEL&quot;</span>&#125;))<br></code></pre></td></tr></table></figure><p>其他诸如 session(会话) 的内容默认已经配置好了（session 是用于保存当前在线用户信息的，用于各种与用户关联的查询），现在可以打开页面查看登录。</p><h4 id="食堂、窗口、菜品展示"><a href="#食堂、窗口、菜品展示" class="headerlink" title="食堂、窗口、菜品展示"></a>食堂、窗口、菜品展示</h4><p>在相应的 views.py 中写好 ORM 方法，将数据库内的表元组全部传到 Django，再到 templates 中写好 html，将传出的元组以循环遍历显示。</p><p>例如显示食堂和窗口，在 <code>canteen/views.py</code> 写入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Canteen, Shop<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_canteen</span>(<span class="hljs-params">request</span>):</span><br>    template_name = <span class="hljs-string">&#x27;canteen/canteen_list.html&#x27;</span><br>    context = &#123;<span class="hljs-string">&#x27;canteen_list&#x27;</span>: Canteen.objects.<span class="hljs-built_in">all</span>()&#125;<br>    <span class="hljs-keyword">return</span> render(request, template_name, context)<br></code></pre></td></tr></table></figure><p>再到 canteen_list.html 中写下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% block store_content %&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>            &#123;% for i in canteen_list %&#125;<br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;align-items-stretch&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card cardmodify cardbackground&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-header&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>&#123;&#123; i.canteen_name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-img-top&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&#123;&#123; i.canteen_photo.url &#125;&#125;&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>&#123;&#123; i.canteen_active &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>卫生等级：&#123;&#123; i.sanitation_level &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            &#123;% endfor %&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure><p>再修改相应的路由，就能在页面中以卡片的形式展示食堂了！样式代码来自 GitHub 的其他开源项目。</p><p>然而，这样只能实现所有食堂、所有窗口、所有菜品在一个静态页面中的显示，无法根据用户选中某个食堂而显示其对应的窗口。于是，本项目中采用了一个取巧的方法，利用 HTML 的锚定位和 <code>id</code> 属性，选中某个食堂跳转到窗口页的相应 <code>id</code> 处，让用户「看似」进入了该食堂独立的页面。</p><h4 id="用户下单"><a href="#用户下单" class="headerlink" title="用户下单"></a>用户下单</h4><p>这里用到了 <code>reverse</code> 方法，也是全项目卡住最久的地方，需要在 Model 中定义如下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_order_url</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">return</span> reverse(<span class="hljs-string">&quot;dish:get_order&quot;</span>, kwargs=&#123;<span class="hljs-string">&#x27;dish_id&#x27;</span>: self.dish_id&#125;)<br></code></pre></td></tr></table></figure><p>这意味着当用户点击按钮时，触发 <code>get_order_url</code> 方法，该方法将传入的 <code>dish_id</code> 转发到 <code>dish/views.py</code> 中的 <code>get_order</code> 方法，再进行处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_order</span>(<span class="hljs-params">request, dish_id</span>):</span><br>    dish = get_object_or_404(Dish, dish_id=dish_id)<br>    user_id = request.session[<span class="hljs-string">&#x27;user_id&#x27;</span>]<br><br>    <span class="hljs-keyword">try</span>:<br>        user = Customer.objects.<span class="hljs-built_in">filter</span>(customer_id=user_id).first()<br>        order = Orders.objects.create(dish=dish, customer=user)<br>        order.order_price = order.dish.dish_price<br>        order.order_status = <span class="hljs-number">0</span><br>        order.save()<br>        messages.success(request, <span class="hljs-string">&#x27;下单成功！&#x27;</span>)<br>        <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&quot;dish:show_order&quot;</span>)<br><br>    <span class="hljs-keyword">except</span> ObjectDoesNotExist:<br>        messages.warning(request, <span class="hljs-string">&quot;你还没有订单哦~&quot;</span>)<br>        <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&quot;dish:show_order&quot;</span>)<br></code></pre></td></tr></table></figure><p>相应的按钮触发事件还需要在 HTML 标签中指出，这里不再赘述。</p><h4 id="其他页面"><a href="#其他页面" class="headerlink" title="其他页面"></a>其他页面</h4><p>诸如订单页面、个人中心页面等，实现方法都是用 ORM 筛选数据库中当前用户的数据，并用模板显示出来。需要注意的是，进入该界面前要先判断，如果未登录则重定向至登录界面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> request.session.get(<span class="hljs-string">&#x27;is_login&#x27;</span>, <span class="hljs-literal">None</span>):<br>    messages.warning(request, <span class="hljs-string">&quot;请先登录顾客账户~&quot;</span>)<br>    <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">&#x27;/customer/login/&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="优化后台管理"><a href="#优化后台管理" class="headerlink" title="优化后台管理"></a>优化后台管理</h4><p>在 <code>admin.py</code> 里修改显示内容，使后台展示更全面。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DishAdmin</span>(<span class="hljs-params">admin.ModelAdmin</span>):</span><br>    list_per_page = <span class="hljs-number">10</span><br>    search_fields = [<span class="hljs-string">&#x27;dish_name&#x27;</span>]<br>    list_display = [<span class="hljs-string">&#x27;dish_id&#x27;</span>, <span class="hljs-string">&#x27;dish_name&#x27;</span>, <span class="hljs-string">&#x27;shop&#x27;</span>, <span class="hljs-string">&#x27;dish_price&#x27;</span>, <span class="hljs-string">&#x27;dish_active&#x27;</span>]<br></code></pre></td></tr></table></figure><p>就可以在后台显示详细信息，并加入搜索框，可以根据菜品名搜索。</p><p>此外，开源资源中还有许多对 Django Admin 的 UI 优化插件，例如 simpleui，只需在 app 中包含即可。</p><h2 id="页面展示"><a href="#页面展示" class="headerlink" title="页面展示"></a>页面展示</h2><p><img src="/img/blog/DB-Project-images/page1.png" alt="菜品展示界面"></p><p><img src="/img/blog/DB-Project-images/page2.png" alt="用户登录界面"></p><p><img src="/img/blog/DB-Project-images/page3.png" alt="订单展示界面"></p><p><img src="/img/blog/DB-Project-images/page4.png" alt="后台管理界面"></p><p><img src="/img/blog/DB-Project-images/page5.png" alt="后台操作演示"></p>]]></content>
    
    
    <categories>
      
      <category>项目经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统 应试笔记</title>
    <link href="/Database-System.html"/>
    <url>/Database-System.html</url>
    
    <content type="html"><![CDATA[<p>该笔记（思维导图）是本人于哈尔滨工业大学（深圳）2021 年秋季学期「数据库系统」课程的笔记，由于试卷较为变态，最后只考了 91 分，教学班排名 2/99。</p><p>由于笔记是在考前复习时才逐渐整理的，笔记内容偏<strong>应试风格</strong>，主要按照课程学习的顺序和考试内容梳理（由于 SQL 部分在实验中考察，考试不涉及），涵盖了课程所学，主要包括：数据库基础概念、数据库设计、数据库实现、数据库事务处理。</p><p>为什么是<strong>思维导图</strong>？因为「数据库」这门课涵盖的内容太多了，简直是进阶版的「计算机导论」，甚至连数据结构、算法设计、操作系统都有涉及，线性地整理笔记似乎不太适合记忆。</p><p>当然，<a href="https://github.com/ailanxier">Ailanxier</a> 用 Markdown 整理的 <a href="https://github.com/ailanxier/Database-System-Note">笔记</a> 也很棒，很多老师上课没讲清楚的点都有解释，配合本文的思维导图复习可能更高效。</p><blockquote><p>图片较大，加载可能比较缓慢，推荐保存下来使用。如需分享，请注明出处！</p></blockquote><h2 id="数据库基础概念"><a href="#数据库基础概念" class="headerlink" title="数据库基础概念"></a>数据库基础概念</h2><p>主要内容包含：</p><ul><li>基本概念</li><li>关系模型与关系运算</li><li>完整性和安全性</li><li>SQL 语句（不考）</li></ul><p><img src="/img/blog/Database-System-images/数据库基础.png" alt="数据库基础"></p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>主要内容包含：</p><ul><li>数据建模</li><li>数据库设计过程</li><li>函数依赖及其公理定理</li><li>关系范式及模式分解</li></ul><p><img src="/img/blog/Database-System-images/数据库设计.png" alt="数据库设计"></p><h2 id="数据库实现"><a href="#数据库实现" class="headerlink" title="数据库实现"></a>数据库实现</h2><p>主要内容包含：</p><ul><li>数据库物理存储</li><li>数据库索引技术</li><li>查询实现算法</li><li>查询优化技术</li></ul><p><img src="/img/blog/Database-System-images/数据库实现.png" alt="数据库实现"></p><h2 id="数据库事务处理"><a href="#数据库事务处理" class="headerlink" title="数据库事务处理"></a>数据库事务处理</h2><p>主要内容包含：</p><ul><li>并发控制</li><li>故障处理</li></ul><p><img src="/img/blog/Database-System-images/数据库事务处理.png" alt="数据库事务处理"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>本科课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PR学习笔记 #4 概率密度：非参数估计</title>
    <link href="/PR-Note-4.html"/>
    <url>/PR-Note-4.html</url>
    
    <content type="html"><![CDATA[<p>上一节介绍了概率密度的 <a href="https://hwcoder.top/PR-Note-3">参数估计</a> 方法，并以最常见的正态分布为例推导了计算公式。然而，并不是所有的<strong>分布</strong>都可以提前假设的。</p><p>当我们观测样本后，发现其概率密度分布的形式不典型时，就需要用到<strong>非参数估计</strong>方法。</p><h2 id="非参数估计-Nonparametric-Estimation"><a href="#非参数估计-Nonparametric-Estimation" class="headerlink" title="非参数估计 | Nonparametric Estimation"></a>非参数估计 | Nonparametric Estimation</h2><p>非参数估计就是在概率密度<strong>形式未知</strong>，根据样本点 $X_1,X_2,\cdots,X_n$ <strong>直接推断</strong>出概率密度<strong>函数本身</strong>的过程。</p><p>回顾前文的贝叶斯分类，我们知道如果属性 $A_k$ 是离散的，可以直接用 $a_k$ 在类别中的比例估计之。这时，我们通常需要大量的样本与监督学习。</p><blockquote><p>这种思想也可以延申到连续属性的 Histogram Algorithm (直方图算法)：将连续的浮点特征值离散化为 $K$ 个整数，将特征值的取值范围分割为 $K$ 个区间。遍历数据，根据浮点值落在区间的样本数在直方图中累计统计量。</p><p>这种方法在 LightGBM 中得到应用，使得内存占用更小（只保存离散化后的值）和计算代价更小（决策树分裂的代价）。</p></blockquote><p>而在非参数估计中，我们也是基于<strong>统计</strong>的思想——若在概率密度函数 $p(x)$ 中固定区间 $R$，则随机变量 $x$ 落入区间 $R$ 的概率为：</p><script type="math/tex; mode=display">P=\int_R{p\left( x \right) \mathrm{d}x}</script><p>当区间 $R$ 足够小时，我们可以认为 $p(x)$ 在区间内保持不变，记<strong>区间体积</strong>为 $V$，上式转化为：</p><script type="math/tex; mode=display">P=\int_R{p\left( x \right) \mathrm{d}x}=p(x)V</script><p>当然，上述概率是在已知 $p(x)$ 的情况下求得。对于<strong>总样本数</strong>为 $N$ 的数据集中，我们可以用<strong>落在区间中的样本数</strong> $k$ 来近似估计：</p><script type="math/tex; mode=display">\hat{P}\approx \frac{k}{N}</script><p>从而我们可以得到 $p(x)$ 的近似估计：</p><script type="math/tex; mode=display">\hat{p}\left( x \right) \approx \frac{k/V}{N}</script><blockquote><p>当样本数量趋于无限时，$\hat{p}\left( x \right)$ <strong>依概率收敛</strong>于 $p(x)$，当且仅当满足下列条件：</p><script type="math/tex; mode=display">\underset{N\rightarrow \infty}{\lim}V_N=0  ,\quad \underset{N\rightarrow \infty}{\lim}k_N=\infty ,\quad \underset{N\rightarrow \infty}{\lim}\frac{k_N}{N}=0</script></blockquote><p>下面介绍的两种方法，是非参数估计的具体实现，分别依赖于估计式中 $V$ 和 $k$。</p><h2 id="Parzen-窗法"><a href="#Parzen-窗法" class="headerlink" title="Parzen 窗法"></a>Parzen 窗法</h2><p>Parzen 窗法的核心是：$V$ 不变，$k$ 可变。通过选取固定大小的「<strong>窗</strong>」，使其遍布整个空间，并估算每个窗的 $\hat{p}\left( x \right) $ 作为窗中心的概率密度。</p><p>假设 $d$ 维空间中的<strong>样本点</strong>为 $x=\left[u_{1}, u_{2}, \ldots, u_{d}\right]^{T}$ ，且空间中每个<strong>小窗</strong>是一个<strong>超立方体</strong>，它在每一维的棱长都为 $h$，则小窗的体积是:</p><script type="math/tex; mode=display">V=h^d</script><p> 要计算每个小窗内落入的样本数目，可以定义如下的 $d$ 维<strong>单位方窗函数</strong>：</p><script type="math/tex; mode=display">\varphi\left(\left[u_{1}, u_{2}, \ldots, u_{d}\right]^{T}\right)=\left\{\begin{array}{lc}1 & \text { 若 }\left|u_{j}\right| \leqslant  \frac{1}{2}, j=1,2, \cdots, d \\0 & \text { 其他 }\end{array}\right.</script><p><img src="/img/blog/PR-Note-4-images/window-1.png" alt="一维方窗函数" width=20% /></p><p>该函数在以<strong>原点</strong>为中心的 $d$ 维单位超立方体内取值为 1，在其他地方取值为 0。对于每个样本点 $x_i$，我们只需计算 $\varphi \left( \frac{x-x_i}{h} \right) $ 就可以知道其<strong>是否落在</strong>观测点 $x$ 为中心、$h$ 为棱长的方窗内。现在共有 $N$ 个样本点，那么就有：</p><script type="math/tex; mode=display">k_{N}=\sum_{i=1}^{N} \varphi\left(\frac{x-x_{i}}{h}\right)</script><p> 将上式代入 $\hat{p}\left( x \right) \approx \frac{k/V}{N}$ 中有：</p><script type="math/tex; mode=display">\hat{p}\left( x \right) \approx \frac{1}{N V} \sum_{i=1}^{N} \varphi\left(\frac{x-x_{i}}{h}\right)</script><p>或者，我们将 $V$ 放入求和号中，并定义非单位的<strong>方窗函数</strong>（<strong>核函数</strong>）如下：</p><script type="math/tex; mode=display">K\left(x, x_{i}\right)=\frac{1}{V} \varphi\left(\frac{x-x_{i}}{h}\right)</script><p>核函数反映了在<strong>方窗情形</strong>下，任意一个样本点 $x_i$ 对于观测点 $x$ 处的概率密度的「<strong>贡献</strong>」。而我们要计算的的概率密度函数，就可以看作是所有样本点对观测点的贡献进行平均：</p><script type="math/tex; mode=display">\hat{p}\left( x \right) \approx \frac{1}{N} \sum_{i=1}^{N}K\left(x, x_{i}\right)</script><h3 id="核函数的选取"><a href="#核函数的选取" class="headerlink" title="核函数的选取"></a>核函数的选取</h3><p>超立方体的棱角带来了一些数据处理上的不合理，如果改用<strong>超球体</strong>，则可以得到<strong>超球窗函数</strong>：</p><script type="math/tex; mode=display">K\left(x, x_{i}\right)=\left\{\begin{array}{cc}V^{-1} & \text { 若 }|| x-x_{i} \| \leqslant  \rho \\0 & \text { 其他 }\end{array}\right.</script><p>其中，距离的度量采用了<strong>范数</strong>，$\rho $ 为超球体的半径。仅当样本点落在超球体内时，其对概率密度有贡献。</p><p>然而，方窗和超球窗都有一个不足之处：忽略了<strong>距离</strong>这一特征。所有落在区域内的样本点一视同仁，而其他点则都被忽视，这就导致了 $h$ 和 $\rho$ 的取值对结果的影响很大。宽度过大会使得<strong>分辨率</strong>变低，而宽度过小则<strong>不平滑效应</strong>明显。</p><p>因此，我们考虑用连续函数计算贡献，只需要满足以下两点：</p><ol><li>任意点处<strong>贡献不为负</strong>：$K\left(x, x_{i}\right)\geqslant 0$</li><li>任一样本点对整个空间的<strong>总贡献之和</strong>为 1：$\int K\left(x, x_{i}\right)\mathrm{d}x=1$</li></ol><p>这样可以确保最终估算出的 $\hat{p}\left( x \right)$ 的总和也为 1。由此，我们引入<strong>正态窗函数</strong>（高斯窗函数）：</p><script type="math/tex; mode=display">K\left(x, x_{i}\right)=\frac{1}{\sqrt{(2 \pi)^{d} \rho^{2 d}|Q|}} \exp \left\{-\frac{1}{2} \frac{\left(x-x_{i}\right)^{T} Q^{-1}\left(x-x_{i}\right)}{\rho^{2}}\right\}</script><p>即以样本 $x_i$ 为均值、协方差矩阵为 $\Sigma=\rho^{2} Q$ 的高维正态分布函数。</p><p><img src="/img/blog/PR-Note-4-images/window-2.png" alt="一维正态窗函数" width=20% /></p><p>同理，还有指数窗函数：</p><script type="math/tex; mode=display">K\left(x, x_{i}\right)=\exp \left\{-\frac{1}{2} || x-x_{i} \|\right\}</script><p><img src="/img/blog/PR-Note-4-images/window-3.png" alt="一维指数窗函数" width=20% /></p><h2 id="KNN-法"><a href="#KNN-法" class="headerlink" title="KNN 法"></a>KNN 法</h2><p>K 近邻法的核心是：$k$ 不变，$V$ 可变。固定每一个「窗」中落入的<strong>样本数</strong>，而窗本身的<strong>体积可变化</strong>，并估算每个窗的 $\hat{p}\left( x \right) $ 作为窗中心的概率密度。</p><p>假设 $d$ 维空间中的<strong>样本点</strong>为 $x=\left[u_{1}, u_{2}, \ldots, u_{d}\right]^{T}$ ，具体的做法是先选定一个 $k_N$，再在点 $x$ 的周围，不断扩大窗的体积，直到捕捉到 $k_N$ 个样本为止。</p><blockquote><p>通常取 $k_N=\sqrt{N}$，窗的形状选择超球窗，半径为第 $k_N$ 个近邻点到样本点的距离。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>模式识别</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
      <tag>PR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PR学习笔记 #3 概率密度：参数估计</title>
    <link href="/PR-Note-3.html"/>
    <url>/PR-Note-3.html</url>
    
    <content type="html"><![CDATA[<p>在前文的 <a href="https://hwcoder.top/PR-Note-2">贝叶斯分类器</a> 中，我们简单介绍了先验概率 $P\left( \omega ^{\left( j \right)} \right)$ 和似然概率 $P\left( x \mid \omega ^{\left( j \right)} \right)$ 的估计方法。</p><p>其中似然概率，也称为<strong>类条件概率密度</strong>（Class Conditional Probability Density），即分布<strong>取决于类别状态</strong>的一种概率密度。</p><p>抛开「类别」不谈，「似然概率的估计」其实就是一个「<strong>概率密度的估计</strong>」问题。下面我们将介绍，对于连续取值的 $x$，如何刻画一个已知形式的概率密度函数。</p><h2 id="参数估计-Parameter-Estimation"><a href="#参数估计-Parameter-Estimation" class="headerlink" title="参数估计 | Parameter Estimation"></a>参数估计 | Parameter Estimation</h2><p>参数估计是在概率密度的<strong>形式已知</strong>（假设其服从某种分布）的情况下，根据样本点 $X_1,X_2,\cdots,X_n$ 推断出其中未知参数 $\theta$ 的过程。</p><p>用来估计未知参数 $\theta$ 的<strong>统计量</strong> $\hat{\theta}=\hat{\theta}\left(X_{1}, X_{2}, \cdots, X_{n}\right)$ 称为 $\theta$ 的<strong>点估计</strong>（Point Estimation），如果只是估计 $\theta$ 的取值范围，也称<strong>区间估计</strong>（Interval Estimation）。</p><blockquote><p>在贝叶斯分类器中，每个类别都有自己对应的似然概率，因此<strong>每个类别</strong>都需要估计其概率密度函数（包括 $x$ 离散和连续的情形，本节只介绍连续情形，离散同理）。</p><p>此外，在有限数目的样本中，样本所属的类别还可能是未知的，即无监督估计，本节也不加以讨论。</p></blockquote><p>下面我们以<strong>一维正态分布</strong> $N(\mu,\sigma^2)$ 的参数估计为例，介绍三种方法：矩估计、极大似然估计、贝叶斯估计。</p><blockquote><p>对于高维的 $X$，即当每个样本有多个特征时，可以分别求出各个特征的似然概率，再朴素地相乘得到 $X$ 的似然概率；也可以假设其符合<strong>高维正态分布</strong>：</p><script type="math/tex; mode=display">P\left( X\mid \omega ^{\left( j \right)} \right) =\frac{1}{(2\pi )^{\frac{d}{2}}|\mathbf{\Sigma }|^{\frac{1}{2}}}\exp \left[ -\frac{1}{2}(X-\mu )^T\mathbf{\Sigma }^{-1}(X-\mu ) \right]</script><p>其中 $\mathbf{\Sigma }$ 代表<strong>协方差矩阵</strong>，一个对称矩阵，对角线外的元素表示了 $X$ 的各列分量之间的协方差（线性相关程度），决定了高维正态分布的形状。</p></blockquote><h2 id="矩估计-Moment-Estimation"><a href="#矩估计-Moment-Estimation" class="headerlink" title="矩估计 | Moment Estimation"></a>矩估计 | Moment Estimation</h2><p>矩估计是最原始最直观的估计方法，首先介绍有关「矩」的两组定义：</p><blockquote><p>设 $X$ 为随机变量，$k$ 为整数，设 $\mathbb{E} X^{k}$，$\mathbb{E}(X-\mathbb{E} X)^{k}$ 存在且有限，则我们分别称</p><script type="math/tex; mode=display">\mu_{k}=\mathbb{E} X^{k}, \quad \sigma_{k}=\mathbb{E}(X-\mathbb{E} X)^{k}</script><p>为 $X$ 的 $k$ 阶总体（原点) 矩，$k$ 阶总体中心矩。</p><p>设 $X_{1}, X_{2}, \ldots, X_{n}$ 为总体 $X$ 的一个样本，$k$ 为整数，则我们分别称</p><script type="math/tex; mode=display">A_{k}=\frac{1}{n} \sum_{i=1}^{n} X^{k}, \quad B_{k}=\frac{1}{n} \sum_{i=1}^{n}(X-\bar{X})^{k}</script><p>为 $X$ 的 $k$ 阶样本 (原点) 矩，$k$ 阶样本中心矩。</p></blockquote><p>我们知道当 $X$ 的概率密度函数为 $f(x,\theta)$ 时，$k$ 阶总体矩可以由参数决定：</p><script type="math/tex; mode=display">\mu_{k}=\mathbb{E} X^{k}=\int x^{k} f(x, \theta) d x</script><p>反之，通常参数 $\theta$ 也可以表示为各阶总体矩 $\mu_k$ 的函数，而根据大数定律，样本矩 $A_k$ <strong>依概率收敛于</strong>总体矩 $\mu_{k}$。因此参数可以用<strong>各阶样本矩</strong>来估计：</p><script type="math/tex; mode=display">\hat{\theta}_{n}:=\theta\left(A_{1}, A_{2}, \cdots, A_{m}\right)</script><h3 id="正态分布的矩估计"><a href="#正态分布的矩估计" class="headerlink" title="正态分布的矩估计"></a>正态分布的矩估计</h3><p>现在回到正态分布 $N(\mu,\sigma^2)$ 的问题，注意到总体矩：</p><script type="math/tex; mode=display">\mu_{1}=\mathbb{E} X=\mu, \quad \mu_{2}=\mathbb{E} X^{2}=\mu_{1}^{2}+\sigma^{2}</script><p>提出参数 $\mu$ 和 $\sigma$，<strong>用样本矩代替总体矩</strong>，可以得到参数的矩估计量为：</p><script type="math/tex; mode=display">\begin{aligned}\hat{\mu}&=A_{1}=\bar{X} \\\hat{\sigma}^{2}&=A_{2}-A_{1}^{2}=\frac{1}{n} \sum_{i=1}^{n} X_{i}^{2}-\bar{X}^{2}=\frac{1}{n} \sum_{i=1}^{n}\left(X_{i}-\bar{X}\right)^{2}\end{aligned}</script><h2 id="极大似然估计-Maximum-Likelihood-Estimation"><a href="#极大似然估计-Maximum-Likelihood-Estimation" class="headerlink" title="极大似然估计 | Maximum Likelihood Estimation"></a>极大似然估计 | Maximum Likelihood Estimation</h2><p>极大似然估计的思想：参数 $\theta$ 应是使得<strong>事件组</strong>最容易发生的值。因此对于已发生的事件组 $(X_1,X_2,\cdots,X_n)=(x_1,x_2,\cdots,x_n)$，我们知道其发生的<strong>联合</strong>概率函数为：</p><script type="math/tex; mode=display">\prod_{i=1}^{n} f\left(x_{i}, \theta\right)</script><p>而我们要做的就是找出参数 $\theta$，使得上述概率<strong>最大化</strong>。因此我们将之看作 $\theta$ 的函数，称之为<strong>极大似然函数</strong>：</p><script type="math/tex; mode=display">L(\theta) = \prod_{i=1}^{n} f\left(x_{i}, \theta\right)</script><p>要求上式的极大值点，我们考虑其<strong>对数</strong>形式简化计算：</p><script type="math/tex; mode=display">l(\theta)=\ln L(\theta)=\sum_{i=1}^{n} \ln f\left(x_{i}, \theta\right)</script><p>此时，我们可以用微积分方法求极值，即考虑求解<strong>极大似然方程</strong>：</p><script type="math/tex; mode=display">\frac{\partial \ln l}{\partial \theta}=0</script><h3 id="正态分布的极大似然估计"><a href="#正态分布的极大似然估计" class="headerlink" title="正态分布的极大似然估计"></a>正态分布的极大似然估计</h3><p>现在回到正态分布 $N(\mu,\sigma^2)$ 的问题，其似然函数为：</p><script type="math/tex; mode=display">\begin{aligned}L\left(\mu, \sigma^{2}\right) &=\prod_{i=1}^{n}\left[\frac{1}{\sqrt{2 \pi} \sigma} \exp \left(-\frac{\left(x_{i}-\mu\right)^{2}}{2 \sigma^{2}}\right)\right] \\&=\left(2 \pi \sigma^{2}\right)^{-\frac{n}{2}} \exp \left(-\frac{1}{2 \sigma^{2}} \sum_{i=1}^{n}\left(x_{i}-\mu\right)^{2}\right)\end{aligned}</script><p>考虑 $L$ 的对数，有：</p><script type="math/tex; mode=display">\ln L\left(\mu, \sigma^{2}\right)=-\frac{n}{2} \ln \left(2 \pi \sigma^{2}\right)-\frac{1}{2 \sigma^{2}} \sum_{i=1}^{n}\left(x_{i}-\mu\right)^{2}</script><p>于是，似然方程组为：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}\begin{aligned}\frac{\partial \ln L}{\partial \mu}=\frac{1}{\sigma^{2}} \sum_{i=1}^{n}\left(x_{i}-\mu\right)=0 \end{aligned}\\\begin{aligned}\frac{\partial \ln L}{\partial \sigma^{2}}=-\frac{n}{2 \sigma^{2}}+\frac{1}{2 \sigma^{4}} \sum_{i=1}^{n}\left(x_{i}-\mu\right)^{2}=0\end{aligned}\end{array}\right.</script><p>解得：</p><script type="math/tex; mode=display">\begin{aligned}&\hat{\mu}=\frac{1}{n} \sum_{i=1}^{n} x_{i}=\bar{x} \\&\hat{\sigma}^{2}=\frac{1}{n} \sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)^{2}\end{aligned}</script><h2 id="贝叶斯估计-Bayes-Estimation"><a href="#贝叶斯估计-Bayes-Estimation" class="headerlink" title="贝叶斯估计 | Bayes Estimation"></a>贝叶斯估计 | Bayes Estimation</h2><p>贝叶斯估计的思想：将未知参数当作随机变量，不关注其值为多少，而是对其取值赋予相应的<strong>概率</strong>。如贝叶斯分类一般，我们首先假设参数 $\theta$ 在其<strong>取值空间</strong> $\varTheta $ 上具有<strong>先验分布</strong> $\rho \left( \theta \right) $。</p><p>再从其样本集 $X$ 中得到<strong>样本联合分布</strong>（似然分布）：</p><script type="math/tex; mode=display">\rho \left( X\mid \theta \right) =\prod_{i=1}^n{\rho \left( x_i\mid \theta \right)}=\prod_{i=1}^n{f\left( x_i,\theta \right)}</script><blockquote><p>注：这里好像有点循环论证的感觉了？但此时的似然分布用的是条件独立的概率乘法公式求得。</p></blockquote><p>根据贝叶斯公式可以计算<strong>后验分布</strong>：</p><script type="math/tex; mode=display">\rho (\theta \mid X)=\frac{\rho (X\mid \theta )\rho (\theta )}{\int_{\Theta}{\rho}(X\mid \theta )\rho (\theta )\mathrm{d}\theta}=\frac{\prod_{i=1}^n{\rho}\left( x_i\mid \theta \right) \rho (\theta )}{\int_{\Theta}{\prod_{i=1}^n{\rho}}\left( x_i\mid \theta \right) \rho (\theta )\mathrm{d}\theta}</script><p>此后，我们可将 $arg\max \left\{ \rho \left( \theta \mid X \right) \right\} $ 作为参数估计，也可借鉴<strong>最小风险</strong>的思想，假设决策的<strong>损失函数</strong>为 $\lambda \left( \hat{\theta},\theta \right) $，定义样本 $x$ 下的<strong>条件风险</strong>：</p><script type="math/tex; mode=display">R(\hat{\theta} \mid x)=\int_{\Theta} \lambda(\hat{\theta}, \theta) \rho(\theta \mid x)\mathrm{d}\theta</script><p>那么，当样本 $x$ 取遍<strong>样本空间</strong> $E^d$ 时，其<strong>总体期望风险</strong>为：</p><script type="math/tex; mode=display">R=\int_{E^{d}} R(\hat{\theta} \mid x) \rho(x) \mathrm{d}x</script><p>但是实际中我们无法取遍 $E^d$，只能对已有样本 $X=(x_1,x_2,\cdots,x_n)$ 求其条件风险的最小化，即：</p><script type="math/tex; mode=display">\theta^{*}=\arg \min _{\hat{\theta}} R(\hat{\theta} \mid X)=\arg \min _{\hat{\theta}} \int_{\Theta} \lambda(\hat{\theta}, \theta) \rho(\theta \mid X) \mathrm{d}\theta</script><p>在决策分类时，需要事先定义代价表，而在连续情况下，需要定义代价函数。最常用的则是平方误差代价函数，即：</p><script type="math/tex; mode=display">\lambda(\hat{\theta}, \theta)=(\theta-\hat{\theta})^{2}</script><p>经一系列计算可得，当参数估计量 $\theta^{*}$ 为样本下 $\theta$ 的条件期望时，代价最小，即：</p><script type="math/tex; mode=display">\theta^{*}=\mathbb{E}\left[ \theta \mid X \right] =\int_{\Theta} \theta \rho(\theta \mid X) \mathrm{d}\theta</script><blockquote><p>贝叶斯估计较为复杂，就不展开论证正态分布的贝叶斯估计了，感兴趣的读者可以查阅这篇 <a href="https://blog.csdn.net/linjing_zyq/article/details/120393298">博客文章</a>。这里给出结论：当样本数目趋于无穷多时，贝叶斯估计的结果与极大似然估计相同。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>模式识别</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
      <tag>PR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ML学习笔记 #3 正规方程：多元线性回归</title>
    <link href="/ML-Note-3.html"/>
    <url>/ML-Note-3.html</url>
    
    <content type="html"><![CDATA[<p>前文提到线性回归问题时，我们说在数学上也可以用最小二乘法（Least Square Method）来解决，实际上其思路也是<strong>最小化</strong>平方误差代价函数（也称<strong>残差函数</strong>）。</p><p>到目前为止，我们都在使用梯度下降算法，但是对于某些线性回归问题，最小二乘法的矩阵解法——正规方程则是更好的解决方案。</p><h2 id="正规方程-Normal-Equation"><a href="#正规方程-Normal-Equation" class="headerlink" title="正规方程 | Normal Equation"></a>正规方程 | Normal Equation</h2><p>利用多元微分学知识，我们知道对于代价函数：</p><script type="math/tex; mode=display">J(\theta)=J(\theta_0, \theta_1,\cdots, \theta_n)</script><p>如果它是<strong>连续</strong>的，则要求出它的最小值，只需要令各偏导为零：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial \theta_j}=0,\quad j=0,1,\cdots,n</script><p>或写作向量形式：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial \theta}=\vec 0</script><p>就能解出令 $J(\theta)$ 最小化的 $\theta$ 值。</p><p>由此，我们将代价函数转化为<strong>有确定解的代数方程组</strong>（其方程式数目正好等于未知数的个数），这个方程组就是正规方程（Normal Equation）。</p><h3 id="数学推导-1"><a href="#数学推导-1" class="headerlink" title="数学推导 1"></a>数学推导 1</h3><p>下面我们就对多元线性回归的代价函数进行求解：</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}\sum_{i=1}^m\left(\theta^Tx^{(i)}-y^{(i)}\right)^2</script><p>于是其偏导函数为：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial \theta}=\frac{1}{m}\sum_{i=1}^m\left(\theta^Tx^{(i)}-y^{(i)}\right)x^{(i)}</script><p>要使之为<strong>零向量</strong>，只能是：</p><script type="math/tex; mode=display">\theta^Tx^{(i)}=y^{(i)},\quad i=1,2,\cdots,m</script><p>恒成立。写作矩阵为：</p><script type="math/tex; mode=display">\theta ^TX^T=y^T\text{ ，或 }X\theta =y</script><p>其中，</p><script type="math/tex; mode=display">X_{(n+1)\times m}=\left[ \begin{matrix}    x_{0}^{(1)}&        x_{1}^{(1)}&        \cdots&        x_{n}^{(1)}\\    x_{0}^{(2)}&        x_{1}^{(2)}&        \cdots&        x_{n}^{(2)}\\    \vdots&        \vdots&        \ddots&        \vdots\\    x_{0}^{(m)}&        x_{1}^{(m)}&        \cdots&        x_{n}^{(m)}\\\end{matrix} \right] =\left[ \begin{array}{c}    {x^{(1)}}^T\\    {x^{(2)}}^T\\    \vdots\\    {x^{(m)}}^T\\\end{array} \right] ,\quad y=\left[ \begin{array}{c}    y^{(1)}\\    y^{(2)}\\    \vdots\\    y^{(m)}\\\end{array} \right]</script><p>两边同时乘以 $X^T$，假设 $X^TX$ 可逆，解得：</p><script type="math/tex; mode=display">\theta=(X^TX)^{-1}X^Ty</script><h3 id="数学推导-2"><a href="#数学推导-2" class="headerlink" title="数学推导 2"></a>数学推导 2</h3><p>前面的推导中，在<strong>向量形式</strong>的偏导函数中发现了简化条件，将零向量提出来单独求解。下面介绍另一个<strong>纯矩阵形式</strong>的解法。</p><p>首先将代价函数表示为：</p><script type="math/tex; mode=display">\begin{aligned}    J(\theta )&=\frac{1}{2m}\left( X\theta -y \right) ^T\left( X\theta -y \right)\\    &=\frac{1}{2}\left( \theta ^TX^T-y^T \right) \left( X\theta -y \right)\\    &=\frac{1}{2}\left( \theta ^TX^TX\theta -\theta ^TX^Ty-y^TX\theta +y^Ty \right)\\\end{aligned}</script><p>接下来对 $J(\theta )$ 求偏导，需要用到<strong>矩阵的求导法则</strong>（证明过程略去不表）：</p><blockquote><ol><li><p>当 $f(x) = Ax$ 时，</p><script type="math/tex; mode=display">\frac{\partial f (x)}{\partial x^T}  = \frac{\partial (Ax)}{\partial x^T}  =A</script></li><li><p>当 $f(x) = x^TAx$ 时，</p><script type="math/tex; mode=display">\frac{\partial f (x)}{\partial x}  = \frac{\partial (x^TAx)}{\partial x}  =Ax+A^Tx</script></li><li><p>当 $f(x) = a^Tx$ 时，</p><script type="math/tex; mode=display">\frac{\partial a^Tx}{\partial x}  = \frac{\partial x^Ta}{\partial x}  =a</script></li><li><p>当 $f(x) = x^TAy$ 时，</p><script type="math/tex; mode=display">\frac{\partial x^TAy}{\partial x}  = Ay</script></li></ol></blockquote><p>分别用法则 2、4、3 求导，得到：</p><script type="math/tex; mode=display">\begin{aligned}    \frac{\partial J\left( \theta \right)}{\partial \theta}&=\frac{1}{2m}\left( 2X^TX\theta -X^Ty-(y^TX)^T+0 \right)\\    &=\frac{1}{2m}\left( 2X^TX\theta -X^Ty-X^Ty+0 \right)\\    &=\frac{1}{m}\left(X^TX\theta -X^Ty\right)\\\end{aligned}</script><p>令偏导为零，解得：</p><script type="math/tex; mode=display">\theta =\left( X^TX \right) ^{-1}X^Ty</script><h3 id="梯度下降-vs-正规方程"><a href="#梯度下降-vs-正规方程" class="headerlink" title="梯度下降 vs. 正规方程"></a>梯度下降 vs. 正规方程</h3><p>观察到在正规方程的结果中，$X^TX$ 是一个 $(n+1)\times(n+1)$ 的矩阵，因此直接取逆计算 $\theta$ 的复杂度是 $O(n^3)$ 。如果 $n$ 不是很大，这是有效的，但是如果 $n$ 达到了 $10^4,10^5$ 或更高，就需要使用梯度下降了。</p><p>下面从其他方面对两种算法进行比较：</p><div class="table-container"><table><thead><tr><th style="text-align:center">区别</th><th style="text-align:center">梯度下降</th><th style="text-align:center">正规方程</th></tr></thead><tbody><tr><td style="text-align:center">学习率 $\alpha$</td><td style="text-align:center">需要选择</td><td style="text-align:center">不需要</td></tr><tr><td style="text-align:center">迭代</td><td style="text-align:center">需要多次迭代</td><td style="text-align:center">一次运算得出</td></tr><tr><td style="text-align:center">$n$ 的取值</td><td style="text-align:center">当 $n$ 大时也能较好适用</td><td style="text-align:center">当 $n$ 小于时 $10^4$ 还是可以接受的</td></tr><tr><td style="text-align:center">特征缩放</td><td style="text-align:center">特征取值范围相差大时需要</td><td style="text-align:center">不需要缩放</td></tr><tr><td style="text-align:center">适用情形</td><td style="text-align:center">适用于各种类型的模型</td><td style="text-align:center">只适用于线性模型</td></tr></tbody></table></div><blockquote><p>这里提及适用情形，是因为随着问题的深入，算法将越发复杂。例如在分类算法中的逻辑回归等模型，就无法使用正规方程求解。</p></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面仍以 <a href="https://www.coursera.org/">Coursera</a> 上的多元线性回归数据集 <code>ex1data2.txt</code> 为例实现，代码非常简洁：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># load data, data.shape = (47, 3)</span><br>data = np.genfromtxt(<span class="hljs-string">&quot;ex1data2.txt&quot;</span>, delimiter=<span class="hljs-string">&#x27;,&#x27;</span>)<br>(m, n) = data.shape<br>X = np.c_[np.ones(m), data[:, :-<span class="hljs-number">1</span>]]<br>y = data[:, -<span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># Normal Equation</span><br>theta = np.linalg.inv(X.T @ X) @ X.T @ y<br><span class="hljs-built_in">print</span>(theta)<br><br><span class="hljs-comment"># predict</span><br>predict = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">1650</span>, <span class="hljs-number">3</span>])<br><span class="hljs-built_in">print</span>(predict @ theta)<br></code></pre></td></tr></table></figure><p>很快就计算完了，预测在 $\left( x_1=1650,x_2=3 \right) $ 时的房价为 293081.46433489426。大约相当于 3000 次梯度下降迭代的精度。</p><h3 id="不可逆情形"><a href="#不可逆情形" class="headerlink" title="不可逆情形"></a>不可逆情形</h3><p>前一节的推导基于 $X^TX$ 可逆（Invertible）的假设，如若不可逆（Non-invertible，也称 Singular），我们只需将代码中的 <code>inv()</code> 换成 <code>pinv()</code> 求出<strong>伪逆矩阵</strong>即可。</p><p>通常导致矩阵不可逆的原因可能有：</p><ul><li>存在冗余特征（特征之间不相互独立）；</li><li>特征数 $n$ 远大于样本数 $m$（样本数不足以刻画这么多特征）。</li></ul><p>解决方法对应为：</p><ul><li>删除冗余特征（线性相关特征只保留其一）；</li><li>削减非必要的特征，或<strong>正则化</strong>方法（Regularization），后文将介绍。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ML学习笔记 #2 梯度下降：多元线性回归</title>
    <link href="/ML-Note-2.html"/>
    <url>/ML-Note-2.html</url>
    
    <content type="html"><![CDATA[<p>在前文 <a href="https://hwcoder.top/ML-Note-1">一元线性回归</a> 的基础上，我们引入多个特征变量，探讨梯度下降对多元线性回归的解法。此外，下一节将介绍正规方程在解多元线性回归中的应用。</p><h2 id="多元线性回归-Multiple-Linear-Regression"><a href="#多元线性回归-Multiple-Linear-Regression" class="headerlink" title="多元线性回归 | Multiple Linear Regression"></a>多元线性回归 | Multiple Linear Regression</h2><p>现在我们的样本点 $\left(x^{(i)}, y^{(i)}\right)$ 有多个特征作为<strong>输入变量</strong>，即给定的数据集为：</p><script type="math/tex; mode=display">\left\{\left(x_1^{(i)},x_2^{(i)},\cdots,x_n^{(i)},y^{(i)}\right),\;i=1,2,\cdots,m\right\}</script><ul><li>$n$ 代表单个样本的特征数量；</li><li>${x}^{(i)}$ 代表第 $i$ 个观察实例的<strong>特征向量</strong>；</li><li>$x^{(i)}_j$ 代表第 $i$ 个观察实例的第 $j$ 个<strong>特征分量</strong>。</li></ul><p>同时，回归方程 $h$ 也具有多个参数 $\theta_0,\theta_1,\cdots,\theta_n$：</p><script type="math/tex; mode=display">h_\theta(x)=\theta_0+\theta_1x_1\cdots+\theta_nx_n</script><p>为简化表达式，这里假定 $x_0 \equiv 1$ ，并以<strong>向量</strong>（vector）表示参数和自变量：$\theta=(\theta_0,\cdots,\theta_n)^T,\;x=(x_0,\cdots,x_n)^T$，得到：</p><script type="math/tex; mode=display">h_\theta(x)=\theta^Tx</script><h3 id="多变量梯度下降"><a href="#多变量梯度下降" class="headerlink" title="多变量梯度下降"></a>多变量梯度下降</h3><p>类似地，我们定义平方误差代价函数：</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}\sum_{i=1}^m\left(\theta^Tx^{(i)}-y^{(i)}\right)^2</script><p>我们的目标和一元线性回归中一样，要找出使得代价函数最小的一系列参数。于是，</p><script type="math/tex; mode=display">\frac{\partial J}{\partial \theta}=\frac{1}{m}\sum_{i=1}^m\left(\theta^Tx^{(i)}-y^{(i)}\right)x^{(i)}</script><p>梯度下降时，不断作迭代：</p><script type="math/tex; mode=display">\theta:=\theta-\alpha\cdot\frac{\partial J}{\partial \theta}</script><p>即可。</p><h3 id="特征缩放与标准化-Standardization"><a href="#特征缩放与标准化-Standardization" class="headerlink" title="特征缩放与标准化 | Standardization"></a>特征缩放与标准化 | Standardization</h3><p>当不同自变量取值范围相差较大时，绘制的<strong>等高线图</strong>上的椭圆会变得瘦长，而梯度下降<strong>算法收敛</strong>将会很慢，因为每一步都可能会跨过这个椭圆导致<strong>振荡</strong>。这里略去数学上的证明。同理，所有依赖于「<strong>距离计算</strong>」的机器学习算法也会有此问题。</p><p>此时，我们需要把所有<strong>自变量</strong>（除了假定的 $x_0$）进行缩放、标准化，使其落在 -1 到 1 之间。最简单的方法是，置：</p><script type="math/tex; mode=display">x_i^{(j)}:=\frac{x_i^{(j)}-\mu_i}{\sigma_i}</script><p>其中，$\mu_i=\frac{1}{m}\sum\limits_{j=1}^m x_i^{(j)}$ 是样本<strong>均值</strong>（Mean Value），$\sigma_i=\sqrt{\frac{\sum\limits_{j=1}^m\left(x_i^{(j)}-\mu_i\right)^2}{m-1}}$ 是样本<strong>无偏标准差</strong>（Unbiased Standerd Deviation），就完成了<strong>标准化</strong>（Standardization）。标准化后样本均值为 0，方差为 1，但不一定是标准正态分布（与其原始分布有关），根据中心极限定理可以推出。</p><p>需要注意的是，<strong>因变量</strong>不需要标准化，否则计算的结果将失真。且如果进行了标准化，对所有<strong>待测</strong>样本点也需要进行一样的操作，参数才能生效。</p><blockquote><p>此外，线性回归并不适用于所有情形，有时我们需要曲线来适应我们的数据，这时候我们也要对特征进行<strong>构造</strong>，如二次函数、三次函数、幂函数、对数函数等。构造后的新变量就可以当作一个新的特征来使用，这就是<strong>多项式回归</strong>（Polynomial Regression）。新变量的取值范围可能更大，此时，特征缩放就非常有必要！</p></blockquote><h3 id="归一化-Normalization"><a href="#归一化-Normalization" class="headerlink" title="归一化 | Normalization"></a>归一化 | Normalization</h3><p>人们经常会混淆标准化（Standardization）与<strong>归一化</strong>（Normalization）的概念，这里也简单提一下：归一化的目的是找到某种映射关系，将原数据<strong>固定映射</strong>到某个区间 $[a,b]$ 上，而标准化则没有限制。</p><p>归一化最常用于把有量纲数转化为<strong>无量纲数</strong>，让不同维度之间的特征在数值上有一定比较性，比如 Min-Max Normalization：</p><script type="math/tex; mode=display">x_{i}^{(j)}:=\frac{x_{i}^{(j)}-\min \left( x_i \right)}{\max \left( x_i \right) -\min \left( x_i \right)}</script><p>但是，在机器学习中，标准化是更常用的手段，归一化的应用场景是有限的。因为「<strong>仅由极值决定</strong>」这个做法过于危险，如果样本中有一个异常大的值，则会将所有正常值挤占到很小的区间，而标准化方法则更加「弹性」，会兼顾所有样本。</p><h3 id="学习率-alpha"><a href="#学习率-alpha" class="headerlink" title="学习率 $\alpha$"></a>学习率 $\alpha$</h3><p>上一节谈到，学习率（Learnig rate）的选取很重要，过小则梯度下降很慢，过大则有可能不收敛。通过绘制<strong>迭代收敛曲线</strong>（Convergence Graph）可以看出学习率的好坏，也可以看出何时算法能收敛并及时<strong>终止算法</strong>。</p><p><img src="/img/blog/ML-Note-2-images/cost-iter.png" alt="代价函数-迭代次数" width=50% /></p><p>特别地，当 $\alpha$ 取值过大时，曲线可能呈现<strong>上扬</strong>或<strong>波浪线</strong>型，解决办法都是选择更小的 $\alpha$ 值。可以证明，只要 $\alpha$ 足够小，凸函数都会收敛于极点。</p><p>此外，还有一种终止算法的方法：判断在某次或连续 $n$ 次迭代后 $J(\theta)$ 的变化小于某个极小量，如 $\varepsilon =1e^{-3}$，此时就可以认为算法终止。但这种办法则不能用于选择尽量大的 $\alpha$ 值。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面以 <a href="https://www.coursera.org/">Coursera</a> 上的多元线性回归数据集 <code>ex1data2.txt</code> 为例实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># load data, data.shape = (47, 3)</span><br>data = np.genfromtxt(<span class="hljs-string">&quot;ex1data2.txt&quot;</span>, delimiter=<span class="hljs-string">&#x27;,&#x27;</span>)<br>(m, n) = data.shape<br>X = data[:, :-<span class="hljs-number">1</span>]<br>y = data[:, -<span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># normalization</span><br>mu = X.mean(axis=<span class="hljs-number">0</span>)<br>sigma = X.std(axis=<span class="hljs-number">0</span>, ddof=<span class="hljs-number">1</span>)<br>X = (X - mu) / sigma<br>X = np.c_[np.ones(m), X] <span class="hljs-comment"># 增加一列 1</span><br><br><span class="hljs-comment"># parameters</span><br>alpha = <span class="hljs-number">0.01</span><br>num_iters = <span class="hljs-number">1500</span><br>theta = np.zeros(n)<br>J_history = np.zeros(num_iters)<br><br><span class="hljs-comment"># Gradient Descent</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, num_iters):<br>error = (X @ theta).flatten() - y  <span class="hljs-comment"># error.shape = (47, )</span><br>theta -= (alpha / m) * np.<span class="hljs-built_in">sum</span>(X * error[:, np.newaxis], <span class="hljs-number">0</span>)<br>J_history[i] = np.<span class="hljs-built_in">sum</span>(np.power(error, <span class="hljs-number">2</span>)) / (<span class="hljs-number">2</span> * m)<br><br><span class="hljs-comment"># predict</span><br>predict = (np.array([<span class="hljs-number">1650</span>, <span class="hljs-number">3</span>]) - mu) / sigma<br>predict = np.r_[<span class="hljs-number">1</span>, predict]<br><span class="hljs-built_in">print</span>(predict @ theta)<br><br><span class="hljs-comment"># plot the convergence graph</span><br>plt.plot(np.arange(J_history.size), J_history)<br>plt.xlabel(<span class="hljs-string">&#x27;Number of iterations&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Cost J&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>得到的 $\left( \theta_0, \theta_1, \theta_2 \right)$ 结果是：[340412.6595 110631.0484  -6649.4724]，预测在 $\left( x_1=1650,x_2=3 \right) $ 时的房价为 293101.0568574823。</p><p>绘制的迭代收敛曲线如下：</p><p><img src="/img/blog/ML-Note-2-images/Figure_1.png" alt="多元线性回归的迭代收敛曲线" width=50% /></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PR学习笔记 #2 贝叶斯分类器</title>
    <link href="/PR-Note-2.html"/>
    <url>/PR-Note-2.html</url>
    
    <content type="html"><![CDATA[<p>在 <a href="https://hwcoder.top/IR-Note-4/">IR学习笔记 #4 概率模型</a> 中曾提到朴素贝叶斯（Naive Bayes）的应用，这里正式学到。贝叶斯分类器基于概率论的原理，是最经典的分类算法之一。其解决的核心点在于根据<strong>已有概率信息</strong>，对未知事物发生结果的概率计算。</p><p><img src="/img/blog/PR-Note-2-images/bayes.jpg" alt="贝叶斯分类器" width = 50% /></p><h2 id="朴素贝叶斯-Naive-Bayes"><a href="#朴素贝叶斯-Naive-Bayes" class="headerlink" title="朴素贝叶斯 | Naive Bayes"></a>朴素贝叶斯 | Naive Bayes</h2><p>概率论中有许多易混淆的<strong>数学表述</strong>，这里列举：</p><ul><li>条件概率公式：$\begin{aligned} P(A \mid B)=\frac{P(A B)}{P(B)}\end{aligned}$</li><li>概率乘法公式：$P(A B)=P(A \mid B) P(B)$</li><li>全概率公式：$\begin{aligned} P(A)=\sum_{i=1}^{n} P\left(A B_{i}\right)=\sum_{i=1}^{n} P\left(A \mid B_{i}\right) P\left(B_{i}\right)\end{aligned}$</li><li>贝叶斯公式：$\begin{aligned} P\left( B_i\mid A \right) =\frac{P\left( AB_i \right)}{P\left( A \right)}=\frac{P\left( A\mid B_i \right) P\left( B_i \right)}{\sum_{i=1}^n{P\left( A\mid B_i \right) P\left( B_i \right)}}\end{aligned}$</li></ul><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>下面引入训练集的定义：</p><script type="math/tex; mode=display">D=\left\{ x^{\left( i \right)},i=1,2,\cdots ,m \right\} ,\quad C=\left\{ x^{(i)}\in \omega ^{\left( j \right)},\;j=1,2,\cdots ,N \right\}</script><ul><li>$m$ 代表训练集中样本点的数量；</li><li>$x^{(i)}$ 代表第 $i$ 个样本点，是一个 $n$ 维向量，$n$ 代表特征数；</li><li>$N$ 代表类别数，所有训练集中样本点被显式地标注；</li><li>样本向量展开为 $x^{\left( i \right)}=\left\{ A_1=a_{i1},A_2=a_{i2},\cdots ,A_n=a_{in} \right\} $。</li></ul><p>贝叶斯分类器要解决的问题就是，利用上述数据集，将一个新的测试样例 $x=\left\{ A_1=a_{1},A_2=a_{2},\cdots ,A_n=a_{n} \right\} $ 归为 $N$ 中的某一类。在这个基础上，我们有如下定义：</p><ul><li>先验概率：$P\left( \omega ^{\left( j \right)} \right)$，表示对<strong>任意未知</strong>测试样例，将其归为类别 $\omega ^{\left( j \right)}$ 的概率，常用训练集中类别 $\omega ^{\left( j \right)}$ 占 $m$ 的比例估计。满足 $\sum_{j=1}^N{P\left( \omega ^{\left( j \right)} \right)}=1$。</li><li>后验概率：$P\left( \omega ^{\left( j \right)} \mid x \right)$，表示对<strong>已知特征</strong>测试样例，将其归为类别 $\omega ^{\left( j \right)}$ 的概率，就是贝叶斯分类器所要求的。满足 $\sum_{j=1}^N{P\left( \omega ^{\left( j \right)}\mid x \right)}=1$。</li><li>似然概率：$P\left( x \mid \omega ^{\left( j \right)} \right)$，表示在类别 $\omega ^{\left( j \right)}$ 中，出现<strong>属性等同于测试样例的训练样例</strong>的概率，可用训练集类别 $\omega ^{\left( j \right)}$ 中含 $x$ 的比例估计。</li></ul><p>于是，利用贝叶斯公式导出：</p><script type="math/tex; mode=display">P\left( \omega ^{\left( j \right)} \mid x \right) =\frac{P\left( x \mid \omega ^{\left( j \right)} \right) P\left( \omega ^{\left( j \right)} \right)}{P\left( x \right)}=\frac{P\left( x \mid \omega ^{\left( j \right)} \right) P\left( \omega ^{\left( j \right)} \right)}{\sum_{i=1}^N{P\left( x \mid \omega ^{\left( i \right)} \right) P\left( \omega ^{\left( i \right)} \right)}}</script><h3 id="似然概率"><a href="#似然概率" class="headerlink" title="似然概率"></a>似然概率</h3><p>前文提到，在计算 $P(x \mid \omega ^{\left( j \right)})$ 时，我们可用训练集类别 $\omega ^{\left( j \right)}$ 中含 $x$ 的比例估计。然而，这样做会遇到一个问题：当类别 $\omega ^{\left( j \right)}$ 中不存在 $x$ 样本点的时候，如果将概率视作 0，那么结果则必为 0，显然不符合要求。</p><p>而上述这种情况经常会发生在<strong>多属性</strong>的样本分类中，因此，我们改用：</p><script type="math/tex; mode=display">P\left(x \mid \omega ^{\left( j \right)}\right)=\prod_{k=1}^n{P\left(A_k=a_k \mid \omega ^{\left( j \right)}\right)}</script><p>其中，$P\left(A_k=a_k \mid \omega ^{\left( j \right)}\right)$ 表示在类别 $\omega ^{\left( j \right)}$ 中，第 $k$ 个属性值时 $a_k$ 的样本出现的概率。</p><blockquote><p>此处采用连乘的形式，是基于<strong>所有属性相互独立</strong>的假设（这正是「<strong>朴素</strong>」的由来），否则应当使用概率乘法公式，即：$P\left( A_1A_2A_3 \right) =P\left( A_1 \right) P\left( A_2 \mid A_1 \right) P\left( A_3 \mid A_1A_2 \right) $。</p></blockquote><p>对于 $P\left(A_k=a_k \mid \omega ^{\left( j \right)}\right)$ 的求法，则须分两种情况来讨论：</p><ol><li><p>$A_k$ 是<strong>离散</strong>属性，直接用 $a_k$ 在类别中的比例估计即可。如果依然发生了零频问题，则需要考虑使用折扣法、插值法、退避法等进行<strong>平滑处理</strong>。</p></li><li><p>$A_k$ 是<strong>连续</strong>属性，通常我们假设 $A_k$ 在类别中是符合均值为 $\mu$，标准差为 $\sigma$ 的正态分布（详见：<a href="https://hwcoder.top/PR-Note-3">PR学习笔记 #3 概率密度：参数估计</a>），则用其<strong>概率密度函数</strong>的值估计其概率：</p><script type="math/tex; mode=display">P(A_k=a_k \mid \omega ^{\left( j \right)})=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(a_k-\mu )^2}{2\sigma ^2}}</script></li></ol><h2 id="决策理论"><a href="#决策理论" class="headerlink" title="决策理论"></a>决策理论</h2><p>有了后验概率，现在则需要考虑决策问题。</p><h3 id="最小错误率分类"><a href="#最小错误率分类" class="headerlink" title="最小错误率分类"></a>最小错误率分类</h3><p>在贝叶斯分类器中，在我们计算出所有类别的后验概率之后，若有：</p><script type="math/tex; mode=display">P\left( \omega ^{\left( j \right)} \mid x \right) =\max \left\{ P\left( \omega ^{\left( 1 \right)} \mid x \right) ,P\left( \omega ^{\left( 2 \right)} \mid x \right) ,\cdots ,P\left( \omega ^{\left( N \right)} \mid x \right) \right\}</script><p>则认为 $x\in \omega ^{\left( j \right)}$，这是基于<strong>最小化错误率</strong>的思想。当选择了类别 $\omega ^{\left( j \right)}$，错误分类的概率就是 $x\notin \omega ^{\left( j \right)}$ 的概率：</p><script type="math/tex; mode=display">P(\mathrm{error} \mid x)=1-\underset{j=1,\cdots ,N}{\max}\left\{ P\left( \omega ^{\left( j \right)} \mid x \right) \right\}</script><p>当然，这时在固定测试样本为 $x$ 的情况下，如果要求对所有不同的 $x$ 取值的平均错误率 $P(\mathrm{error})$，则需要对整个特征空间进行加权求和。</p><p>此外，按照最小错误率来分类时，我们只需要比较出后验概率最大的一类就行，因此在计算过程中只需比较分子部分 $P\left( x \mid \omega ^{\left( j \right)} \right) P\left( \omega ^{\left( j \right)} \right)$ 的大小即可。</p><h3 id="最小风险分类"><a href="#最小风险分类" class="headerlink" title="最小风险分类"></a>最小风险分类</h3><p>但在实际分类情形中，我们还应当考虑每次决策的代价——譬如将患者诊断为阴性的代价要远大于将正常人诊断为阳性。为此，我们补充如下定义：</p><ul><li>决策：$\alpha_i$，表示将测试样例 $x$ 分到类别 $\omega ^{\left(i\right)}$。</li><li>代价：$\lambda _{ij}=\lambda \left( \alpha _i \mid \omega _j \right)$，表示将<strong>真实</strong>类别 $\omega ^{\left(j\right)}$ 中的样本分到<strong>预测</strong>类别 $\omega ^{\left(i\right)}$ 的代价，当 $i=j$ 时代价显然较小，其他时候代价较大。在决策分类的<strong>离散</strong>情况下，通常需要事先绘制代价矩阵 $\lambda _{N \times N}$。</li></ul><p>则可以得到下面的<strong>条件风险</strong>：</p><script type="math/tex; mode=display">R\left( \alpha _i \mid x \right) =\mathbb{E}\left[ \lambda _{ij} \mid x \right] =\sum_{j=1}^N{\lambda _{ij}}P\left( \omega _j \mid x \right)</script><p>如果我们致力于<strong>最小化总体风险</strong>，则需要定义<strong>决策函数</strong>（最优分类器）：</p><script type="math/tex; mode=display">\alpha \left( x \right) =\underset{i=1,\cdots ,N}{\mathrm{arg}\min}R\left( \alpha _i\mid x \right)</script><p>此时，在整个特征空间中，对所有不同的 $x$ 取值，采取决策函数带来的<strong>期望风险</strong>为：</p><script type="math/tex; mode=display">R=\int{R\left( \alpha \left( x \right) \mid x \right)}P\left( x \right) \mathrm{d}x</script><h2 id="半朴素贝叶斯分类"><a href="#半朴素贝叶斯分类" class="headerlink" title="半朴素贝叶斯分类"></a>半朴素贝叶斯分类</h2><p>前文提到，朴素贝叶斯分类中采用了<strong>所有属性条件独立</strong>的假设，但在现实任务中这个假设往往很难成立。因此，我们对假设进行一定程度的放松，适当考虑<strong>部分属性</strong>间的相互依赖信息，因此称为「<strong>半朴素</strong>」。</p><p>其中，<strong>独依赖估计</strong>（One-Dependent Estimator，ODE）是半朴素贝叶斯分类器最常用的一种策略，顾名思议，就是假设每个属性<strong>最多仅依赖于一个</strong>其他属性。</p><p>被依赖的属性称为<strong>父属性</strong>，用 $pA_k$ 来表示，则似然概率：</p><script type="math/tex; mode=display">P\left( x\mid \omega ^{\left( j \right)} \right) =\prod_{k=1}^n{P\left( A_k=a_k\mid \omega ^{\left( j \right)},pA_k=pa_k \right)}</script><p>那么，问题的关键就转化为如何确定每个属性的父属性。最直接的做法就是假设所有属性都依赖于同一个父属性，称之为<strong>超父</strong>（Super-Parent），对应的方法称为 <strong>SPODE</strong> (Super-Parent ODE)。</p><p>此外，还有更为复杂的 <strong>TAN</strong> (Tree Augmented Naive Bayes)，通过计算所有属性两两之间的<strong>条件互信息</strong>（Conditional Mutual Information）：</p><script type="math/tex; mode=display">I\left( A_i,A_j\mid C \right) =\sum_{A_i,A_j;\omega ^{\left( j \right)}\in C}{P}\left( A_i,A_j\mid \omega ^{\left( j \right)} \right) \log \frac{P\left( A_i,A_j\mid \omega ^{\left( j \right)} \right)}{P\left( A_i\mid \omega ^{\left( j \right)} \right) P\left( A_j\mid \omega ^{\left( j \right)} \right)}</script><p>绘制出带权无向完全图，任意两个结点之边的权重为 $I\left( A_i,A_j\mid C \right)$。再构建此完全图的<strong>最大带权生成树</strong>，挑选根结点，将边置为有向，就得到了每个属性及其父属性的依赖关系。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>模式识别</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
      <tag>PR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PR学习笔记 #1 KNN分类器</title>
    <link href="/PR-Note-1.html"/>
    <url>/PR-Note-1.html</url>
    
    <content type="html"><![CDATA[<p>该笔记是本人于哈尔滨工业大学（深圳）2021 年秋季学期「模式识别」课程的笔记，授课教师为 <a href="https://scholar.google.com/citations?hl=zh-CN&amp;user=zOVgYQYAAAAJ">徐勇</a> 教授。姑且算是一门 CV 入门课程。</p><h2 id="PR-vs-ML"><a href="#PR-vs-ML" class="headerlink" title="PR vs. ML"></a>PR vs. ML</h2><p>「模式识别」与「机器学习」作为学校开设的<strong>人工智能</strong>领域二选一的先修课程，想必是有其考虑的。作为一个初学者，或许需要对这二者有更系统的认识。</p><p>这里引用一篇知乎回答的内容：</p><p><img src="/img/blog/PR-Note-1-images/content.jpg" alt="参考自相关书籍目录" width = 80% /></p><p>从上面的目录大致看出模式识别跟机器学习之间有很大部分的<strong>重叠</strong>。但是两者之间还是有很明显的区别的：</p><ul><li>在模式识别中，模式即用来描述研究对象的<strong>特征</strong>。一般模式识别中的大部分分类器，都是在假定已经了用来描述对象性质的特征，系统的输入就是这些处理好的特征。因此，<strong>模式识别研究的是怎么样通过输入的特征对样本进行分类</strong>。</li><li>然而，如果特征与所研究的分类问题没有关系或者关系很弱，那么无论采用怎么样的分类器，都很难取得理想的分类效果。相比之下，<strong>机器学习更加关注的是特征抽取、特征分析，进而实现分类</strong>。</li></ul><p>此外，既然上述图中还提到了「深度学习」，那不妨探讨一下经典面试题「深度学习和机器学习有什么不同？」，同样与特征有关：</p><ul><li><strong>深度学习是一种特殊的机器学习</strong>，具有强大的能力和灵活性。它通过学习将世界表示为嵌套的层次结构，每个表示都与<strong>更简单的特征</strong>相关，而抽象的表示则用于计算<strong>更抽象的表示</strong>。</li><li>传统的机器学习侧重人工进行特征抽取、特征分析，而深度学习从数据中先学习简单的特征，并从其逐渐学习到更为复杂抽象的深层特征，<strong>不依赖人工的特征工程</strong>。</li></ul><h2 id="K-近邻算法-K-Nearest-Neighbor"><a href="#K-近邻算法-K-Nearest-Neighbor" class="headerlink" title="K 近邻算法 | K-Nearest Neighbor"></a>K 近邻算法 | K-Nearest Neighbor</h2><p>最近邻算法是解决<strong>分类</strong>问题的一种算法，是一种监督学习算法。它的思想是：如果一个<strong>样本点</strong>在特征空间中<strong>最相似的样本点</strong>中的属于某一个类别，则该样本也属于这个类别。</p><p>关于「<strong>相似</strong>」这个概念，涉及到<strong>样本距离</strong>的度量，常用的度量方式是<strong>二范数</strong>，对向量而言就是<strong>欧式距离</strong>（Euclidean Distance)：</p><script type="math/tex; mode=display">D(x,y)=\sqrt{\sum_{i=1}^n{(}x_i-y_i)^2}=\left\| x-y \right\| _2</script><p>大多数情况下，欧式距离可以满足我们的需求，但有时候也需要了解其他方式：</p><ul><li>闵可夫斯基距离（Minkowski Distance）：$\sqrt[p]{\sum\limits_{i=1}^{n}(|x_i-y_i|)^p}$</li><li>曼哈顿距离（Manhattan Distance）：$\sum\limits_{i=1}^{n}|x_i-y_i|$，相当于 $p=1$</li><li>切比雪夫距离（Chebyshev Distance）：$\underset{i=1,\cdots ,n}{\max}\left| x_{\boldsymbol{i}}-y_i \right|$，相当于 $p=\infty $</li><li>汉明距离（Hamming Distance）：仅当特征值为 bool 值时使用</li><li>夹角余弦距离（Cosine Distance）：$\begin{aligned}\cos \theta =\frac{\sum_{i=1}^n{x_i}\times y_i}{\sqrt{\sum_{i=1}^n{x_{i}^{2}}\sum_{i=1}^n{y_{i}^{2}}}}\end{aligned}$</li></ul><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>解决了度量问题，剩下的就很简单了，假设有训练集：</p><script type="math/tex; mode=display">D=\left\{x^{(i)},\;i=1,2,\cdots,m\right\},\quad C=\left\{ x^{(i)}\in \omega ^{\left( j \right)},\;j=1,2,\cdots ,N \right\}</script><ul><li>$m$ 代表训练集中样本点的数量；</li><li>$x^{(i)}$ 代表第 $i$ 个样本点，是一个 $n$ 维向量，$n$ 代表特征数；</li><li>$N$ 代表类别数，所有训练集中样本点被显式地标注。</li></ul><p>那么，最近邻算法可以表述为：</p><ol><li>计算测试样本点 $x$ 与所有训练样本点 $x^{(i)}$ 的距离 $\left\| x-x^{(i)} \right\| _2$；</li><li>找出距离最小的情况 $g_k\left( x \right) =\min \left\| x-x^{\left( k \right)} \right\| _2$；</li><li>若 $x^{(k)}\in \omega ^{\left( j \right)}$，则测试样本 $x \in \omega ^{\left( j \right)}$。</li></ol><p>然而，上述方法有明显的缺陷：<strong>单个训练样本</strong>对分类的结果有较大的影响。如果在一个样本空间中有反常的样本点，那么它很可能会影响到周围测试样本的判别。</p><p>因此，$\text{KNN}$ 选择了<strong>多数表决法</strong>作为改进，在做决策时选择特征空间中最相似的 $K$ 个样本点，并以其中<strong>大多数样本所属</strong>的类别作为测试样本的类别。故 $\text{KNN}$ 算法可以改进为：</p><ol><li>计算测试样本点 $x$ 与所有训练样本点 $x^{(i)}$ 的距离 $\left\| x-x^{(i)} \right\| _2$；</li><li>找出距离最小的前 $K$ 个样本点； </li><li>统计其中最多样本点所属的类别 $\omega ^{\left( j \right)}$，则测试样本 $x \in \omega ^{\left( j \right)}$。</li></ol><p>此外，$\text{KNN}$ 算法还可以用于<strong>回归</strong>的决策，即用最近的 $K$ 个样本的平均值作为回归预测值。</p><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>$\text{KNN}$ 算法是一种<strong>懒散学习法</strong>（Lazy Learing），在模型训练的过程中几乎不耗时，主要的计算量则花在预测时的计算，因此会比其他许多算法都要慢。</p><p>通过 Brute-Force 的方法找到最相近的前 $K$ 个样本点，在样本量小、样本特征少的时候或许还能用，但实际运用中我们通常采用更高级的处理方法：</p><ul><li>KDTree (K-Dimension Tree)：根据样本的 $n$ 维特征建树，选取<strong>特征取值方差最大者</strong>作为根结点，将所有结点以该特征值均分为左右子树（将特征空间以<strong>超平面</strong>分割），再以同样方法递归建树。测试时，只需以测试样本点为圆心绘制<strong>超球体</strong>，在所有与球面交割的<strong>超矩形体</strong>中搜索最近邻的点。</li><li>BallTree：KDTree 中利用球面交割矩形体的方法搜索，对于不均匀数据集，空间中的超矩形体会有许多棱角，导致会因为<strong>超球体交割于棱角</strong>导致进行多余的搜索。本方法将分割块改为<strong>超球体</strong>，建立球树以避免问题的发生，搜索回溯的方法与 KDTree 类似。</li></ul><p>当然，上述方法在建模时需要较大的内存，属于「空间换时间」的经典样例。</p><h3 id="超参数-K"><a href="#超参数-K" class="headerlink" title="超参数 K"></a>超参数 K</h3><p>所谓超参数（Hyper-Parameter），就是在开始<strong>模型训练之前</strong>，就<strong>人为设置</strong>好的参数，这是相对其他<strong>模型训练得出</strong>的参数（Parameter）提出的一个概念。</p><p>作为本算法唯一的参数 $K$，就需要根据经验进行优化，以提高学习的性能和效果。下面我们通过<strong>交叉验证</strong>（Cross-Validation）来分析这个问题。</p><blockquote><p>所谓的交叉验证，就是将样本数据按照一定比例，<strong>拆分</strong>出训练用的数据和验证用的数据，其中验证集不参与模型的构建。</p></blockquote><p>选取一个较小的 $K$ 值，不断增加，并计算验证集的错误率，最终可以绘制出如下曲线：</p><p><img src="/img/blog/PR-Note-1-images/KNN-error.png" alt="K值与误差率" width=80%/></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>模式识别</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
      <tag>PR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python笔记 #3 Matplotlib</title>
    <link href="/Python-Note-3.html"/>
    <url>/Python-Note-3.html</url>
    
    <content type="html"><![CDATA[<p>学习 Machine Learning 的时候发现需要用许多矩阵运算和画图的库，本文将以<strong>实用主义</strong>的方式记录每次遇到的新用法。</p><p>2021 年贵系的暑培新增了「科学计算」内容，本文部分内容参考了清华 LZJ 同学的教程。本文将持续更新。</p><h2 id="Matplotlib-基础"><a href="#Matplotlib-基础" class="headerlink" title="Matplotlib 基础"></a>Matplotlib 基础</h2><p>绘图时最常用的模块是 Matplotlib 中的 <strong>pyplot</strong> 模块。绘图时先调用相关绘图函数，设置图像各种细节，最后调用 <code>plt.show()</code> 打开新窗口显示图片，此时程序会暂停。如果使用 <code>%matplotlib inline</code> 方法，可以使图片在 Cell 中显示而不开新窗口（适用于 Notebook）。</p><p>这时会出现一个基于 Qt 实现的交互窗口，程序执行到 <code>plt.show()</code> 时阻塞。在交互窗口中可以<strong>进一步调整图片</strong>格式细节或<strong>保存图片</strong>，关闭窗口后程序继续运行。下面以一个例子说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>x = np.linspace(-<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">30</span>)  <span class="hljs-comment"># [-4, 4] 中长度为 30 的等差数列</span><br>y = np.sin(x)<span class="hljs-comment"># 获得 sin 值</span><br>plt.plot(x, y)<span class="hljs-comment"># 以 x 为自变量，y 为因变量，绘制折线图</span><br>plt.show()<span class="hljs-comment"># 显示图像，程序阻塞</span><br>plt.savefig(<span class="hljs-string">&#x27;myFig.png&#x27;</span>) <span class="hljs-comment"># 保存图像</span><br></code></pre></td></tr></table></figure><h3 id="格式字符串"><a href="#格式字符串" class="headerlink" title="格式字符串"></a>格式字符串</h3><p>与 Matlab 相似，Matplotlib 使用事先约定好的字符串代表<strong>绘图格式</strong>，将其写入 <code>plt.plot()</code> 即可，如  <code>plt.plot(x, y, &#39;bo&#39;)</code> 即蓝色圆圈标记。</p><ul><li><code>color</code>：绘制点的颜色，支持以下常用缩写（还有更多未列出的颜色全名），还可以用十六进制代码 <code>c=&#39;#000&#39;</code> 指定。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">颜色</th><th style="text-align:center">字符</th><th style="text-align:center">颜色</th><th style="text-align:center">字符</th><th style="text-align:center">颜色</th><th style="text-align:center">字符</th><th style="text-align:center">颜色</th></tr></thead><tbody><tr><td style="text-align:center"><code>b</code></td><td style="text-align:center">蓝色</td><td style="text-align:center"><code>r</code></td><td style="text-align:center">红色</td><td style="text-align:center"><code>m</code></td><td style="text-align:center">洋红色</td><td style="text-align:center"><code>k</code></td><td style="text-align:center">黑色</td></tr><tr><td style="text-align:center"><code>g</code></td><td style="text-align:center">绿色</td><td style="text-align:center"><code>c</code></td><td style="text-align:center">青色</td><td style="text-align:center"><code>y</code></td><td style="text-align:center">黄色</td><td style="text-align:center"><code>w</code></td><td style="text-align:center">白色</td></tr></tbody></table></div><ul><li><code>color#xkcd</code>：xkdc 调色盘总结了数百种最常用的颜色，比标准色更美观，使用 <code>c=&#39;xkcd:pink&#39;</code> 格式即可使用。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">全称</th><th style="text-align:center">颜色</th><th style="text-align:center">全称</th><th style="text-align:center">颜色</th><th style="text-align:center">全称</th><th style="text-align:center">颜色</th><th style="text-align:center">全称</th><th style="text-align:center">颜色</th></tr></thead><tbody><tr><td style="text-align:center"><code>pink</code></td><td style="text-align:center">粉色</td><td style="text-align:center"><code>sky blue</code></td><td style="text-align:center">天蓝色</td><td style="text-align:center"><code>orange</code></td><td style="text-align:center">橘色</td><td style="text-align:center"><code>light green</code></td><td style="text-align:center">嫩绿色</td></tr><tr><td style="text-align:center"><code>light purple</code></td><td style="text-align:center">嫩紫色</td><td style="text-align:center"><code>lavender</code></td><td style="text-align:center">粉紫色</td><td style="text-align:center"><code>tan</code></td><td style="text-align:center">褐色</td><td style="text-align:center"><code>aqua</code></td><td style="text-align:center">海绿色</td></tr></tbody></table></div><ul><li><code>marker</code>：绘制点的形状。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">标记</th><th style="text-align:center">字符</th><th style="text-align:center">标记</th><th style="text-align:center">字符</th><th style="text-align:center">标记</th><th style="text-align:center">字符</th><th style="text-align:center">标记</th></tr></thead><tbody><tr><td style="text-align:center"><code>.</code></td><td style="text-align:center">点标记</td><td style="text-align:center"><code>&gt;</code></td><td style="text-align:center">右三角标记</td><td style="text-align:center"><code>p</code></td><td style="text-align:center">五边形标记</td><td style="text-align:center"><code>D</code></td><td style="text-align:center">菱形标记</td></tr><tr><td style="text-align:center"><code>,</code></td><td style="text-align:center">像素标记</td><td style="text-align:center"><code>1</code></td><td style="text-align:center">三叉戟标记</td><td style="text-align:center"><code>*</code></td><td style="text-align:center">星形标记</td><td style="text-align:center"><code>d</code></td><td style="text-align:center">菱形标记</td></tr><tr><td style="text-align:center"><code>o</code></td><td style="text-align:center">圆圈标记</td><td style="text-align:center"><code>2</code></td><td style="text-align:center">三叉戟标记</td><td style="text-align:center"><code>h</code></td><td style="text-align:center">六角形标记</td><td style="text-align:center"><code>丨</code></td><td style="text-align:center">竖线标记</td></tr><tr><td style="text-align:center"><code>v</code></td><td style="text-align:center">倒三角标记</td><td style="text-align:center"><code>3</code></td><td style="text-align:center">三叉戟标记</td><td style="text-align:center"><code>H</code></td><td style="text-align:center">六角形标记</td><td style="text-align:center"><code>_</code></td><td style="text-align:center">横线标记</td></tr><tr><td style="text-align:center"><code>^</code></td><td style="text-align:center">正三角标记</td><td style="text-align:center"><code>4</code></td><td style="text-align:center">三叉戟标记</td><td style="text-align:center"><code>+</code></td><td style="text-align:center">+标记</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>&lt;</code></td><td style="text-align:center">左三角标记</td><td style="text-align:center"><code>s</code></td><td style="text-align:center">正方形标记</td><td style="text-align:center"><code>x</code></td><td style="text-align:center">x标记</td><td style="text-align:center"></td></tr></tbody></table></div><ul><li><code>line</code>：绘制线的形状。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">格式</th><th style="text-align:center">字符</th><th style="text-align:center">格式</th><th style="text-align:center">字符</th><th style="text-align:center">格式</th><th style="text-align:center">字符</th><th style="text-align:center">格式</th></tr></thead><tbody><tr><td style="text-align:center"><code>-</code></td><td style="text-align:center">实线</td><td style="text-align:center"><code>--</code></td><td style="text-align:center">虚线</td><td style="text-align:center"><code>-.</code></td><td style="text-align:center">点划线</td><td style="text-align:center"><code>:</code></td><td style="text-align:center">点线</td></tr></tbody></table></div><h2 id="特定类型图"><a href="#特定类型图" class="headerlink" title="特定类型图"></a>特定类型图</h2><p>下面是一些常用的绘图函数。更多官网案例：<a href="https://matplotlib.org/stable/gallery/index.html。">https://matplotlib.org/stable/gallery/index.html。</a></p><h3 id="折线图-plot"><a href="#折线图-plot" class="headerlink" title="折线图 plot()"></a>折线图 <code>plot()</code></h3><p><code>plt.plot()</code> 用于绘制<strong>折线图</strong>，需要一系列点作为因变量和自变量，函数接口如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">matplotlib.pyplot.plot(*args, scalex=<span class="hljs-literal">True</span>, scaley=<span class="hljs-literal">True</span>, data=<span class="hljs-literal">None</span>, **kwargs)<br></code></pre></td></tr></table></figure><p>观察接口，可以发现有以下的用法：</p><ul><li>传入<strong>两个等长</strong>数组或列表，前者是自变量，后者是因变量。</li><li>只传入<strong>一个</strong>数组或列表，自变量默认从 0 开始整数递增。</li><li>传入两个列表，<strong>各包含两个值</strong>，可以绘制一条直线。</li></ul><h3 id="散点图-scatter"><a href="#散点图-scatter" class="headerlink" title="散点图 scatter()"></a>散点图 <code>scatter()</code></h3><p><code>plt.scatter()</code> 用于绘制<strong>散点图</strong>，需要<strong>两个等长</strong>数组或列表，函数接口如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">matplotlib.pyplot.scatter(x, y, s=<span class="hljs-literal">None</span>, c=<span class="hljs-literal">None</span>, marker=<span class="hljs-literal">None</span>, **kwargs)<br></code></pre></td></tr></table></figure><p>其中只有 <code>x</code> 和 <code>y</code> 为必填项，<code>s</code> 代表每个点的大小，可以是常数也可以是列表。</p><h3 id="轮廓图-contour"><a href="#轮廓图-contour" class="headerlink" title="轮廓图 contour()"></a>轮廓图 <code>contour()</code></h3><p><code>plt.contour()</code> 用于绘制<strong>等高线图</strong>，也可绘制闭合的<strong>轮廓图</strong>，函数接口如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">matplotlib.pyplot.contour(x, y, Z, [levels], **kwargs)<br></code></pre></td></tr></table></figure><p>其中 <code>x</code> 和 <code>y</code> 是一维的数组，代表绘制的网格点的横纵坐标；<code>Z</code> 是形状为 <code>(len(X), len(Y))</code> 的二维数组，代表绘制点的高度。参数 <code>levels</code> 是一个列表，如果空缺则默认绘制<strong>一组等距的等高线</strong>，也可以传入 <code>[0, 0.5, 1]</code> 这样的列表，则只会<strong>显示对应高度</strong>的轮廓线。</p><h3 id="热力图-imshow"><a href="#热力图-imshow" class="headerlink" title="热力图 imshow()"></a>热力图 <code>imshow()</code></h3><p><code>plt.imshow()</code> 本身是用于绘制<strong>二维数字图像</strong>，但图像有更好的工具，因此主要用于绘制<strong>热力图</strong>（heatmap），配套使用的还有<strong>色值柱</strong>，函数接口如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">matplotlib.pyplot.imshow(X, cmap=<span class="hljs-literal">None</span>, interpolation=<span class="hljs-literal">None</span>, **kwargs)<br>matplotlib.pyplot.colorbar()<br></code></pre></td></tr></table></figure><p>其中 <code>X</code> 是二维数组，数组元素的值就是热力值，<code>cmap</code> 为<strong>色彩风格</strong>，可选的值有：<code>plt.cm.hot</code>、<code>cool</code>、<code>gray</code>、<code>bone</code>、<code>white</code>、<code>spring</code>、<code>summer</code>、<code>autumn</code>、<code>winter</code>。</p><p>非必要的参数如，<code>interpolation</code>设置为 <code>’nearest’</code> 可以将相邻的<strong>相同的颜色连成片</strong>。最后调用 <code>plt.colorbar()</code> 可以把色值柱附在图像旁边。</p><h3 id="直方图-hist"><a href="#直方图-hist" class="headerlink" title="直方图 hist()"></a>直方图 <code>hist()</code></h3><p><code>plt.hist()</code> 用于绘制直方图（Histogram），一种特殊的柱状图。，函数接口如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">matplotlib.pyplot.hist(x, bins=<span class="hljs-literal">None</span>, <span class="hljs-built_in">range</span>=<span class="hljs-literal">None</span>, **kwargs)<br></code></pre></td></tr></table></figure><p>其中 <code>x</code> 为一维数组，可以是浮点数，<code>bins</code> 为直方图的组数，会<strong>自动量化原始数据</strong>。非必要的参数 <code>range</code> 可输入一个范围元组，默认为 <code>(x.min(), x.max())</code>，如果设置了则会依据 <code>range</code> 来划分直方图的组宽。</p><h2 id="子图布局"><a href="#子图布局" class="headerlink" title="子图布局"></a>子图布局</h2><p>Matplotlib 有一个概念 subplot：包含在 Figure 对象中的小型 Axes 对象。这允许我们在一幅图中创建很多个子图，方便对比数据。在前面绘制单张图时，可以不声明 Figure 对象作为<strong>所有内容的容器</strong>，但<strong>绘制子图时则必须声明</strong>。总共有三种方法。</p><h3 id="任意位置-add-axes"><a href="#任意位置-add-axes" class="headerlink" title="任意位置 add_axes()"></a>任意位置 <code>add_axes()</code></h3><p>先调用 <code>plt.figure()</code> 创建 Figure 对象，接着调用 <code>fig.add_axes()</code> 在图表的任意位置添加子图，函数接口如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ax = fig.add_axes(rect, projection=<span class="hljs-literal">None</span>, polar=<span class="hljs-literal">False</span>, **kwargs)<br></code></pre></td></tr></table></figure><p>其中只有 <code>rect</code> 是必要的，这是一个四个浮点数的列表 <code>[left, bottom, width, height]</code>，分别代表子图<strong>左下角</strong>的坐标，子图的宽度和高度。这四个数字的取值范围都是 0 到 1，代表<strong>相对位置和大小</strong>。</p><p>最后在每个子图里用各自的类型图进行绘制即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">fig = plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">7</span>))<br><br><span class="hljs-comment"># 创建子图</span><br>ax1 = fig.add_axes([<span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.45</span>, <span class="hljs-number">0.45</span>])  <span class="hljs-comment"># 在图表的左上角创建一个子图</span><br>ax2 = fig.add_axes([<span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.45</span>, <span class="hljs-number">0.45</span>])  <span class="hljs-comment"># 在图表的右下方创建一个子图</span><br><br><span class="hljs-comment"># 左上角子图：曲线图</span><br>x1 = np.linspace(-<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>)<br>ax1.plot(x1, np.sin(x1), color=<span class="hljs-string">&quot;red&quot;</span>)<br><br><span class="hljs-comment"># 右下角子图：柱状图</span><br>x2 = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>]<br>y2 = [<span class="hljs-number">1.2</span>, <span class="hljs-number">1.3</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1.56</span>]<br>ax2.bar(x2, y2, color=<span class="hljs-string">&quot;blue&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="对齐网格-subplot"><a href="#对齐网格-subplot" class="headerlink" title="对齐网格 subplot()"></a>对齐网格 <code>subplot()</code></h3><p><code>plt.subplot()</code> 用于在一张图里绘制<strong>多个子图</strong>，函数接口如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ax = matplotlib.pyplot.subplot(nrows=<span class="hljs-number">1</span>, ncols=<span class="hljs-number">1</span>, index, **kwargs)<br></code></pre></td></tr></table></figure><p>其中只有 <code>nrow</code> 和 <code>ncols</code> 表示总共有多少子图，<code>index</code> 代表其中第几个。如：<code>plt.subplot(2,2,1)</code>，也可以缩写为 <code>plt.subplot(221)</code>。紧跟在 <code>plt.subplot()</code> 语句后面的语句绘制的就是 <code>index</code> 所指向的图，绘制完再次使用 <code>plt.subplot()</code> 语句切换到下一张子图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">fig = plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">7</span>))  <span class="hljs-comment"># 如果对整体有标题、标签，在此处添加</span><br><br>ax1 = plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>ax1.plot()  <span class="hljs-comment">#　如果对子图有标题、标签，在此处添加</span><br><br>ax2 = plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>ax2.plot()  <span class="hljs-comment">#　如果对子图有标题、标签，在此处添加</span><br></code></pre></td></tr></table></figure><p>但是，上述方法不适用于大量子图的绘制，如 100 张子图拼接等，因此有另一个相似的方法 <code>plt.subplots()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fig, axes = matplotlib.pyplot.subplots(nrows=<span class="hljs-number">1</span>, ncols=<span class="hljs-number">1</span>, *, sharex=<span class="hljs-literal">False</span>, sharey=<span class="hljs-literal">False</span>, **fig_kw)<br></code></pre></td></tr></table></figure><p>同时返回一个固定的 Figure 对象（设置的参数一起写即可）和一个 Axes 对象<strong>二维列表</strong>，通过循环可以遍历：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个图形对象，拆分为2*3的网格，包含6个坐标对象</span><br>fig, axes = plt.subplots(<br>    nrows=<span class="hljs-number">2</span>,  <span class="hljs-comment"># 定义行数</span><br>    ncols=<span class="hljs-number">3</span>,  <span class="hljs-comment"># 定义列数</span><br>    sharex=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 是否共享x轴坐标</span><br>    sharey=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 是否共享y轴坐标</span><br>    figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">7</span>)  <span class="hljs-comment"># 图像大小</span><br>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        axes[i, j].plot()<br></code></pre></td></tr></table></figure><h3 id="自由网格-GridSpec"><a href="#自由网格-GridSpec" class="headerlink" title="自由网格 GridSpec"></a>自由网格 <code>GridSpec</code></h3><p>如果想创建<strong>不规则的子图</strong>，部分子图更大，展示核心信息，有的子图较小，展现辅助信息，<code>plt.GridSpec()</code> 可实现这一点，工作原理是先创建一个网格状的蓝图，然后<strong>合并部分子图</strong>。函数接口如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">grid = matplotlib.gridspec.GridSpec(nrows, ncols, figure=<span class="hljs-literal">None</span>, **kwargs)<br></code></pre></td></tr></table></figure><p>使用时调用 <code>plt.GridSpec</code> 创建网格状的<strong>二维数组</strong> <code>grid</code>，通过<strong>切片和索引</strong>按需求合并子图，最后调用 <code>ax.plot()</code> 将数据映射到图表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">fig = plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">7</span>))<br><br>grid = plt.GridSpec(nrows=<span class="hljs-number">2</span>, ncols=<span class="hljs-number">3</span>, figure=fig)  <span class="hljs-comment"># 创建 2*3 的网格蓝图</span><br><br><span class="hljs-comment"># 合并子图</span><br>ax1 = plt.subplot(grid[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>])<br>ax2 = plt.subplot(grid[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>:])  <span class="hljs-comment"># 合并(0,1)和(0,2)位置的子图</span><br>ax3 = plt.subplot(grid[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>:<span class="hljs-number">2</span>])  <span class="hljs-comment"># 合并(1,0)和(1,1)位置的子图</span><br>ax4 = plt.subplot(grid[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br><br>x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">30</span>)<br><br>ax1.plot(x, np.sin(x), <span class="hljs-string">&quot;-r&quot;</span>)<br>ax2.plot(x, np.cos(x), <span class="hljs-string">&quot;-ob&quot;</span>)<br>ax3.plot(x, np.sin(x + <span class="hljs-number">10</span>), <span class="hljs-string">&quot;-oy&quot;</span>)<br>ax4.plot(x, np.cos(x + <span class="hljs-number">10</span>), <span class="hljs-string">&quot;-g&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="装饰输出"><a href="#装饰输出" class="headerlink" title="装饰输出"></a>装饰输出</h2><p>除了上述常用的绘图函数，Matplotlib 还带有各种绘图组件，用于装饰输出。</p><h3 id="全局配置-rcParams"><a href="#全局配置-rcParams" class="headerlink" title="全局配置 rcParams"></a>全局配置 <code>rcParams</code></h3><p>Matplotlib 使用 MRC（Matplotlib <strong>Resource Configurations</strong>）配置文件来自定义各种属性，我们称之为 rc 配置或者 rc 参数。使用 <code>rcParams</code> 可以控制几乎所有的默认属性：视图窗口、线条、颜色、样式、坐标轴、网格、文本、字体等属性。</p><p>通常在 Notebook 中使用，使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br>%matplotlib inline<br>plt.rcParams[<span class="hljs-string">&#x27;figure.figsize&#x27;</span>] = (<span class="hljs-number">10.0</span>, <span class="hljs-number">8.0</span>)<br>plt.rcParams[<span class="hljs-string">&#x27;image.interpolation&#x27;</span>] = <span class="hljs-string">&#x27;nearest&#x27;</span><br>plt.rcParams[<span class="hljs-string">&#x27;image.cmap&#x27;</span>] = <span class="hljs-string">&#x27;gray&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="画板-figure"><a href="#画板-figure" class="headerlink" title="画板 figure()"></a>画板 <code>figure()</code></h3><h3 id="图例-legend"><a href="#图例-legend" class="headerlink" title="图例 legend()"></a>图例 <code>legend()</code></h3><p>注意 label 不要拼错了</p><h3 id="坐标轴"><a href="#坐标轴" class="headerlink" title="坐标轴"></a>坐标轴</h3><p>去掉坐标轴的<strong>轴线</strong>、刻度、标签：<code>plt.axis(&#39;off&#39;)</code></p><p>去掉坐标轴的刻度、标签：<code>plt.xticks([])</code> 和 <code>plt.yticks([])</code></p><p>去掉坐标轴的刻度，但保留标签：<code>plt.tick_params(left=False, bottom=False)</code></p><p>去掉坐标轴的标签，但保留刻度（适用于画 Attention 热力图）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ax = plt.gca()<br>ax.axes.xaxis.set_ticklabels([])<br>ax.axes.yaxis.set_ticklabels([])<br></code></pre></td></tr></table></figure><h3 id="文字说明"><a href="#文字说明" class="headerlink" title="文字说明"></a>文字说明</h3><ul><li><code>plt.xlabel(’X Label‘)</code>：</li><li><code>plt.ylabel(’Y Label‘)</code>：</li><li><code>plt.title(&#39;TITLE&#39;)</code>：</li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python笔记 #2 NumPy</title>
    <link href="/Python-Note-2.html"/>
    <url>/Python-Note-2.html</url>
    
    <content type="html"><![CDATA[<p>学习 Machine Learning 的时候发现需要用许多矩阵运算和画图的库，本文将以<strong>实用主义</strong>的方式记录每次遇到的新用法。</p><p>2021 年贵系的暑培新增了「科学计算」内容，本文部分内容参考了清华 LZJ 同学的教程，部分参考自 NumPy 中文官网 <a href="https://www.numpy.org.cn/reference/">参考手册</a>。本文将持续更新。</p><h2 id="常用的库"><a href="#常用的库" class="headerlink" title="常用的库"></a>常用的库</h2><p>计算机领域，有用的数据特指<strong>结构化的数据</strong>，即符合一定的语法规范，才能方便计算机处理。这些数据包括表格型的数据，多维数组型的数据，由键位列关联起来的多张表数据等等。针对这些数据，Python 都有相应库去处理。</p><p><strong>数据处理</strong>：</p><ul><li><p><strong>NumPy</strong>：是 Numerical Python 的缩写，用于处理<strong>大规模多维数组</strong>，<strong>矩阵计算</strong>等，有成熟的 C 接口，很多 Python 的第三方库都基于 NumPy 实现（例如 Python 的计算机视觉库 cv2 ）。</p></li><li><p><strong>Pandas</strong>：提供了更高级的数据结构和函数，适用于处理<strong>表格化</strong>、<strong>结构化</strong>的数据。</p></li></ul><p><strong>科学计算</strong>：</p><ul><li><strong>SciPy</strong>：Python 的<strong>科学计算</strong>库，可以处理积分微分、线性代数、最优化问题、信号处理、统计学等问题。</li><li><strong>Scikit-learn</strong>：Python 的<strong>机器学习</strong>工具包，可以处理机器学习的众多计算问题，如支持向量机，聚类，特征选择等问题。</li><li><strong>Statmodels</strong>：处理统计学和经济学问题的库，与 scikit-learn 相比包含更多经典模型。</li></ul><p><strong>数据可视化</strong>：</p><ul><li><strong>Matplotlib</strong>：最经典的<strong>二维数据</strong>可视化库，结合 NumPy 使用可以成为 Matlab 的有力替代品。</li></ul><p><strong>自动化办公</strong>：</p><ul><li><strong>docx</strong>：处理 Doc 文档。</li><li><p><strong>pptx</strong>：处理 Powerpoint 幻灯片。</p></li><li><p><strong>openpyxl</strong>：处理 Excel 表格。</p></li></ul><h2 id="NumPy-基础"><a href="#NumPy-基础" class="headerlink" title="NumPy 基础"></a>NumPy 基础</h2><p>NumPy 底层是用 C 写的，所以可以很方便的操作内存，这点与 Python 的原生数据结构不同。因此，NumPy 在处理大型数据时<strong>速度更快</strong>，内存<strong>开销也更小</strong>（和原生 Python 相比）。</p><h3 id="ndarray-对象"><a href="#ndarray-对象" class="headerlink" title="ndarray 对象"></a>ndarray 对象</h3><p>ndarray 是 NumPy 的核心数据结构，全称是 N-dimensional Array，N 维数组，一个快速、灵活的大型数据集容器，内部储存<strong>同一类型</strong>的数据。</p><p>ndarray 有两个重要属性，<code>dtype</code> 和 <code>shape</code>，分别表示元素的<strong>数据类型</strong>和<strong>形状参数</strong>，此外还有 <code>ndim</code> (维数), <code>size</code> (元素个数), <code>itemsize</code> (每个元素字节数) 等属性。</p><ul><li><code>arr.dtype</code>、<code>np.dtype(arr)</code>：返回 <code>arr</code> 的数据类型，常见类型如下：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">int16/uint16</td><td style="text-align:center">有符号和无符号 16 位整数</td></tr><tr><td style="text-align:center"><strong>int32</strong>/uint32</td><td style="text-align:center">有符号和无符号 32 位整数</td></tr><tr><td style="text-align:center">int64/uint64</td><td style="text-align:center">有符号和无符号 64 位整数</td></tr><tr><td style="text-align:center">float32</td><td style="text-align:center">标准单精度浮点数，兼容 C 的 float</td></tr><tr><td style="text-align:center"><strong>float64</strong></td><td style="text-align:center">标准双精度浮点数，兼容 C 的 double</td></tr><tr><td style="text-align:center">float128</td><td style="text-align:center">拓展精度浮点数</td></tr><tr><td style="text-align:center">complex128</td><td style="text-align:center">基于 float64 的复数</td></tr><tr><td style="text-align:center">bool</td><td style="text-align:center">布尔值，为 True 或 False</td></tr></tbody></table></div><ul><li><code>arr2 = arr1.astype(np.float64)</code>：改变原数据类型为目标类型。</li><li><code>arr.shape</code>、<code>np.shape(arr)</code>：返回 <code>arr</code> 的形状参数，通常赋值给变量 <code>(m, n)</code>，不同的参数含义如下：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"><code>arr</code></th><th style="text-align:center"><code>arr.shape</code></th><th style="text-align:center"><code>arr.dtype</code></th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">array(1)</td><td style="text-align:center"><code>()</code></td><td style="text-align:center">int32</td><td style="text-align:center">单个整数</td></tr><tr><td style="text-align:center">array(1.)</td><td style="text-align:center"><code>()</code></td><td style="text-align:center">float64</td><td style="text-align:center">单个浮点数</td></tr><tr><td style="text-align:center">array([1, 2])</td><td style="text-align:center"><code>(2,)</code></td><td style="text-align:center">int32</td><td style="text-align:center">一维数组，2 个元素</td></tr><tr><td style="text-align:center">array([[1],<br/> [2]])</td><td style="text-align:center"><code>(2, 1)</code></td><td style="text-align:center">int32</td><td style="text-align:center">二维数组，2 行 1 列</td></tr><tr><td style="text-align:center">array([[1, 2]])</td><td style="text-align:center"><code>(1, 2)</code></td><td style="text-align:center">int32</td><td style="text-align:center">二维数组，1 行 2 列</td></tr><tr><td style="text-align:center">array([[1, 2],<br/> [3, 4]])</td><td style="text-align:center"><code>(2, 2)</code></td><td style="text-align:center">int32</td><td style="text-align:center">二维数组，2 行 2 列</td></tr><tr><td style="text-align:center">array([[[1, 1],<br/>               [1, 1]],<br/>            [[1, 1],<br/>    [1, 1]]])</td><td style="text-align:center"><code>(2, 2, 2)</code></td><td style="text-align:center">int32</td><td style="text-align:center">三维数组</td></tr></tbody></table></div><ul><li><code>arr.shape[0]</code>、<code>arr.shape[1]</code>：返回 <code>arr</code> 的第 0 维、第 1 维的长度。</li><li><code>arr.size</code>：返回元素个数，通常赋值给变量 <code>m</code>，用于生成等长的数组。</li><li><code>np.set_printoptions(formatter=&#123;&#39;float&#39;: &#39;&#123;: 0.6f&#125;&#39;.format&#125;)</code>：设置<strong>全局</strong>精度。</li></ul><h3 id="ndarray-构造"><a href="#ndarray-构造" class="headerlink" title="ndarray 构造"></a>ndarray 构造</h3><p>根据不同的需求，有各种构造 ndarray 的方法。</p><ul><li><strong>已有容器转化数组</strong></li></ul><p>生成 ndarray 的基本函数是 <code>np.array()</code>，其参数可以是 list 、tuple 或 另一个 ndarray，会<strong>自动识别</strong>类型。其函数接口如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    obj: 传入原数组</span><br><span class="hljs-string">    dtype: 指定数据类型，默认根据原数组推断为 int32 或 float64</span><br><span class="hljs-string">    copy: 是否拷贝（不共享内存）</span><br><span class="hljs-string">    order: 数组存储风格，C 按行优先，F 按列优先，K 自适应</span><br><span class="hljs-string">    ndmin: 最小维数</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>np.array(<span class="hljs-built_in">object</span>, dtype = <span class="hljs-literal">None</span>, copy = <span class="hljs-literal">True</span>, order = <span class="hljs-string">&#x27;K&#x27;</span>, subok = <span class="hljs-literal">False</span>, ndmin = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>样例测试如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># list</span><br>arr1 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<span class="hljs-comment"># arr1.shape = (3,)</span><br>arr2 = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]) <span class="hljs-comment"># arr2.shape = (2, 2)</span><br><span class="hljs-comment"># tuple</span><br>arr3 = np.array((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<span class="hljs-comment"># arr3.shape = (3,)</span><br>arr4 = np.array(((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)))<span class="hljs-comment"># arr4.shape = (2, 2)</span><br><span class="hljs-comment"># float</span><br>arr5 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3.14</span>])<span class="hljs-comment"># arr5.dtype = float64</span><br>arr6 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], dtype = np.float64)<br><span class="hljs-comment"># merge</span><br>arr7 = np.array([arr1, arr5])<span class="hljs-comment"># arr7.shape = (2, 3)</span><br></code></pre></td></tr></table></figure><ul><li><strong>生成已初始化数组</strong></li></ul><p>NumPy 自带初始化函数，用来生成默认数组，以下为样例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = np.zeros((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<span class="hljs-comment"># 全 0.  数组，arr1.shape = (2, 3)</span><br>arr2 = np.ones(<span class="hljs-number">10</span>)<span class="hljs-comment"># 全 1.  数组，arr2.shape = (10,)</span><br>arr3 = np.empty((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>))<span class="hljs-comment"># 未初始化数组，arr3.shape = (3, 4, 5)</span><br></code></pre></td></tr></table></figure><p>需要注意的是，传入的实参为生成数组的 <code>shape</code>，必须用<strong>元组</strong>表示！且生成的数组默认类型都为 float64。</p><p>若要生成高维数组，除了用 <code>np.array()</code> 拼接两个低维数组，通常都是用 <code>np.empty()</code> 实现。</p><ul><li><strong>基于范围生成数组</strong></li></ul><p>生成方式与 Matlab 类似，这里给出函数接口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 范围在 [start, stop) 之间，缺省其一则视为 [0, stop)，步长为 step</span><br>np.arange(start, stop, step, dtype)<br><span class="hljs-comment"># 生成等差数列，[start, stop] 之间，限定总数为 num，endpoint 表示是否包含 stop 端点</span><br>np.linspace(start, stop, num=<span class="hljs-number">50</span>, endpoint=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 生成等比数列，注意范围是 [base^start, base^stop] 之间,限定总数为 num</span><br>np.logspace(start, stop, num=<span class="hljs-number">50</span>, endpoint=<span class="hljs-literal">True</span>, base=<span class="hljs-number">10.0</span>)<br></code></pre></td></tr></table></figure><ul><li><strong>生成随机数组</strong></li></ul><p>常用的有三种方式，这里给出函数接口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成 0 到 1 之间的浮点数，参数为各个维度</span><br>np.random.rand(d0, d1, ..., dn)<br><span class="hljs-comment"># 生成 [low, high) 之间的整数，缺省其一则视为 [0, high)，size 用元组表示</span><br>np.random.randint(low, high, size=<span class="hljs-literal">None</span>, dtype=<span class="hljs-built_in">int</span>)<br><span class="hljs-comment"># 生成 均值为 0，方差为 1 的正态分布浮点数，参数为各个维度</span><br>np.random.randn(d0, d1, ..., dn)<br></code></pre></td></tr></table></figure><ul><li><strong>从外部文件导入</strong></li></ul><p>实践最常用的方式是从外部文件导入大量数据集，Numpy 自身的文件后缀为 .npy，专用于 ndarray 的独写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">np.save(<span class="hljs-string">&quot;array&quot;</span>, arr)<br>arr_copy = np.load(<span class="hljs-string">&quot;array.npy&quot;</span>)<br></code></pre></td></tr></table></figure><p>此外，Numpy 还有对 .txt 类型文件的读写方法，这里列出样例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入 .txt 文件，每行作为数组的一行，分隔符为逗号，选中前 2 列</span><br>data = np.loadtxt(<span class="hljs-string">&#x27;ex1data1.txt&#x27;</span>, delimiter=<span class="hljs-string">&#x27;,&#x27;</span>, usecols=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>x = data[:, <span class="hljs-number">0</span>] <span class="hljs-comment"># 第 0 列作为自变量</span><br>y = data[:, <span class="hljs-number">1</span>]<span class="hljs-comment"># 第 1 列作为因变量</span><br>m = y.size<span class="hljs-comment"># 元素组数定义为 m</span><br></code></pre></td></tr></table></figure><p>当 .txt 文件有<strong>空缺数据</strong>时，需要使用复杂度更高的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入有空缺的 .txt 文件，每行作为数组的一行，分隔符为逗号，选中前 2 列</span><br>data = np.genfromtxt(<span class="hljs-string">&#x27;ex1data1.txt&#x27;</span>, delimiter=<span class="hljs-string">&#x27;,&#x27;</span>, usecols=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>导入其他格式文件或许需要用到其他辅助库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> scipy.io <span class="hljs-keyword">as</span> scio<br><span class="hljs-comment"># 导入 .mat 文件需要用到 scipy.io 模块，这是一个二进制字典文件</span><br>data = scio.loadmat(<span class="hljs-string">&#x27;ex6data1.mat&#x27;</span>)<br>X = data[<span class="hljs-string">&#x27;X&#x27;</span>]<span class="hljs-comment"># 获取字典键 &#x27;X&#x27;</span><br>y = data[<span class="hljs-string">&#x27;y&#x27;</span>].flatten()<span class="hljs-comment"># 获取字典键 &#x27;y&#x27;，展开成一维</span><br>m = y.size<br></code></pre></td></tr></table></figure><h3 id="ndarray-索引"><a href="#ndarray-索引" class="headerlink" title="ndarray 索引"></a>ndarray 索引</h3><p>ndarray 容器的赋值主要用<strong>索引</strong>完成，其基本特性：<strong>浅拷贝</strong>，即多个对象<strong>共用一块内存</strong>。NumPy 官方解释是，NumPy 主要用于处理大量数据，所以不希望用缺省复制的方式，否则会引起各种内存问题。</p><p>索引语法和原生 Python 类似，用<strong>数字和冒号</strong>表示<strong>左闭右开</strong>范围：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 索引 [5,8) 位</span><br>arr1 = np.arange(<span class="hljs-number">6</span>)<span class="hljs-comment"># 内存中 [0, 1, 2, 3, 4, 5]</span><br>arr2 = arr1[<span class="hljs-number">3</span>:<span class="hljs-number">4</span>]<br><span class="hljs-comment"># 缺省，索引全部值</span><br>arr2[:] = <span class="hljs-number">6</span><span class="hljs-comment"># 内存中 [0, 1, 2, 6, 6, 5]</span><br><span class="hljs-comment"># 如果不想索引原数组</span><br>arr3 = arr1[<span class="hljs-number">1</span>:<span class="hljs-number">2</span>].copy()<span class="hljs-comment"># 用 .copy() 可以强制拷贝</span><br></code></pre></td></tr></table></figure><p>对于高维数组，如果想通过赋值实现<strong>降维</strong>，可以使用<strong>切片索引</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br><span class="hljs-built_in">print</span>(arr1[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], arr1[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<span class="hljs-comment"># 4 4，前者为 Python 列表索引</span><br><span class="hljs-built_in">print</span>(arr1[:<span class="hljs-number">1</span>, <span class="hljs-number">0</span>:])<span class="hljs-comment"># [[1 2 3]]</span><br><span class="hljs-built_in">print</span>(arr1[:, <span class="hljs-number">0</span>])<span class="hljs-comment"># [1 4]</span><br><span class="hljs-built_in">print</span>(arr1[:, :<span class="hljs-number">1</span>])<span class="hljs-comment"># [[1] [4]]</span><br></code></pre></td></tr></table></figure><p>由第一个例子注意到，不同于原生 Python，高维数组还可以通过 <code>[x,y,z]</code> 的方式在不同维度之间索引，同时还可以用<strong>冒号加数字</strong>表示<strong>左闭右开</strong>范围。</p><p>特别注意最后两个例子，在第二维上虽然范围都是 0，但前者只用了数字，后者还用了冒号，导致结果的维数并不相同。这说明：<strong>使用冒号不会降维</strong>，哪怕确实范围中只有一列。</p><p>此外，NumPy 中还有一种<strong>布尔索引</strong>的有趣用法，不是本文重点，这里举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 按 50% 概率，随机抽取序列</span><br>arr = np.arange(<span class="hljs-number">10</span>)<span class="hljs-comment"># 生成 待抽取 的序列 0 - 9</span><br>p = np.random.rand(<span class="hljs-number">10</span>)  <span class="hljs-comment"># 生成 0 - 1 之间的随机小数</span><br><span class="hljs-built_in">print</span>(arr[p &lt; <span class="hljs-number">0.5</span>])<span class="hljs-comment"># 利用标量语法，转化为 bool 数组，再索引 arr</span><br><span class="hljs-comment"># 浓缩成一行</span><br><span class="hljs-built_in">print</span>(np.arange(<span class="hljs-number">10</span>)[np.random.rand(<span class="hljs-number">10</span>) &lt; <span class="hljs-number">0.5</span>])<br></code></pre></td></tr></table></figure><h3 id="ndarray-变形"><a href="#ndarray-变形" class="headerlink" title="ndarray 变形"></a>ndarray 变形</h3><p>ndarray 可通过一些自带的函数改变形状（维度），以便完成一些复杂的矩阵运算。</p><ul><li><code>arr.flatten()</code>：返回一份<strong>深拷贝</strong>的展开成<strong>一维</strong>的数组，默认按行优先展开 <code>order=&#39;C&#39;</code>，用于矩阵时默认展开到 <code>(n,1)</code>。</li><li><code>arr[:,np.newaxis]</code>：将一维 <code>arr</code> 增加到二维数组 <code>(m,1)</code>。常用于生成<strong>列向量</strong>，才能<strong>点乘</strong>系数矩阵。</li><li><code>arr[np.newaxis,:]</code>：将一维 <code>arr</code> 增加到二维数组 <code>(1,m)</code>。</li><li><code>np.c_[arr1, arr2]</code>：将<strong>二维数组</strong>按列相连，要求<strong>行数一致</strong>。如果对象是<strong>一维</strong>数组，视作 <code>(m,1)</code> 的二维数组。<ul><li><code>np.column_stack([arr1, arr2])</code>：类似 <code>np.c_</code> 的函数形式，要求传入<strong>数组列表</strong>。</li><li><code>np.hstack([arr1,arr2])</code>：类似 <code>np.c_</code> 的函数形式，要求传入<strong>数组列表</strong>。</li></ul></li><li><code>np.r_[arr1, arr2]</code>：将<strong>二维数组</strong>按行相连，要求<strong>列数一致</strong>。如果对象是<strong>一维</strong>数组或<strong>常数</strong>，则仍拼成<strong>一维</strong>数组。<ul><li><code>np.row_stack([arr1, arr2])</code>：类似 <code>np.r_</code> 的函数形式，要求传入<strong>数组列表</strong>。</li><li><code>np.vstack([arr1,arr2])</code>：类似 <code>np.c_</code> 的函数形式，要求传入<strong>数组列表</strong>。</li></ul></li><li><code>np.reshape(arr, (5,5))</code>：调整形状，默认<strong>按行展开</strong>后填到新形状，要求<strong>规模匹配</strong>。如果形状元组里某一维填 <code>-1</code>，则会根据其他维度计算该维长度。如果只有一个 <code>-1</code>，则效果同 <code>arr.flatten()</code>。</li><li><code>np.flip(arr, axis=0)</code>：将 <code>arr</code> 在按行切片，并把<strong>行</strong>次序颠倒。如果不加 <code>axis</code> 则会在<strong>所有维度</strong>都进行颠倒，常用于卷积核的翻转。</li><li><code>np.concatenate((a1,a2,...), axis=0)</code>：高效地拼接大规模数组，<code>axis</code> 表示拼接时切片的维度，对于一维数组默认拼完还是一维。</li><li><code>np.pad(arr, width, mode=‘edge’)</code>：在 <code>arr</code> 的每个轴边缘填充，填充的长度 <code>width</code> 为嵌套元组 <code>((before_1, after_1), ..., (before_N, after_N))</code>，<code>mode</code> 为填充的值，可以为边缘值、最大值、平均值等。</li></ul><h2 id="常用数学函数"><a href="#常用数学函数" class="headerlink" title="常用数学函数"></a>常用数学函数</h2><p>ndarray 的另一特点是支持<strong>类标量语法</strong>的计算，标量会作用在数组的<strong>每一个</strong>元素上，例如：<code>arr + 2</code>、<code>arr * 10</code> 、<code>arr[:] = 2</code>、<code>arr &gt; 5</code> 等。此外，还支持一系列运算函数，以下所有函数同样支持 <code>数组变量.函数名(参数)</code> 形式调用：</p><h3 id="普通运算"><a href="#普通运算" class="headerlink" title="普通运算"></a>普通运算</h3><ul><li><code>np.sum(arr[1,:])</code>：对一维数组 <code>arr[1,:]</code>，求和，得到一个值。</li><li><code>np.sum(arr, 0)</code>：对二维数组 <code>arr</code>，求每一列和，<strong>塌缩</strong>成 <code>(列数,)</code>。</li><li><code>np.sum(arr, 1)</code>：对二维数组 <code>arr</code>，求每一行和，塌缩成 <code>(行数,)</code>。</li><li><code>np.max(arr)</code>：对整个数组，求最大值，得到一个值。</li><li><code>np.max(arr, 0)</code>：对二维数组 <code>arr</code>，求每一列最大值，塌缩成 <code>(列数,)</code>。</li><li><code>np.argmax(arr,0)</code>：对二维数组 <code>arr</code>，求每一列最大值的索引，塌缩成 <code>(列数,)</code>。</li><li><code>np.sin(arr)</code>、<code>np.cos(arr)</code>、<code>np.tan(arr)</code>：作用于每个元素求三角函数。</li><li><code>np.arcsin(arr)</code>、<code>np.arccos(arr)</code>、<code>np.arctan(arr)</code>：作用于每个元素求反三角函数。</li><li><code>np.arctan2(y, x)</code>：<code>(x, y)</code> 为坐标系上的一点，该函数可求出该点与原点连线到 x 轴的夹角，范围为 <code>[-pi, pi]</code>，通常使用 <code>np.arctan2(y, x) * 180 / np.pi</code> 来求出夹角。</li><li><code>np.power(arr, n)</code>：作用于每个元素求 <code>n</code> 次幂。</li><li><code>np.square(arr)</code>：作用于每个元素求平方，更快。</li><li><code>np.sqrt(arr)</code>：作用于每个元素开根号，更快。</li></ul><h3 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h3><ul><li><p><code>arr1 @ arr2</code>：<strong>矩阵点乘</strong>，要求第一个矩阵的列数等于第二个矩阵的行数，一维数组视作二维数组的<strong>行向量或列向量</strong>。</p><ul><li><code>np.dot(arr1, arr2)</code>：同上，矩阵点乘</li><li><code>np.matmul(arr1, arr2)</code>：同上，矩阵点乘，支持高维矩阵的 Broadcast。</li></ul></li><li><p><code>arr1 * arr2</code>：<strong>对应位置相乘</strong>，即 Hadmard 积，要求两个矩阵<strong>各个维度长度相等</strong>。</p><ul><li><code>np.multiply(arr1, arr2)</code>：同上，对应位置相乘。</li></ul></li><li><p><code>arr1.T</code>：求数组<strong>转置</strong>，数组没有求逆、共轭的函数。</p><ul><li><code>np.transpose(arr1)</code>：同上，<strong>不指定参数</strong>时求二维数组的转置，高维数组需用元组指定索引，表示相应的索引顺序<strong>交换</strong>。</li></ul></li></ul><h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><ul><li><code>np.linalg.inv(arr)</code>：求逆矩阵，要求二维数组。</li><li><code>np.linalg.pinv(arr)</code>：求伪（广义）逆矩阵，要求二维数组。</li><li><code>np.linalg.det(arr)</code>：求行列式（标量），要求二维数组。</li><li><code>np.linalg.solve(A,b)</code>：解形如 Ax=b 线性方程组。</li><li><code>w = np.linalg.eigvals(arr)</code>：求矩阵特征值，<code>w</code> 为 (m,) 一维数组，存放特征值。</li><li><code>w,v = np.linalg.eig(arr)</code>：求矩阵特征值，<code>v</code> 为 (m,m) 二维数组，每一列都是特征向量，与 <code>w</code> 对应。</li><li><code>np.linalg.svd(arr)</code>：求矩阵的 SVD 分解。</li><li><code>np.linalg.norm(arr, axis=0, ord=1)</code>：按列求向量 1 范数。</li><li><code>np.linalg.norm(arr, axis=0, ord=2)</code>：按列求向量 2 范数，默认选项。</li><li><code>np.linalg.norm(arr, axis=0, ord=np.inf)</code>：按列求向量无穷范数。</li></ul><h3 id="统计运算"><a href="#统计运算" class="headerlink" title="统计运算"></a>统计运算</h3><ul><li><code>np.mean(arr)</code>：求<strong>所有</strong>样本平均值。</li><li><code>np.mean(arr, 0)</code>：对二维数组 <code>arr</code>，求每一列样本平均值，<strong>塌缩</strong>成 <code>(列数,)</code>。</li><li><code>np.average(arr, weights=None)</code>：求样本加权平均值。</li><li><code>np.std(arr)</code>：求所有样本标准差。</li><li><code>np.std(arr, ddof=1)</code>：求所有样本<strong>无偏</strong>标准差。</li><li><code>np.std(arr, axis=0, ddof=1)</code>：对二维数组 <code>arr</code>，求每一列样本<strong>无偏</strong>标准差，<strong>塌缩</strong>成 <code>(列数,)</code>。</li><li><code>np.var(arr)</code>：求所有样本方差，相当于标准差的平方。</li><li><code>np.cov(arr)</code>：对一维数组 <code>arr</code>，相当于求自身的协方差（退化为<strong>无偏</strong>方差），即<strong>无偏</strong>标准差的平方。</li><li><code>np.cov(arr)</code>：对二维数组 <code>arr</code>，返回一个二维数组，元素 <code>[i,j]</code> 代表<code>arr[i]</code> 与 <code>arr[j]</code> 两列元素的协方差。</li></ul><h2 id="NumPy-进阶"><a href="#NumPy-进阶" class="headerlink" title="NumPy 进阶"></a>NumPy 进阶</h2><h3 id="matrix-对象"><a href="#matrix-对象" class="headerlink" title="matrix 对象"></a>matrix 对象</h3><p>除了 ndarray，NumPy 针对二维数组还专门设置了一个<strong>矩阵</strong>对象。matrix 的大部分性质与 ndarray 无异，但多了一些功能函数：</p><ul><li><code>np.mat([[1,2],[5,7]])</code>：声明矩阵，注意维数必须为 2。</li><li><code>np.mat([1,2,3])</code>：会被强制转化为 <code>(1,3)</code> 的二维矩阵。</li><li><code>np.mat(arr1)</code>、<code>np.asmatricx(arr1)</code>：从数组转到矩阵。</li><li><code>np.asarray(mat1)</code>：从矩阵转到数组。</li><li><code>mat1.T</code>、<code>mat1.H</code>、<code>mat1.I</code>：求转置矩阵、共轭矩阵、逆矩阵。</li><li><code>mat1 * mat2</code>：<strong>点乘</strong>，要求第一个矩阵的列数等于第二个矩阵的行数。</li><li><code>np.multiply(mat1, mat2)</code>：<strong>对应位置相乘</strong>，要求两个矩阵<strong>各个维度长度相等</strong>。</li></ul><h3 id="Broadcast-广播机制"><a href="#Broadcast-广播机制" class="headerlink" title="Broadcast 广播机制"></a>Broadcast 广播机制</h3><p>NumPy 中对于两个 ndarray 的<strong>加减乘除</strong>都是标量操作，即对应位置元素之间的操作。并且，当两个数组的形状不同时，NumPy 自带的 Broadcast 机制会<strong>自动扩展数组</strong>进行操作，这是 NumPy 向量化运算的基石。</p><p>例如，在归一化变量时，我们使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 元素减去平均值，除以无偏标准差</span><br>data = (data - data.mean(<span class="hljs-number">0</span>)) / data.std(axis=<span class="hljs-number">0</span>, ddof=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>很明显，<code>data</code> 和塌缩后的 <code>np.mean(data, 0)</code> 形状不相同，但仍可以相减。</p><p>广播兼容的条件有两种：</p><ul><li>两个<strong>不同维度</strong>的数组的<strong>后缘维度</strong>（trailing dimension，即从末尾开始算起的维度）的轴长度相符。如：<code>(4,3)</code> 与 <code>(3,)</code>；<code>(5,6,7)</code> 与 <code>(6,7)</code>。</li><li>两个<strong>相同维度</strong>的数组，但其中在<strong>某一维度</strong>上仅为 1。如 <code>(4,5,6)</code> 与 <code>(4,1,6)</code>、<code>(4,5,1)</code>。</li></ul><h3 id="C-API"><a href="#C-API" class="headerlink" title="C-API"></a>C-API</h3><p>NumPy 提供了一个 C-API，使用户能够扩展系统并快速访问<strong>数组对象</strong>，以便在其他例程中使用。真正理解 C-API 的最好方法是阅读源代码，这里仅列举部分神奇的用法。</p><ul><li><p><code>np.argpartition(arr, n)</code>：高效地将数组中的所有元素<strong>分割</strong>，分割点为结果下标 <code>n</code> 的元素，左侧是较小数，右侧是较大数。注意仅返回分割后数组的<strong>索引</strong>，常用于检索算法中输出 Top N 结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.array([<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(np.argpartition(a, -<span class="hljs-number">5</span>))<br>[<span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">0</span>]  <span class="hljs-comment"># 结果的索引</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a[np.argpartition(a, -<span class="hljs-number">5</span>)]<br>array([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>])<span class="hljs-comment"># 真正的结果</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a[np.argpartition(a, -<span class="hljs-number">5</span>)[-<span class="hljs-number">5</span>:]]<br>array([<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>])<span class="hljs-comment"># Top 5</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p><code>np.where(condition)</code>：找出满足条件 <code>condition</code> 元素的坐标，返回一个 tuple，每一项是一个一维 ndarray，分别对应符合条件元素的<strong>各维坐标</strong>。简单的条件用<strong>布尔索引</strong>也可替代，常用于绘制散点图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">pos = np.where(y == <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br>neg = np.where(y == <span class="hljs-number">0</span>)[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 返回 label 为 0 和 1 的样本点的索引</span><br><br>plt.scatter(X[pos, <span class="hljs-number">0</span>], X[pos, <span class="hljs-number">1</span>], marker=<span class="hljs-string">&quot;o&quot;</span>, c=<span class="hljs-string">&#x27;c&#x27;</span>)<br>plt.scatter(X[neg, <span class="hljs-number">0</span>], X[neg, <span class="hljs-number">1</span>], marker=<span class="hljs-string">&quot;x&quot;</span>, c=<span class="hljs-string">&#x27;r&#x27;</span>)  <span class="hljs-comment"># 绘制散点图</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p><code>X, Y = np.meshgrid(x, y)</code>：生成<strong>格点矩阵</strong>，<code>x</code> 和 <code>y</code> 需是一维向量，输出的是一个 <code>x * y</code> 格点矩阵的每个点的横纵坐标，<code>X</code> 和 <code>Y</code> 是形状为 <code>(x, y)</code> 的二维矩阵。常用于绘制等高线图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">u = np.linspace(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">50</span>)<br>v = np.linspace(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">50</span>)<br>U, V = np.meshgrid(u, v)  <span class="hljs-comment"># 生成 50x50 网格点矩阵</span><br>z = (map_feature(U.flatten(), V.flatten()) @ theta).reshape((<span class="hljs-number">50</span>, <span class="hljs-number">50</span>))  <span class="hljs-comment"># 计算等高线</span><br>plt.contour(u, v, z, [<span class="hljs-number">0</span>], colors=<span class="hljs-string">&#x27;r&#x27;</span>)  <span class="hljs-comment"># 绘制轮廓图，取高度为 0 的点</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p><code>np.concatenate((np.ravel(a), np.ravel(b)))</code>：扁平化参数，其中 <code>ravel(a)</code> 是将多维数组变成一维数组，<code>concatenate((arr1, arr2, ...),axis=0)</code> 是将一维数组首尾相接。有些 SciPy 中的科学计算方法（梯度下降）需要一次性将所有参数线性输入，就可以用到这个。</p></li><li><p><code>np.cumsum(arr, axis=None)</code>：对一维、二维等数组求<strong>前缀和</strong>，如果不加 <code>axis</code> 参数则默认按行展开为一维数组后求前缀和；如果为 0 ，按照行累加，为 axis=1，按照列累加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<br><span class="hljs-meta">&gt;&gt;&gt; </span>np.cumsum(a)<br>array([ <span class="hljs-number">1</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">21</span>])  <span class="hljs-comment"># 展开成一维数组</span><br></code></pre></td></tr></table></figure></li><li><p><code>np.argsort(arr)</code>：返回的是元素值从小到大排序后的<strong>索引</strong>，内置快排实现，如果要从大到小，只需将参数改为 <code>-arr</code>。常用于求完特征值和特征向量后进行排序，提取主成分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.array([<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>np.argsort(a)<br>array([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])  <span class="hljs-comment"># 升序</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>np.argsort(-a)<br>array([<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>])  <span class="hljs-comment"># 降序</span><br><br><span class="hljs-comment"># PCA z</span><br>w, v = np.linalg.eig(M)<br>sorted_indices = np.argsort(-w)<br>eigenvalues = w[sorted_indices[:k]]<br>eigenvectors = v[:, sorted_indices[:k]].astype(np.float64).T<br></code></pre></td></tr></table></figure></li><li><p><code>grid = np.indices((H, W))</code>：返回一个给定 <code>shape=(2,H,W)</code> 的<strong>序号网格数组</strong>，其中 <code>grid[0]</code> 里的每个元素为该位置元素的<strong>行</strong>序号，<code>grid[1]</code> 为<strong>列</strong>序号，可以用于<strong>局部提取</strong>数组元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.arange(<span class="hljs-number">20</span>).reshape((<span class="hljs-number">5</span>,<span class="hljs-number">4</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>grid = np.indices((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br><span class="hljs-comment"># [[[0 0 0],</span><br><span class="hljs-comment">#   [1 1 1]],</span><br><span class="hljs-comment">#  [[0 1 2],</span><br><span class="hljs-comment">#   [0 1 2]]]</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>x[grid[<span class="hljs-number">0</span>], grid[<span class="hljs-number">1</span>]]<br><span class="hljs-comment"># [[0 1 2]</span><br><span class="hljs-comment">#  [4 5 6]]</span><br></code></pre></td></tr></table></figure></li><li><p><code>np.allclose(arr1, arr2)</code>：用于检查两个数组是否每个元素都相似，返回<strong>布尔值</strong>，默认在 1e-5 的相对误差范围内。</p></li><li><p><code>np.nonzero(arr)</code>：用于得到 N 维数组中非零元素的位置（数组索引），返回一个<strong>N 元元组</strong>，每一个元素都为一个一维数组，<code>tuple[i][j]</code> 代表第 <code>j</code> 个非零元素的第 <code>i</code> 维下标：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">a =[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<br>    [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]]<br><span class="hljs-meta">&gt;&gt;&gt; </span>np.nonzero(a)<br><span class="hljs-comment"># (array([0, 0, 0, 1, 2, 2], dtype=int64), array([0, 1, 2, 1, 1, 2], dtype=int64))</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>indices = np.stack(np.nonzero(a)).T<br><span class="hljs-comment"># array([[0,0], [0,1], [0,2], [1,1], [2,1], [2,2]])</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python笔记 #1 基础语法</title>
    <link href="/Python-Note-1.html"/>
    <url>/Python-Note-1.html</url>
    
    <content type="html"><![CDATA[<p>跟着贵系的暑培过了一遍语法，然而写代码时还是感到乏力，总觉得要打一遍才能记住，于是有了这篇博客。</p><p>本文部分内容参考了清华 AYF 同学的教程，部分参考了 Python 官方的一份 <a href="https://docs.python.org/zh-cn/3/tutorial/index.html">Tutorial</a>，函数用法参考了 <a href="https://xyfjason.top">xyfJASON</a> 的博客。本文将持续更新。</p><h2 id="Python-特性"><a href="#Python-特性" class="headerlink" title="Python 特性"></a>Python 特性</h2><p>相比于 C 的编译型、弱类型、静态类型特点，Python 则是一种解释型、强类型、动态类型的语言。</p><h3 id="交互式-vs-脚本"><a href="#交互式-vs-脚本" class="headerlink" title="交互式 vs 脚本"></a>交互式 vs 脚本</h3><p>作为一种解释型语言，Python 不需要像 C 一样编译运行，它可以<strong>逐行运行</strong>代码，因此又分为<strong>交互式窗口</strong>运行与<strong>脚本</strong>运行两种模式：</p><ul><li>交互式窗口：在 CLI 输入 <code>python</code>，即可进入交互式窗口，输入一行代码即可运行。本文使用的交互式环境是 <strong>IPython</strong>，输入 <code>ipython</code> 即可呼出。</li><li>脚本：在 CLI 输入 <code>python xxx.py</code>，就会依次执行整个脚本文件。本文使用的 IDE 是 <strong>PyCharm</strong>。</li></ul><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>) <span class="hljs-comment"># 打印输出</span><br>Hello, world!<br></code></pre></td></tr></table></figure><p>在交互式窗口，<code>&gt;&gt;&gt;</code> 作为提示符，在 IPython 中则是 <code>In [1]:</code>。执行 <code>exit()</code> 或者按下 <code>Ctrl+D</code> 就能退出窗口。</p><p>注意到，这行代码中没有 <code>;</code> 分号，可以直接运行而无需编译，字符串用了单引号，注释用 <code>#</code> 开始【与 C 不同】。</p><h2 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h2><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>【与 C 不同】，Python <strong>不用</strong>声明变量类型，解释器自动解释。</p><ul><li><code>int</code>：变长整数，默认是 4 字节，有需要时自动增长，用于高精度运算，还支持十六进制、八进制和二进制表示。</li><li><code>complex</code>：自带的复数类型，表示为 <code>real + imag*1j</code> 的形式，虚部为 1 的时候不可省略 1，可以用 <code>j</code> 也可以用 <code>J</code>。实虚部分别为一个 <code>float</code>。</li><li><code>float</code>：8 字节浮点数，【相当于 C 的 double】。</li><li><code>bool</code>：True 和 False，注意首字母大写，用作数值计算时与 C 一样视作 0 和 1。</li><li><code>NoneType</code>： None，空值，常用于返回值、特判。</li></ul><blockquote><p>需要单独说明的是，Python 会存储所有的 -5 到 256 的整数，其他任何变量是这些值时，会被指向这个<strong>预先开好</strong>的内存，因此任何两个值为 5 的 int 变量都指向同⼀内存地址。</p></blockquote><p>尽量用小写变量名（<strong>下划线法</strong>），这是 Python3 的主流命名方式。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>这里列出常见的运算符，运算符可以重载，重载需要修改其对应的定义函数。</p><p><strong>算术运算符</strong>：</p><ul><li><code>+</code> <code>-</code> <code>*</code>【与 C 相同】</li><li><code>%</code>：<code>35 % 4 == 3</code>，<code>-35 % 4 == 1</code>，<code>35 % -4 == -1</code>，<code>-35 % -4 == -3</code>，【与 C 不同：负数对正数取模时返回正余数，而非像 C 那样返回负余数】</li><li><code>/</code>： <code>__trudiv__</code>，真除，得到 <code>float</code> 结果</li><li><code>//</code>： <code>__floordiv__</code>，除后向下取整（不是舍弃小数），得到 <code>int</code> 结果</li><li><code>**</code>： <code>__pow__</code>，幂运算</li></ul><p><strong>比较运算符</strong>：</p><ul><li><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code> <code>==</code> <code>!=</code> 【与 C 相同】</li></ul><p><strong>位运算符</strong>:</p><ul><li><code>&amp;</code> <code>|</code> <code>^</code> <code>~</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> 【与 C 相同】</li></ul><p><strong>赋值运算符</strong>：</p><ul><li><code>=</code>：赋值号，不能被重载</li><li><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> 【与 C 相同】</li><li>注意 Python 中没有 <code>++</code> <code>--</code> 的运算符，只能通过 <code>+= 1</code> 实现</li></ul><p><strong>逻辑运算符</strong>：</p><ul><li><code>and</code> <code>or</code> <code>not</code> 【类似 C 中的 <code>&amp;&amp;</code> <code>||</code> <code>！</code>】</li><li>对于 <code>and</code> 和 <code>or</code>，通常用于条件分支 <code>bool</code> 的判断，如果非要连接 <code>int</code> 变量，得到的结果不会直接转换为 <code>bool</code>，而是返回<strong>能够得出结果</strong>的<strong>最后一个变量</strong>【与 C 中的短路类似】</li></ul><p><strong>三目运算符</strong>：</p><ul><li><code>a if cond else b</code>：相当于 C 中的 <code>cond ? a : b</code>，注意其参数顺序【与 C 不同】，但更贴近自然语言</li></ul><p><strong>特殊条件运算符</strong>：</p><ul><li><code>in</code>：被包含于，详见下文「容器」，返回 bool</li><li><code>not in</code>：<code>in</code> 的否定，返回 bool</li><li><code>is</code>：判断两个变量的地址是否相同，不可重载，返回 bool</li><li><code>is not</code>：判断两个变量地址是否不同，不可重载，返回 bool</li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Python 将字符串封装成了<strong>基本类型</strong>并处理了多种运算，带来许多便利，注意基本类型本身是<strong>不可修改</strong>的，所谓修改其实是将<strong>重新生成</strong>另一个字符串，再将其<strong>赋值</strong>给目标。</p><p>此外，Python 中没有单独的字符类型，单个字符将被视为长度为 1 的字符串。【与 C 不同】，可以用 <code>&quot;&quot;</code> 或者 <code>&#39;&#39;</code> 括起字符串。</p><p>下面是一些常用函数，设 <code>str</code> 是一个字符串：</p><ul><li><code>str.title()</code>：返回单词首字母大写，其余字母小写（不管以前是不是大写）的字符串</li><li><code>str.upper()</code>、<code>str.lower()</code>：返回全大/小写的字符串</li><li><code>str1 + str2</code>：返回用加号拼接的字符串【与 C++ 的 <code>string</code> 类似】</li><li><code>str * 3</code>：返回重复三遍拼接的字符串</li><li>制表符 <code>\t</code>，换行符 <code>\n</code>【与 C 相同】</li><li><code>str.lstrip()</code>、<code>str.rstrip()</code>、<code>str.strip()</code>: 返回删除开头/末尾/两端空白的字符串</li><li><code>str.replace(str1, str2)</code>：将字符串中的单词 <code>str1</code> 全部替换成 <code>str2</code> </li><li><code>str.split(str1)</code>：以 <code>str1</code> 为分隔符把字符串拆成子串，并返回包含子串的列表，默认分隔符为空格</li><li><code>str.zfill(n)</code>：将数字字符串补全<strong>前导零</strong>，<code>n</code> 为总位数</li></ul><p>此外还有一种跨行字符串，用 <code>’‘’</code> 或 <code>”“”</code> 括起来，由于脚本中顺序执行时不会输出变量值，这类字符串常用于<strong>跨行注释</strong>，特别是函数头注释。</p><h3 id="输入输出与编码"><a href="#输入输出与编码" class="headerlink" title="输入输出与编码"></a>输入输出与编码</h3><p>此处说明几个重要函数：</p><ul><li><code>len(obj)</code>：获取 <code>obj</code> 的长度，常用于获取字符串（注意是 Unicode，因此中文和英文字符都占 1 位）、字节串、容器的长度</li><li><code>str(a)</code>: 把数字（整型或浮点型） <code>a</code> 转换成字符串</li><li><code>chr(0x4f60)</code>：将整型变量 <code>i</code> 转化成单个字符</li><li><code>ord(&#39;你&#39;)</code>：获取单个字符的编码（Unicode），注意在 Unicode 中，英文字母的编码有意设置与 ASCII 码一致</li></ul><p>最常用的输出语句 <code>print</code>，本质上是将变量<strong>转化为字符串</strong>输出，在末尾自动<strong>换行</strong>。该函数可以有多个变量，变量间用 <code>,</code> 分隔，输出时会用空格隔开。</p><p>如果要在一句话中插入许多变量，这条 <code>print</code> 语句可能会很丑陋，因此 Python 中有三种格式化字符串的方法。</p><ul><li><code>%</code>：如 <code>print(&#39;I am %d&#39; % (age))</code>，【与 C 类似】</li><li><code>str.format()</code>：如 <code>print(&#39;hello, &#123;&#125;&#39;.format(name))</code></li><li><code>f-string</code>：如 <code>print(f&#39;hello,&#123;name&#125;.I am &#123;age&#125;&#39;)</code></li></ul><p>其中 <code>f-string</code> 是 Python3.6 的新特性，最为直观便利。</p><p>此外，<code>input(&#39;Press ENTER to continue&#39;)</code> 是常见的一种输入语句，会显示对应的提示内容，读入内容以以字符串存储，可以用 <code>int(input())</code> 或 <code>map(int, input().split())</code> 处理。</p><h3 id="字节串"><a href="#字节串" class="headerlink" title="字节串"></a>字节串</h3><p><code>bytes</code> 即是 Python 中的字节串，它表示最纯粹的<strong>二进制</strong>数据，【类似 C 的 <code>unsigned char *</code>】，但是在显示上它仅支持 ASCII 显示，因此用肉眼看显得有些不伦不类，通常它只存在于数据的处理过程中。</p><p><code>bytes</code> 的构造与字符串类似，但是要加一个 <code>b</code> 做前导，如 <code>print(b&#39;\x41&#39;)</code>。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>Python 提供了一系列内置容器，它们如同 C++ 的 STL ⼀样，不过比 STL 的用法灵活得多。</p><p>同样先介绍几个重要函数：</p><ul><li><code>type(obj)</code>：可以获取参数 <code>obj</code> 的类型</li><li><code>isinstance(obj, class_or_tuple)</code>：可以判断 <code>obj</code> 是不是类的实例</li><li><code>id(obj)</code>：获取 <code>obj</code> 的地址， <code>a is b</code> 等价于 <code>id(a) == id(b)</code></li></ul><h3 id="列表-List"><a href="#列表-List" class="headerlink" title="列表 | List"></a>列表 | List</h3><p>列表（list）是很常用的容器，常被看作 Python 中的数组，但实际上【与 C++ 的 vector 类似】。设 <code>lst</code> 是一个列表：</p><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><ul><li>定义列表：<code>lst = [a, b, c, d]</code> ，其中 <code>a,b,c,d</code> 等是列表的元素，<strong>类型可以不同</strong></li><li>构造空列表：直接写 <code>[]</code> 或 <code>list()</code></li><li>打印列表：<code>print(lst)</code>（会将列表中的元素列出，括在<strong>方括号</strong>里）</li><li>访问元素：<code>lst[3]</code> ， 下标从 <strong>0</strong> 开始。此外，还支持<strong>负数</strong>索引，<code>-1</code> 表示倒数第一个，<code>-2</code> 倒数第二个【与 C 不同】</li></ul><h4 id="修改、添加、删除元素"><a href="#修改、添加、删除元素" class="headerlink" title="修改、添加、删除元素"></a>修改、添加、删除元素</h4><ul><li>修改：直接访问元素并赋值</li><li><code>lst.append(x)</code>：在列表末尾添加元素 <code>x</code> </li><li><code>lst.insert(idx, x)</code>：在列表索引 <code>idx</code> 处插入一个元素 <code>x</code> （插入后，<code>x</code> 的索引是 <code>idx</code>，其后的元素后移一格）</li><li><code>del lst[3]</code>：删除指定元素（删除后，其后元素前移一格）</li><li><code>lst.pop()</code>：弹出<strong>并返回</strong>最后一个元素</li><li><code>lst.pop(idx)</code>：弹出<strong>并返回</strong>指定元素</li><li><code>lst.remove(x)</code>：删除<strong>第一个</strong>值为 <code>x</code> 的元素</li></ul><h4 id="组织列表"><a href="#组织列表" class="headerlink" title="组织列表"></a>组织列表</h4><ul><li><code>lst.sort()</code>、<code>lst.sort(reverse = True)</code>：对列表排序，永久性修改顺序</li><li><code>sorted(lst)</code>、<code>sorted(lst, reverse = True)</code>：返回排序后的列表，但<strong>不改变</strong>列表原有顺序</li><li><code>lst.reverse()</code>：翻转列表，永久性修改顺序</li><li><code>len(lst)</code>：返回列表长度，即元素个数（不论类型）</li></ul><h4 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h4><ul><li><p>从头到尾遍历列表：<code>for i in lst:</code> 循环表达式，【与 C 不同】<code>i</code> 是列表<strong>元素</strong>，不是索引；循环结束后 <code>i</code> 停留为<strong>最后一个</strong>元素</p></li><li><p>遍历列表时同时遍历下标：<code>for idx, value in enumerate(lst):</code></p></li><li><p>若要检查列表是否为空，可以用 <code>if lst:</code> 条件表达式，返回 bool</p></li></ul><h4 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h4><ul><li><code>lst[l:r]</code>：返回一个列表，元素依次是 <code>lst</code> 列表的索引在<strong>左闭右开区间</strong>内的元素，省略 <code>l</code> 或 <code>r</code> 则默认从头开始或到尾结束</li><li><p><code>lst[l:r:step]</code>：指定步长为 <code>step</code> 切片，<code>step</code> 为 -1 时返回倒序</p></li><li><p>可以用循环遍历列表切片：<code>for i in lst[l:r]:</code> </p></li><li><p>复制列表：在切片中同时省略 <code>l</code> 和 <code>r</code>，即返回<strong>从头到尾</strong>的列表，如 <code>lst2 = lst1[:]</code>，而非 <code>lst2=lst1</code>，后者<code>lst1</code> 和 <code>lst2</code> 实质是同一个列表【类似 C 的引用】</p></li></ul><h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 | Tuple"></a>元组 | Tuple</h3><p>元组就是元素值<strong>不可修改</strong>（弱意义上的，其中<strong>元素的元素</strong>可以被修改）的列表。设 <code>tpl</code> 是一个元组：</p><h4 id="基础操作-1"><a href="#基础操作-1" class="headerlink" title="基础操作"></a>基础操作</h4><ul><li>定义元组：<code>tpl = (a, b, c, d)</code>，把列表定义中的方括号改成圆括号 <code>()</code> 即可</li><li>定义时的小括号有时候可以省略，可以直接用 <code>,</code> 逗号构造元组【与 C 不同，没有逗号运算符】</li><li>构造单元组：<code>(1)</code> 会被理解成表达式，要用 <code>(1,)</code></li><li>构造空元组，直接写 <code>()</code> 或 <code>tuple()</code>，但 <code>(,)</code> 会报错</li><li>访问元素：<code>tpl[3]</code> ， 下标从 <strong>0</strong> 开始。</li></ul><h4 id="遍历元组"><a href="#遍历元组" class="headerlink" title="遍历元组"></a>遍历元组</h4><p><code>for i in tpl:</code> 和列表一样</p><h4 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h4><p>元组中元素的值不能修改，但是<strong>元组变量本身</strong>可以被赋值，这点与字符串类似。此外，如果元组的中的元素是可修改的，如 List，则可以修改 List 内部的元素。</p><h4 id="元组解包"><a href="#元组解包" class="headerlink" title="元组解包"></a>元组解包</h4><p>经典的 Python 交换赋值代码：<code>a, b = b, a</code>，利用了解包和逗号构造。</p><p>其余的若干种解包方法待补充：<a href="https://zhuanlan.zhihu.com/p/351369448">https://zhuanlan.zhihu.com/p/351369448</a></p><h4 id="元组打包"><a href="#元组打包" class="headerlink" title="元组打包"></a>元组打包</h4><p><code>zip()</code> 函数用于将<strong>若干个迭代容器</strong>打包为元组（通常是两个 List），返回一个 <code>zip</code> 对象。如果初始 List 的大小不同，则会向最小的<strong>对齐</strong>。初始的 <code>zip</code> 对象不占内存空间（Python 3.x 新特性），如果要展示，则需手动 <code>list()</code> 转换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>b = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>zipped = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(a,b))     <span class="hljs-comment"># 打包为元组的列表</span><br>[(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(*zipped))          <span class="hljs-comment"># 与 zip 相反，*zipped 可理解为解包，返回二维矩阵</span><br>[(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span>c, d = <span class="hljs-built_in">zip</span>(*zipped)<span class="hljs-comment"># 解包后利用逗号构造两个列表</span><br></code></pre></td></tr></table></figure><h3 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合 | Set"></a>集合 | Set</h3><p>集合由一组无序、互不重复的元素构成（在数学上也是如此），在内部用哈希实现。设 <code>st</code> 是一个集合：</p><h4 id="基础操作-2"><a href="#基础操作-2" class="headerlink" title="基础操作"></a>基础操作</h4><ul><li>定义集合：<code>st = &#123;1, 2, 3&#125;</code>，把列表定义的方括号改成花括号 <code>&#123;&#125;</code> 即可</li><li>构造空集合：只能用 <code>set()</code>，因为 <code>&#123;&#125;</code> 的表达被空字典占用了</li><li>由列表转集合：<code>st = set([1, 1, 1, 2, 2, 3])</code>，会自动去重，常用于去重列表的遍历 <code>for i in set(lst):</code></li><li>注意集合的元素必须是可 hash 的，不能为 list 这种可变容器变量</li></ul><h4 id="添加、删除元素"><a href="#添加、删除元素" class="headerlink" title="添加、删除元素"></a>添加、删除元素</h4><ul><li><code>st.add(4)</code>：添加一个元素</li><li><code>st.remove(2)</code>：删除一个元素</li></ul><h3 id="字典-Dictionary"><a href="#字典-Dictionary" class="headerlink" title="字典 | Dictionary"></a>字典 | Dictionary</h3><p>字典是一系列「<strong>键值对</strong>」，用于存储一组有穷映射，可将任何 Python 对象作为值，【类似于更高端版本的 C++ 的 map】。</p><h4 id="基础操作-3"><a href="#基础操作-3" class="headerlink" title="基础操作"></a>基础操作</h4><ul><li>定义字典：<code>dic = &#123;&#39;name&#39;: &#39;张三&#39;, &#39;age&#39;: 18&#125;</code>，<strong>花括号</strong>括起一系列键值对，键与值之间冒号 <code>:</code> 分隔，键值对之间逗号 <code>,</code> 分隔。</li><li>访问元素：<code>d[&#39;name&#39;]</code>，用键访问</li><li>注意字典的键必须是可 hash 的，不能为 list 或 set 这种可变容器变量，但可以是 tuple</li></ul><h4 id="添加、修改、删除"><a href="#添加、修改、删除" class="headerlink" title="添加、修改、删除"></a>添加、修改、删除</h4><ul><li>添加：直接赋值即可（即使键本来不存在），如：<code>dic[&#39;x&#39;] = 0</code> </li><li>修改：<code>dic[&#39;age&#39;] = 18</code>，直接赋值即可</li><li>删除：<code>del dic[&#39;age&#39;]</code> </li></ul><h4 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h4><ul><li>遍历所有键值对：<code>for k, v in dic.items():</code>，其中 <code>items()</code> 返回键值对的<strong>列表</strong></li><li>遍历所有键：<code>for k in dic.keys():</code>，其中 <code>keys()</code> 返回键的<strong>列表</strong>，可省略</li><li>由于 <code>keys()</code> 的本质是<strong>列表</strong>，各种对列表的操作也适用，如：<code>for k in sorted(dic.keys()):</code> 或 <code>if &#39;age&#39; in dic.keys():</code></li><li>遍历所有值：<code>for v in dic.values():</code>，其中 <code>values()</code> 返回值的<strong>列表</strong></li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>前文提到的所有容器，包括字符串、字节串都是可迭代的，这意味着它们可以用 <code>for</code> 循环来遍历，也可以用<strong>生成式</strong>构造（下面介绍）。</p><p>但最为特殊的迭代器是 <code>range</code> 类型，作为<strong>数值列表</strong>，与列表有相似之处，但它实际上<strong>不占用内存</strong>（用于大循环时很节省空间）。下面是一些常用方法：</p><ul><li><code>range(l, r)</code>：依次生成<strong>左闭右开区间</strong>中的整数【类似于 C++ 的 <code>for(int i = l; i &lt; r; i++)</code>】，如果省略左端，会默认以 0 开始</li><li><code>range(l, r, step)</code>：指定步长为 <code>step</code>【类似于 C++ 的 <code>for(int i = l; i &lt; r; i += step)</code>】</li><li><code>min(range(l, r))</code>、<code>max(range(l, r))</code>、<code>sum(range(l, r))</code>：返回数值列表的最小值、最大值、总和</li><li>在 <code>for i in range(10):</code> 的循环中改变了 <code>i</code> 的值，如 <code>i += 1</code>， 不会影响循环的次数，因为迭代器中的数值列表是<strong>不可修改</strong>的【与 C 不同】</li></ul><h3 id="生成式"><a href="#生成式" class="headerlink" title="生成式"></a>生成式</h3><p>使用生成式构造容器是非常常见、高效的操作，下面举几个例子：</p><ul><li><code>a = list(range(10))</code>：直接转化数值列表为基本列表</li><li><code>lst = [i ** 2 for i in a]</code>：列表生成式</li><li><code>st = &#123;x % 7 for x in a&#125;</code>：集合生成式</li><li><code>dic = &#123;x ** 2: x for x in a&#125;</code>：字典生成式，保留 <code>:</code> 来分隔键与值</li><li><code>tpl = tuple(x + 1 for x in a)</code>：元组生成式，直接用 <code>()</code> 会被当成表达式</li></ul><p>综上所述，生成式表达可以用三段式：<code>表达式 for 循环变量 in 迭代对象 if 筛选条件</code>，其中最后的筛选条件不一定要。</p><p>此外，还可以用更简单的 <code>map()</code> 函数构造容器，其内置了一系列<strong>映射句柄</strong>，如 <code>map(int, [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;])</code>，或 <code>map(square, [1, 2, 3])</code>。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>Python 中不用大括号来显式地分块，而是用<strong>冒号配合缩进</strong>（Indent）。代码块与代码块之间至少隔着一个空行表示结束。当一个代码块必须存在，又不想写任何语句的时候，可以写一个 <code>pass</code> 作为占位符。</p><h3 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> a == <span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;a is 1&#x27;</span>)<br><span class="hljs-keyword">elif</span> a == <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;a is 0&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;wtf is a?&#x27;</span>)<br></code></pre></td></tr></table></figure><p>注意，<code>elif</code> 和 <code>else</code> 后面也要有冒号配合缩进，如果有多个条件，用 <code>and</code> 和 <code>or</code> 逻辑运算符连接。</p><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>前面所列的容器、数值列表都可以用于 <code>for</code> 循环迭代，比较特别的是字符串也可以迭代：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&#x27;hello world&#x27;</span><br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> a:<br>    <span class="hljs-built_in">print</span>(c) <span class="hljs-comment"># 竖着打印出 hello world，因为 print 自带换行</span><br></code></pre></td></tr></table></figure><p>此外，如果在数值列表的迭代中用不到迭代变量 <code>i</code>，仅作为迭代次数使用，可以用 <code>_</code> 变量表达。</p><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">10</span><br><span class="hljs-keyword">while</span> <span class="hljs-number">2</span> &lt;= a &lt; <span class="hljs-number">20</span>:    <span class="hljs-comment"># 语法糖，这种写法是被建议使⽤的</span><br>    <span class="hljs-built_in">print</span>(a)<br>    a -= <span class="hljs-number">1</span>            <span class="hljs-comment"># 注意 Python 中没有⾃增 1 和⾃减 1 运算符</span><br></code></pre></td></tr></table></figure><p>跳出循环可以用 <code>break</code> 和 <code>continue</code>【与 C 相同】</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;函数文档注释&quot;&quot;&quot;</span><br>    current, then = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        current, then = then, current + then<br>    <span class="hljs-keyword">return</span> current<br><br>fib(<span class="hljs-number">10</span>) <span class="hljs-comment"># 调用函数</span><br></code></pre></td></tr></table></figure><h4 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h4><p>Python 是<strong>不允许</strong>程序员选择采用传值还是传址的。Python 参数传递采用的肯定是「<strong>传对象引用</strong>」的方式【类似 C 中传值和传址的结合】。如果函数收到的是一个<strong>可变对象</strong>（比如 list、dict）的引用，就能修改对象的原始值；如果是一个<strong>不可变对象</strong>（比如 int、float、str）的引用，就不能直接修改原始对象。</p><p>传入参数的数量可以<strong>不固定</strong>，但是必须指定默认值；也可以<strong>调换顺序</strong>，但必须指明对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b = <span class="hljs-number">0</span></span>):</span><br>    <span class="hljs-built_in">print</span>(a + b)<br><br>add(<span class="hljs-number">1</span>) <span class="hljs-comment"># 参数 b 采用默认 0</span><br>add(b = <span class="hljs-number">2</span>, a = <span class="hljs-number">1</span>) <span class="hljs-comment"># 调换顺序，指明对象</span><br></code></pre></td></tr></table></figure><p>当然，也可以传递列表等容器，但传递的也是列表的地址，在函数中修改同样会改变原列表，如果不想修改原列表可以用 <code>[:]</code> 传递切片。</p><h4 id="传递任意数量的参数"><a href="#传递任意数量的参数" class="headerlink" title="传递任意数量的参数"></a>传递任意数量的参数</h4><ul><li>在形参前加星号 <code>*</code>，Python3 会创建一个该形参名称的<strong>元组</strong>，本质上是一种元组解包</li><li>在形参前加双星号 <code>**</code>，Python3 会创建一个该形参名称的<strong>字典</strong></li></ul><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>作为动态类型语言，函数返回值可以不固定，可以多个 <code>return</code> 在不同情况下返回不同值，或者没有 <code>return</code>（等价于 <code>return None</code>）。</p><h3 id="函数模块调用"><a href="#函数模块调用" class="headerlink" title="函数模块调用"></a>函数模块调用</h3><p>函数可以被存储在模块中被调用，<strong>模块</strong>是扩展名为 .py 的文件，包含函数的代码【类似于 C 的头文件】</p><ul><li>导入<strong>整个模块</strong>：使用 <code>import pizza</code> 导入，调用时使用 <code>.</code> 句点，如：<code>pizza.make(16, &#39;green peppers&#39;)</code></li><li>导入模块中<strong>特定函数</strong>：使用 <code>from pizza import make, eat</code>，调用时无需句点，直接用函数名</li><li>导入特定函数<strong>别名</strong>：使用 <code>from pizza import make as mk</code>，调用时无需句点，直接用别名</li><li>导入模块中<strong>所有函数</strong>：使用 <code>from pizza import *</code>，调用时无需句点，但是会<strong>污染命名空间</strong>，不建议使用</li></ul><p>所有 <code>import</code> 都放在程序开头【类似于 C++ 的 <code>#include&lt;&gt;</code>】。</p><h4 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h4><p>作为一种工具语言，大部分情况我们都是通过「调包」完成任务，即导入第三方库。市面上的第三方库可以通过多种途径获取，包括 <code>pip</code>、<code>conda</code> 等。在命令行中使用 <code>pip list</code> 即可查看当前安装的所有库和版本信息，也可以结合管道 <code>pip list | findstr numpy</code>（Windows）。</p><h4 id="模块封装"><a href="#模块封装" class="headerlink" title="模块封装"></a>模块封装</h4><p>在 Python 的程序模板中经常看见 <code>if __name__ = &#39;__main__&#39;</code>，这其实是 Python 中的一种 Magic Method。</p><p>Python 中所有 <code>.py</code> 文件都可被视为一个模块，当模块作为脚本被<strong>直接运行</strong>时，其 <code>__name__</code> 的值变为 <code>__main__</code>。相反，当模块被其他<strong>导入其他脚本运行</strong>时，其 <code>__name__</code> 存放的就是模块的名字（类似环境变量）。</p><p>而作为一种解释型语言，Python 会将所有导入的代码全部顺序执行一遍。如果我们在一个脚本中实现了某个算法，想将其作为模块在其他脚本中调用，我们并不希望它在 <code>import</code> 的那一刻就执行，因此，正确的做法是将其封装成函数。</p><p>但如果要单独运行该模块，譬如调试功能时，使用 <code>__name__</code> 就可以完美解决：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>():</span><br><span class="hljs-comment"># 这里写函数代码</span><br>    <span class="hljs-keyword">return</span><br><br><span class="hljs-keyword">if</span> __name__ = <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    func() <span class="hljs-comment"># 这里调试函数</span><br></code></pre></td></tr></table></figure><h3 id="Lambda-匿名函数"><a href="#Lambda-匿名函数" class="headerlink" title="Lambda 匿名函数"></a>Lambda 匿名函数</h3><p>和很多语言⼀样，Python 中可以使用 Lambda 匿名函数完成一些简单的逻辑，但比较特殊的地方在于，Python 中匿名函数必须只由<strong>单个表达式</strong>构成，这个表达式的值也就是匿名函数的返回值。</p><p><code>lambda</code> 关键字可以用来创建一个匿名函数，紧跟其后的是<strong>参数列表</strong>和用冒号 <code>:</code> 分割开的单个表达式。如，<code>lambda x: 2 * x</code> 是将任何输入的数乘 2，而 <code>lambda x, y: x+y</code> 是计算两个数字的和。</p><p>使用匿名函数的经验准则是保持简单以及只在本地使用一次。一种常见却不推崇的做法是将其作为简单函数的另一种<strong>声明</strong>方式，赋值给<strong>变量</strong>，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>doubler = <span class="hljs-keyword">lambda</span> x: <span class="hljs-number">2</span> * x<br><span class="hljs-meta">&gt;&gt;&gt; </span>doubler(<span class="hljs-number">5</span>)<br><span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(doubler)<br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">function</span>&#x27;&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>对 lambda 函数命名的唯一作用可能是出于教学目的，其问题在于这使得调试不那么直观——错误信息只会提示某个 <code>lambda</code> 函数存在问题，但不会提示哪个函数。</p></blockquote><p>正确的做法应该是将其作为<strong>参数</strong>传递，如 <code>.sort</code> 函数、<code>sorted</code> 函数等，此时单个表达式会被计算为一个值并且参与后续的计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>integers = [(<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">5</span>, <span class="hljs-number">1</span>), (-<span class="hljs-number">4</span>, <span class="hljs-number">4</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sorted</span>(integers, key=<span class="hljs-keyword">lambda</span> x: x[-<span class="hljs-number">1</span>])<br>[(<span class="hljs-number">3</span>, -<span class="hljs-number">3</span>), (<span class="hljs-number">5</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (-<span class="hljs-number">4</span>, <span class="hljs-number">4</span>)]<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>nums.sort(key=<span class="hljs-keyword">lambda</span> a: <span class="hljs-built_in">abs</span>(<span class="hljs-number">5</span>-a))<br><span class="hljs-meta">&gt;&gt;&gt; </span>nums<br>[<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p><code>open()</code> 函数的第二个实参 <code>w</code> 表示写入（自动创建或<strong>覆盖</strong>原内容），<code>r</code> 表示只读，<code>a</code> 表示附加（自动创建或<strong>添加到文件末尾</strong>），<code>r+</code> 表示读写。如果不加第二个实参，则默认为 <code>r</code> 只读。</p><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>一种【与 C 相似】的操作是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;temp.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>)  <span class="hljs-comment"># 打开一个文件，返回表示文件的对象</span><br>contents = file.read()<span class="hljs-comment"># 读取整个文件</span><br><span class="hljs-built_in">print</span>(contents)<br>file.close()<span class="hljs-comment"># 关闭文件</span><br></code></pre></td></tr></table></figure><p>此外，还有一种更推崇的操作方式，使用 <code>with</code> 上下文管理器，将<strong>打开的文件的对象</strong>存储在 <code>as</code> 后的变量，这样可以避免由于忘记关闭文件导致丢失数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;temp.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    contents = file.read()<br>    <span class="hljs-built_in">print</span>(contents)<br></code></pre></td></tr></table></figure><p>回到读取本身，方法 <code>read()</code> 读取<strong>整个文件</strong>的内容并返回<strong>单个字符串</strong>，并包含每个 <code>\n</code> 换行符。</p><p>但实际操作中读入<strong>一个长字符串</strong>是丑陋而且难以处理的，我们更倾向于逐行读入，用 <code>line.rstrip()</code> 消除行末的 <code>\n</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;temp.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file:  <span class="hljs-comment"># file 也可作为一个迭代器</span><br>        <span class="hljs-built_in">print</span>(line)<span class="hljs-comment"># 注意每一行末都会有一个 \n 被打印，而 print 本身又自带换行</span><br></code></pre></td></tr></table></figure><p>另一种逐行读入是创建一个包含文件各行内容的<strong>列表</strong>，每个元素是一行内容的字符串，包含行尾的 <code>\n</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;temp.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    line1 = file.readline()<span class="hljs-comment"># 读入第一行作为字符串</span><br>    lines = file.readlines()<span class="hljs-comment"># 读入第二行以后的行（文件指针被移动了），作为 List[]</span><br></code></pre></td></tr></table></figure><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;temp.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    file.write(<span class="hljs-string">&quot;I love programming.\n&quot;</span>) <span class="hljs-comment"># wirte 不会换行，要手动加</span><br></code></pre></td></tr></table></figure><p>方法 <code>write()</code> 表示将<strong>字符串</strong>写入文件。如果要写入数值，应先用 <code>str()</code> 将其转化为字符串。</p><p>同样，按行写入也有对应的函数 <code>writelines()</code>，但要求传入的参数为字符串列表，同时每个字符串后面<strong>都要自带</strong>换行符，因此比较鸡肋。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>Python 中的类基础用法比 C/C++ 更简洁一些，待补充。</p>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ML学习笔记 #1 梯度下降：一元线性回归</title>
    <link href="/ML-Note-1.html"/>
    <url>/ML-Note-1.html</url>
    
    <content type="html"><![CDATA[<p>该笔记是观看斯坦福大学教授 <a href="https://scholar.google.com/citations?hl=zh-CN&amp;user=mG4imMEAAAAJ">Andrew-Ng</a> 在 <a href="https://www.coursera.org/">Coursera</a> 上开设的 <a href="https://www.coursera.org/learn/machine-learning">Machine-Learning</a> 网课所做的笔记。由于网上可见的该课程笔记繁多，而本文所记内容并无不同，仅供个人娱乐。BTW，做笔记的过程中还参考了 <a href="https://xyfjason.top">xyfJASON</a> 的博客，解答了我许多疑惑。</p><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p>首先给出两个「机器学习」的定义，尽管对于相关从业者来说，也不存在一个被广泛认可的定义来准确定义机器学习是什么，但或许有助于回答诸如「机器学习是什么？」之类的面试问题：</p><ul><li>Arthur Samuel (1959). Machine Learning: Field of study that gives computers the ability to learn <strong>without</strong> being explicitly programmed. </li><li>Tom Mitchell (1998) Well-posed Learning Problem: A computer program is said to <em>learn</em> from <strong>experience</strong> E with respect to some <strong>task</strong> T and some <strong>performance measure</strong> P, if its performance on T, as measured by P, improves with experience E. </li></ul><h3 id="监督学习-Supervised-Learning"><a href="#监督学习-Supervised-Learning" class="headerlink" title="监督学习 | Supervised Learning"></a>监督学习 | Supervised Learning</h3><p>如果我们给学习算法一个数据集，这个数据集由「<strong>正确答案</strong>」组成，然后运用该算法算出更多可能正确的答案，这就是监督学习。</p><p>监督学习领域有两大问题：</p><ul><li>回归（Regression）：以一系列<strong>离散值</strong>（discrete），试着推测出这一系列<strong>连续值</strong>（continuous）属性。譬如根据已知房价预测未知房价。</li><li>分类（Classification）：以一系列<strong>离散值</strong>，试着推测出同样是<strong>离散值</strong>的属性。譬如预测肿瘤的恶性与否。</li></ul><p>对于分类问题，输出的结果可以大于两个（分出许多类），输入的<strong>特征</strong>（feature）也可以更多，例如通过患者年龄和肿瘤大小等特征预测肿瘤的恶性与否。</p><p>在绘制这些样本时，可以用一个<strong>多维空间</strong>中不同颜色的<strong>样本点</strong>来表示。在一些问题中，我们希望使用无穷多的特征来学习，显然电脑的内存肯定不够用，而后文将介绍的<strong>支持向量机</strong>（SVM，Support Vector Machine）巧妙地解决了这个问题。</p><h3 id="无监督学习-Unsupervised-Learning"><a href="#无监督学习-Unsupervised-Learning" class="headerlink" title="无监督学习 | Unsupervised Learning"></a>无监督学习 | Unsupervised Learning</h3><p>对于监督学习里的每条数据，我们已经清楚地知道，训练集对应的正确答案。而在无监督学习中，这些数据「<strong>没有任何标签</strong>」或是只有「<strong>相同的标签</strong>」。</p><p>因此，我们希望学习算法能够判断出数据具有不同的<strong>聚集簇</strong>（Cluster），这就是无监督学习领域的经典问题：<strong>聚类算</strong>（Cluster Algorithm）。</p><p>譬如在谷歌新闻中，我们对收集的网络新闻分组，组成有关联的新闻；又如在鸡尾酒宴会问题中，两个位置不同的麦克风录到的两个音源，通过学习算法可以各自分离出来。</p><h2 id="一元线性回归-Univariate-Linear-Regression"><a href="#一元线性回归-Univariate-Linear-Regression" class="headerlink" title="一元线性回归 | Univariate Linear Regression"></a>一元线性回归 | Univariate Linear Regression</h2><p>前文提到，回归是监督学习的一个经典问题，这里我们将以线性回归来一窥整个监督学习的模型建立过程。假设已经拥有了回归问题的<strong>数据集</strong>，我们将之描述为：</p><script type="math/tex; mode=display">\left\{\left(x^{(i)}, y^{(i)}\right), i=1,2, \cdots, m\right\}</script><ul><li>$m$ 代表训练集中实例的数量；</li><li>$x$ 代表<strong>特征</strong> or 输入变量；</li><li>$y$ 代表<strong>目标变量</strong> or 输出变量；</li><li>$({x}^{(i)},{y}^{(i)})$ 代表第 $i$ 个观察实例；</li><li>$h$ 代表学习算法的解决方案或函数也称为<strong>假设</strong>（hypothesis）。</li></ul><p>为了解决这样一个问题，我们实际上是要将训练集「喂」给我们的学习算法，进而学习得到一个假设 $h$。在本文中，我们尝试用线性函数 $h_\theta \left( x \right)=\theta_{0} + \theta_{1}x$ 拟合之。因为只含有一个特征 or 输入变量，因此这样的问题叫作<strong>一元线性回归</strong>问题。</p><h3 id="代价函数-Cost-Function"><a href="#代价函数-Cost-Function" class="headerlink" title="代价函数 | Cost Function"></a>代价函数 | Cost Function</h3><p>有了上文建立的基础模型，现在要做的便是为之选择合适的<strong>参数</strong>（parameters）$\theta_{0}$ 和 $\theta_{1}$，即直线的斜率和在 $y$ 轴上的截距。</p><p>选择的参数决定了得到的直线相对于训练集的<strong>准确程度</strong>，模型所预测的值与训练集中实际值之间的差距就是<strong>建模误差</strong>（modeling error）。我们要做的就是尽量选择参数使得误差降低，即最小化 $h_{\theta}(x^{(i)})$ 和 $y^{(i)}$ 的距离。于是我们有了经典的<strong>平方误差代价函数</strong>：</p><script type="math/tex; mode=display">J\left( \theta _0,\theta _1 \right) =\frac{1}{2m}\sum_{i=1}^m{\left( h_{\theta}(x^{(i)})-y^{(i)} \right) ^2}</script><p>也即是每个数据纵坐标的预测值与真实值的差的平方之和的平均，除以 2 仅是为了后续求导方便，没有什么本质的影响。</p><p>绘制一个三维空间，三个坐标分别为 $\theta_{0}$ 和 $\theta_{1}$ 和 $J(\theta_{0}, \theta_{1})$，对每个 $\left( \theta_0, \theta_1 \right)$ 对，代入训练集可以得到一个 $J(\theta_{0}, \theta_{1})$ 值，经过一系列计算，我们得到一个<strong>碗状曲面</strong>：</p><p><img src="/img/blog/ML-Note-1-images/3d-surface.png" alt="三维空间中的碗状曲面" width="67%" /></p><p>显然，在三维空间中存在一个使得 $J(\theta_{0}, \theta_{1})$ 最小的点。为了更好地表达，我们将三维空间投影到二维，得到<strong>等高线图</strong>（Contour plot）：</p><p><img src="/img/blog/ML-Note-1-images/contour.png" alt="二维空间的等高线图" width="50%" /></p><p>这些同心椭圆的中心，就是我们要找到使得 $J(\theta_{0}, \theta_{1})$ 最小的点。</p><h3 id="梯度下降法-Gradient-Descent"><a href="#梯度下降法-Gradient-Descent" class="headerlink" title="梯度下降法 | Gradient Descent"></a>梯度下降法 | Gradient Descent</h3><p>在数学上，我们知道最小二乘法可以解决一元线性回归问题。现在有了等高线图，我们需要的是一种有效的算法，能够自动地找出这些使代价函数 $J$ 取最小值的 $\left( \theta_0, \theta_1 \right)$ 对。当然并不是把这些点画出来，然后人工读出中心点的数值——对于更复杂、更高维度、更多参数的情况，我们很难将其可视化。</p><p>梯度下降是一个用来求<strong>一般函数最小值</strong>的算法，其背后的思想是：开始时<strong>随机选择</strong>一个参数组合$\left( \theta_{0},\theta_{1},……,\theta_{n} \right)$，计算代价函数，然后一点点地修改参数，直到找到<strong>下一个</strong>能让代价函数值下降最多的参数组合。</p><p>持续这么做会让我们找到一个<strong>局部最小值</strong>（local minimum），但我们无法确定其是否就是<strong>全局最小值</strong>（global minimum），哪怕只是稍微修改初始参数，也可能最终结果完全不同。当然，在一元线性回归问题中，生成的曲面始终是<strong>凸函数</strong>（convex function），因此我们可以不考虑这个问题。</p><p>在高等数学中，我们知道「下降最多」其实指的是函数 $J$ 的<strong>梯度方向的逆方向</strong>，也即方向导数最大的方向，梯度定义为：</p><script type="math/tex; mode=display">\nabla J=\mathrm{grad} J=\left\{ \frac{\partial J}{\partial \theta _0},\frac{\partial J}{\partial \theta _1} \right\}</script><p>所以不断迭代进行赋值：</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha\cdot\frac{\partial}{\partial\theta_j} J(\theta_{0}, \theta_{1})</script><p>直到收敛，即可找到一个<strong>极小值</strong>。其中，$\alpha$ 就是这一步的<strong>步长</strong>，也称为<strong>学习率</strong>（Learnig rate）。学习率的选取很重要，过小则梯度下降很慢，过大则有可能不收敛。</p><h3 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h3><p>对代价函数求偏导：</p><ul><li><p>$j=0$  时：$\frac{\partial}{\partial \theta _0}J(\theta _0,\theta _1)=\frac{1}{m}\sum_{i=1}^m{\left( \theta _1x^{(i)}+\theta _0-y^{(i)} \right)}$</p></li><li><p>$j=1$  时：$\frac{\partial}{\partial \theta _1}J(\theta _0,\theta _1)=\frac{1}{m}\sum_{i=1}^m{x^{(i)}\left( \theta _1x^{(i)}+\theta _0-y^{(i)} \right)}$</p></li></ul><p>所以梯度方向为：</p><script type="math/tex; mode=display">\mathrm{grad } J=\left\{ \frac{\partial J}{\partial \theta _0},\frac{\partial J}{\partial \theta _1} \right\} =\left\{ \frac{1}{m}\sum_{i=1}^m{\left( \theta _1x^{(i)}+\theta _0-y^{(i)} \right)},\frac{1}{m}\sum_{i=1}^mx^{(i)}\left( \theta _1x^{(i)}+\theta _0-y^{(i)} \right) \right\}</script><p>此外，我们注意到在<strong>每一步</strong>迭代过程中，我们都用到了<strong>所有的</strong>训练样本，如 $\sum_{i=1}^mx^{(i)}$、$\sum_{i=1}^my^{(i)}$、$\sum_{i=1}^mx^{(i)}y^{(i)}$ 等项，这也称为<strong>批量梯度下降</strong>（Batch Gradient Descent）。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>需要注意的是，迭代赋值的过程中，$\left( \theta_0, \theta_1 \right)$ 的值要同时更新，否则就会与梯度方向有微小区别。用 Python 元组解包赋值可以实现，用矩阵乘法也可实现。</p><p>为了用向量化加速计算，这里利用了一个小性质，就是当 $a$ 和 $b$ 都为向量时有 $a^Tb=b^Ta$，所以有：</p><script type="math/tex; mode=display">X\theta =\left[ \begin{array}{c}    -\left( x^{(1)} \right) ^T\theta -\\    -\left( x^{(2)} \right) ^T\theta -\\    \vdots\\    -\left( x^{(m)} \right) ^T\theta -\\\end{array} \right] =\left[ \begin{array}{c}    -\theta ^T\left( x^{(1)} \right) -\\    -\theta ^T\left( x^{(2)} \right) -\\    \vdots\\    -\theta ^T\left( x^{(m)} \right) -\\\end{array} \right]</script><p>下面以 <a href="https://www.coursera.org/">Coursera</a> 上的一元线性回归数据集 <code>ex1data1.txt</code> 为例实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># load data, data.shape = (97, 2)</span><br>data = np.loadtxt(<span class="hljs-string">&#x27;ex1data1.txt&#x27;</span>, delimiter=<span class="hljs-string">&#x27;,&#x27;</span>, usecols=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>x = data[:, <span class="hljs-number">0</span>]<br>y = data[:, <span class="hljs-number">1</span>]<br>m = y.size<br><br><span class="hljs-comment"># parameters</span><br>alpha = <span class="hljs-number">0.01</span><br>num_iters = <span class="hljs-number">5000</span><br>theta = np.zeros(<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># X.shape = (97, 2), y.shape = (97, ), theta.shape = (2, )</span><br>X = np.c_[np.ones(m), x]  <span class="hljs-comment"># 增加一列 1 到 矩阵 X，实现多项式运算</span><br><br><span class="hljs-comment"># Gradient Descent</span><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, num_iters):<br>    error = (X @ theta).flatten() - y  <span class="hljs-comment"># error.shape = (97, )</span><br>    theta -= (alpha / m) * np.<span class="hljs-built_in">sum</span>(X * error[:, np.newaxis], <span class="hljs-number">0</span>) <span class="hljs-comment"># 0 表示每列相加</span><br><br><span class="hljs-comment"># plot</span><br><span class="hljs-built_in">print</span>(theta)<br>plt.scatter(x, y)<br>x_plot = np.array([np.<span class="hljs-built_in">min</span>(x), np.<span class="hljs-built_in">max</span>(x)])<br>y_plot = theta[<span class="hljs-number">0</span>] + x_plot * theta[<span class="hljs-number">1</span>]  <span class="hljs-comment"># NumPy Broadcast</span><br>plt.plot(x_plot, y_plot, c=<span class="hljs-string">&quot;m&quot;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>得到的 $\left( \theta_0, \theta_1 \right)$ 结果是：[-3.8953  1.1929]，作图如下：</p><p><img src="/img/blog/ML-Note-1-images/Figure_1.png" alt="一元线性回归" width="50%" /></p><blockquote><p><strong>向量化</strong>：在 Python 或 Matlab 中进行科学计算时，如果有多组数据或多项式运算，转化成矩阵乘法会比直接用 <code>for</code> 循环高效很多，可以实现<strong>同时赋值</strong>且代码更简洁。</p><p>这是由于科学计算库中的函数更好地利用了硬件的特性，更好地支持了诸如<strong>循环展开、流水线、超标量</strong>等技术。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习笔记 #3 使用远程服务器</title>
    <link href="/Linux-Note-3.html"/>
    <url>/Linux-Note-3.html</url>
    
    <content type="html"><![CDATA[<p>在前文的基础上，介绍了<strong>远程控制</strong> Linux 服务器的情景，以及在学习中常用的<strong>不间断会话</strong>服务。</p><p>本文大部分内容参考了清华 ZAH 同学的教程，部分参考了 刘遄 老师的《<a href="https://www.linuxprobe.com">Linux 就该这么学</a>》，<a href="https://www.runoob.com/linux/linux-tutorial.html">菜鸟教程-Linux</a>。</p><h2 id="远程控制服务"><a href="#远程控制服务" class="headerlink" title="远程控制服务"></a>远程控制服务</h2><p>日常工作中，我们常常会使用远程服务器来进行开发/运维，连接远程服务器需要用到 SecureShell（SSH）。</p><h3 id="初次连接"><a href="#初次连接" class="headerlink" title="初次连接"></a>初次连接</h3><p>打开本地的终端模拟器，通过如下命令使用 SSH 连接到其他服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> ssh hewei@server.hitsz.edu.cn -p 30001</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们尝试以用户名 <code>hewei</code> 登陆服务器 <code>server.hitsz.edu.cn</code>。服务器可以通过<strong>服务器主机名</strong>指定（如本例），也可以使用 <strong>IP </strong>指定（如 <code>hewei@192.168.1.42</code>）。SSH 的默认端口是 22，也可以通过 <code>-p port</code> 制定端口。</p><p>输入上述命令后，如果成功连接，会提示输入密码，该密码就是远程服务器中<strong>对应账户</strong>的密码。</p><blockquote><p>本文中由于没有其他服务器，就在本机上用 VirtualBox 创建了一个 Ubuntu <strong>虚拟机</strong>作为服务器，获取虚拟机 IP，在主机中用终端连接。参考文章：<a href="https://www.cnblogs.com/clqbolg/p/11729868.html">用vbox搭建Linux服务器</a>。</p><p>注意：用本方法需要确保主机接有<strong>网线</strong>，且虚拟机配置<strong>桥接网卡</strong>与主机以太网相同。</p><p>另一种方法是用公共集群作为临时服务器，可能不支持 SSH，这时候要在远程终端手动激活 <code>sudo service sshd start</code>。</p></blockquote><p>进入服务器后，可以看到命令行左侧的提示符变成了 <code>hewei@hewei-VirtualBox ~&gt;</code>，其中 <code>~</code> 代表在 <code>/home/hewei</code> 用户目录下，<code>&gt;</code> 符号提示远程用户身份，不同服务器可能不一样。输入 <code>logout</code> 可退出远程服务器。</p><h3 id="SSH-配置文件"><a href="#SSH-配置文件" class="headerlink" title="SSH 配置文件"></a>SSH 配置文件</h3><p>上述<strong>连接</strong>远程服务器的命令还可以通过修改 SSH 配置文件来简化，进入<strong>主机</strong>所在的用户文件夹下的 <code>.ssh</code> 文件夹（SSH 密钥所在的文件夹），新建配置文件 <code>config</code>，添加：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">HOST</span> <span class="hljs-selector-tag">training</span> (任意别名，用于助记)<br><span class="hljs-selector-tag">HostName</span> <span class="hljs-selector-tag">152</span><span class="hljs-selector-class">.136</span><span class="hljs-selector-class">.177</span><span class="hljs-selector-class">.53</span> (域名/IP)<br>    <span class="hljs-selector-tag">Port</span> <span class="hljs-selector-tag">30001</span> (端口号)<br>    <span class="hljs-selector-tag">User</span> <span class="hljs-selector-tag">hewei</span> (用户名)<br>    <span class="hljs-selector-tag">IdentityFile</span> ~/<span class="hljs-selector-class">.ssh</span>/<span class="hljs-selector-tag">id_rsa</span> (私钥路径，默认，可不填)<br></code></pre></td></tr></table></figure><p>配置完文件后，我们可以使用 <code>ssh test</code> 这样的命令来连接服务器，有助于管理多个服务器的账户。</p><h3 id="免登录执行"><a href="#免登录执行" class="headerlink" title="免登录执行"></a>免登录执行</h3><p>SSH 的一个经常被忽视的特性是它可以在<strong>不登录服务器</strong>的状态下直接远程执行命令，例如在配置完 <code>config</code> 后，使用 <code>ssh 别名</code> 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> ssh training ls /home/hewei</span><br></code></pre></td></tr></table></figure><p>这步操作同样需要输入密码，但不会登录服务器，在主机环境中直接返回结果。</p><h3 id="SSH-鉴权"><a href="#SSH-鉴权" class="headerlink" title="SSH 鉴权"></a>SSH 鉴权</h3><p>使用 SSH 当然免不了基于<strong>密钥对</strong>的验证机制，我们只需要将<strong>公钥</strong>放在服务器上，每次登录时向服务器证明客户端持有对应的<strong>私钥</strong>。这样就可以避免每次登陆都输入密码了。</p><p>在 <a href="https://hwcoder.top/Git-Note-3/">Git学习笔记 #3 远程仓库使用</a> 中，同样讲述了这个问题，这里假设我们已经生成了密钥对。在<strong>本机</strong>终端下，可以通过如下命令把公钥传到服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> cat ~/.ssh/id_rsa.pub | ssh training <span class="hljs-string">&#x27;mkdir -p ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys&#x27;</span></span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-comment"># 拷贝公钥，利用 ssh training 免登录操控主机，创建路径并重定向公钥到 authorized_keys</span></span><br></code></pre></td></tr></table></figure><p>如果<strong>本机</strong>是 Linux/MacOS，支持 <code>ssh-copy-id</code> 命令，可以用下面这种更简单的方案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> ssh-copy-id -i ~/.ssh/id_rsa.pub training</span><br></code></pre></td></tr></table></figure><p>当然，如果已经连上<strong>远程</strong>终端，也可以在远程直接操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> mkdir -p ~/.ssh</span><br><span class="hljs-meta">$</span><span class="bash"> vi  ~/.ssh/authorized_keys  <span class="hljs-comment"># 用 vi 编辑器打开，手动复制公钥进去</span></span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;这里放你的公钥&quot;</span> &gt;&gt; ~/.ssh/authorized_keys  <span class="hljs-comment"># 这样可以不用 vi</span></span><br></code></pre></td></tr></table></figure><blockquote><p>如果服务器添加公钥后本机登录<strong>仍需要密码</strong>，则原因可能是 <code>~/.ssh</code> 目录和 <code>~/.ssh/authorized_keys</code> 文件的权限不对，使用以下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> chmod 700 ~/.ssh</span><br><span class="hljs-meta">$</span><span class="bash"> chmod 644 ~/.ssh/authorized_keys</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="文件上传下载"><a href="#文件上传下载" class="headerlink" title="文件上传下载"></a>文件上传下载</h3><p>通常我们需要将文件的工程文件放到服务器上执行，如果采用了 MobaXterm、Xshell 这类增强终端，可以通过<strong>拖拽</strong>的方式直接实现文件互传。</p><p>但如果直接在<strong>本机</strong>终端中，可以通过如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-comment"># 上传文件到服务器，参数一为本地文件</span></span><br><span class="hljs-meta">$</span><span class="bash"> scp test.zip training:/home/hewei/test.zip</span> <br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-comment"># 从服务器下载文件，参数一为服务器文件</span></span><br><span class="hljs-meta">$</span><span class="bash"> scp training:/home/hewei/test.zip test.zip</span><br></code></pre></td></tr></table></figure><p>此外，使用 <code>scp -r</code> 可以上传文件夹。如果需要更高级的功能，可以考虑使用 <code>rsync</code>。</p><p>此方法也可以用于<strong>两台服务器</strong>之间传输文件，此时服务器 A 就相当于主机，服务器 B 就相当于<strong>远程</strong>（B 的 <code>.ssh/authorized_keys</code> 里需要有 A 的公钥）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ scp -r /home/hewei/anaconda3/envs/<span class="hljs-built_in">test</span> hewei@B:/home/hewei/anaconda3/envs<br></code></pre></td></tr></table></figure><h3 id="利用-VS-Code-连接"><a href="#利用-VS-Code-连接" class="headerlink" title="利用 VS Code 连接"></a>利用 VS Code 连接</h3><p>在今年的操作系统实验课上，又学到了一招连接远程服务器的办法，不得不说 VS Code 太强大了！以下的内容需要 <code>Remote - SSH</code> 插件支持。</p><p>安装插件后，在 <code>SSH TARGETS</code> 栏选择 <code>Add New</code>，之后会弹出输入框，输入 <a href="#初次连接">初次连接命令</a>，则会弹出提示自动设置 <code>.ssh/config</code> 文件！添加成功后，左侧的 <code>SSH TARGETS</code> 栏就会增加新的远程节点。</p><p>在该节点旁边，选中 <code>Connect to Host in New Window</code> 即可打开一个 VS Code 窗口，新打开的窗口会要求你选择目标机器的平台，选择 Linux，按下回车，再确定连接，输入<strong>密码</strong>，即可连接成功。观察到终端显示的提示符是 <code>190110429@OSLabExecNode1:~$</code>，成功！</p><p>之后，点击 VS Code 侧边栏的资源管理器，就可以直接打开远程的文件夹和文件，更方便<strong>编程和调试</strong>。此外，同样可以用 SSH <strong>鉴权</strong>来简化输入密码的步骤，方法同上。在 VS Code 中按下 <code>Ctrl+反引号</code> 可以快捷打开终端。 </p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="Vim-入门"><a href="#Vim-入门" class="headerlink" title="Vim 入门"></a>Vim 入门</h3><p>通常我们将工程传到服务器上跑时，可能需要修改某些代码或参数，如果没有使用增强终端或者 VSCode Remote 等插件，我们就只能在 CLI 界面进行交互。</p><p>要在 CLI 界面简单地<strong>编辑</strong>⼀个文件，可用的选择大概有 vi, vim, nano 等，通常来说我们选择使用 vim。使用 <code>vim &lt;filename&gt;</code> 命令打开文件进行编辑。</p><p>刚打开文件时，vim 处于一个 Normal 模式，在 Normal 模式下按 <code>i</code> 进入 Insert 模式，此时就可以像其他编辑器一样对文件进行编辑。编辑后按下 <code>ESC</code> 键退回到 Normal 模式。</p><p>在 Normal 模式下按 <code>:</code> 进入 Command 模式，在这个模式下可以使用命令进行操作，常用命令有：<code>:q</code> 退出，<code>:w</code> 保存，<code>:wq</code> 保存并退出。</p><h3 id="软件包管理机制"><a href="#软件包管理机制" class="headerlink" title="软件包管理机制"></a>软件包管理机制</h3><p>大多数现代类 Unix 操作系统都提供了一个集中的<strong>软件包管理机制</strong>，以帮助用户搜索、安装和管理软件。而软件通常以包的形式存储在<strong>仓库</strong>（repository）中，对软件包的使用和管理被称为包管理。而 Linux 包的基本组成部分通常有：共享库、应用程序、服务和文档。</p><p><strong>包管理器</strong>又称软件包管理系统，它是在电脑中自动安装、配制、卸载和升级软件包的工具组合，在各种系统软件和应用软件的安装管理中均有广泛应用。</p><p>几乎每⼀个系统发行版都有它的包管理器，Ubuntu 有 <code>apt</code>，Arch 有 <code>pacman</code>，macOS 有 <code>Homebrew</code>。</p><h3 id="包管理器换源"><a href="#包管理器换源" class="headerlink" title="包管理器换源"></a>包管理器换源</h3><p>由于众所周知的原因，<strong>仓库</strong>在国内的访问速度是不佳的，往往需要更换为国内的镜像源，常见的镜像站点有清华的 Tuna，其 Ubuntu 源地址为：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</a> 。</p><p>Ubuntu 的软件配置文件时 <code>/etc/apt/source.list</code>，首先将系统自带的该文件备份：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> sudo cp /etc/apt/source.list /etc/apt/source.list.bak</span><br><span class="hljs-meta">$</span><span class="bash"> ls /etc/apt/source.list -lah <span class="hljs-comment"># 查看文件权限，发现需要 root 权限</span></span><br></code></pre></td></tr></table></figure><p>此时如果直接用 vim 打开文件，会发现无法进入 Insert 模式，于是需要用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> sudo vim /etc/apt/source.list <span class="hljs-comment"># 用 root 身份打开文件</span></span><br></code></pre></td></tr></table></figure><p>进入编辑器后，可以进入 Insert 慢慢删除，也可以直接在 Normal 模式下输入 <code>ggyG</code> 全选删除。然后将网站中的配置文件复制进去。</p><p>现在就可以使用镜像源下载软件包了，这里以下面要用的 Tmux 为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-comment"># 由于包管理器是在系统中，也需要 sudo 来获得 root 权限，且需要密码</span></span><br><span class="hljs-meta">$</span><span class="bash"> sudo apt update       <span class="hljs-comment"># 检查已安装的软件包是否有可用的更新</span></span><br><span class="hljs-meta">$</span><span class="bash"> sudo apt search tmux  <span class="hljs-comment"># 在仓库中查找是否有该源文件，可以跳过</span></span><br><span class="hljs-meta">$</span><span class="bash"> sudo apt install tmux <span class="hljs-comment"># 安装软件包</span></span><br><span class="hljs-meta">$</span><span class="bash"> sudo apt remove tmux  <span class="hljs-comment"># 删除已安装软件包</span></span><br></code></pre></td></tr></table></figure><h3 id="从网络下载资源"><a href="#从网络下载资源" class="headerlink" title="从网络下载资源"></a>从网络下载资源</h3><p>如果没有 <code>sudo</code> 权限也想下载软件，或者想下载某些数据集时，就需要内容下载命令 <code>wget</code> 或 <code>curl</code>，其中前者由系统自带，后者需要用包管理器安装 <code>sudo apt-get install curl</code>。两个命令的功能有所重叠，总体而言，后者更适合复杂的下载任务，具体用法如下：</p><ul><li><p>基础下载功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> curl -O https://hwcoder.top/index.html<span class="hljs-comment"># 大写 O，如果缺省则只会打印内容不会下载</span></span><br><span class="hljs-meta">$</span><span class="bash"> wget https://hwcoder.top/index.html<span class="hljs-comment"># 不用参数，直接下载到当前目录</span></span><br></code></pre></td></tr></table></figure></li><li><p>下载文件并重命名（指定路径）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> curl -o rename.html https://hwcoder.top/index.html<span class="hljs-comment"># 小写 o</span></span><br><span class="hljs-meta">$</span><span class="bash"> wget -O rename.html https://hwcoder.top/index.html<span class="hljs-comment"># 大写 O</span></span><br></code></pre></td></tr></table></figure></li><li><p>断点续传：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> curl -O -C https://hwcoder.top/index.html<span class="hljs-comment"># 大写 C</span></span><br><span class="hljs-meta">$</span><span class="bash"> wget -c https://hwcoder.top/index.html<span class="hljs-comment"># 小写 c</span></span><br></code></pre></td></tr></table></figure></li></ul><p>其中 <code>curl -#</code> 还有进度条功能，支持正则表达式匹配批量下载。<code>wget</code> 支持递归下载，常用于打包下载整个网页。</p><h2 id="不间断会话服务"><a href="#不间断会话服务" class="headerlink" title="不间断会话服务"></a>不间断会话服务</h2><p>命令行的典型使用方式是，打开一个<strong>终端窗口</strong>（terminal window，以下简称窗口），在里面输入命令。用户与计算机的这种临时的交互，称为⼀次「<strong>会话</strong>」（session） 。</p><h3 id="服务中断"><a href="#服务中断" class="headerlink" title="服务中断"></a>服务中断</h3><p>会话的⼀个重要特点是，窗口与其中启动的进程是<strong>绑定</strong>的——打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行结束。</p><p>因此，使用 SSH 远程控制服务时，当<strong>与远程主机的会话</strong>被关闭时，在远程主机上运行的命令也随之被中断。</p><p>如果运行某个重要的程序，中途是<strong>绝对不能</strong>关闭在本地打开的终端窗口或断开网络连接的，甚至连网速的波动都有可能导致任务中断，此时只能重新进行远程连接并重新开始任务。而我们需要在服务器上跑的东西恰恰就是比较<strong>占用资源</strong>的程序，通常需要执行较长时间，如果因为网速波动而中断就很难受。</p><h3 id="分离会话"><a href="#分离会话" class="headerlink" title="分离会话"></a>分离会话</h3><p>为了解决这个问题，会话与窗口可以「<strong>解绑</strong>」：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话「<strong>重新绑定</strong>」其他窗口。</p><p>Terminal  Multiplexer（终端复用器，简称为 Tmux）就是一款能够实现<strong>多窗口远程控制</strong>的开源服务程序。简单来说就是为了<strong>解决网络异常中断</strong>或为了<strong>同时控制多个远程终端窗口</strong>而设计的程序。Unix 系统自带，无需安装。</p><p>远程连接服务器后，输入 <code>tmux</code> 进入 Tmux 窗口，窗口下方会出现<strong>绿色</strong>的一行。在 Tmux 窗口中，输入 <code>tmux detach</code> 命令，就会将当前<strong>会话与窗口分离</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> tmux        <span class="hljs-comment"># 在终端窗口输入，进入 Tmux 窗口</span></span><br><span class="hljs-meta">$</span><span class="bash"> tmux detach <span class="hljs-comment"># 在 Tmux 窗口输入，退回终端窗口</span></span><br></code></pre></td></tr></table></figure><p>上述命令执行后，就会退回到本地终端窗口，但是会话和里面的进程仍然在后台运行。此时可以输入命令查看后台正在运行的 Tmux 会话：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> tmux list-session</span><br><span class="hljs-meta">$</span><span class="bash"> tmux ls  <span class="hljs-comment"># 两条命令等价</span></span><br></code></pre></td></tr></table></figure><p>会弹出 <code>0: 1 windows (created Mon Sept 9 20:34:12 2021)</code> 的提示信息，其中 <code>0</code> 表示该窗口标题（默认从 0 开始递增），此外也可以<strong>命名窗口</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> tmux new -s &lt;session-name&gt;  <span class="hljs-comment"># 新建 Tmux 窗口并命名</span></span><br></code></pre></td></tr></table></figure><h3 id="接入会话"><a href="#接入会话" class="headerlink" title="接入会话"></a>接入会话</h3><p>此时就算退出远程连接，会话也会保持运行，可以使用以下命令<strong>重新接入</strong>某个已存在的会话：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> tmux attach -t 0 <span class="hljs-comment"># 使用会话编号</span></span><br><span class="hljs-meta">$</span><span class="bash"> tmux attach -t &lt;session-name&gt;  <span class="hljs-comment"># 使用会话名称</span></span><br></code></pre></td></tr></table></figure><h3 id="杀死会话"><a href="#杀死会话" class="headerlink" title="杀死会话"></a>杀死会话</h3><p>在终端窗口中，如果要<strong>彻底杀死</strong>一个运行中的会话，需要用到以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> tmux kill-session -t 0     <span class="hljs-comment"># 使用会话编号</span></span><br><span class="hljs-meta">$</span><span class="bash"> tmux kill-session -t &lt;session-name&gt;  <span class="hljs-comment"># 使用会话名称</span></span><br></code></pre></td></tr></table></figure><p>当然，也可以先用 <code>attach</code> 命令接入会话，再按下 <code>Ctrl+D</code> 或者输入 <code>exit</code> <strong>直接退出</strong> Tmux 会话（注意退出与解绑不同）。</p><h3 id="管理多窗格"><a href="#管理多窗格" class="headerlink" title="管理多窗格"></a>管理多窗格</h3><p>有时候需要同时执行多个程序，并观察输出，就需要多个会话窗口。利用 Tmux 还可以将一个<strong>窗口切分</strong>为多个（并且独立执行会话，<strong>互不干扰</strong>）。只要使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> tmux split-window     <span class="hljs-comment"># 上下切割窗格</span></span><br><span class="hljs-meta">$</span><span class="bash"> tmux split-window -h  <span class="hljs-comment"># 左右切割窗格</span></span><br><span class="hljs-meta">$</span><span class="bash"> tmux select-pane -U / -D / -L / -R  <span class="hljs-comment"># 切换至 上/下/左/右 窗格</span></span><br></code></pre></td></tr></table></figure><p>在工作中，通过输入命令来切换窗格难免有些麻烦，Tmux 为用户提供了一系列快捷键来执行窗格的切换：先同时按下 <code>Ctrl+B</code> 组合键，松手后再按下 <code>%</code> 表示划分左右两个窗格，按下 <code>“</code> 表示划分上下两个窗格，<code>&lt;方向键&gt;</code> 表示到上下左右相邻的一个窗格，<code>x</code> 表示关闭窗格。</p>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习笔记 #2 高级的Shell与文件管理</title>
    <link href="/Linux-Note-2.html"/>
    <url>/Linux-Note-2.html</url>
    
    <content type="html"><![CDATA[<p>在前文的基础上，记录了 Linux 中如何充分利用 Shell 命令，以及对<strong>文件权限</strong>的管理。</p><p>本文部分内容参考了清华 ZAH 同学的教程，部分参考了 刘遄 老师的《<a href="https://www.linuxprobe.com">Linux 就该这么学</a>》，<a href="https://www.runoob.com/linux/linux-tutorial.html">菜鸟教程-Linux</a>。</p><h2 id="高级的-Shell"><a href="#高级的-Shell" class="headerlink" title="高级的 Shell"></a>高级的 Shell</h2><p>Linux 中可以将简单的 Shell 命令组合以发挥更大的作用，常见的如：与文件读写操作有关的重定向技术、处理命令输出值的管道命令符、通配符和转义字符等。这些技巧在 Shell 脚本批处理中十分常用。</p><h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>输入重定向是指把文件<strong>导入到命令</strong>中，而输出重定向则是指把原本要输出到屏幕的数据信息<strong>写入到指定文件</strong>中。</p><p>日常的学习和工作中，使用输出重定向的频率更高，所以又将输出重定向分为了<strong>标准输出</strong>重定向和<strong>错误输出</strong>重定向两种不同的技术，以及<strong>覆盖写入</strong>与<strong>追加写入</strong>两种模式。</p><blockquote><p>错误信息的输出对于执行一个<strong>自动化</strong>的 Shell 脚本非常有用，它可以把整个脚本执行过程中的<strong>报错信息</strong>都记录到文件中，便于安装后的排错工作。</p></blockquote><p>对于输入重定向，格式如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">格式</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>命令 &lt; 文件</code></td><td style="text-align:center">将文件作为命令的标准输入</td></tr><tr><td style="text-align:center"><code>命令 &lt;&lt; 分界符</code></td><td style="text-align:center">从键盘输入中读入，直到遇见分界符才停止</td></tr><tr><td style="text-align:center"><code>命令 &lt; 文件A &gt; 文件B</code></td><td style="text-align:center">将文件 A 作为命令的输入并将标准输出到文件 B</td></tr></tbody></table></div><blockquote><p>通常用输入重定向能做的事情，直接执行该命令也能做，因此使用频率较低。</p></blockquote><p>对于输出重定向，格式如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">格式</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>命令 &gt; 文件</code></td><td style="text-align:center">将标准输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td style="text-align:center"><code>命令 2&gt; 文件</code></td><td style="text-align:center">将错误输出重定向到一个文件中（清空原有文件的数据）</td></tr><tr><td style="text-align:center"><code>命令 &gt;&gt; 文件</code></td><td style="text-align:center">将标准输出重定向到一个文件中（追加到原有内容的后面）</td></tr><tr><td style="text-align:center"><code>命令 2&gt;&gt; 文件</code></td><td style="text-align:center">将错误输出重定向到一个文件中（追加到原有内容的后面）</td></tr></tbody></table></div><h3 id="管道命令符"><a href="#管道命令符" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>管道命令符 <code>|</code> 用于把<strong>前一个命令</strong>原本要输出到屏幕的信息当作<strong>后一个命令</strong>的标准输入，就像一个「管道」连接了两条命令一样，其本质是创建一个<strong>临时文件</strong>用以读写。</p><p>下面用一些例子来展示管道命令符的巧妙之处：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> grep /sbin/nologin /etc/passwd | wc -l <span class="hljs-comment"># 抓取文件中含 /sbin/nologin 的行，统计行数</span></span><br><span class="hljs-meta">$</span><span class="bash"> ls -lah /etc/ | more <span class="hljs-comment"># 罗列目录下的文件信息，用翻页的形式查看</span></span><br><span class="hljs-meta">$</span><span class="bash"> ls -lah usr/bin | grep <span class="hljs-built_in">echo</span> <span class="hljs-comment"># 罗列目录下的文件信息，抓取 echo 文件</span></span><br><span class="hljs-meta">$</span><span class="bash"> ps aux | grep bash <span class="hljs-comment"># 显示全部进程，抓取 bash 的进程信息</span></span><br></code></pre></td></tr></table></figure><p>此外，管道命令符在一条命令中还可以多次复用，完成更复杂的工作。</p><p>但是，由于管道运算符实现的本质，它默认会将前者的输出作为<strong>一整个临时文件</strong>传给后者，而有时候我们却需要拆散这个文件，<strong>依次输入</strong>到后者，这时就需要这个命令：</p><ul><li><code>xargs</code>：代表 eXtended ARGuments，管道命令传递参数的一个<strong>过滤器</strong>，格式为：<code>命令1 | xargs [参数] 命令2</code>。</li></ul><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>在 Git 学习中，已经介绍了一些常用的通配符，这里附上完整表格：</p><div class="table-container"><table><thead><tr><th style="text-align:center">通配符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>*</code></td><td style="text-align:center">任意字符</td></tr><tr><td style="text-align:center"><code>?</code></td><td style="text-align:center">单个任意字符</td></tr><tr><td style="text-align:center"><code>[a-z]</code></td><td style="text-align:center">单个小写字母</td></tr><tr><td style="text-align:center"><code>[A-Z]</code></td><td style="text-align:center">单个大写字母</td></tr><tr><td style="text-align:center"><code>[a-Z]</code></td><td style="text-align:center">单个字母</td></tr><tr><td style="text-align:center"><code>[0-9]</code></td><td style="text-align:center">单个数字</td></tr><tr><td style="text-align:center"><code>[[:alpha:]]</code></td><td style="text-align:center">任意字母</td></tr><tr><td style="text-align:center"><code>[[:upper:]]</code></td><td style="text-align:center">任意大写字母</td></tr><tr><td style="text-align:center"><code>[[:lower:]]</code></td><td style="text-align:center">任意小写字母</td></tr><tr><td style="text-align:center"><code>[[:digit:]]</code></td><td style="text-align:center">所有数字</td></tr><tr><td style="text-align:center"><code>[[:alnum:]]</code></td><td style="text-align:center">任意字母加数字</td></tr><tr><td style="text-align:center"><code>[[:punct:]]</code></td><td style="text-align:center">标点符号</td></tr></tbody></table></div><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>转义字符通常用于避免命令的歧义，最常用的有如下几种：</p><ul><li>反斜杠 <code>\</code>：使反斜杠后面的一个保留字符变为单纯的字符。</li><li>单引号 <code>‘’</code>：转义其中所有的变量为单纯的字符串。</li><li>双引号 <code>“”</code>：保留其中的<strong>变量属性</strong>，不进行转义处理。</li></ul><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>回归一个最本质的问题，当我们在 Shell 环境中输入一条命令时（我们知道这条命令其实是一个 C 编写的程序），Shell 是如何找到这个程序的呢？</p><p>首先，Shell 会用户是否以<strong>绝对路径或相对路径</strong>的方式输入命令（如 /bin/ls），如果是绝对路径则直接执行。如果不是，系统则需要在<strong>多个路径</strong>中查找用户输入的命令文件，而定义这些路径的变量就叫作 <strong>PATH</strong>。我们可以通过如下命令来查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span>  <span class="hljs-comment"># 符号 $ 表示输出环境变量的值</span></span><br>/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/root/bin<br></code></pre></td></tr></table></figure><p>可以看到，PATH 文件中含有多个量，都是这条命令可能存放的位置，于是解释器会在这些位置中逐个查找。</p><p>当然，为了 Linux 这样庞大系统的运行，类似的环境还有许多，我们可以使用 <code>env</code> 命令来查看所有环境变量。这里列出常用的一些变量：</p><div class="table-container"><table><thead><tr><th style="text-align:center">变量名称</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">HOME</td><td style="text-align:center">用户的主目录（即家目录）</td></tr><tr><td style="text-align:center">SHELL</td><td style="text-align:center">用户在使用的 Shell 解释器名称</td></tr><tr><td style="text-align:center">HISTSIZE</td><td style="text-align:center">输出的历史命令记录条数</td></tr><tr><td style="text-align:center">HISTFILESIZE</td><td style="text-align:center">保存的历史命令记录条数</td></tr><tr><td style="text-align:center">MAIL</td><td style="text-align:center">邮件保存路径</td></tr><tr><td style="text-align:center">LANG</td><td style="text-align:center">系统语言、语系名称</td></tr><tr><td style="text-align:center">RANDOM</td><td style="text-align:center">生成一个随机数字</td></tr><tr><td style="text-align:center">PS1</td><td style="text-align:center">Bash 解释器的提示符</td></tr><tr><td style="text-align:center">PATH</td><td style="text-align:center">定义解释器搜索用户执行命令的路径</td></tr></tbody></table></div><blockquote><p>PATH 是最重要的一个环境变量，许多黑客会在 /tmp 中存放一个与 ls 或 cd 同名的木马文件，再把路径加入 PATH。</p></blockquote><h2 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h2><p>Linux 作为一个多用户、多任务的操作系统，具有很好的稳定性与安全性，在幕后保障 Linux 系统的安全则是一系列复杂的配置工作。这里暂不介绍<strong>用户身份</strong>相关的命令，只介绍<strong>文件权限与归属</strong>。</p><h3 id="目录详解"><a href="#目录详解" class="headerlink" title="目录详解"></a>目录详解</h3><p>Unix/Linux 中，<strong>一切皆文件</strong>。涉及权限操作时，不可避免地要接触各个目录，这里简单介绍一些常用目录的作用：</p><p><img src="/img/blog/Linux-Note-2-images/directory.jpg" alt="树状目录结构"></p><p><strong>系统启动项</strong>：</p><ul><li><p>/boot：存放的启动 Linux 时使用的<strong>内核文件</strong>，包括连接文件以及镜像文件。</p></li><li><p>/etc：表示 Etcetera，存放所有的系统需要的<strong>配置文件</strong>和<strong>子目录列表</strong>。</p></li></ul><p><strong>指令集合</strong>：</p><ul><li><p>/bin：存放着最常用的<strong>程序和指令</strong>，如 <code>ls</code> 就是在 /bin/ls 目录下的。</p></li><li><p>/sbin：表示 Super User，只有系统管理员能使用的程序和指令。</p></li></ul><p><strong>账户</strong>：</p><ul><li><p>/root：<strong>系统管理员</strong>的用户主目录。</p></li><li><p>/home：用户的主目录，以各个用户的账号命名，<strong>支持多用户</strong>。</p></li><li><p>/usr：表示 Unix Shared Resources，用户的很多<strong>应用程序和文件</strong>都放在这个目录下，类似 Windows 下的 Program Files 目录。</p><ul><li>/usr/bin：系统用户使用的应用程序与指令。</li><li>/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。</li><li>/usr/src：内核源代码默认的放置目录。</li></ul></li></ul><p><strong>其他</strong>：</p><ul><li>外部文件管理：/dev、/media、/mnt，挂载外部设备，如 U盘，光驱等。</li><li>临时文件：/run，存储系统运行信息；/tmp，存储用户临时信息。</li><li>运行过程项：/var，存放日志等；/proc，管理<strong>内存空间</strong>，系统内存的映射。</li><li>扩展目录：/src，存放服务启动后需要提取的数据，不用<strong>服务器</strong>就是空。</li></ul><h3 id="权限类型"><a href="#权限类型" class="headerlink" title="权限类型"></a>权限类型</h3><p>在 Linux 系统中，每个<strong>文件和目录</strong>都有归属的所有者和所属组，并且规定了其<strong>所有者</strong>、<strong>所属组</strong>以及<strong>其他人</strong>所拥有的可读取（r）、可写入（w）、可执行（x，代表 execute）的权限。</p><p>这三个权限对于文件和目录的含义各不相同：</p><div class="table-container"><table><thead><tr><th style="text-align:center">权限</th><th style="text-align:center">文件</th><th style="text-align:center">目录</th></tr></thead><tbody><tr><td style="text-align:center">读取（r）</td><td style="text-align:center">能读取文件</td><td style="text-align:center">能够读取目录内的<strong>文件列表</strong></td></tr><tr><td style="text-align:center">写入（w）</td><td style="text-align:center">能编辑、新增、修改、删除文件</td><td style="text-align:center">能够在目录内新增、删除、重命名文件</td></tr><tr><td style="text-align:center">执行（r）</td><td style="text-align:center">能运行一个<strong>脚本</strong>程序</td><td style="text-align:center">能够<strong>进入该目录</strong></td></tr></tbody></table></div><p>三类对象，三种权限，总共需要<strong>九个标志位</strong>来限定一个文件或目录的权限范围，为了区分文件和目录等，还有<strong>一个附加标志位</strong>。权限的表示就分为<strong>字符</strong>表示和<strong>数字</strong>表示两种：</p><p><img src="/img/blog/Linux-Note-2-images/file-permission.png" alt="文件权限的字符与数字表示"></p><p>数字表示即在字符对应的<strong>二进制位</strong>填写 1 或 0，表示授权或未授权，转换为<strong>十进制</strong>就是 4、2、1。</p><p>下面以一个例子来说明这两种表示法：现在有这样一个文件，其<strong>所有者</strong>拥有可读、可写、可执行的权限，其文件<strong>所属组</strong>拥有可读、可写的权限；<strong>其他人</strong>只有可读的权限。</p><ul><li>字符表示：<code>rwxrw-r--</code></li><li>数字表示：<code>111110100</code> 即 <code>764</code></li></ul><p>那么现在我们用 <code>ls -l</code> 查看文件的信息：</p><p><img src="/img/blog/Linux-Note-2-images/ls-l.png" alt="通过ls命令查看到的文件属性信息"></p><p>这些信息依次为：<strong>文件类型与权限</strong>；硬链接数；所有者；所有组；文件大小（字节）；最后修改时间；文件名。</p><blockquote><p>文件类型有 7 种，最常见的是 <code>-</code> 表示普通文件，<code>d</code> 表示目录文件。</p><p>硬链接数，对于普通文件，表示指向存储数据块中该文件的<strong>链接数</strong>（相当于 Windows 的快捷方式）；对于目录文件，表示所在<strong>子目录级数</strong>。</p></blockquote><p>在复杂的实际情况中，单纯设置 rwx 权限已无法满足需求，因此还有 SUID、SGID 与 SBIT 三个特殊权限位，这里不多赘述。</p><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>通常来讲，修改权限的操作有以下两个：</p><ul><li><p><code>chmod</code>：代表 Change mode，格式为 <code>chmod [参数] 文件名称</code>。其中参数为数字表示的权限。</p></li><li><p><code>chown</code>：代表 Change owner，格式为 <code>chown 所有者:所有组 文件名</code>。</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>chmod +x script.sh</code></td><td style="text-align:center">给脚本添加可执行权限（默认对于任何人）</td></tr><tr><td style="text-align:center"><code>chmod 777 a.txt</code></td><td style="text-align:center">赋予所有人<strong>完整权限</strong></td></tr><tr><td style="text-align:center"><code>chmod 000 a.txt</code></td><td style="text-align:center">赋予<strong>最小权限</strong>，只有 root 才能操作</td></tr><tr><td style="text-align:center"><code>chown root:root a.txt</code></td><td style="text-align:center">修改所有者和所有组为 root</td></tr></tbody></table></div><p>此外，它们还有一个特别的共性，就是针对目录进行操作时需要加上大写参数 <code>-R</code> 来表示递归操作，即对目录内所有的文件进行整体操作。</p><h3 id="管理员权限"><a href="#管理员权限" class="headerlink" title="管理员权限"></a>管理员权限</h3><p>Linux 系统为了安全性考虑，使得许多系统命令和服务只能被 root 管理员来使用，通过一些命令可以<strong>切换或暂时切换</strong> root 权限。</p><ul><li><code>su</code>：不退出登录的情况下，<strong>切换</strong>用户身份，格式为 <code>su - 用户名称</code>。</li></ul><p>注意到命令中间有个 <code>-</code> 符号，这意味着<strong>完全切换</strong>到新的用户，即把环境变量信息也变更为新用户的相应信息，而不是保留原始的信息。用户名称可以是普通用户，也可以是 root。由普通用户切换至 root 需要输入<strong>管理员密码</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> su - root</span><br>Password:  #此处输入管理员密码<br></code></pre></td></tr></table></figure><ul><li><code>sudo</code>：代表 Superuser do，给普通用户提供<strong>额外</strong>的权限，格式为 <code>sudo [参数] 用户名称</code>。</li></ul><p>最常用的是为当前用户<strong>暂时</strong>提供 root 权限，此时不需要输入管理员密码，只需要<strong>当前用户密码</strong>。该命令可以避免显式输入管理员密码，但有效时间仅有 5 分钟。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">$</span><span class="bash"> sudo su</span><br>Password:  #此处输入当前用户密码<br></code></pre></td></tr></table></figure><p>此外，<code>sudo</code> 还可加在其他命令前面，以获取高权限的执行，常用的有包管理命令。</p>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习笔记 #1 终端与Shell</title>
    <link href="/Linux-Note-1.html"/>
    <url>/Linux-Note-1.html</url>
    
    <content type="html"><![CDATA[<p>继 Git 后贵系的另一个暑培项目，讲授 Linux 的基本用法，恰好这学期「操作系统」课程实验需要用到 Linux，而且实验室的服务器也需要学习相关用法，故学之。</p><p>本文部分内容参考了清华 ZAH 同学的教程，部分参考了 刘遄 老师的《<a href="https://www.linuxprobe.com">Linux 就该这么学</a>》，<a href="https://www.runoob.com/linux/linux-tutorial.html">菜鸟教程-Linux</a>。</p><h2 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h2><p>Linux，全称 GNU/Linux，是一套免费使用和自由传播的类 Unix 操作系统。相比于其他系统，Linux 更加稳定且有效率、更加安全、相对不耗资源……以至于几乎所有<strong>长期稳定运行的网站服务器</strong>上、在<strong>处理大数据的集群系统</strong>中，以及需要<strong>协同工作的服务器环境</strong>都采用 Linux 系统。</p><h3 id="Linux-发行版"><a href="#Linux-发行版" class="headerlink" title="Linux 发行版"></a>Linux 发行版</h3><p>Linux 严格来说是单指操作系统的<strong>内核</strong>，因操作系统中包含了许多用户图形接口和其他实用工具。如今 Linux 常用来指「基于 Linux 的完整操作系统」，内核则改以「Linux 内核」称之。</p><p>一些组织或厂商将 Linux 内核与各种软件和文档<strong>包装</strong>起来，并提供系统安装界面和系统配置、设定与管理工具，就构成了 Linux 的发行版本。</p><p><img src="/img/blog/Linux-Note-1-images/Linux-release.jpg" alt="常见的Linux发行版"></p><h2 id="命令行与终端"><a href="#命令行与终端" class="headerlink" title="命令行与终端"></a>命令行与终端</h2><p>在学习 Linux 的过程中，有几个易混淆的概念：</p><ul><li>图形用户界面（GUI）= 使用<strong>图形</strong>方式进行交互的用户界面</li><li>命令行界面（CLI）= 使用<strong>文本</strong>命令进行交互的用户界面</li><li>控制台（Console）= 物理意义的终端，电脑主机的一部分</li><li>终端（Terminal）= TTY (Teletypewriter，打字机) = <strong>文本输入输出环境</strong></li><li>终端模拟器（Terminal Emulator）= 套壳程序，用来<strong>模拟传统终端</strong></li><li>Shell = 一个程序，<strong>命令行解释器</strong>，执行用户输入的命令并返回结果</li></ul><h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h3><p>命令行界面（Command-Line Interface，CLI）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为字符用户界面（Character User Interface，CUI）。</p><p>一般来说，在<strong>服务器</strong>中较多采用的是 CLI 界面，或许有以下几点原因：</p><ul><li>服务器的功能是对外提供服务，并不需要直观的 GUI 界面来让用户日常使用，使用 GUI 界面反而浪费资源。</li><li>使用 CLI 界面管理服务器，本质上是直接用命令控制服务器，这允许一系列的自动化脚本（Shell 脚本）出现来节省时间。</li><li>方便自动化、规模化部署服务器。</li></ul><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 等系统的桥梁，如同「<strong>壳</strong>」一般。它的本质是一个<strong>命令解释器</strong>，将用户输入的命令（符合 Shell 语法）处理成对应<strong>操作系统的控制命令</strong>，处理完毕后再将结果反馈给用户。</p><p>不同操作系统下面的 Shell 种类众多，常见的有：</p><ul><li>Windows：cmd (Command Shell)、PowerShell；</li><li>Linux/macOS：sh、bash、zsh 等。</li></ul><p>Ken Thompson 的 sh 是第一种 Unix Shell，本教程关注的是 Bash，也就是 Bourne Again Shell，Bash 也是大多数 Linux 系统默认的 Shell。</p><h3 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h3><p>终端 (Terminal)，是一种用来让用户输入数据至计算机，以及显示其计算结果的机器。早期的终端通常就是一台<strong>电子打字机</strong>（Teletypewriter, TTY），后来随着计算机的发展，打字机被键盘和显示器取代，而 GUI 界面也成了主流。</p><p>于是，这时候我们就需要一个程序来模拟传统终端的行为，即<strong>终端模拟器</strong>（Terminal Emulator），当用户打开终端模拟器时，实际上是进入一个<strong>会话进程</strong>（Session）。终端模拟器有很多，这里举几个经典的例子：</p><ul><li>GNU/Linux：gnome-terminal、Konsole；</li><li>macOS：Terminal.app、iTerm2；</li><li>Windows：Windows Terminal、Cmder 等。</li></ul><h2 id="Shell-使用"><a href="#Shell-使用" class="headerlink" title="Shell 使用"></a>Shell 使用</h2><p>在 Linux 系统中打开终端时，会看到一个提示符，通常类似 <code>hewei@hewei-VirtualBox ~$</code>。在提示符下，命令会被 Shell 环境<strong>解析并反馈</strong>到终端中。</p><p>提示符是 Shell 最主要的<strong>文本接口</strong>。它告诉你，你的主机名是 <code>hewei-VirtualBox</code>，你现在的身份是 <code>hewei</code> 并且你当前的<strong>工作目录</strong>（Current working directory）是 <code>~</code> （默认在 <code>/home/hewei/</code> 用户目录）。 </p><p><code>$</code> 符号表示您现在的身份不是 <code>root</code>，输入如下命令可以暂时切换到 <code>root</code> 权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hewei@hewei-VirtualBox ~$ sudo su  <span class="hljs-comment"># 获取 root 权限</span><br>[sudo] hewei 的密码:  <span class="hljs-comment"># 在此输入密码，Terminal 下密码都是不可见的</span><br></code></pre></td></tr></table></figure><p>输入密码后，可以看到提示符变成了 <code>root@hewei-VirtualBox:/home/hewei#</code>，其中 <code>#</code> 符号就是超级用户权限的标志。再输入 <code>exit</code> 即可退回普通用户身份。</p><h3 id="终端快捷键"><a href="#终端快捷键" class="headerlink" title="终端快捷键"></a>终端快捷键</h3><p>在 <a href="https://hwcoder.top/2021/08/28/Git-Note-1">Git学习笔记 #1 基础知识介绍</a> 中，已经简单介绍了命令行界面的一些使用技巧，这些命令在 Linux 系统的 Bash 中同样使用。这里罗列出 Linux 常用快捷键：</p><ul><li><code>Ctrl+Shift+T</code>：唤出一个终端窗口。</li><li><code>Tab</code>：实现对命令、参数或文件的内容补全。</li><li><code>Ctrl+C</code>：终止当前进程的运行，重获终端的控制权。</li><li><code>Ctrl+Z</code>：挂起当前进程。</li><li><code>Ctrl+D</code>：结束键盘输入，若正在使用 Shell 则退出，相当于输入 <code>exit()</code>。</li><li><code>Ctrl+L</code>：清空当前终端中已有的内容，相当于输入 <code>clear</code>。</li><li><code>&lt;上下键&gt;</code>：翻看使用过的命令记录。</li><li><code>Shift+PgUp/PgDn</code>：翻页终端。</li><li><code>home/end</code>：光标快速移动到当前行首或行尾。</li><li><code>Ctrl/Shift+Ins</code> ：复制粘贴文本。</li><li><code>‘’</code> 和 <code>“”</code>：命令参数中若存在空格，需要用引号括起来。</li></ul><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p>常见的执行 Linux 命令的格式是这样的：<code>命令名称 [命令参数] [命令对象]</code>。其中，命令参数用于对命令进行调整，使之更好地贴近需求，参数分为<strong>长格式</strong>和<strong>短格式</strong>，如：<code>man --help</code>，<code>man -h</code>。短格式之间可以合并，合并后仅保留一个减号即可。</p><p>在 Linux 相关的手册中，我们会约定俗成地将可选择的、非必需的参数使用<strong>中括号</strong>引起来，而命令所要求的、必须有的参数或对象值，则不带中括号。</p><p>此外，要注意 Linux 系统中的命令、参数、对象都是<strong>严格区分大小写</strong>的。</p><h3 id="Shell-脚本"><a href="#Shell-脚本" class="headerlink" title="Shell 脚本"></a>Shell 脚本</h3><p>Shell 除了是一个<strong>交互式</strong>（Interactive）的命令解释器，它还是一种<strong>程序设计语言</strong>（Shell Script）。它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支。</p><p>用 Shell 编写的<strong>脚本文件</strong>即 <code>.sh</code> 文件，它能在 Shell 环境下运行，fork 出一个<strong>子进程</strong>，调用系统内核来执行<strong>批处理</strong>（Batch）的系统控制。在文件的第一行，通常是 <code>#!/bin/bash</code>，这句话约定了这个脚本需要哪种 Shell 环境来执行。</p><p>通过如下命令就可以执行一个 Shell 脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta">#</span><span class="bash"> 通过将文件作为参数传递给 shell 以运行 shell 脚本</span><br><span class="hljs-meta">$</span><span class="bash"> bash example.sh<span class="hljs-comment"># 这种方法不需要有 x 权限</span></span><br><span class="hljs-meta">#</span><span class="bash"> 通过具体指定 shell 脚本的路径来执行脚本</span><br><span class="hljs-meta">$</span><span class="bash"> chmod u+x script.sh</span><br><span class="hljs-meta">$</span><span class="bash"> ./example.sh<span class="hljs-comment"># 注意这种方法必须有 ./ z</span></span><br></code></pre></td></tr></table></figure><h2 id="常用命令摘要"><a href="#常用命令摘要" class="headerlink" title="常用命令摘要"></a>常用命令摘要</h2><p>下面罗列了部分常用指令与参数的介绍，更多功能请在帮助手册中检索。</p><h3 id="唤出帮助界面命令"><a href="#唤出帮助界面命令" class="headerlink" title="唤出帮助界面命令"></a>唤出帮助界面命令</h3><ul><li><code>man</code>：代表 Manuel，查看帮助手册，格式为 <code>man 命令名称</code>。会进入「<strong>导航</strong>」模式，使用如下快捷键进行查阅：</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;空格键&gt;</code></td><td style="text-align:center">向下翻一页</td></tr><tr><td style="text-align:center"><code>PaDn</code>/<code>PgUp</code></td><td style="text-align:center">向下/上翻一页</td></tr><tr><td style="text-align:center"><code>home</code>/<code>end</code></td><td style="text-align:center">直接前往首页/尾页</td></tr><tr><td style="text-align:center"><code>/</code></td><td style="text-align:center">从上至下搜索某个关键词，如 <code>/linux</code></td></tr><tr><td style="text-align:center"><code>?</code></td><td style="text-align:center">从下至上搜索某个关键词，如 <code>?linux</code></td></tr><tr><td style="text-align:center"><code>q</code></td><td style="text-align:center">退出帮助文档</td></tr></tbody></table></div></blockquote><h3 id="常用系统工作命令"><a href="#常用系统工作命令" class="headerlink" title="常用系统工作命令"></a>常用系统工作命令</h3><ul><li><code>echo</code>：输出<strong>字符串</strong>或<strong>变量</strong>提取后的值，格式为 <code>echo [字符串] [$变量]</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>echo &#39;hello world&#39;</code></td><td style="text-align:center">输出一个字符串参数，<code>hello world</code></td></tr><tr><td style="text-align:center"><code>echo hello world</code></td><td style="text-align:center">输出两个<strong>空格隔开</strong>的字符串参数，<code>hello</code> 和 <code>world</code></td></tr><tr><td style="text-align:center"><code>echo hello\ world</code></td><td style="text-align:center">输出一个字符串参数，<code>\</code> <strong>转义</strong>空格</td></tr><tr><td style="text-align:center"><code>echo $PATH</code></td><td style="text-align:center">输出环境变量 <code>PATH</code> 的提取值</td></tr></tbody></table></div></blockquote><ul><li><code>date</code>：显示或设置系统的时间与日期，格式为：<code>date [+指定的格式]</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>date</code></td><td style="text-align:center">显示 <code>Sat Sep 5 09:13:45 CST 2020</code></td></tr><tr><td style="text-align:center"><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code></td><td style="text-align:center">按格式显示 <code>2020-09-05 09:14:35</code></td></tr><tr><td style="text-align:center"><code>date -s &quot;20201101 8:30:00&quot;</code></td><td style="text-align:center">设置系统时间</td></tr></tbody></table></div></blockquote><ul><li><code>reboot</code>：重启系统，无格式，需要 <code>root</code> 权限。</li><li><code>poweroff</code>：关闭系统，无格式，需要 <code>root</code> 权限。</li><li><code>ps</code>：代表 Processes，查看系统中的<strong>进程状态</strong>，格式为 <code>ps [参数]</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>-a</code></td><td style="text-align:center">显示所有进程（包括其他用户的进程）</td></tr><tr><td style="text-align:center"><code>-u</code></td><td style="text-align:center">显示用户以及其他详细信息</td></tr><tr><td style="text-align:center"><code>-x</code></td><td style="text-align:center">显示没有控制终端的进程</td></tr><tr><td style="text-align:center"><code>aux</code></td><td style="text-align:center">合并三个参数，<code>ps</code> 命令可省略 <code>-</code></td></tr></tbody></table></div></blockquote><ul><li><p><code>pstree</code>：以<strong>树状图</strong>形式展示进程之间关系，无格式。</p></li><li><p><code>top</code>：<strong>动态地监视</strong>进程活动及系统负载等信息，无格式。</p></li><li><p><code>nice</code>：调整进程的<strong>优先级</strong>，格式为 <code>nice -n 优先级数字 服务名称</code>。取值为 -20 到 19，数字越小，优先级越高。</p></li><li><p><code>pidof</code>：查询指定进程的 PID，格式为 <code>pidof [参数] 服务名称</code>。</p></li><li><p><code>kill</code>：终止指定 PID 值的进程，格式为 <code>kill [参数] PID</code>。</p></li></ul><h3 id="系统状态检测命令"><a href="#系统状态检测命令" class="headerlink" title="系统状态检测命令"></a>系统状态检测命令</h3><ul><li><code>ifconfig</code>：代表 Interface config，获取网卡配置与网络状态等信息。</li><li><code>ipaddr</code>：代表 IP address，获取 IP 地址等信息。</li><li><code>uname</code>：代表 Unix name，查看系统<strong>内核</strong>版本与系统架构等信息。</li><li><code>uptime</code>：查看系统的<strong>负载信息</strong>（当前系统时间、已运行时间、启用终端数、平均负载值），无格式。</li><li><code>free</code>：显示当前系统中<strong>内存的使用量</strong>，格式为 <code>free [-h]</code>，<code>-h</code> 为易读模式（human readable）。</li><li><code>who</code>：查看当前登入主机的<strong>用户终端信息</strong>，无格式。</li><li><code>ping</code>：测试主机之间的网络连通性，格式为 <code>ping [参数] 主机地址</code>。</li><li><code>history</code>：显示执行过的命令历史，格式为 <code>history [-c]</code>，<code>-c</code> 为清空（clear）。</li></ul><h3 id="查找定位文件命令"><a href="#查找定位文件命令" class="headerlink" title="查找定位文件命令"></a>查找定位文件命令</h3><ul><li><code>pwd</code>：代表 Print working directory，显示用户当前所处的工作目录，无格式。</li><li><code>cd</code>：代表 Change directory，切换当前的工作路径，格式为 <code>cd [参数] [目录]</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>cd -</code></td><td style="text-align:center">返回到上一次所处的目录</td></tr><tr><td style="text-align:center"><code>cd .</code></td><td style="text-align:center">进入目录（无变化）</td></tr><tr><td style="text-align:center"><code>cd ..</code></td><td style="text-align:center">进入上级目录</td></tr><tr><td style="text-align:center"><code>cd /</code></td><td style="text-align:center">切换到根目录</td></tr><tr><td style="text-align:center"><code>cd ~</code></td><td style="text-align:center">切换到当前用户的 <code>/home/</code> 目录</td></tr><tr><td style="text-align:center"><code>cd ~ &lt;username&gt;</code></td><td style="text-align:center">切换到其他用户的 <code>/home/</code> 目录</td></tr><tr><td style="text-align:center"><code>cd /bin</code></td><td style="text-align:center">切换到绝对路径 <code>/bin</code> 下</td></tr></tbody></table></div></blockquote><ul><li><code>ls</code>：代表 List，显示目录中的文件信息，格式为 <code>ls [参数] [文件名称]</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>ls -a</code></td><td style="text-align:center">查看全部文件（包括隐藏文件）</td></tr><tr><td style="text-align:center"><code>ls -l</code></td><td style="text-align:center">列表形式，查看文件的属性、大小等详细信息</td></tr><tr><td style="text-align:center"><code>ls -al</code></td><td style="text-align:center">合并以上两个参数</td></tr><tr><td style="text-align:center"><code>ls -alh</code></td><td style="text-align:center">易读显示（human readable）</td></tr><tr><td style="text-align:center"><code>ls -ld</code></td><td style="text-align:center">查看当前路径文件夹的属性、大小等详细信息</td></tr></tbody></table></div></blockquote><ul><li><code>tree</code>：以树状图的形式列出<strong>目录内容及结构</strong>，无格式。</li><li><code>find</code>：指定条件查找文件所对应的位置，格式为 <code>find [查找范围] 寻找条件</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>find /etc -name &quot;host*&quot;</code></td><td style="text-align:center">查找 <code>/etc</code> 路径下 <code>host</code> 开头的文件</td></tr><tr><td style="text-align:center"><code>find / -perm -4000</code></td><td style="text-align:center">整个系统中搜索权限包括 SUID 的文件</td></tr></tbody></table></div></blockquote><ul><li><p><code>updatedb</code>：生成文件索引库，无格式。和以下命令配合使用，快于 <code>find</code>。</p></li><li><p><code>locate</code>：按照名称快速搜索文件所对应的位置，格式为 <code>locate 文件名称</code>。</p></li><li><p><code>whereis</code>：按照名称快速搜索<strong>命令</strong>、<strong>源代码</strong>及<strong>帮助文件</strong>的位置，格式为 <code>whereis 命令名称</code>。</p></li><li><p><code>which</code>：按照名称检索<strong>命令</strong>的位置，格式为 <code>which 命令名称</code>，默认在 PATH 变量所指定的路径中检索。</p></li></ul><h3 id="文本统计编辑命令"><a href="#文本统计编辑命令" class="headerlink" title="文本统计编辑命令"></a>文本统计编辑命令</h3><ul><li><code>cat</code>：代表 Concatenate，查看<strong>内容较少</strong>的纯文本文件，格式为 <code>cat [参数] 文件名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>cat a.txt</code></td><td style="text-align:center">查看当前目录下文件内容</td></tr><tr><td style="text-align:center"><code>cat -n a.txt</code></td><td style="text-align:center">查看时显示行号</td></tr><tr><td style="text-align:center"><code>cat /etc/os-release</code></td><td style="text-align:center">查看操作系统信息</td></tr></tbody></table></div></blockquote><ul><li><code>more</code>：查看<strong>内容较多</strong>的纯文本文件，格式为 <code>more [参数] 文件名称</code>。用空格键或回车键向下滚动查看。</li><li><code>head</code>：查看纯文本文件的前 <em>N</em> 行，格式为 <code>head -n [行数] 文件名称</code>。</li><li><code>tail</code>：查看纯文本文件的后 <em>N</em> 行，格式为 <code>tail [参数] 文件名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>tail -n 10 a.txt</code></td><td style="text-align:center">显示文件的后 10 行</td></tr><tr><td style="text-align:center"><code>tail -f /var/log/messages</code></td><td style="text-align:center">查看并实时刷新，常用于日志文件</td></tr></tbody></table></div></blockquote><ul><li><code>tr</code>：代表 Translate，替换文本内容中的字符，格式为 <code>tr [原始字符] [目标字符]</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>cat a.txt丨tr [a-z] [A-Z]</code></td><td style="text-align:center">把文本中的英文以全大写输出（经过管道运算符）</td></tr></tbody></table></div></blockquote><ul><li><code>wc</code>：统计指定文本文件的行数 <code>-l</code>、字数 <code>-w</code> 或字节数 <code>-c</code>，格式为 <code>wc [参数] 文件名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>wc -l /etc/passwd</code></td><td style="text-align:center">统计 <code>passwd</code> 行数，等价于求用户数</td></tr><tr><td style="text-align:center"><code>wc 1.txt</code></td><td style="text-align:center">不加参数，默认三个值都返回</td></tr></tbody></table></div></blockquote><ul><li><code>stat</code>：查看文件的具体存储细节和时间等信息，格式为 <code>stat 文件名称</code>。</li><li><code>grep</code>：代表 Global Regular Expression Print，按行提取文本内容，格式为 <code>grep [参数] 查询内容 文件名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>-b</code></td><td style="text-align:center">将可执行文件 (bin) 当作文本文件 (txt) 来搜索</td></tr><tr><td style="text-align:center"><code>-c</code></td><td style="text-align:center">仅显示找到的行数</td></tr><tr><td style="text-align:center"><code>-i</code></td><td style="text-align:center">忽略查询内容的大小写</td></tr><tr><td style="text-align:center"><code>-n</code></td><td style="text-align:center">同时显示行号</td></tr><tr><td style="text-align:center"><code>-v</code></td><td style="text-align:center">反向选择，列出不包含查询内容的行</td></tr></tbody></table></div></blockquote><ul><li><code>diff</code>：比较多个文件之间内容的差异，格式为 <code>diff [参数] 文件名称A 文件名称B</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>diff --brief diff_A.txt diff_B.txt</code></td><td style="text-align:center">仅显示判断结果</td></tr><tr><td style="text-align:center"><code>diff -c diff_A.txt diff_B.txt</code></td><td style="text-align:center">描述不同的行</td></tr></tbody></table></div></blockquote><ul><li><code>uniq</code>：代表 Unique，去除文本中连续的重复行，格式为 <code>uniq [参数] 文件名称</code>。</li><li><code>sort</code>：对文本内容进行再排序，格式为 <code>sort [参数] 文件名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>-f</code></td><td style="text-align:center">忽略大小写</td></tr><tr><td style="text-align:center"><code>-b</code></td><td style="text-align:center">忽略缩进与空格</td></tr><tr><td style="text-align:center"><code>-n</code></td><td style="text-align:center">以数值型排序</td></tr><tr><td style="text-align:center"><code>-r</code></td><td style="text-align:center">反向排序</td></tr><tr><td style="text-align:center"><code>-u</code></td><td style="text-align:center">去除重复行</td></tr><tr><td style="text-align:center"><code>-t</code></td><td style="text-align:center">指定间隔符</td></tr><tr><td style="text-align:center"><code>-k</code></td><td style="text-align:center">按照间隔符，指定第几列值</td></tr></tbody></table></div></blockquote><h3 id="文件目录管理命令"><a href="#文件目录管理命令" class="headerlink" title="文件目录管理命令"></a>文件目录管理命令</h3><ul><li><code>touch</code>：创建空白文件或设置文件的时间，格式为 <code>touch [参数] 文件名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>touch 1.txt</code></td><td style="text-align:center">创建一个空白文件</td></tr><tr><td style="text-align:center"><code>touch -d &quot;2020-05-04 15:44&quot; 1.txt</code></td><td style="text-align:center">设置文件上次修改时间</td></tr></tbody></table></div></blockquote><ul><li><code>mkdir</code>：代表 Make directory，创建空白的目录，格式为 <code>mkdir [参数] 目录名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>mkdir mydir</code></td><td style="text-align:center">在当前路径下新建文件夹</td></tr><tr><td style="text-align:center"><code>mkdir -p a/b/c/d/e</code></td><td style="text-align:center">创建层叠目录</td></tr></tbody></table></div></blockquote><ul><li><code>cp</code>：代表 Copy，复制文件或目录，格式为 <code>cp [参数] 源文件名称 目标文件名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">源文件</th><th style="text-align:center">目标文件</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">文件</td><td style="text-align:center">目录</td><td style="text-align:center">把源文件复制到该目录中</td></tr><tr><td style="text-align:center">文件</td><td style="text-align:center">文件</td><td style="text-align:center">询问是否要覆盖它（需要 <code>-i</code>）</td></tr><tr><td style="text-align:center">文件</td><td style="text-align:center">不存在</td><td style="text-align:center">执行正常的复制操作（如<strong>备份</strong>）</td></tr><tr><td style="text-align:center">目录</td><td style="text-align:center">目录</td><td style="text-align:center">递归持续复制（需要 <code>-r</code> 或 <code>-a</code>）</td></tr></tbody></table></div></blockquote><ul><li><code>mv</code>：移动文件，格式为 <code>mv [参数] 源文件名称 目标文件名称</code>。不同于复制操作，默认会把源文件删除，只保留剪切后的文件。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>mv 1.txt 2.txt</code></td><td style="text-align:center">相当于重命名文件</td></tr><tr><td style="text-align:center"><code>mv 1.txt mydir</code></td><td style="text-align:center">剪切到新目录下</td></tr></tbody></table></div></blockquote><ul><li><code>rm</code>：删除文件或目录，格式为 <code>rm [参数] 文件名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>-f</code></td><td style="text-align:center">强制执行，不询问</td></tr><tr><td style="text-align:center"><code>-i</code></td><td style="text-align:center">删除前询问（默认）</td></tr><tr><td style="text-align:center"><code>-r</code></td><td style="text-align:center">递归删除目录</td></tr><tr><td style="text-align:center"><code>-v</code></td><td style="text-align:center">显示正在删除过程</td></tr></tbody></table></div></blockquote><ul><li><code>rmdir</code>：删除<strong>空</strong>目录，格式为 <code>rmdir [参数] 目录名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">样例</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>rmdir mydir</code></td><td style="text-align:center">删除当前路径的<strong>空</strong>目录</td></tr><tr><td style="text-align:center"><code>rmdir -p a/b/c</code></td><td style="text-align:center">删除层叠空目录</td></tr></tbody></table></div></blockquote><ul><li><code>file</code>：查看文件的类型，常用于无后缀文件，格式为 <code>file 文件名称</code>。</li></ul><blockquote><p>Linux 中一切皆文件，而许多文件都是没有后缀的。</p><p>不像 Windows，用户双击鼠标打开文件，此时系统会自行判断用户双击的文件是什么类型，因此需要有后缀进行区别。</p><p>而 Linux 系统则是根据用户执行的命令来调用文件，例如执行 cat 命令查看文本等，所以也就不需要强制让用户给文件设置后缀了。</p></blockquote><ul><li><code>tar</code>：文件进行打包压缩或解压，格式为 <code>tar 参数 文件名称</code>。</li></ul><blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>-c</code></td><td style="text-align:center">创建压缩文件</td></tr><tr><td style="text-align:center"><code>-x</code></td><td style="text-align:center">解开压缩文件</td></tr><tr><td style="text-align:center"><code>-t</code></td><td style="text-align:center">查看压缩包内有哪些文件</td></tr><tr><td style="text-align:center"><code>-v</code></td><td style="text-align:center">显示真正压缩或解压的过程</td></tr><tr><td style="text-align:center"><code>-C</code></td><td style="text-align:center">指定解压到的目录</td></tr></tbody></table></div></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习笔记 #4 GitHub合作开发</title>
    <link href="/Git-Note-4.html"/>
    <url>/Git-Note-4.html</url>
    
    <content type="html"><![CDATA[<p>接上文，本文介绍了 Git 基于 <strong>GitHub</strong> 的使用，以及<strong>合作开发</strong>的注意事项。文章的最后还留下了一些待填的坑…</p><p>本文大部分内容参考了 RCY 同学的教程，部分参考了 <a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰教程-Git</a>，<a href="https://www.runoob.com/git/git-tutorial.html">菜鸟教程-Git</a>，以及 Git 官网文档 <a href="https://git-scm.com/doc">Git-Documentation</a>。</p><h2 id="GitHub-合作开发"><a href="#GitHub-合作开发" class="headerlink" title="GitHub 合作开发"></a>GitHub 合作开发</h2><p>以下内容也适用于不同的服务器平台，如 Gitee、GitLab 等。</p><h3 id="新建远程仓库"><a href="#新建远程仓库" class="headerlink" title="新建远程仓库"></a>新建远程仓库</h3><p>从 GitHub 上创建一个空仓库后，通常有三个选择：</p><ul><li><strong>直接克隆</strong>到本地，会生成一个仓库文件夹，里面只有一个 <code>.git</code> 文件夹。可以在仓库文件夹中创作。</li><li>在<strong>本地新建</strong>一个同名文件夹，再创建本地仓库，添加远程仓库，推送并绑定上游分支。</li><li>对<strong>本地已有</strong>的一个仓库（确保同名），添加远程仓库，推送并绑定上游分支。</li></ul><p>对于第一种方法，只需要 <code>git clone</code> 命令即可，对于第二种方法，GitHub 提供了一系列指引命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;# test&quot;</span> &gt;&gt; README.md<br>$ git init<br>$ git add README.md<br>$ git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br>$ git branch -M main  <span class="hljs-comment"># 重命名本地主分支，避免冲突，新版本特性</span><br>$ git remote add origin https://github.com/hewei2001/test.git<br>$ git push -u origin main  <span class="hljs-comment"># 推送并绑定上游分支</span><br></code></pre></td></tr></table></figure><p>对于第三种情况，只需完成后面三步即可。</p><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p>在通过 GitHub 新建仓库时，我们会发现有个 <code>Add .gitignore</code> 按钮，这有什么用呢？实际上我们知道，维护真正项目时可能有一次修改会涉及到多个文件，这个时候一般大家会倾向于使用 <code>git add .</code> 的简单操作。</p><p>但是，并非所有文件都应该被放入 Git 仓库中，如：</p><ul><li>IDE / 编辑器 的<strong>配置文件</strong>（如 .vscode、.idea 等）；</li><li>数据库文件；</li><li>带有敏感信息的文件。</li></ul><p>这和便利的命令形成了矛盾，为此出现了特殊文件 <code>.gitignore</code>，它可以决定哪些的文件不需要添加到版本管理中。一个样例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Python3 的缓存文件（预编译模块）</span><br>__pycache__<br><span class="hljs-comment"># Vscode 的配置文件</span><br>.vscode<br><span class="hljs-comment"># Pycharm 等Jet的配置文件</span><br>.idea<br><span class="hljs-comment"># 忽略项目中所有 ckpt 目录</span><br>ckpt/<br><span class="hljs-comment"># 忽略项目根目录下的 data 目录</span><br>/data/<br><span class="hljs-comment"># 忽略项目根目录下的 foo 目录下所有的 model.pt</span><br>/foo/**/model.pt<br></code></pre></td></tr></table></figure><p>以行为单位，一行写一个规则，决定什么不被添加，书写规则也很简单：</p><ul><li>以 <code>#</code> 开头的一行是注释，用 <code>\</code> 进行转义。</li><li>若规则不包含 <code>/</code>，会对 <code>.gitignore</code> <strong>同路径下</strong>的文件和目录进行屏蔽；</li><li>若规则以 <code>/</code> 结束，则会匹配项目中所有同名目录下的内容，但不匹配同名文件；</li><li>若规则以 <code>/</code> 开始，则会从项目根目录开始匹配；</li><li><code>*</code> 匹配<strong>除了 <code>/</code> 以外</strong>的任意字符串，<code>**</code> 匹配完整路径名；</li><li><code>?</code> 匹配<strong>除了 <code>/</code> 以外</strong>的任意单个字符；</li><li>区间表示，如 <code>[a-zA-Z]</code>，可以用于匹配任何一个区间范围内的字符；</li><li><code>!</code> 开头的模式标识<strong>否定</strong>，该文件将会再次被包含，通常用于在屏蔽的文件中添加<strong>特例</strong>；</li><li>不能识别<strong>中文</strong>，因为默认编码是 GBK。</li></ul><p>创建一个 <code>.gitignore</code> 文件最便捷的方法是，在创建仓库时勾选 GitHub 自动创建，并在选项中选择合适的 <code>.gitignore</code> 文件模板，再克隆到本地手动补充。</p><blockquote><p>在实际工程中，用 GitHub 创建仓库还可以便捷地添加合适的 LICENSE 文件。</p></blockquote><h3 id="远程服务器拒绝"><a href="#远程服务器拒绝" class="headerlink" title="远程服务器拒绝"></a>远程服务器拒绝</h3><p>如果你是在一个<strong>大合作团队</strong>中工作，很可能是 main 被<strong>锁定</strong>了（只有 Collaborators 有权限推送），其他人需要 Pull Request 流程来合并修改。</p><p>如果你直接提交到本地 main，然后试图推送修改，你将会收到这样类似的信息:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less">! <span class="hljs-selector-attr">[远程服务器拒绝]</span> <span class="hljs-selector-tag">main</span> <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">main</span> (<span class="hljs-attribute">TF402455</span>: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)<br></code></pre></td></tr></table></figure><p>这里推荐一个做法：<strong>Fork</strong> 最新的仓库，此时你将拥有这个远程仓库的<strong>从分支</strong>——你的用户名就是从分支名。再将你的修改提交到这条分支，最后通过 GitHub 网站来提交一个 PR，请求主分支<strong>拉取并合并</strong>你的从分支。</p><blockquote><p>当然，如果只是几个人的<strong>小开发团队</strong>，还是建议在仓库的 <code>Settings</code> 界面找到 <code>Collaborators</code>，直接添加队友来得方便。</p></blockquote><h3 id="upstream"><a href="#upstream" class="headerlink" title="upstream"></a>upstream</h3><p>在前文介绍 Push 时，曾提过上游（upstream）的概念，对于个人开发而言，<code>upstream</code> 只是标识了多个远程仓库或分支中的某个默认值。但在合作开发，特别是需要提 PR 时，<code>upstream</code> 有其特定意义。</p><ul><li><code>upstream</code> 通常指代你所 fork 的原始仓库，你无权修改。</li><li><code>origin</code> 则是你所 fork 下来的仓库，你有权修改。</li></ul><p>因此，当需要对一个大型项目贡献时，你的操作流程应该是：</p><ol><li><p>先在 GitHub 上 fork 原始仓库，得到你所有的仓库。</p></li><li><p>再 clone 你所有的仓库到本地，此时它默认为 <code>origin</code> 分支。</p></li><li><p>将原始仓库添加到 <code>upstream</code> 以保持联系，跟进其变化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote add upstream git://github.com/&lt;aUser&gt;/&lt;aRepo.git&gt;<br>$ git remote -v  <span class="hljs-comment"># 查看远程仓库情况</span><br></code></pre></td></tr></table></figure><p>当原始仓库有变化时，可以拉取其更新：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git fetch upstream  <span class="hljs-comment"># 如果设置了 upstream 可以缺省</span><br>$ git merge<br></code></pre></td></tr></table></figure></li><li><p>当本地做出提交时，先推送到自己的 <code>origin</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin  <span class="hljs-comment"># 如果不加 origin 会被远程服务器拒绝</span><br></code></pre></td></tr></table></figure><p>然后再通过 Pull Request 请求原始仓库拉取你的修改。</p></li></ol><h2 id="多远程与多分支"><a href="#多远程与多分支" class="headerlink" title="多远程与多分支"></a>多远程与多分支</h2><p>实践中遇到的最多的问题：</p><ul><li>创建空分支：<a href="https://www.jianshu.com/p/a18487d987ac">https://www.jianshu.com/p/a18487d987ac</a></li><li>推送本地所有分支和拉取远程所有分支：<a href="https://blog.csdn.net/toopoo/article/details/85260277">https://blog.csdn.net/toopoo/article/details/85260277</a></li><li>将一个项目同时从本地推送到 GitHub 和 Gitee：<a href="https://www.cnblogs.com/poloyy/p/12215199.html">https://www.cnblogs.com/poloyy/p/12215199.html</a></li><li>将 upstream 的分支拉到本地后没有对应的同名分支：</li></ul><h2 id="高端的-Git"><a href="#高端的-Git" class="headerlink" title="高端的 Git"></a>高端的 Git</h2><p>高端的操作往往意味着危险的操作，以下将介绍前文未提及的一些操作，同时也挖下一些坑以后来填。</p><h3 id="版本回退-Reset"><a href="#版本回退-Reset" class="headerlink" title="版本回退 (Reset)"></a>版本回退 (Reset)</h3><p>有时候你可能希望放弃 Git 仓库中的一部分提交，退到其他某处，这种情况下可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reset &lt;Commit ID or Branch&gt;         <span class="hljs-comment"># 让 Git 仓库回退到某个记录或分支位置</span><br>$ git reset &lt;Commit Id or Branch&gt; --hard  <span class="hljs-comment"># 让所有区回退到某个记录或分支位置（将丢失你工作区和暂存区的数据）</span><br></code></pre></td></tr></table></figure><p>这种情况下可以带着分支一起回退，然后重新 commit，走一条完全不同的道路，而放弃了部分数据。</p><p>但是，如果你 reset 完后又后悔了，该怎么办？没关系，只要你没玩 gc 这样的危险指令，那么你 Git 仓库中的数据总有机会找回来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reflog <span class="hljs-comment"># 查看最近一些变动快照的操作与版本号</span><br></code></pre></td></tr></table></figure><p>在看到后面的快照的版本号后，则可以 reset 回去。</p><h3 id="Cherry-Pick"><a href="#Cherry-Pick" class="headerlink" title="Cherry-Pick"></a>Cherry-Pick</h3><p>一个相对高端的分支管理命令，将一些提交复制到当前所在的位置（HEAD）下面，这些提交可以来自其他分支，但不一定是顺序的！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cherry-pick &lt;Commit ID&gt;<br></code></pre></td></tr></table></figure><h3 id="Stash"><a href="#Stash" class="headerlink" title="Stash"></a>Stash</h3><p>用于将目前暂存区的东西移入一片额外空间，从而清空暂存区。</p><h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><p>无论是本博客，还是网上的文档，甚至官方的教程，都未必能把每个指令的每个参数、用法提到，因此 Git 自带的帮助文档就很重要：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add --<span class="hljs-built_in">help</span><br>$ git <span class="hljs-built_in">help</span> add<br><span class="hljs-comment"># 以上两个指令的效果等价，都会</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习笔记 #3 远程仓库使用</title>
    <link href="/Git-Note-3.html"/>
    <url>/Git-Note-3.html</url>
    
    <content type="html"><![CDATA[<p>接上文，本文介绍了 Git 在<strong>远程仓库</strong>的使用，以及<strong>合作开发</strong>的简易教程。</p><p>本文大部分内容参考了 RCY 同学的教程，部分参考了 <a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰教程-Git</a>，<a href="https://www.runoob.com/git/git-tutorial.html">菜鸟教程-Git</a>，以及 Git 官网文档 <a href="https://git-scm.com/doc">Git-Documentation</a>。</p><h2 id="远程的-Git"><a href="#远程的-Git" class="headerlink" title="远程的 Git"></a>远程的 Git</h2><p>尽管 Git 本身是分布式的，但我们通常需要一个服务器来同步、传递我们的本地仓库数据，处于一种「<strong>伪集中式</strong>」的状态。但服务器上的内容不一定是最新的内容，只是一个用于传递的中间态而已。</p><p>因此有了一系列的相关网站，通常来说我们用以下两个：</p><ul><li>GitHub：⼀个基于 Git 的代码托管服务平台，开源社区交流代码的重要网站，参考 <a href="https://www.github.com/">https://www.github.com/</a> 。</li><li>GitLab：类似 Git，有完善的管理界面和权限控制，一般用于在企业、学校等内部网络搭建 Git 私服，参考 <a href="https://www.gitlab.com/">https://www.gitlab.com/</a> 。</li></ul><p>从代码的私有性上来看，GitLab 是一个更好的选择。但是对于开源项目而言，GitHub 依然是代码托管的首选。</p><h3 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h3><p>在使用远程仓库之前，我们要先解决鉴权问题：云服务器需要知道你是否有权力访问这个仓库。</p><p>鉴权有两种方法：</p><ol><li>用户名 + 密码</li><li>SSH 密钥对</li></ol><p>通常来说，使用密钥对比用户名密码更安全，这里不介绍相关原理，先简单讲下密钥对的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;631670924@qq.com&quot;</span> <span class="hljs-comment"># 获取 SSH Key</span><br><span class="hljs-comment"># 参数 -t 代表 type 设置，默认使用 SSH2d 的 rsa</span><br><span class="hljs-comment"># 参数 -C 代表 Comment 设置，提供一个新注释</span><br><span class="hljs-comment"># 其他参数用于生成更多功能的密钥，请自行查阅相关网站</span><br>$ cat ~/.ssh/id_rsa.pub <span class="hljs-comment"># 代表 concatenate，用于连接文件并打印到标准输出</span><br></code></pre></td></tr></table></figure><p>密钥对生成时会需要设置密码，但由于其本身就是加密的，密码只是为了适应更特殊的情景，这里可以直接回车<strong>跳过</strong>。</p><p><code>cat</code> 命令会把<strong>公钥</strong>放到标准输出，复制到 GitHub 或 GitLab 上的对应位置即可。注意 <code>id_rsa.pub</code> 是可以公开的，而<strong>私钥</strong>存储在 <code>id_rsa</code> 文件，用于在每次操作远程仓库时与公钥进行匹配。</p><p>如果你有多台电脑或服务器，可以<strong>分别</strong>在各个主机上生成<strong>各自的</strong> SSH 密钥对，并将公钥复制到 GitHub 或 GitLab，并区分命名。这样就可以实现在不同主机上的鉴权，方便多地办公。</p><h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><p>远程仓库通常是由 clone 或 push 开始的，这里假设我们已经在 GitHub 上有了一个仓库，现在要将其克隆到本地。</p><p>常见的克隆方法有两种：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> &lt;仓库的 HTTPS URL 地址&gt;<br>$ git <span class="hljs-built_in">clone</span> &lt;仓库的 SSH Key&gt;<br></code></pre></td></tr></table></figure><p>前者不需要配置 SSH 也能完成，但是每次操作远程仓库都需要用户名和密码。后者是在配置完 SSH Key 后使用的，可以省去填写用户名和密码的步骤，也能帮助你克隆<strong>私有仓库</strong>。如果前面生成密钥对时设置了密码，这里就需要输入。</p><p>此外，如果要克隆一个较大的仓库（仓库有很长的提交历史或大量二进制文件），常用的一个方法是限制 clone 的深度，只克隆最新的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> --depth=1 https://github.com/hewei2001/HITSZ-OpenCS<br></code></pre></td></tr></table></figure><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><p>现在对本地仓库查看 log，会发现除了 HEAD、main 这些原有的指针，还多了 <code>origin/</code> 的字样，这是<strong>远程仓库分支</strong>的默认标识。</p><p>这些远程分支与本地分支<strong>并存</strong>，反映了远程仓库在你上次和它「<strong>通信</strong>」时的状态，可以用前面的命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch --all  <span class="hljs-comment"># 参数 --all 代表所有分支，包括远程分支</span><br></code></pre></td></tr></table></figure><p>同样，也可以用 <code>git checkout</code> 切换到任意一个远程分支，只需要加上 <code>origin/</code>。</p><blockquote><p>远程分支有一个特别的属性，在你检出时自动进入一个「<strong>分离 HEAD 状态</strong>」。在此状态下，不会有 <code>HEAD -&gt; origin/main -&gt; node</code>，而是直接有 <code>HEAD -&gt; node</code>。这样做是因为 Git 不能直接在远程分支上进行操作，必须在本地操作后将 main 分支同步到远程，origin/main 才会发生变动。</p><p>一旦发生了分离 HEAD 并提交修改，下次 push 时本地仓库将与远程仓库发生分歧，可能需要 Rebase 操作。</p></blockquote><p>在实际操作中，我们<strong>只需要检出到本地分支</strong>即可。当克隆一个仓库时，它通常会自动地创建一个<strong>跟踪</strong> origin/main 的 main 分支。</p><p>但如果一个远程分支 origin/test 在本地没有对应分支 test，我们却要检出 test，该命令会自动复制一个「<strong>跟踪分支</strong>」作为本地分支。</p><h2 id="本地与远程的交互"><a href="#本地与远程的交互" class="headerlink" title="本地与远程的交互"></a>本地与远程的交互</h2><h3 id="下载-Fetch"><a href="#下载-Fetch" class="headerlink" title="下载 (Fetch)"></a>下载 (Fetch)</h3><p>所谓的拉取通常可由两个操作来完成，初学者往往分不清两个操作究竟分别做了什么：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git fetch  <span class="hljs-comment"># 下载--下载远程分⽀到本地</span><br>$ git pull   <span class="hljs-comment"># 拉取--使本地分支与远程分支同步</span><br></code></pre></td></tr></table></figure><p>下面我们用一组图来解释 <code>git fetch</code> 操作：</p><p><img src="/img/blog/Git-Note-3-images/git-fetch-1.png" alt="使用fetch前的仓库"></p><p>在这个例子中，虚线的结点代表远程仓库，它有两个我们本地仓库中没有的提交。而此时本地的远程分支 origin/main 还停留在你上次和它「<strong>通信</strong>」时的状态。如果此时使用 <code>git fetch</code>，则会出现：</p><p><img src="/img/blog/Git-Note-3-images/git-fetch-2.png" alt="使用fetch后的仓库"></p><p>可以发现，本地仓库<strong>缺失的结点</strong> C2 和 C3 被<strong>下载</strong>到了本地仓库，同时<strong>远程分支</strong> origin/main 也被更新，反映到了这一下载，但是<strong>本地分支</strong> main 依旧不变！</p><p>因此，我们可以知道：<code>git fetch</code> 并不会改变本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上原有的文件使其与远程「<strong>同步</strong>」，它只是将「同步」这一操作所需要的数据都下载下来了。</p><h3 id="拉取-Pull"><a href="#拉取-Pull" class="headerlink" title="拉取 (Pull)"></a>拉取 (Pull)</h3><p>那么，如何将这些数据真正完成「同步」呢？实际上有很多方法，上一节提到的 <code>git merge origin/main</code> 和 <code>git rebase origin/main</code> 等命令都可实现。</p><p>实际上，由于<strong>先抓取更新再合并到本地分支</strong>这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 <code>git pull</code>。</p><p>这里我们先用一个<strong>分叉</strong>的例子来演示：</p><p><img src="/img/blog/Git-Note-3-images/git-pull-1.png" alt="使用pull前的仓库"></p><p><strong>分叉</strong> (Branch Diverged) 是由于不同开发者进行了<strong>时空错位</strong>的提交导致的。观察该图，我们可以猜测本地开发者是在 C1 时刻克隆的仓库，并再克隆后完成了一次 C2 提交，而与此同时，另一个开发者在远程完成了 C3 提交。</p><p>此时如果想提交代码到远程，会提示 main 分支发生了<strong>分歧</strong>——因为远程仓库包含了本地尚不存在的结点，无法通过<strong>快速前移</strong>直接合并。Git 会提示你先将远程仓库拉取到本地解决分叉。</p><p><img src="/img/blog/Git-Note-3-images/git-pull-2.png" alt="使用pull后的仓库"></p><p>可以看到，<code>git pull</code> 其实就是 <code>git fetch</code> 和 <code>git merge origin/main</code> 两个指令的缩写。</p><p>需要注意的是，如果此时 C2 和 C3 有<strong>冲突</strong>，则 <code>git pull</code> 不完全执行，需要<strong>手动维护</strong>后再 merge，这个维护的过程对另一开发者是不可见的。</p><blockquote><p>在实际操作中，我们偶尔会用 <code>git fetch</code> 和 <code>git rebase origin/main</code> 来避免一个不必要的合并。 </p></blockquote><h3 id="推送-Push"><a href="#推送-Push" class="headerlink" title="推送 (Push)"></a>推送 (Push)</h3><p>相比于拉取，推送操作就尤为简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push<br></code></pre></td></tr></table></figure><p>如果无分歧发生，远程仓库将会接收本地新增的结点，而远程仓库中的 main 也会指向本地仓库中 main 的位置。此外，本地仓库的远程分支 origin/main，会在这次「<strong>通信</strong>」的过程中，也移动到本地 main 的位置。</p><p>再回顾一下上面的<strong>分叉</strong>的例子，如果我们已经 merge 解决了冲突，这时再用 <code>git push</code> 则会有：</p><p><img src="/img/blog/Git-Note-3-images/git-push-1.png" alt="分叉的第一种解决方案"></p><p>可以看到，远程仓库清楚地记录了这次 merge 的历程！</p><p>而如果我们用 <code>git fetch</code> 和 <code>git rebase origin/main</code> 的组合（虽然很繁琐），但是远程仓库历史将变得十分整洁，并且能清楚地体现<strong>提交顺序</strong>。</p><p><img src="/img/blog/Git-Note-3-images/git-push-2.png" alt="分叉的第二种解决方案"></p><h3 id="Push-的参数"><a href="#Push-的参数" class="headerlink" title="Push 的参数"></a>Push 的参数</h3><p>上文介绍了最简单的 Push 命令，但这个命令看似简单，实际上却是最「模糊」的，很容易出现报错。完整的 Push 指令应该是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;  <span class="hljs-comment"># 冒号前后无空格</span><br><span class="hljs-comment"># 例如：</span><br>$ git push origin main:<span class="hljs-built_in">test</span>  <span class="hljs-comment"># 将本地 main 推送到 origin 的 test</span><br></code></pre></td></tr></table></figure><p>这个命令显式地指出了<strong>远程仓库名</strong>，如果只关联了一个远程，这个参数就可以<strong>缺省</strong>。但是如果关联了多个仓库（如 GitHub 和 Gitee），则必须用这个参数指明。使用 <code>git remote -v</code> 命令可以查看关联的远程仓库。</p><p>此外，它还指出了本地分支及其映射的<strong>上游分支</strong>，该命令可以用于不同名分支的推送，但实际工程中我们倾向于用本地远程<strong>同名分支</strong>（避免分歧），因此命令可以简化为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin <span class="hljs-built_in">test</span>  <span class="hljs-comment"># 将本地 test 推送到 origin 的 test</span><br></code></pre></td></tr></table></figure><p>但是，如果远程仓库 origin 没有一个同名的 test 分支，又会报错，此时我们需要为 test 建立上游分支，并将其<strong>跟踪绑定</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push --set-upstream origin <span class="hljs-built_in">test</span> <span class="hljs-comment"># 推送同时绑定上游分支</span><br>$ git push -u origin <span class="hljs-built_in">test</span>  <span class="hljs-comment"># 参数 -u 为上述命令的缩写</span><br></code></pre></td></tr></table></figure><p>注意，一次 Push 默认<strong>只推送一个分支</strong>，因此如果<strong>不加分支名</strong>，会默认推送当前 HEAD 所在的分支。因此指令还可以逐步缺省：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push -u origin  <span class="hljs-comment"># 表示将 当前分支 推送并绑定 到 &lt;origin&gt;/同名上游分支</span><br>$ git push origin  <span class="hljs-comment"># 表示将 当前分支 推送 到 &lt;origin&gt;/同名上游分支（需先绑定)</span><br>$ git push  <span class="hljs-comment"># 表示将 当前分支 推送 到 &lt;s远程&gt;/同名分支（需先绑定且有权限)</span><br></code></pre></td></tr></table></figure><p>最后一条指令就是我们最早提及的推送命令，它需要满足：</p><ol><li>只有一个远程仓库；或者有多个仓库，但用 <code>-u</code> 绑定其中一个。</li><li>只有一条分支；或者有多条分支，但当前分支与上游分支同名并绑定。</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习笔记 #2 本地仓库使用</title>
    <link href="/Git-Note-2.html"/>
    <url>/Git-Note-2.html</url>
    
    <content type="html"><![CDATA[<p>接上文，本文在命令行的基础上介绍了常用指令的在<strong>本地的使用情景</strong>。</p><p>本文大部分内容参考了 RCY 同学的教程，部分参考了 <a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰教程-Git</a>，<a href="https://www.runoob.com/git/git-tutorial.html">菜鸟教程-Git</a>，以及 Git 官网文档 <a href="https://git-scm.com/doc">Git-Documentation</a>。</p><h2 id="本地的-Git"><a href="#本地的-Git" class="headerlink" title="本地的 Git"></a>本地的 Git</h2><h3 id="预先准备"><a href="#预先准备" class="headerlink" title="预先准备"></a>预先准备</h3><p>在正式的操作前，你需要先配置你的用户信息，这件事情通常在你的机器上只需要干一次即可，因为我们使用了全局配置。在任意⼀个目录打开你的终端，配置你的用户名和邮箱：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global user.name &lt;username&gt; <span class="hljs-comment"># 替换为 GitHub 用户名</span><br>$ git config --global user.email &lt;email&gt;   <span class="hljs-comment"># 替换为绑定的邮箱</span><br><span class="hljs-comment"># username 中如果有空格，需要加双引号</span><br></code></pre></td></tr></table></figure><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>在想用 Git 管理的项目路径下右键进入 Bash 终端，然后将当前目录<strong>初始化</strong>为 Git 仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git init<br></code></pre></td></tr></table></figure><p>手动新建一个文件，随便写点什么，譬如一个 hello.md，此时文件存在于工作区。下面将其跟踪并提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add hello.md      <span class="hljs-comment"># 如果有更多文件，也可直接追加在后面</span><br>$ git commit -m <span class="hljs-string">&quot;Init&quot;</span>  <span class="hljs-comment"># -m: 表示 message，备注本次提交信息</span><br></code></pre></td></tr></table></figure><p>注意到，add  后面是<strong>文件名</strong>，也可以是<strong>目录</strong>、<strong>通配符</strong>，因此也支持以下写法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add .          <span class="hljs-comment"># 相对路径中 . 表示当前目录，因此这一选项会添加当前目录下所有文件</span><br>$ git add *.cpp   <span class="hljs-comment"># * 代表任意字符串，所有 .cpp后缀的文件被添加</span><br>$ git add <span class="hljs-built_in">test</span>?.cpp  <span class="hljs-comment"># ? 代表单个字符，不得为空，因此如 test1.cpp 将被添加，而 test.cpp 等不会</span><br>$ git add dir/   <span class="hljs-comment"># 添加路径下的 d 文件夹内全部文件， / 有没有皆可</span><br></code></pre></td></tr></table></figure><p>此外，为了体现三个区，我们可以使用一些指令来对比：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git status         <span class="hljs-comment"># 查看工作区、暂存区的文件，一般前者是红色，后者是绿色</span><br>$ git diff           <span class="hljs-comment"># 查看工作区和暂存区的差异，适用于暂存后又修改的内容</span><br>$ git diff --cached  <span class="hljs-comment"># 查看暂存区与 Git 仓库的差异，适用于提交前查看</span><br>$ git diff HEAD      <span class="hljs-comment"># 同时查看其他两个区和 Git 仓库的差异</span><br></code></pre></td></tr></table></figure><p><img src="/img/blog/Git-Note-2-images/git-diff.jpg" alt="Diff用法图解"></p><blockquote><p>在工程中，通常我们不用命令行查看差异，而是用 VSCode、GitHub Desktop、GitLab 等可视化工具。</p></blockquote><p>如果对于已暂存的文件后悔了，也可以取消暂存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reset &lt;filename&gt;  <span class="hljs-comment"># 对于该命令，如果不带参数则会清空暂存区</span><br>$ git restore --stage &lt;filename&gt;<br></code></pre></td></tr></table></figure><p>在完成了几次提交后，可以查看提交历史：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>提交历史中，每个提交记录都有对应的 commit hash 值，唯一标识了这次提交，这是 Git 用 <code>SHA-1 hash</code> 生成的加密字符串。</p><p>注：如果 log 比较长或者窗口比较小，这会触发「<strong>导航</strong>」模式，很多人第⼀次见到可能不知所措，不会退出该页面，此时可以：</p><ul><li>上下键移动或 Page Up / Down 翻页；</li><li>输入 <code>\</code> 接字符来全局查找 ；</li><li>输入 <code>q</code> 退出，与其他系统中的导航模式类似；</li><li>其他操作可以通过查询关键字「Linux less 导航」来查到。</li></ul><h2 id="分支-Branch"><a href="#分支-Branch" class="headerlink" title="分支 (Branch)"></a>分支 (Branch)</h2><p>有了前面的知识，我们已经在脑海中想象⼀副快照变更图了，本节中我们将快照称作「<strong>结点</strong>」，若干结点组织成了<strong>版本树</strong>——Git 本身正是使用了红黑树对结点进行高效管理。</p><blockquote><p>以下内容强烈推荐结合 <a href="https://learngitbranching.js.org/?locale=zh_CN">Git 分支在线教程</a> 来学习！</p></blockquote><p>目前我们的结点树基本是串行的（除了回退、重新提交会导致<strong>分叉</strong>），那么所谓的并行开发如何体现呢？</p><p>注意到了反复有⼀个单词 main 出现在命令行，这即是 Git 默认的分支：<strong>主分支</strong>（旧版本叫 master）。main 即是这个分支的名字，也是一个<strong>指针</strong>，指向了该分支的最新结点。</p><p>和它⼀起的还有⼀个单词 HEAD，这表示<strong>头指针</strong>，指向<strong>当前所处</strong>的结点。在你做分支相关的操作前，会有 <code>HEAD -&gt; main -&gt; 最新结点</code>，直到你将它们分开。</p><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>与初始化仓库类似，创建分支也很方便：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch <span class="hljs-built_in">test</span>  <span class="hljs-comment"># 创建⼀个名为 test 的分⽀</span><br></code></pre></td></tr></table></figure><p>注意：创建完后分支的即会指向当前所在的结点，因此当前最新结点同时被 main、test、HEAD 指向，即 <code>HEAD -&gt; main(test) -&gt; 最新结点</code>。</p><p>对于已有的分支，也可以通过以下命令查看、切换：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch <span class="hljs-comment"># 查看本地分支，带 * 的为 HEAD 指向的当前分支</span><br>$ git checkout <span class="hljs-built_in">test</span>  <span class="hljs-comment"># 检出，表示切换到 test 分支</span><br><br><span class="hljs-comment"># 上述的创建、切换操作也可以被缩减为一步操作</span><br>$ git checkout -b <span class="hljs-built_in">test</span> <span class="hljs-comment"># 创建⼀个名为 test 的分⽀并且切换过去</span><br></code></pre></td></tr></table></figure><p>切换分支后，可以看到出现在命令行右侧的 main 已经变成了 test。查看 log 也可发现 <code>HEAD -&gt; test(main) -&gt; 最新结点</code>。</p><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>如果此时我们已经在不同的分支提交了不同修改 C2 和 C3，那么如何将分支合并到一起，使得并行开发结果汇总呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout main  <span class="hljs-comment"># 切换到 main 分⽀</span><br>$ git merge <span class="hljs-built_in">test</span>     <span class="hljs-comment"># 让 main 分⽀合并 test 分⽀的结点</span><br></code></pre></td></tr></table></figure><p>对于分支的合并，Git 有专门的<strong>图形化输出</strong>命令来进行查看版本树（也可以用其他可视化工具）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --graph --oneline --all<br><span class="hljs-comment"># oneline 表示用行来显示记录，最上方的是最新的提交</span><br><span class="hljs-comment"># all 表示显示所有分支，如果没有则只显示当前分支及其祖先</span><br><br><span class="hljs-comment"># 当然，还有其他许多参数可以美化版本树，这里贴一个大神的版本</span><br>$ git <span class="hljs-built_in">log</span> --graph --all --pretty=format:<span class="hljs-string">&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27;</span> --abbrev-commit --date=relative<br></code></pre></td></tr></table></figure><p>为展示方便，这里使用在线教程里的图例：</p><p><img src="/img/blog/Git-Note-2-images/git-merge-1.png" alt="main分支合并test分支"></p><p>可以看到，合并后产生了一个新结点 C4，该结点具有<strong>双父结点</strong>，指向原来的 C2 和 C3。需要注意的是，该结点属于 main 分支，是 main 分支的最新结点（被指针 main 所指），而 test 仍指向旧的 C2。</p><p>如果要把 test 分支也<strong>同步</strong>到新结点，只需要让 test 分支合并 C4，也就是合并<strong>当前</strong>的 main 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout <span class="hljs-built_in">test</span>  <span class="hljs-comment"># 切换到 test 分⽀</span><br>$ git merge main     <span class="hljs-comment"># 让 test 分⽀合并 main 分⽀的结点</span><br></code></pre></td></tr></table></figure><p>而由于 main 分支的最新结点 C4 继承自 C2，此时的 Git 不会有任何操作，只是简单地将指针 test 移动到指针 main 所在位置，即<strong>快速前移</strong>（fast-forward）：</p><p><img src="/img/blog/Git-Note-2-images/git-merge-2.png" alt="test分支合并main分支"></p><blockquote><p>多数情况下，我们会先用<strong>主分支合并从分支</strong>，如果之后需要再从分支继续开发，才会把<strong>从分支快速前移</strong>！</p></blockquote><h3 id="冲突的合并"><a href="#冲突的合并" class="headerlink" title="冲突的合并"></a>冲突的合并</h3><p>如果 C2 和 C3 修改的代码不在同一文件的同一处，上述的 merge 是没有问题的，但是一旦发生冲突，<code>git merge test</code> 命令时就会提示错误。</p><p>此时如果我们用 <code>git status</code> 查看，会发现<strong>工作区</strong>里有一个新的状态「<strong>未合并的路径</strong>」，里面就是冲突的文件。打开该文件，会发现 Git 已经在里面标记出了双方修改的内容（用 VSCode 等 IDE 将看得更清楚）。</p><p>而我们只需要<strong>手动维护</strong>冲突，将该文件手动加入暂存区，最后再提交，就会生成一个新的结点，该结点无异于直接使用 <code>git merge test</code> 命令得到的。</p><h3 id="变基-Rebase"><a href="#变基-Rebase" class="headerlink" title="变基 (Rebase)"></a>变基 (Rebase)</h3><p>一个来回穿插的版本树是有点凌乱的，此时不得不提到第二种合并分支的办法：变基 (rebase) 操作。Rebase 实际上就是取出<strong>从分支</strong>的提交记录，「<strong>复制</strong>」它们，然后在<strong>主分支</strong>逐个的放下去。</p><p>Rebase 的优势就是可以创造更<strong>线性</strong>的提交历史。如果两个分支没有冲突，如上文提到的第一种情况，直接 Merge 会出现一个新的结点（实际上该结点并没有做出实质的修改，反而使版本树变得冗长）。</p><p>此时如果我们用 Rebase 操作，则可以简化版本树：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout <span class="hljs-built_in">test</span>  <span class="hljs-comment"># 切换到 test 分⽀</span><br>$ git rebase main    <span class="hljs-comment"># 让 test 分⽀以 main 为基，因此 test 成为 main 的后代</span><br></code></pre></td></tr></table></figure><blockquote><p>注意，Rebase 操作通常是让<strong>从分支变基到主分支</strong>，这与 Merge 操作是相反的！</p></blockquote><p><img src="/img/blog/Git-Note-2-images/git-rebase.png" alt="test分支变基到main"></p><p>观察该图，我们可以发现 test 分支上的工作在 main 的最顶端，同时我们也得到了一个更线性的提交序列。</p><p>而提交记录 C2 依然存在（树上那个半透明的节点），而 C2’ 是我们 Rebase 到 main 分支上的 C2 的副本，它们具有不同的 hash 值，可以通过 log 查看。</p><p>之后我们也可以通过类似的操作，把 main <strong>快速前移</strong>到最新的结点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout main  <span class="hljs-comment"># 切换到 main 分⽀</span><br>$ git rebase <span class="hljs-built_in">test</span>    <span class="hljs-comment"># 让 main 分⽀以 test 为基，快速前移</span><br><span class="hljs-comment"># 当然，z也可以用前面的 merge 操作</span><br></code></pre></td></tr></table></figure><blockquote><p>Rebase 操作在没有冲突时将非常舒适，可以避免没有意义的合并结点（尤其是涉及到远程仓库时），但是一旦发生了<strong>冲突</strong>，操作将十分繁琐！这里不再赘述，具体工程中如果遇到了请根据 Git 的自动提示逐步操作。</p></blockquote><p>而对于 Rebase 后的从分支上的结点，就变成了所谓的「<strong>悬垂结点</strong>」，这些结点的访问将十分复杂。此外，如果这个从分支被<strong>废弃</strong>，我们也可以用以下指令将其删去：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -d <span class="hljs-built_in">test</span>  <span class="hljs-comment"># 删除名为 test 的分⽀，用于合并后废弃的分支</span><br></code></pre></td></tr></table></figure><h2 id="分叉-Branch-Diverged"><a href="#分叉-Branch-Diverged" class="headerlink" title="分叉 (Branch Diverged)"></a>分叉 (Branch Diverged)</h2><p>分叉是分支的一种特殊情况，往往是因为某些「不友好」操作而产生，最终被废弃掉。对于<strong>单人操作</strong>的仓库，其产生原因可能是：</p><ul><li>Reset 后旧分支：版本回退后重新提交，这种情况下往往是要弃用旧分支。但如果旧的分支仍有需要保留的更改，则需要 Cherry-Pick 等操作。</li><li>Rebase 后从分支：上文介绍到，Rebase 将创造更线性的主分支，但这样做的代价是从分支将被废弃，成为一个无用的分叉。</li></ul><p>上述情形的发生往往可以人为进行控制，而对于<strong>多人操作</strong>的仓库，如果不同开发者同时对一个结点进行了更改，将会造成「不可控」的分叉，具体情形及解决方法将在下一节介绍。</p>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习笔记 #1 基础知识介绍</title>
    <link href="/Git-Note-1.html"/>
    <url>/Git-Note-1.html</url>
    
    <content type="html"><![CDATA[<p>无意中发现了清华贵系科协的暑培项目，内容都十分贴合计算机系学生的学习需求，正好下学期有「软件工程」课，就决定先把 Git 入门了。</p><p>本文大部分内容参考了 RCY 同学的教程，部分参考了 <a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰教程-Git</a>，<a href="https://www.runoob.com/git/git-tutorial.html">菜鸟教程-Git</a>，以及 Git 官网文档 <a href="https://git-scm.com/doc">Git-Documentation</a>。</p><h2 id="版本控制软件"><a href="#版本控制软件" class="headerlink" title="版本控制软件"></a>版本控制软件</h2><p>版本控制是合作开发、工程项目中必要的手段，考虑以下情况：</p><ul><li>需求模糊：不得不准备两种方案。</li><li>伟大尝试：如果尝试失败，可以回到旧的版本。</li><li>组员弃坑：删除掉难以开发的代码。</li><li>并行开发：需要合并代码时，人工比对容易遗漏。</li></ul><p>为了让这样繁琐的工作自动化，就有了以下的工具：</p><ul><li>Git：行业内最为流行的版本控制软件，采用<strong>分布式</strong>。</li><li>SVN(Subversion)：较早期的版本控制软件，采用<strong>集中式</strong>。</li></ul><h2 id="关于-Git"><a href="#关于-Git" class="headerlink" title="关于 Git"></a>关于 Git</h2><p>事实上，Git 仅在过去十年里，就以极快地速度占据了市场。与 SVN 的集中式不同的是，Git 采用的分布式，除了少数的交互步骤外，版本控制操作、历史记录都在本地，这保证了它极高的操作效率。</p><blockquote><p>所谓集中式， 即所有人都把代码放到一个远程的服务器，要写代码时将远程资源拉取到本地，用一个同一的仓库来实现协同。</p><p>所谓分布式，即每个人都有自己的仓库，每个仓库都可能存放着最新的代码，需要修改时直接在本地修改（即使断网），需要同步时再与远程仓库交互。</p></blockquote><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>多数版本控制软件是基于<strong>差异</strong>的控制，即不同版本间记录的是文本的「<strong>变化</strong>」，版本切换时再根据 delta 前进和后退。</p><p><img src="/img/blog/Git-Note-1-images/deltas.png" alt="Delta-based"></p><p>而 Git 采用的是「<strong>快照</strong>」的方法，对每个版本记录全部文件快照并建立索引（特别地，没有变动的文件只是创建一个<strong>链接</strong>指向之前的快照）。</p><p><img src="/img/blog/Git-Note-1-images/snapshots.png" alt="Snapshot-based"></p><p>这样做的好处是，Git <strong>切换版本和分支</strong>的速度远快于第一种模式。因为 Delta-based 模式下，切换版本相当于一个线性遍历的过程，而 Git 相当于是在文件系统层面做了一个哈希索引。</p><p>此外，快照并不是以整个文件为单位的，否则修改一行就需要增量整个文件的大小，在 Git 中是以<strong>行</strong>为单位进行 diff 的。因此对于二进制文件，Git 的功能就相对较差。</p><h3 id="基本状态"><a href="#基本状态" class="headerlink" title="基本状态"></a>基本状态</h3><p>Git 中用三个状态来区分文件，生成版本：</p><ul><li>已修改 (modified)：你的文件<strong>修改</strong>了，但是没和 Git 发生关系，如同没有 Git 存在⼀般。</li><li>已暂存 (staged)：已修改文件被<strong>标记</strong>后的状态，下次提交 (commit) 时将为它生成快照，多数情况下处于暂存态后紧接着便被提交。</li><li>已提交 (committed)：已经安全地保存到<strong>本地数据库</strong>的数据，通常来说不手动清理则不会丢失。</li></ul><p>这三个状态对应到了 Git 的三个区域：工作区、暂存区、Git 仓库：</p><p><img src="/img/blog/Git-Note-1-images/areas.png" alt="三个区域"></p><p>如果修改了一个已暂存的文件，它会同时出现在工作区和暂存区两个区域，此时可以选择<strong>再次暂存</strong>，覆盖掉暂存区的文件；也可以选择<strong>恢复工作</strong>，撤销后来的修改，覆盖掉工作区的文件（但暂存区的仍然保留）。</p><p>因此，我们可以对这三个区域加以定义：</p><ul><li>工作区是可以直接看到的文件，包括已修改和未修改；</li><li>暂存区本身是个文件，记录了下次要提交（快照）的文件列表信息；</li><li>Git 仓库包含了数据库、元数据等，是 Git 最重要的部分，它的全部数据存储在项目根目录的 .git 路径下，其大小甚至会超过其他文件之和。</li></ul><h2 id="使用-Git"><a href="#使用-Git" class="headerlink" title="使用 Git"></a>使用 Git</h2><p>在官网的文档中有详细的介绍，这里仅介绍部分常用内容。</p><h3 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h3><p>Git 同时提供了 GUI 和 Bash 的操作方式，但图形界面功能不够齐全，同时容易误触造成无法逆转的文件改动。</p><p>使用命令行界面 (Command Line Interface) 意味着：</p><ul><li>几乎放弃鼠标功效，最大化键盘作用；</li><li>放弃炫酷的界面显示，用文本配合着色传递信息；</li><li>你所学的操作到了服务器上仍然能流畅使用。</li></ul><p>对 Windows 而言，cmd 、Power Shell、WSL、Git 都可以提供命令行界面，为了执行下列 Git 指令，需要使用 Git 提供的终端，在文件夹中右键选中 <code>Git Bash Here</code> 即可。</p><p>关于命令行界面，有这些常用快捷键：</p><ul><li><code>Tab</code>：实现对命令、参数或文件的内容补全。</li><li><code>Ctrl+C</code>：终止当前进程的运行，重获终端的控制权。</li><li><code>Ctrl+D</code>：结束键盘输入，即退出终端，相当于输入 <code>exit()</code>。</li><li><code>Ctrl+I</code>：清空当前终端中已有的内容，相当于输入 <code>clear</code>。</li><li><code>&lt;上下键&gt;</code>：翻看使用过的命令记录。</li><li><code>Shift+PgUp/PgDn</code>：翻页终端。</li><li><p><code>Ctrl/Shift+Ins</code> ：复制粘贴文本，有的系统下可用 <code>Ctrl+Shift+C/V</code>。</p></li><li><p><code>‘’</code> 和 <code>“”</code>：命令是以空格来作为间隔符的，参数中若存在空格，必须用<strong>引号</strong>括起来。</p></li></ul><p>一些在 Git 使用中会用到的 Shell 命令有：</p><ul><li><code>ls</code>：List，罗列当前文件夹下的<strong>文件和下级文件夹</strong>，并且会用颜色区分二者，如果用 <code>dir</code> 目录命令则无区分。</li><li><code>cd</code>：Change Directory，<strong>改变目录</strong>，这里再介绍一下路径的表示：<ul><li><code>.</code> 代表当前目录，也可代表当前目录下所有文件。</li><li><code>..</code> 代表上级目录，<code>cd ..</code> 即回退上级。</li><li><code>/</code> 代表盘符根目录，<code>cd /</code> 即切换到根目录。</li><li>输入当前目录下的文件夹名，即可进入该文件夹，可以用 <code>Tab</code> 补全。</li></ul></li><li><code>mkdir</code>：Make Directory，在当前目录下<strong>新建文件夹</strong>。</li><li><code>touch</code>：<strong>新建空文件</strong>或改变已有文件的时间戳属性。</li><li><code>echo</code>：Echo Protocol（应答协议），强制显示文字，直接使用会将字符串显示在终端。<ul><li>利用该命令也可新建文件，如：<code>echo ‘test’ &gt; 1.txt</code>，强制输出内容到一个记事本文件，如果没有该文件则强制创建一个。</li><li>此外，新建文件还可以用其他<strong>重定向</strong>命令辅助完成，如<code>cd . &gt; 1.txt</code>，<code>type NUL &gt; 1.txt</code>，<code>copy NUL &gt; 1.txt</code>。</li></ul></li></ul><h3 id="Git-基本指令"><a href="#Git-基本指令" class="headerlink" title="Git 基本指令"></a>Git 基本指令</h3><p>这里先列举一些基本指令，它们的使用格式基本都是 <code>git &lt;instruction&gt; &lt;other-params-if-needed&gt;</code> 。以下列举的都是 <code>&lt;instruction&gt;</code> 项，对应的参数在后面介绍。</p><p>本地基本操作：</p><ul><li><code>init</code>：告诉 Git 你要让它接管这个文件夹。</li><li><code>config</code>：做相关配置，告诉 Git 你是谁。</li><li><code>add</code>：文件从<strong>工作区</strong>转到<strong>暂存区</strong>，即「跟踪」。</li><li><code>commit</code>：文件从<strong>暂存区</strong>转到 Git <strong>仓库</strong>，即「提交」。</li></ul><p>远程基本操作：</p><ul><li><code>clone</code>：克隆远程仓库到本地。</li><li><code>push</code>：本地数据库同步到远程，即「推送」。</li><li><code>pull</code>：远程数据库同步到本地，即「拉取」。</li></ul><p>分支操作：</p><ul><li><code>branch</code>：分支基本操作。</li><li><code>checkout</code>：分支、版本的切换。</li></ul><p>状态切换：</p><ul><li><code>stash</code>：⼀个栈式额外存储区。</li><li><code>reset</code>：版本回退。</li></ul><p>信息获取：</p><ul><li><code>log</code>：查看记录。</li><li><code>reflog</code>：查看操作记录（常用于 reset 后撤销操作时寻找版本号）</li><li><code>status</code>：查看<strong>已修改</strong>和<strong>已暂存</strong>的文件。</li><li><code>diff</code>：查看不同 <strong>区/版本</strong> 间的差异。</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数理逻辑 应试笔记</title>
    <link href="/Mathematical-Logic.html"/>
    <url>/Mathematical-Logic.html</url>
    
    <content type="html"><![CDATA[<p>该笔记是本人于哈尔滨工业大学（深圳）2021 年春季学期「数理逻辑」课程的笔记，最终课程成绩是满分。授课教师为任世军，是本部经验丰富的老教师。</p><p>由于笔记是在考前复习时才逐渐整理的，笔记内容偏<strong>应试风格</strong>，标题顺序也是按照哈工大「数理逻辑」课程一贯的出题模板来的，涵盖了课程所学，主要包括：命题逻辑、三大系统中定理的证明、谓词逻辑。</p><h2 id="命题逻辑部分"><a href="#命题逻辑部分" class="headerlink" title="命题逻辑部分"></a>命题逻辑部分</h2><h3 id="求-主-析取-合取范式"><a href="#求-主-析取-合取范式" class="headerlink" title="求(主)析取/合取范式"></a>求(主)析取/合取范式</h3><p>一般会涉及到三个原子命题，唯一方法——列真值表。</p><p>列真值表的顺序可以依照语法分析树。</p><p>主合取看 0，主析取看 1，直接写。列真值表一定要<strong>反复检查细节</strong>。蕴含的前后件不要看反了。</p><h3 id="用完备联结词组表示公式"><a href="#用完备联结词组表示公式" class="headerlink" title="用完备联结词组表示公式"></a>用完备联结词组表示公式</h3><p>通常最终结果要化为与非式、或非式。</p><p>先把原式子中的「蕴含、等价」全换成「与、或、非」。（<strong>可以用等价式化简，但没必要，除非很明显的吸收律</strong>）</p><ul><li><strong>与非</strong>：</li></ul><p>用德摩根律把 $\lor$ 全消掉，再把 $\land$ 用</p><script type="math/tex; mode=display">p\land q\Leftrightarrow \lnot \left( p\uparrow q \right)</script><p>替换，再把所有的 $\lnot$ 用下式替换，注意此时 p 可能是个很长的式子。</p><script type="math/tex; mode=display">\lnot p\Leftrightarrow p\uparrow p</script><ul><li><strong>或非</strong>：</li></ul><p>同理，也是消掉另一个符号，再把或替换了，再替换非。</p><h3 id="判断逻辑蕴含-逻辑等价的正确性"><a href="#判断逻辑蕴含-逻辑等价的正确性" class="headerlink" title="判断逻辑蕴含/逻辑等价的正确性"></a>判断逻辑蕴含/逻辑等价的正确性</h3><ol><li><strong>逻辑蕴含</strong>，一般前提会有多个</li></ol><p>通常做法是，给前提均指派为真，利用公式法，推出一系列公式，然后推得右边的公式的值恒为 1，则<strong>成立</strong>。</p><p>如果推不到右边，可以先假设右边为 0（反证法），推出左边的值可以均为 1，则<strong>不成立</strong>。</p><p><strong>注意</strong>：假设右边为 1 没用，不充分。</p><ol><li><strong>逻辑等价</strong>，一般是一对一，两边都比较长</li></ol><p>理论上可以用<strong>真值表</strong>，但是语法分析树太长了。</p><p>如果可以一眼判断出<strong>不成立</strong>，那么枚举一个反例也行。</p><p>通常做法是，两边利用公式法化简，最后推出的赋值式相等，则对于任意的指派 $v$，都有 $A^v = B^v$，故成立。</p><p>化简过程中，有一些较长的非、蕴含符号可以替换成与非，如：</p><script type="math/tex; mode=display">\begin{aligned}\lnot p\rightarrow q\,\,&\text{换成 } p\lor q\\\lnot \left( p\rightarrow \lnot q \right) \,\,&\text{换成 } p\land q\end{aligned}</script><p>避免列赋值式太长。</p><p>注意：化简到最后可能形式上不相等，这时候可以两个式子<strong>联立消项</strong>，看最后是不是<strong>永真式</strong>，如果不是，同样可以举反例（举反例不好直接想到，因此还是要推理，可以先用 PC 的方法变形看看）。</p><h2 id="PC-中定理的证明"><a href="#PC-中定理的证明" class="headerlink" title="PC 中定理的证明"></a>PC 中定理的证明</h2><p>依次使用以下方法。</p><h3 id="1-逆向推理法（直接法）"><a href="#1-逆向推理法（直接法）" class="headerlink" title="1 逆向推理法（直接法）"></a>1 逆向推理法（直接法）</h3><p>对待证明定理进行等价转化，转变成熟悉的形式。常用工具：</p><ul><li>加前件定理3：去相同前件</li><li>加后件定理4：去相同后件</li><li>逆否转换：四种情况</li><li><p>前件互换定理2：前件移到里面后</p></li><li><p>公理2：提出前件</p></li><li>补前件定理：去单个前件，只需证出后件就可以</li><li>三段论定理8：需要多次加前件、后件时</li></ul><p>例题：</p><ol><li><strong>二难推理</strong>（后面发现用定理18更好做）</li></ol><script type="math/tex; mode=display">\vdash \left( A\rightarrow C \right) \rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( A\lor B \right) \rightarrow C \right) \right)</script><p>观察形式，发现三项都有共同后件 $C$，则三项全取逆否</p><script type="math/tex; mode=display">\left( \lnot C\rightarrow \lnot A \right) \rightarrow \left( \left( \lnot C\rightarrow \lnot B \right) \rightarrow \left( \lnot C\rightarrow \lnot \left( \left( A\lor B \right) \right) \right) \right)</script><p>利用公理 2 及 加前件定理可以去掉前件 $\lnot C$</p><script type="math/tex; mode=display">\lnot A\rightarrow \left( \lnot B\rightarrow \lnot \left( A\lor B \right) \right)</script><p>再用逆否转换，前件互换等定理即可逆向</p><p><strong>类似题</strong>：</p><script type="math/tex; mode=display">\vdash \left( A\rightarrow C \right) \rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( \left( A\rightarrow B \right) \rightarrow B \right) \rightarrow C \right) \right)</script><p>也必须用逆否来做。</p><ol><li><strong>作业题5</strong>（常规做法是演绎定理，其他都很麻烦）</li></ol><script type="math/tex; mode=display">\vdash \left( A\rightarrow \left( B\rightarrow C \right) \right) \rightarrow \left( \left( C\rightarrow D \right) \rightarrow \left( A\rightarrow \left( B\rightarrow D \right) \right) \right)</script><p>先前件互换可使得后件两项都含 $A$</p><script type="math/tex; mode=display">\left( C\rightarrow D \right) \rightarrow \left( \left( A\rightarrow \left( B\rightarrow C \right) \right) \rightarrow \left( A\rightarrow \left( B\rightarrow D \right) \right) \right) \,\,</script><p>发现去掉前件 $A$ 后还可以去掉前件 $B$</p><p>但是再用一次前件互换即可得到定理4的形式</p><script type="math/tex; mode=display">\left( C\rightarrow D \right) \rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( B\rightarrow D \right) \right)</script><ol><li><strong>砍头操作</strong></li></ol><p>砍头操作有两种办法：将</p><script type="math/tex; mode=display">\left( \lnot A\rightarrow B \right) \rightarrow \left( \left( \lnot A\rightarrow \lnot B \right) \rightarrow A \right)</script><p>变成</p><script type="math/tex; mode=display">B\rightarrow \left( \left( \lnot A\rightarrow \lnot B \right) \rightarrow A \right)</script><p><strong>方法一</strong>：先添前件（用公理1再分离）变成</p><script type="math/tex; mode=display">B\rightarrow \left( \left( \lnot A\rightarrow B \right) \rightarrow \left( \left( \lnot A\rightarrow \lnot B \right) \rightarrow A \right) \right)</script><p>再用公理2分离，前件是公理1的形式，后件自然成立，总计要4行</p><p><strong>方法二</strong>：直接用三段论定理8，因为</p><script type="math/tex; mode=display">B\rightarrow \left( \lnot A\rightarrow B \right)</script><p>显然成立，用三段论定理8接上，只需要2行，但是要分条件（有可能不允许使用定理8，如作业题PC1）</p><ol><li><strong>反公理2</strong>（19 年试卷的答案，思路清奇，没用定理18）</li></ol><script type="math/tex; mode=display">\vdash \left( \left( A\rightarrow B \right) \rightarrow \left( A\rightarrow C \right) \right) \rightarrow \left( A\rightarrow \left( B\rightarrow C \right) \right)</script><p>一开始观察三项前件都有 $A$，以为可以用类似二难推理的办法做。</p><p>但是！注意到整体的形式是「两项推一项」，与二难推理不同，因此不能用公理2来提出前件，再去掉前件。</p><p>观察发现，后件 $A\to(B\to C)$ 可以用一次前件互换定理，得到</p><script type="math/tex; mode=display">\vdash \left( \left( A\rightarrow B \right) \rightarrow \left( A\rightarrow C \right) \right) \rightarrow \left( B\rightarrow \left( A\rightarrow C \right) \right)</script><p>此时有共同的后件，可以用加后件定理快速解决。</p><h3 id="2-利用定理18"><a href="#2-利用定理18" class="headerlink" title="2 利用定理18"></a>2 利用定理18</h3><p>定理18证明的简便性和方法1相近，尝试方法1失败后，若形式符合$(A \to B)\to C$，可以考虑定理18</p><p>将原式子拆成 $\lnot A \to C$ 和 $B \to C$ ，再用方法1</p><p>例题：</p><ol><li><strong>反公理2</strong>（书上用演绎定理证明，很简短）</li></ol><script type="math/tex; mode=display">\vdash \left( \left( A\rightarrow B \right) \rightarrow \left( A\rightarrow C \right) \right) \rightarrow \left( A\rightarrow \left( B\rightarrow C \right) \right)</script><p>如果看前两项，想用逆推的方法解决，但是发现加前件定理用不了，因为接不上。直接考虑定理18。</p><ul><li>拆成</li></ul><script type="math/tex; mode=display">\left( A\rightarrow C \right) \rightarrow \left( A\rightarrow \left( B\rightarrow C \right) \right)</script><p>只需前件互换，去掉后件即可证明。</p><ul><li>拆成</li></ul><script type="math/tex; mode=display">\lnot \left( A\rightarrow B \right) \rightarrow \left( A\rightarrow \left( B\rightarrow C \right) \right)</script><p>比较复杂，需要前件互换，<strong>再摘掉 A</strong></p><p>（<strong>注意：这一步可以不需要前件互换，只需用公理1+三段论，直接砍后件头</strong>）</p><p>（<strong>附注</strong>：砍后件头，倒过来书写时其实是加后件头，与前面的砍头操作不同）</p><script type="math/tex; mode=display">\lnot \left( A\rightarrow B \right) \rightarrow \left( B\rightarrow C \right)</script><p>然后再换前件，因为前面的 <strong>$\lnot$ 是在整体上的，必须要和单体进行一次逆否转换</strong></p><script type="math/tex; mode=display">B\rightarrow \left( \lnot \left( A\rightarrow B \right) \rightarrow C \right)</script><p>再对里面做逆否，此时 $\lnot$ 已经转移到单独的 $C$ 上了</p><script type="math/tex; mode=display">B\rightarrow \left( \lnot C\rightarrow \left( A\rightarrow B \right) \right)</script><p>需要前件互换，<strong>再摘掉 $\lnot C$</strong> </p><p>（<strong>注意：这一步可以不需要前件互换，只需用公理1+三段论，直接砍后件头</strong>）</p><ul><li>补充</li></ul><script type="math/tex; mode=display">\lnot \left( A\rightarrow B \right) \rightarrow \left( B\rightarrow C \right)</script><p>前面的 <strong>$\lnot$ 是在整体上的，还有另一种办法可以消去</strong></p><p>因为 $\lnot (A \to B)$ 可以推出 $A$ 或 $\lnot B$ ，利用<strong>三段论</strong>定理可以接上去。</p><p>此题可以用 $\lnot B$，转化后的形式是定理6。</p><ol><li><strong>二难推理</strong></li></ol><script type="math/tex; mode=display">\vdash \left( A\rightarrow C \right) \rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( A\lor B \right) \rightarrow C \right) \right)</script><p>二难推理系列的题目，比思维流更好的办法其实是定理18，并且套路十分明显。</p><ul><li>拆成</li></ul><script type="math/tex; mode=display">\lnot A\rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( A\lor B \right) \rightarrow C \right) \right)</script><p>首先第一部分，由于 $C$ 在后件的两个后件，此时用加后件定理可以轻松消去 $C$。</p><script type="math/tex; mode=display">\lnot A\rightarrow \left( \left( A\lor B \right) \rightarrow B \right)</script><p>再用一次前件互换定理，发现就是定理1。</p><ul><li>（<strong>这一步纯套路，每题都是一样</strong>）拆成</li></ul><script type="math/tex; mode=display">C\rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( A\lor B \right) \rightarrow C \right) \right)</script><p>此时不能直接用加后件了，否则最前面的  $C$ 消不掉。直接前件互换，</p><script type="math/tex; mode=display">\left( B\rightarrow C \right) \rightarrow \left( C\rightarrow \left( \left( A\lor B \right) \rightarrow C \right) \right)</script><p>发现后件是公理1，于是摘掉前件，成立。</p><p><strong>类似题</strong>：</p><script type="math/tex; mode=display">\vdash \left( A\rightarrow C \right) \rightarrow \left( \left( B\rightarrow C \right) \rightarrow \left( \left( \left( A\rightarrow B \right) \rightarrow B \right) \rightarrow C \right) \right)</script><p>也可以用同样的套路秒做。</p><h3 id="3-反证法"><a href="#3-反证法" class="headerlink" title="3 反证法"></a>3 反证法</h3><p>前两种方法都想不出来的情况下考虑，书写过程会相对繁琐。</p><ol><li>基本方法</li></ol><p>假定原定理为0，按照依次将式子标上0和1，直到推出矛盾（一般会有多处，找容易的）。</p><p>证明时显而易见的（前几条）可以不用加注释，可以理解成真值表的体现。</p><p>后面的推理过程可以按标0和1的顺序来，通常都是由大后件的结论往前件找矛盾。</p><p><strong>最常使用：三段论定理</strong>，用于把 $\lnot P$ 接上去，最后才能转到矛盾。</p><ol><li>推演技巧</li></ol><p>最无脑的方法是把所有单项都用 $\lnot P$ 推出来，再进行排列组合出矛盾。</p><p>高级的方法是抓住「<strong>矛盾块</strong>」（通常是原式的一端），再把「<strong>另一个矛盾块</strong>」通过逆向推理法（直接法）证到原式的另一端，即可。</p><h3 id="4-演绎定理"><a href="#4-演绎定理" class="headerlink" title="4 演绎定理"></a>4 演绎定理</h3><p>没啥好说的，一般不给用，对三个以上变量比较友好，提取出所有前件后就可以用直接法证明。</p><h2 id="ND-中定理的证明"><a href="#ND-中定理的证明" class="headerlink" title="ND 中定理的证明"></a>ND 中定理的证明</h2><h3 id="思维流"><a href="#思维流" class="headerlink" title="思维流"></a>思维流</h3><p>本质是<strong>逆向推理法</strong>，逆推的同时可以注意左端项的逻辑规律（赋1，看矛盾）</p><p>结合常见形式及解决套路可以更快解决。</p><ol><li><strong>当右端项包含 $\lnot$ 时：</strong></li></ol><script type="math/tex; mode=display">\lnot A\land \lnot B\vdash \lnot \left( A\lor B \right)</script><p>用 $\lnot +$ 规则把右端项挪到左边时，要导出矛盾，往往这个矛盾是右端项的<strong>部分</strong>，如析取、合取的部分。</p><p>此时的惯常做法是将这两个矛盾合取，如 $A\land \lnot A$ ，这个式子必定为0，事实上左边此时的两个式子已经自相矛盾。</p><p>当然不一定要用 $A\land \lnot A$，因为左边矛盾的情况下，赋1可以推出很多对矛盾，只是这个最常见。</p><ol><li><strong>当左端项有 $\lor$ 时：</strong></li></ol><script type="math/tex; mode=display">\lnot A\lor \lnot B\vdash \lnot \left( A\land B \right)</script><p>充分利用析取，将其两项分别放到左端，用 $\in$ 规则把两项先推出来。</p><p>左端多出来的两项最终也需要消去。</p><ul><li>这就需要 $\lor-$ 规则，因此上面推出来的两式要最后导出到同一个目标，通常是$A\land \lnot A$，这类式子。</li><li>也有可能是需要 $\to +$ 规则，把小项拿到右边当前件。</li></ul><p><strong>注意</strong>：如果 $\lor$ 是含在某个大的式子里，也可以将小项直接拿到外面来推。</p><ol><li><strong>当右端项有 $\lor$ 时：</strong></li></ol><script type="math/tex; mode=display">\lnot \left( A\land B \right) \vdash \lnot A\lor \lnot B</script><p>一般可以用 $\lor -$ 简化，只需证一半，但是保留哪一半要根据左边的情况推理，即思维流。</p><p>但有时也不能上来就简化，因为左边的条件可能太宽泛了（太少了），因此可能要加上一些小项再看。</p><p>这时候常用的是 $-$ 规则。这也是最难用的一个规则。</p><ol><li><strong>当左端项有 $\land$ 时：</strong></li></ol><script type="math/tex; mode=display">A\land \left( {B}\lor {C} \right) \vdash \left( {A}\land {B} \right) \lor \left( {A}\land {C} \right)</script><p>利用 $\land -$ 规则，将两个子命题拆出来。</p><p>当然不能白拆，要和前几条综合起来用，往往时加入了很多项后，用这个来助攻。</p><ol><li><strong>当右端项有 $\land$ 时：</strong></li></ol><p>可能是要把两个细分都推出来。</p><script type="math/tex; mode=display">\lnot \left( {A}\lor {B} \right) \vdash \lnot {A}\land \lnot {B}</script><p>也可能是要整个推出，即生成未出现过的项，常用 $\lor-$ 规则。</p><script type="math/tex; mode=display">\left( A\land {B} \right) \lor \left( {A}\land {C} \right) \vdash {A}\land \left( {B}\lor {C} \right)</script><ol><li><strong>在右端生成从未出现过的项：</strong></li></ol><p>常用 $\lor-$ 规则，但是这种必须有理有据的推出，而且左端要含 $\lor$。</p><p>另一个方法是 $\lnot -$，矛盾可以推任意。</p><ul><li>通常的用法是：</li></ul><script type="math/tex; mode=display">\begin{aligned}XXX, A, \lnot A&\vdash A\\XXX, A, \lnot A&\vdash \lnot A\\XXX, A, \lnot A&\vdash B\end{aligned}</script><ul><li>然后再想办法消掉多出来的单项，如</li></ul><script type="math/tex; mode=display">XXX, \lnot A\vdash A\rightarrow B</script><ul><li>或者再利用 $\lor-$ ，二者结合，如</li></ul><script type="math/tex; mode=display">\begin{aligned}XXX, A, \lnot A&\vdash B\\XXX, A, B&\vdash B\\XXX, A&\vdash \lnot A\lor B\\XXX, A&\vdash B\end{aligned}</script><p>例：（需要用到两种引入方法）</p><script type="math/tex; mode=display">\left( A\lor B \right) \land \left( \lnot B\lor C \right) \vdash A\lor C</script><p>按照思维流推断，发现最开始可以引入 $B$，$\lnot B$ 的矛盾推任意。</p><p>而右端项的析取，一次只能推一半。</p><p>推一半的时候，还是需要引入新项，此时用 $\lor-$ ，因为左端项还有个析取（隐藏在合取中）可以用，将两个子项单独拿出来放到左边，即可推出。</p><ol><li><strong>当左端项有 $\to$ 时：</strong></li></ol><p>由于ND中没有分离规则，所以要利用好这个 $\to$ 需要先在左端加上前件，用两次 $\in$ 规则。</p><p>最后再用 $\to -$ 规则把后件推到右端。 </p><ol><li><strong>当左端项包含 $\lnot$ 时：</strong></li></ol><script type="math/tex; mode=display">\lnot ( A\to B ) \vdash A\land \lnot B</script><p>想按照逻辑推出东西基本不可能，最好的办法是利用已有的一个 $\lnot$ ，制造矛盾，使得矛盾可以推任意，或者 $\lnot +$。</p><p>但是如果要制造矛盾，必须引入新的变量，这样左边就会多一个元素，即使 $\lnot -$ 推出了任意，但左边也不符合。</p><p>因此可以用 $\lnot +$ 规则，在左边引入一个<strong>待求右端项</strong>的 $\lnot$ ，推出矛盾后再用反证法把<strong>待求变量</strong>移到右边，此时可能要用 $\lnot \lnot-$ 规则。</p><h2 id="FC-中定理的证明"><a href="#FC-中定理的证明" class="headerlink" title="FC 中定理的证明"></a>FC 中定理的证明</h2><h3 id="两种书写格式"><a href="#两种书写格式" class="headerlink" title="两种书写格式"></a>两种书写格式</h3><ol><li><p>用 PC 中的公式序列，最后再补上 $\Gamma$ ，不用序号，用「<strong>从而</strong>…」连接结论。</p><p>常用于 <strong>FC 反证法定理8</strong>、<strong>双向证明</strong>（先证后证）</p></li><li><p>用 ND 中的演绎序列，直接证出结果（书写内容多），如果此时<strong>要用 PC 或者 FC 的定理</strong>，需要在公式前面写 $\vdash$，并在下一条用分离规则导出（<strong>注意</strong>：不用写用若干次 $+$ 规则）。 </p><p>常用于 <strong>FC 存在消除定理10</strong></p></li></ol><p>具体证明过程依次使用以下方法。</p><h3 id="存在消除定理"><a href="#存在消除定理" class="headerlink" title="存在消除定理"></a>存在消除定理</h3><p>当式子左端有 $\exists xA$ 或 $\exists x(A\to B)$ 的量词时，优先考虑用存在消除定理10。</p><p>在左端补上 $A$ 或 $(A\to B)$ ，并用 ND 中的规则推出想要的右端项。</p><p>接着就可以用存在消除定理把左端补上的东西消除了。</p><script type="math/tex; mode=display">\begin{aligned}&\left( 1 \right) \exists v\left( B\rightarrow A \right) , B\rightarrow A, B\vdash A\\&\left( 2 \right) \exists v\left( B\rightarrow A \right) , B\vdash \exists v\left( B\rightarrow A \right) \\&\left( 3 \right) \exists v\left( B\rightarrow A \right) , B\vdash A\,\,\end{aligned}</script><p><strong>注意</strong>：虽说「存在」消除定理，但是最后消掉的是 $\exists x$ 里面的东西。</p><p><strong>警告</strong>：使用该方法时，(3) 式中左右端项都不能有 $v$ 的自由出现！</p><h3 id="反证法定理"><a href="#反证法定理" class="headerlink" title="反证法定理"></a>反证法定理</h3><p>反证法不一定是最优解，但是是最 FC 的做法，一般标准答案会用。当右端的整体上有个 $\lnot$ 打头，或者右端有个 $\exists x$ 时，建议使用。</p><script type="math/tex; mode=display">\begin{aligned}&\text{从而}\varGamma \vdash A\,\,\text{且} \varGamma \vdash \lnot A\\&\text{从而公式集}\varGamma \text{不一致，由}FC\text{反证法定理}8\\&\text{得}\forall vB\rightarrow A\vdash \lnot \forall v\lnot \left( B\rightarrow A \right)\end{aligned}</script><p>注意：如果左右都有 $\exists x$，优先用存在消除定理。</p><h3 id="思维流-1"><a href="#思维流-1" class="headerlink" title="思维流"></a>思维流</h3><p>前两种方法都不可以使用的时候考虑，跟 ND 中的证明没啥区别。可能会用到一些 PC 中的定理，如三段论定理8、逆否定理、以及一些小套件（定理6，定理9）。</p><h3 id="其他小技巧"><a href="#其他小技巧" class="headerlink" title="其他小技巧"></a>其他小技巧</h3><ol><li>FC 定理 9 平时用的少，但是有时有妙用。</li></ol><script type="math/tex; mode=display">\begin{aligned}&\left( 1 \right) \exists v\left( B\rightarrow A \right) , B\vdash A\\&\left( 2 \right) \exists v\left( B\rightarrow A \right) , \forall vB\vdash A\end{aligned}</script><ol><li><p>FC 也有<strong>演绎定理</strong>，并且考试中可以<strong>直接使用</strong>。（省步骤，不然就得用 ND 中复杂的规则来代替）</p><p>比如往左放就要用 $(+)$ 再用 $(\to-)$ 规则，往右放就要用 $(\to +)$ 规则。</p></li><li><p>全称推广定理 和 定理1 是互逆的关系，是 PC/ND 系统与 FC 联系的关键。常用于导出待证明式子右端项。</p></li><li><p>补充：使用 FC 定理时，有的定理有限制。</p></li></ol><ul><li>公理4 （项 t 对 v 可代入）</li><li>公理6 （v 在 A 中无自由出现）</li><li><strong>全称推广定理5</strong> （v 在 $\Gamma$ 中无自由出现）</li><li>定理9 （v 在 $\Gamma$ 中无自由出现）</li><li><strong>存在消除定理10</strong> （v 在 $\Gamma$ 和 B 中无自由出现）（在最后一行前后都无自由出现）</li></ul><h2 id="谓词演算部分"><a href="#谓词演算部分" class="headerlink" title="谓词演算部分"></a>谓词演算部分</h2><h3 id="构造语义和指派"><a href="#构造语义和指派" class="headerlink" title="构造语义和指派"></a>构造语义和指派</h3><p>语义就是 $U=<D,I>$ 即论域和解释，其中论域部分令 $D=\{1, 2\}$。</p><p>解释部分 $I$ 要加横杠，分别对常元、函词、谓词做一个映射。<strong>构造时根据要求，巧妙选择</strong>。</p><script type="math/tex; mode=display">\begin{aligned}&\bar{a}=1\\&\bar{f}\left( 1,1 \right) =1,\bar{f}\left( 1,2 \right) =1,\bar{f}\left( 2,1 \right) =1,\bar{f}\left( 2,2 \right) =1\\&\bar{R}=\left\{ 1,2 \right\} ,\bar{P}=\left\{ \left( 1,1 \right) \right\} ,\bar{Q}=\oslash\end{aligned}</script><p><strong>注意</strong>：函词是<strong>个体</strong>映射到<strong>个体</strong>，谓词是取这些<strong>个体</strong>时值为 <strong>True</strong>。<strong>一元谓词跟函词很容易混淆</strong>。</p><p>指派 $s$ 就是给变元取值。</p><script type="math/tex; mode=display">\bar{x}=2,\bar{y}=1</script><p>注意：书写时展开函词的时候，<strong>横杠</strong>都要加上。特别是多层函词时。</p><script type="math/tex; mode=display">\overline{f\left( x,y \right) }=\bar{f}\left( \bar{x},\bar{y} \right)</script><p>判断真假的时候，简单的直接写 T 或 F 就可以（需要横杠），表示映射。</p><p>但是含有<strong>任意、存在量词</strong>的必须用标准写法（不用横杠）<strong>拆去</strong>。</p><script type="math/tex; mode=display">\begin{aligned}&\models _U\left( \forall x \right) P\left( x \right) \left[ s \right] \,\, iff.\models _UP\left( x \right) \left[ s\left( x|1 \right) \right] \,\,\text{且} \models _UP\left( x \right) \left[ s\left( x|2 \right) \right] \\&\models _U\left( \exists x \right) P\left( x \right) \left[ s \right] \,\, iff.\models _UP\left( x \right) \left[ s\left( x|1 \right) \right] \,\,\text{或} \models _UP\left( x \right) \left[ s\left( x|2 \right) \right]\end{aligned}</script><h3 id="构造自然语句的形式化"><a href="#构造自然语句的形式化" class="headerlink" title="构造自然语句的形式化"></a>构造自然语句的形式化</h3><p>格式要注意，在开头要令出谓词、函词，一般不需要论域（除非真的只有一种个体词）。</p><p><strong>每个出现的个体词</strong>都应该有对应的谓词，如「作家」「作品」「小说」「学生」「实数」。</p><p>一个基本原则：$\forall \text{配}\rightarrow \text{，}\exists \text{配}\land $</p><p>常用短语：</p><ul><li>并非所有：$\lnot \forall x$</li><li>有且仅有、唯一：$\exists x\left( R\left( x \right) \land \forall u\left( R\left( u \right) \rightarrow E\left( x, u \right) \right) \right) $</li><li>不是就是、要么要么：$\forall x\left( R\left( x \right) \rightarrow P\left( x \right) \oplus Q\left( x \right) \right) $</li></ul><p>例题：形式化表示第二数学归纳法。</p><script type="math/tex; mode=display">\begin{aligned}&\text{令谓词：}\\&F\left( x \right) \text{表示当}n=x\text{时，命题成立；}\\&L\left( x,k \right) \text{表示}x<k\text{；}\\&P\left( x \right) \text{表示}x\text{是正整数。}\\&\left( 1 \right) F\left( 1 \right) \\&\left( 2 \right) \forall k\left( \left( P\left( k \right) \land \forall x\left( P\left( x \right) \land L\left( x,k \right) \rightarrow F\left( x \right) \right) \right) \rightarrow F\left( k \right) \right) \\&\left( 3 \right) \forall x\left( P\left( x \right) \rightarrow F\left( x \right) \right)\end{aligned}</script>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>本科课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR课程项目-文学检索-开发文档</title>
    <link href="/IR-Project.html"/>
    <url>/IR-Project.html</url>
    
    <content type="html"><![CDATA[<p><img src="/img/blog/IR-Project-images/logo.png" alt="logo" style="zoom: 33%;" /></p><p><code>Date</code>：2021-08</p><p><code>Description</code>：本文档作为 2021 年夏季学期 IR 课程 Project 搜索引擎搭建的开发文档，检索主题为「<strong>文学</strong>」。</p><p><code>Reference</code>：参考自 CHH12 的 <a href="https://gitee.com/CHH12/IR-project-pioneer-search">实现方案</a>，在其基础上改进了算法，适配了现版本工具并完善文档。</p><p><code>Copyleft</code>：© 2021 Hwcoder. Some rights reserved.</p><h2 id="系统说明"><a href="#系统说明" class="headerlink" title="系统说明"></a>系统说明</h2><p>中国文学有数千年悠久历史，以特殊的内容、形式和风格构成了自己的特色，有自己的审美理想，有自己的起支配作用的思想文化传统和理论批判体系，是世界文学宝库中光彩夺目的瑰宝。</p><p>本搜索引擎主要收录了与<strong>中国文学</strong>有关的网页文档，包括但不限于民族文学、宗教文学、语言文学、诗词文学、中国外国文学等，爬取网站均来自中国社科院等官方机构。</p><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p><img src="/img/blog/IR-Project-images/system.png" alt="系统架构"></p><p>本搜索引擎系统主要架构如上图所示。 </p><p>检索的源文档由网络爬虫从给定的种子页面开始爬取，爬取到本地后利用 Python 中的 BeautifulSoup4 模块进行网页的解析，并写入文档数据库中。 之后利用搜索引擎解决方案 Xunsearch（迅搜）构建搜索引擎，利用索引器 Indexer 对文档数据进行索引，并构建基于 Xapian 的后端搜索服务器与前端的搜索应用，向用户展示出搜索功能。 </p><h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h3><h4 id="网络爬虫：Larbin"><a href="#网络爬虫：Larbin" class="headerlink" title="网络爬虫：Larbin"></a>网络爬虫：Larbin</h4><p>Larbin 是一种开源的网络爬虫，用 C++ 语言实现。其设计简单，具有高度的可配置性，能够配置抓取深度、间隔、并发度、代理，并支持通过后缀名对抓取网页进行过滤。Larbin 具有非常高的效率，可以轻易获取单个网站的所有链接，自动扩展 url 页面并抓取与保存，从而为搜索引擎提供广泛的数据来源。 </p><p>然而，Larbin 只是一个爬虫，<strong>只抓取网页</strong>，并不负责网页的解析、数据库的存储以及索引的建立，也不支持分布式系统。另外，Larbin 已经较长时间不再更新，因而不支持 https 协议，这在今天很大程度上造成了网页页面的局限性。</p><p>这里采用由国人在基于原版 Larbin2.6.3 版本上继续开发并发布于 GitHub 的 Larbin2.6.5 版本进行搜索引擎系统的构建。</p><p>项目网址：<a href="https://github.com/ictxiangxin/larbin">https://github.com/ictxiangxin/larbin</a></p><h4 id="网页解析：BeautifulSoup4-bs4"><a href="#网页解析：BeautifulSoup4-bs4" class="headerlink" title="网页解析：BeautifulSoup4 (bs4)"></a>网页解析：BeautifulSoup4 (bs4)</h4><p>BeautifulSoup4 是一个可以从 HTML 或 XML 文件中提取数据的 Python 库。</p><p>由于 HTML 和 XML 文件本身是<strong>结构化的文本</strong>，有一定的规则，通过它的结构可以简化信息提取。类似的网页信息提取库还有 Lxml 和 Pyquery 等，但是 bs4 相比其他的库更加简单易用。</p><p>本项目就采用 BeautifulSoup4 快速对网页文档内容进行解析和格式化。</p><p>官方文档：<a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/">https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/</a></p><h4 id="前端-amp-搜索引擎：Xunsearch-amp-Xapian"><a href="#前端-amp-搜索引擎：Xunsearch-amp-Xapian" class="headerlink" title="前端&amp;搜索引擎：Xunsearch &amp; Xapian"></a>前端&amp;搜索引擎：Xunsearch &amp; Xapian</h4><p>Xunsearch（迅搜）是一款以 GPL 协议开源发布的高性能、全功能的<strong>全文检索</strong>解决方案，并针对<strong>中文</strong>深度优化和处理，用于帮助开发者针对海量数据快速建立搜索引擎。 </p><p>Xunsearch 采用结构化分层设计，包含后端服务器和前端开发包两大部分。后端是用 C/C++ 基于 Xapian 搜索库、SCWS 中文分词、libevent 等开源库开发，借鉴了 nginx 的多进程多线程混合工作方式，是一个可承载高并发的高性能服务端。前端则是使用流行的脚本语言编写了开发工具包（SDK)。 </p><p>本项目采用 Xunsearch 还考虑了以下特点：</p><ul><li>具有为搜索而自主开发 SCWS 中文分词库，支持复合分词、自定义补充词库，保障查全率、准确率。</li><li>索引接口齐全，索引添加简便，支持实时搜索，支持多种数据源（SQL、JSON、CSV 等）。</li><li>除通用搜索引擎功能外，还内置支持拼音检索、分面搜索、相关搜索、同义词搜索、搜索纠错建议等专业功能。</li></ul><p>官方地址：<a href="http://www.xunsearch.com/">http://www.xunsearch.com/</a> </p><p>此外，Xunsearch 的高速响应能力还离不开 Xapian 这一搜索引擎库。</p><p>Xapian 是一个允许开发人员轻易地添加<strong>高级索引和搜索功能</strong>到他们的应用系统的高度可修改的工具，它在支持概率论检索模型的同时也支持布尔型操作查询集。</p><p>Xapian 相比 Lucene 有更多的优势：基于 C++ 开发的强可移植性（可以运行在 Linux, MacOS, Windows 系统上），丰富的查询机制（概率性搜索排名、相关度反馈、邻近搜索、布尔搜索、词干提取、通配符查询、别名查询、拼写纠正等）和较强的检索性能。</p><h2 id="设计文档"><a href="#设计文档" class="headerlink" title="设计文档"></a>设计文档</h2><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><p>主机：</p><ul><li>系统：Windows 10</li><li>带宽：40 Mbps</li></ul><p>虚拟机：</p><ul><li>软件：Oracle VM VirtualBox 6.1.26</li><li>配置设置：<ul><li>内存：2GB</li><li>磁盘：20GB</li><li>处理器：Intel(R) Core(TM) i5-9300H CPU @ 2.40GHz（核心数：1） </li></ul></li><li>系统：Linux Ubuntu 20.04</li><li>依赖环境：<ul><li>Apache 2.4.41</li><li>PHP 7.4.3</li><li>Python 3.8.10</li></ul></li></ul><h3 id="总体设计流程"><a href="#总体设计流程" class="headerlink" title="总体设计流程"></a>总体设计流程</h3><ol><li>安装 Ubuntu 虚拟机，配置环境，安装 Larbin 和 Xunsearch。</li><li>配置 Larbin 爬虫选项，选定种子页面，爬取文档。</li><li>利用 BeautifulSoup4 模块编写脚本 Parser.py 解析文档，存储为 csv 文件。</li><li>生成 Xunsearch 配置文件，构建索引，生成搜索框架。</li><li>部署至 Apache HTTP Server，前后端代码再开发，优化搜索页面。</li></ol><h3 id="各模块设计细节"><a href="#各模块设计细节" class="headerlink" title="各模块设计细节"></a>各模块设计细节</h3><h4 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h4><p>网络爬虫模块使用 Larbin2.6.5 进行网页文档的爬取。在按照配置进行爬取 30 分钟后，最终获得 10965 个文档（约 409 MB）。由于爬虫自身的限制，这些文档均来自 http 站点。 </p><p>以下是关键的配置项及说明：</p><ul><li>是否锁定种子站点：<strong>否</strong>。取消锁定才能根据链接爬取到更多内容。</li><li>是否使用扩展链接：<strong>否</strong>。大部分网页为了提高排名，都会引入无关的友链，由于本项目是专题检索，故关闭此功能避免进入其他域名。</li><li>同一个服务器的两次请求的间隔时间：<strong>无限制</strong>。通常基于礼貌原则，我们应该限制访问频率，但由于关闭了扩展链接，爬虫只会在少数域名中爬取，如果限制了间隔时间会使得爬取效率极低。</li><li>是否哈希页面以去重：<strong>是</strong>。由于站点固定，去重可以减少大量数据冗余。</li></ul><p>以下是种子网页地址：</p><ul><li><a href="http://philosophychina.cssn.cn/">http://philosophychina.cssn.cn/</a> （中国哲学网-中国社科网子域名）</li><li><a href="http://literature.cssn.cn/">http://literature.cssn.cn/</a> （中国文学网-中国社科网子域名）</li><li><a href="http://cel.cssn.cn/#story1">http://cel.cssn.cn/#story1</a> （中国民族文学网-中国社科网子域名）</li><li><a href="http://ling.cssn.cn/">http://ling.cssn.cn/</a> （中国语言文学网-中国社科网子域名）</li><li><a href="http://iwr.cssn.cn/">http://iwr.cssn.cn/</a> （中国宗教文学网-中国社科网子域名）</li><li><a href="http://ifl.cssn.cn">http://ifl.cssn.cn</a> （中国外国文学网-中国社科网子域名）</li><li><a href="http://www.china-language.edu.cn/">http://www.china-language.edu.cn/</a> （中国语言学网）</li><li><a href="http://www.huaxiawen.com/">http://www.huaxiawen.com/</a> （华夏古代文学网）</li><li><a href="http://www.zgwenxue.com/">http://www.zgwenxue.com/</a> （中国文学网）</li><li><a href="http://www.eduwx.com/">http://www.eduwx.com/</a> （教育文学网）</li><li><a href="http://www.wgwxzz.cn/">http://www.wgwxzz.cn/</a> （外国文学网）</li><li><a href="http://www.zhexue.org/">http://www.zhexue.org/</a> （哲学网）</li><li><a href="http://www.52shici.cn/">http://www.52shici.cn/</a> （吾爱诗词网）</li></ul><p>在终端运行爬虫过程如下：</p><p><img src="/img/blog/IR-Project-images/Larbin1.png" alt="Larbin运行过程" style="zoom: 67%;" /></p><p>打开 localhost:8081 查看统计结果：</p><p><img src="/img/blog/IR-Project-images/Larbin2.png" alt="Larbin运行结果" style="zoom:67%;" /></p><p>从统计结果可以看出，共收到 13783 个 URL，访问了 13783 个页面，最终成功爬取 10965 个页面。</p><p><img src="/img/blog/IR-Project-images/Larbin3.png" alt="爬取速度变化" style="zoom:67%;" /></p><p>从上图可以具体地得出爬虫的爬取效率，可见爬虫爬取的速度随着时间的推移会发生较大的变化。</p><h4 id="网页解析"><a href="#网页解析" class="headerlink" title="网页解析"></a>网页解析</h4><p>解析器模块利用 Python 的 BeautifulSoup4 和 Pandas 模块编写，前者可以对网页文档进行解析，后者便于将数据以 csv 文件形式保存，便于后续搜索引擎使用。 </p><p>调用 BeautifulSoup4 的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path + file, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    soup = BeautifulSoup(f.read(), <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>    <span class="hljs-keyword">if</span> soup.title == <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> soup.title.string == <span class="hljs-literal">None</span>:<br>        title.append(<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        title.append(soup.title.string.replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;\r&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>))<br>    body.append(soup.get_text().replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;\r&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>))<br></code></pre></td></tr></table></figure><p>调用 Pandas 的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">data = &#123;<span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-built_in">id</span>, <span class="hljs-string">&#x27;title&#x27;</span>: title, <span class="hljs-string">&#x27;body&#x27;</span>: body, <span class="hljs-string">&#x27;urls&#x27;</span>: urls&#125;<br>frame = pd.DataFrame(data)<br><span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>    frame.to_csv(<span class="hljs-string">&#x27;data_u.csv&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8-sig&#x27;</span>, index=<span class="hljs-literal">False</span>)<br><span class="hljs-keyword">else</span>:<br>    frame.to_csv(<span class="hljs-string">&#x27;data_u.csv&#x27;</span>, mode=<span class="hljs-string">&#x27;a+&#x27;</span>, header=<span class="hljs-literal">False</span>, encoding=<span class="hljs-string">&#x27;utf-8-sig&#x27;</span>, index=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>处理结果如下：</p><p><img src="/img/blog/IR-Project-images/data.png" alt="处理后的数据（部分）" style="zoom: 67%;" /></p><p>可以看到每个文档被分出 id, title, body, urls 四个字段，存储在一个 csv 文件中。 </p><h4 id="前端-amp-搜索引擎"><a href="#前端-amp-搜索引擎" class="headerlink" title="前端&amp;搜索引擎"></a>前端&amp;搜索引擎</h4><p>搜索引擎模块利用 Xunsearch 提供的开发工具即可实现。首先确定运行环境正常，然后编写配置文件对格式化的 csv 文件建立索引，并生成搜索骨架代码，即可实现基本检索功能。 </p><p>首先利用工具包中的 RequiredCheck 检查当前环境是否满足 Xunsearch 的运行条件：</p><p><img src="/img/blog/IR-Project-images/xun1.png" alt="迅搜运行条件检查" style="zoom:50%;" /></p><p>环境正常后，利用工具包中的配置文件生成工具 IniWizzard，在 Web 交互页面中即可完成各个字段的设计：</p><p><img src="/img/blog/IR-Project-images/xun2.png" alt="配置生成工具" style="zoom: 50%;" /></p><p>其中，各个字段的含义如下：</p><ul><li>id 为主键，作为每个文档的标识符。</li><li>title 为文档的标题，赋予较高权重。</li><li>body 为文档的内容，截取 300 个字符作为搜索结果的摘要显示。</li><li>urls 作为每个文档在展示时的附属信息，不需要进行索引。 </li></ul><p>此后，就可以用工具包中的索引管理器 Indexer 批量建立索引：</p><p><img src="/img/blog/IR-Project-images/xun3.png" alt="批量建立索引" style="zoom: 67%;" /></p><p>在 db 文件夹下，可以看到建立的索引文件：</p><p><img src="/img/blog/IR-Project-images/xun4.png" alt="建立的索引文件" style="zoom: 67%;" /></p><p>此时，可以用工具包中配备的测试工具 Quest，在当前索引中进行测试搜索，测试给定查询词的返回的数据。 </p><p><img src="/img/blog/IR-Project-images/xun5.png" alt="测试搜索" style="zoom:50%;" /></p><p>可以看到搜索功能已经可以使用了，这时需要用到工具包中的骨架代码生成工具 SearchSkel，生成前端代码。</p><p><img src="/img/blog/IR-Project-images/xun6.png" alt="骨架代码生成" style="zoom: 67%;" /></p><p>最后，运行 Apache2.0，将生成的 search 目录放到 /var/www/html 中，即可在本地服务器 localhost 访问搜索页面，实现搜索引擎的功能。 </p><p><img src="/img/blog/IR-Project-images/xun7.png" alt="基础页面"></p><p>点击文档标题，会返回对应的文档主键（id）：</p><p><img src="/img/blog/IR-Project-images/xun8.png" alt="点击标题后的弹框" style="zoom: 67%;" /></p><h4 id="页面再开发"><a href="#页面再开发" class="headerlink" title="页面再开发"></a>页面再开发</h4><p>可以看到，直接生成的框架文件有如下的不足：</p><ul><li>前端较为简陋，重点不够突出。</li><li>由于使用了国外的 cdn，访问速度较慢。</li><li>搜索结果点击后无法直接跳转至页面。</li></ul><p>开发 style.css 和 search.tpl 文件后，可以得到新的页面：</p><p><img src="/img/blog/IR-Project-images/xun9.png" alt="再开发后的页面"></p><h2 id="页面展示"><a href="#页面展示" class="headerlink" title="页面展示"></a>页面展示</h2><p>网站部署到 web 可访问目录后，可以通过虚拟机的端口转发设置，实现在主机上访问，也可以购买 HTTP 映射服务后在给定域名访问。这里选择最简单的在虚拟机中访问。</p><h3 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h3><p>使用搜索前：</p><p><img src="/img/blog/IR-Project-images/page0.png" alt="使用搜索前" style="zoom: 67%;" /></p><p>使用搜索后：</p><p><img src="/img/blog/IR-Project-images/page1.png" alt="使用搜索后" style="zoom:67%;" /></p><p>在使用了搜索功能后，搜索引擎将分析<strong>搜索日志</strong>，从而提供<strong>热门搜索词</strong>。 此外，可以看到搜索时可以选择多种方式，页脚有标明版权、处理时间以及作者的信息。</p><h3 id="搜索页面"><a href="#搜索页面" class="headerlink" title="搜索页面"></a>搜索页面</h3><p>点击搜索后，会反馈查询结果的标题、文档摘要以及文档对应的原网址，并进行对查询词进行高亮表示（标题中红字、摘要中加粗），并会返回检索条目、检索时间、检索相似度等信息。</p><p>特别地，在页脚还提供了相关的搜索内容的联想，下图是在搜索「散文」后的联想：</p><p><img src="/img/blog/IR-Project-images/page2.png" alt="相关搜索" style="zoom:67%;" /></p><h3 id="部分功能"><a href="#部分功能" class="headerlink" title="部分功能"></a>部分功能</h3><ol><li>查询联想</li></ol><p><img src="/img/blog/IR-Project-images/page3.png" alt="查询联想" style="zoom:67%;" /></p><ol><li>拼音联想</li></ol><p><img src="/img/blog/IR-Project-images/page4.png" alt="拼音联想" style="zoom:67%;" /></p><ol><li>搜索纠错</li></ol><p><img src="/img/blog/IR-Project-images/page5.png" alt="搜索纠错" style="zoom:67%;" /></p><ol><li>拼音纠错</li></ol><p><img src="/img/blog/IR-Project-images/page6.png" alt="拼音纠错" style="zoom:67%;" /></p><ol><li>布尔检索</li></ol><p><img src="/img/blog/IR-Project-images/page7.png" alt="未使用布尔检索的结果" style="zoom:67%;" /></p><p>插入否定连接词后：</p><p><img src="/img/blog/IR-Project-images/page8.png" alt="插入布尔连接词后的结果" style="zoom:67%;" /></p><h2 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h2><p>下表随机选取 10 个与本搜索引擎相关的查询词进行检索，评估搜索引擎的 Top5 查准率（precision@5）与平均响应时间（mean responding time）。 </p><div class="table-container"><table><thead><tr><th style="text-align:center">查询</th><th style="text-align:center">查准率@5</th><th style="text-align:center">响应时间/s</th><th style="text-align:center">匹配文档总数</th></tr></thead><tbody><tr><td style="text-align:center">校园文学</td><td style="text-align:center">4</td><td style="text-align:center">0.0219</td><td style="text-align:center">2000</td></tr><tr><td style="text-align:center">宗教文学</td><td style="text-align:center">5</td><td style="text-align:center">0.0186</td><td style="text-align:center">1000</td></tr><tr><td style="text-align:center">汉语</td><td style="text-align:center">5</td><td style="text-align:center">0.0210</td><td style="text-align:center">990</td></tr><tr><td style="text-align:center">藏语</td><td style="text-align:center">3</td><td style="text-align:center">0.0229</td><td style="text-align:center">68</td></tr><tr><td style="text-align:center">季羡林</td><td style="text-align:center">1</td><td style="text-align:center">0.0173</td><td style="text-align:center">50</td></tr><tr><td style="text-align:center">鲁迅</td><td style="text-align:center">4</td><td style="text-align:center">0.0188</td><td style="text-align:center">501</td></tr><tr><td style="text-align:center">毛泽东诗词</td><td style="text-align:center">5</td><td style="text-align:center">0.0221</td><td style="text-align:center">300</td></tr><tr><td style="text-align:center">马克思主义哲学中国化</td><td style="text-align:center">5</td><td style="text-align:center">0.0356</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">散文作品</td><td style="text-align:center">4</td><td style="text-align:center">0.0128</td><td style="text-align:center">800</td></tr><tr><td style="text-align:center">小说集</td><td style="text-align:center">3</td><td style="text-align:center">0.0225</td><td style="text-align:center">120</td></tr></tbody></table></div><p>计算得：平均查准率为 3.9，平均响应时间为 0.02135s。</p><p>从结果上看，该搜索引擎在对应领域有着良好的表现，且响应迅速，但是对著名人物作品的查询则稍显不足。</p><p>此外，在部分检索结果中，有些无关文档由于重复出现了查询词而被赋予较高的「相似度」，但实际上 Top 10 返回结果的「相似度」都很高，可以考虑用 PageRank 等算法优化网站排名，提高 MRR 等指标。</p>]]></content>
    
    
    <categories>
      
      <category>项目经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #11 问答系统</title>
    <link href="/IR-Note-11.html"/>
    <url>/IR-Note-11.html</url>
    
    <content type="html"><![CDATA[<p>在传统的搜索引擎中，通常是以关键词为索引，通过匹配而返回相似的文档。然而，有时用户在搜索引擎中检索，并非想得到若干个网页，而是直接返回询问的答案，免去用户人工定位信息的过程。</p><p><strong>问答式信息检索</strong>，是一种允许用户以自然语言方式询问，系统从单语或多语文档集中查找并返回<strong>确切答案或者蕴含答案文本片断</strong>的新型信息检索的方式。</p><p>要做到这一点，就需要先做到：</p><ol><li>理解问句中的查询意图。</li><li>根据分析结果去检索匹配文档，尽量缩小范围。</li><li>在返回的文档中提取答案信息或定位答案文本。</li></ol><p>当然，早期还有一种做法是构建 FAQ (Frequently Asked Questions，常用问题解答) 库，将用户的问句与问题库中的问句进行相似度匹配，直接返回对应的答案。</p><h2 id="AskMSR-Shallow-approach"><a href="#AskMSR-Shallow-approach" class="headerlink" title="AskMSR: Shallow approach"></a>AskMSR: Shallow approach</h2><p>AskMSR 是 Microsoft Research 提出的是一种简易的基于检索的问答系统。</p><p>其大体步骤分为六步：</p><ol><li>Rewrite Query：重写查询，并将问句类型归类。</li><li>Search Engine：将所有重写结果输入到搜索引擎，返回前若干个文档。</li><li>Mine N-grams：文档分词，N 通常枚举 1，2，3，根据出现频率给出置信度。</li><li>Filter N-grams：过滤分词结果，保留与问题类型相关的。</li><li>Tile N-grams：组合分词结果，把重叠可拼接的词 merge，置信度也相加。</li><li>N-best Answers：答案通常都是多个，以置信度排序。</li></ol><h3 id="重写查询-Query-Rewriting"><a href="#重写查询-Query-Rewriting" class="headerlink" title="重写查询 | Query Rewriting"></a>重写查询 | Query Rewriting</h3><p>如果只是检索用户输入的问句，很可能返回的就是含有句子本身的文档。而根据我们的直觉：用户需要的答案通常在语义上与查询<strong>相近</strong>的句子中。为此，我们需要将疑问句改写成<strong>陈述句</strong>，如果在文本中有这样一句陈述句，它可能本身就包含了问题的答案。</p><p>重写后的陈述句不一定是满足语法规则的句子，但是这并不影响检索结果。一个 query 可以被改写成若干个问题，并通过搜索引擎查询更多个相似的文本片段。</p><p>此外，重写问句时，通常要对语言的语法规则有一点了解，从而对问题进行分类。如在英语中：Who 对应人名，When 对应时间，Where 对应地名等。这将用于后续的分词结果的过滤。</p><h2 id="模式挖掘-ISI-Surface-patterns-approach"><a href="#模式挖掘-ISI-Surface-patterns-approach" class="headerlink" title="模式挖掘 | ISI: Surface patterns approach"></a>模式挖掘 | ISI: Surface patterns approach</h2><p>在 AskMSR 中，我们只在句法相近的句子中寻找答案，但是实际上很多答案会隐藏在不同的形式中。如果我们使用特征短语——<strong>模式</strong>（Pattern），就可以检索到不同形式的答案。</p><p>例如在问题 “When was <code>person</code> born ?” 中，答案的形式可能是：</p><ul><li>Mozart was born in 1756.</li><li>Gandhi (1869-1948) …</li></ul><p>这两种特征短语可以挖掘出如下的模式：</p><ul><li><code>NAME</code> was born in <code>BIRTHDATE</code></li><li><code>NAME</code> (<code>BIRTHDATE</code> - <code>DEATHDATE</code>)</li></ul><p>对于不同的模式，我们也可以赋予不同的置信度（准确度）。而后我们就可以用这两种模式在搜索引擎中匹配结果，并根据置信度返回结果排序。</p><p>在 2002 年 Hovy 等人还提出 QA Typology 的问答分类体系，将常见的问答分为以下六种类型：BIRTHDATE、LOCATION、INVENTOR、DISCOVERER、DEFINITION、WHY-FAMOUS，并给出了对应类型下常用的模式和置信度。这在使用中取得了较高的 MRR (Mean Reciprocal Rank)。</p><h3 id="Shortcomings-amp-Extensions"><a href="#Shortcomings-amp-Extensions" class="headerlink" title="Shortcomings &amp; Extensions"></a>Shortcomings &amp; Extensions</h3><p>接下来分析 ISI 可能出现的问题，以及改进的方法。</p><p>第一，由于使用了简单的字符串匹配，可能会在文档中出现「模式符合，但并非答案」的句子，这就需要利用<strong>词性标注</strong>（Part-Of-Speech Tagging）对答案内容加以分析，从而修改置信度。</p><p>第二，原始的模式不支持<strong>长距离</strong>答案的匹配，实际中的陈述句中如果含有形容词、副词或者更长的插入语，就容易割裂模式。如「Mozart, who was a famous classical composer, was born in 1756.」中，原始的模式就会漏掉答案。因此我们需要在原始的模式中插入可任意文本填充的空白字段。</p><p>第三，当问句中的 <code>NAME</code> 以<strong>同义词或释义</strong>的形式出现时，直接字符串匹配的模式也会漏掉答案。这时就需要对问句中的关键词进行语义上的扩展，需要用到 WordNet 等词典。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #10 查询相关反馈</title>
    <link href="/IR-Note-10.html"/>
    <url>/IR-Note-10.html</url>
    
    <content type="html"><![CDATA[<p>用户在检索信息时，通常会以一个简短的 query 开始，这样的查询往往得不到其最想要的结果。而用户会在得到结果后优化自己的 query，如：增删词项、重新赋权、加入布尔运算符等。</p><p><strong>相关反馈</strong>（Relevance Feedback）的主要思想就是：在信息检索的过程中通过用户交互来优化查询，从而提高最终的检索效果。我们的目的是实现一个良好的<strong>反馈机制</strong>。</p><h2 id="最佳查询-Best-Query"><a href="#最佳查询-Best-Query" class="headerlink" title="最佳查询 | Best Query"></a>最佳查询 | Best Query</h2><p>为了使反馈能让 query 真正往「更好」的方向演变，需要定义评价 query 的一个指标。通常我们在<strong>向量空间模型</strong>中评价之，因为可以较好地表达相似度。</p><p>假设我们要找一个最优查询向量 $\vec{q}$，它与相关文档之间的相似度最大，和不相关文档之间的相似度最小。若 $C_r$ 表示相关文档集，$C_{nr}$ 表示不相关文档集，我们希望找到的最优的是 $\vec{q}$ 应当满足：</p><script type="math/tex; mode=display">\begin{aligned}\vec{q}_{opt} &= argmax[Sim(\vec{q},C_r)-Sim(\vec{q},C_{nr})]\\&=argmax(\frac{1}{|C_r|}\sum_{\vec{d}_j\in C_r}{\vec{q}\cdot \vec{d}_j}-\frac{1}{|C_{nr}|}\sum_{\vec{d}_j\in C_{nr}}{\vec{q}\cdot \vec{d}_j})\\&=argmax(\vec{q}\cdot \vec{a})\end{aligned}</script><p>其中 $argmax(x)$​​​​ 函数是返回使 $x$​​​​ 最大的变量，相似度 $Sim$​​​​ 的求法则采用余弦夹角， $\vec{q}$​​​​ 和 $\vec{d}$​​​ ​采用归一化后的<strong>单位向量</strong>。此外，我们令：</p><script type="math/tex; mode=display">\vec{a}=\frac{1}{|C_r|}\sum_{\vec{d_j}\in{C_r}}{\vec{d_j}} - \frac{1}{|C_{nr}|}\sum_{\vec{d_j}\in{C_{nr}}}{\vec{d_j}}</script><p>若使 $\vec{q}\cdot{\vec{a}}$ 最大，$\vec{q}$ 需要与 $\vec{a}$ 平行，且 $\vec{q}$​ 为单位向量，故有最佳查询：</p><script type="math/tex; mode=display">\vec{q}_{opt}=\frac{1}{|C_r|}\sum_{\vec{d_j}\in{C_r}}{\vec{d_j}} - \frac{1}{|C_{nr}|}\sum_{\vec{d_j}\in{C_{nr}}}{\vec{d_j}}</script><p>这就是说，最优的查询向量等于相关文档的质心向量和不相关文档的质心向量的差，相当于是最接近相关文档，同时最远离不相关文档。</p><h3 id="查询优化-Query-Modification"><a href="#查询优化-Query-Modification" class="headerlink" title="查询优化 | Query Modification"></a>查询优化 | Query Modification</h3><p>然而，即使有了上述最佳查询的表示方法，也无法直接求出来——因为检索本来的目的就是要找相关文档，而所有的相关文档事先是未知的。</p><p>Rocchio 提出在真实的检索情景中，我们可以利用已检索到的部分相关文档 $D_r$ 和不相关文档 $D_{nr}$，逐步修改原始的查询向量：</p><script type="math/tex; mode=display">\vec{q}_m=\alpha\vec{q}_0 + \beta \frac{1}{|D_r|}\sum_{\vec{d_j}\in{D_r}}{\vec{d_j}} - \gamma\frac{1}{|D_{nr}|}\sum_{\vec{d_j}\in{D_{nr}}}{\vec{d_j}}</script><p>修改后的新查询从 $\vec{q}_{0}$​​ 开始，向着相关文档的质心向量靠近了一段距离，而同时又与不相关文档的质心向量远离了一段距离——更加接近最优查询了。通过不断迭代，可以观察到查询效果确实有显著的提升。</p><h2 id="查询反馈-Relevance-Feedback"><a href="#查询反馈-Relevance-Feedback" class="headerlink" title="查询反馈 | Relevance Feedback"></a>查询反馈 | Relevance Feedback</h2><p>通常情况下，反馈可分为以下两种：</p><ul><li>真实相关反馈：搜索引擎返回结果，用户提供反馈，搜索引擎根据反馈返回更好的结果。</li><li>假设相关反馈：搜索引擎得到结果但不返回，根据结果自动优化 query，根据优化后的 query 返回「更好」的结果。</li></ul><h3 id="点击流数据-Clickthrough-Data"><a href="#点击流数据-Clickthrough-Data" class="headerlink" title="点击流数据 | Clickthrough Data"></a>点击流数据 | Clickthrough Data</h3><p>在真实相关反馈中，用户往往不愿意主动提供反馈信息（如标记相关或不相关文档），于是搜索引擎收集用户的<strong>间接反馈</strong>。</p><p>而点击流数据则是这个领域最常用的一种反馈，可以在不干扰用户的情况下大量收集（此外还有一种补充用户行为信息的方法是眼动追踪）。</p><p>同一搜索结果中，用户进行点击浏览的结果被认为是相关的，或者说是「用户更<strong>偏好</strong>的」。如果用户查看了每个搜索引擎下面显示的文本短摘要后，决定跳过它并点击在排序中低于它的结果，就可以说用户相对更喜欢这个被点击的结果。</p><h3 id="局部上下文分析-Local-Context-Analysis"><a href="#局部上下文分析-Local-Context-Analysis" class="headerlink" title="局部上下文分析 | Local Context Analysis"></a>局部上下文分析 | Local Context Analysis</h3><p>在假设相关反馈中，还可分为两种基本方法：</p><ul><li>局部分析（Local Analysis）：从结果集合排名靠前的文档中产生反馈信息。</li><li>全局分析（Global Analysis）：从外部资源产生反馈信息，如同义词典（用于扩充查询）。</li></ul><p>同义词典构建的代价十分昂贵，通常考虑用<strong>上下文和短语结构</strong>进行分析获得。而如果把这个思想用于局部分析，则诞生了 LCA 方法：一种聚焦于从反馈结果中筛选出与 query 相关性更高的 term，再用这些 term 扩展 query 重新检索的方法。</p><p>大致的步骤如下：</p><ol><li>找到与这个 query 检索结果排名靠前的文章，使用一个固定长度（如 300 个词）的滑动窗口，来划分<strong>段落</strong>。引入段落是为了最小化冗长文档中的无关内容。</li><li>对段落进行检索排序，找到结果排名靠前的段落，对其使用语义分析和文本分词、词性标注技术找到<strong>名词项</strong>。名词在搜索引擎中往往被视为最重要的词。</li><li>统计名词项的出现次数，以及出现时离 query 的距离，通过特殊的加权方法来选择出候选 term。</li><li>将排名靠前的几个候选 term 加入到原始 query 中，进行新的查询。</li></ol><h2 id="排序学习-Learning-to-Rank"><a href="#排序学习-Learning-to-Rank" class="headerlink" title="排序学习 | Learning to Rank"></a>排序学习 | Learning to Rank</h2><p>相关反馈信息，包括前述文章中提到的相关度、重要度，其实只是 IR 中许多因子的冰山一角。实际中可能还有若干、数十个因子，这些因子最后会加权构成一个统一的<strong>指标函数</strong>。</p><p>这个指标函数的输入是数据集（包括查询和文档集），输出是最终检索出的 ranklist。如何构造这样一个复杂的函数呢？</p><p>对于构造函数，人们最原始的想法通常是拟合所有 <query, ranklist> 点，但是这显然不适用于这种规模的问题。</p><h3 id="机器学习的使用-Machine-learning-for-IR-ranking"><a href="#机器学习的使用-Machine-learning-for-IR-ranking" class="headerlink" title="机器学习的使用 | Machine learning for IR ranking"></a>机器学习的使用 | Machine learning for IR ranking</h3><p>过去的 IR 系统较少用到机器学习，是因为缺乏训练集，特别是在真实世界中得到的数据集（而不是学术论文中），因为很难收集到用户检索的真实需求和对返回文档的相关反馈。</p><p>此外，过去的 IR 系统往往只使用少量的<strong>特征</strong>（feature），如词项频率、逆文档频率、term 出现的位置等。</p><p>少量的特征带来的是构造函数的便利。而随着现在网络的发展、算力的提升，大家开始关注数据集中大量的特征，并尝试用机器学习使用这些特征。</p><p>定义 loss function $l(r_a,r_b)$​​​，其中 $r_a$ 是基于用户反馈得到的「标准排名」，$r_b$ 是通过拟合的排序函数 <em>F</em> 计算出的「模拟排名」。我们要寻找到一个 <em>F</em> 使得损失最小——这就是机器学习的目标。</p><h3 id="Example-title-amp-body"><a href="#Example-title-amp-body" class="headerlink" title="Example - title &amp; body"></a>Example - title &amp; body</h3><p>下面以一个例子说明机器学习在 IR 中的应用。考虑查询中的 term 出现在文档的 title (标题) 或 body (正文) 中对返回结果排名的影响。</p><p>为此，我们需要对 term 出现的四种情况分别打分：</p><script type="math/tex; mode=display">\operatorname{score}\left(d, q\right)=g {s_{t}}\left(d, q\right)+(1-g) s_{b}\left(d, q\right)</script><p>其中 $s_t$ 和 $s_b$ 函数是关于 term 是否存在于文档对应位置的布尔函数（0/1），故 score 的结果只有 0, <em>g</em>, 1-<em>g</em>, 1 四种。我们要求的就是权重 <em>g</em>。</p><p>在第 <em>j</em> 个查询中，我们对检索结果中的文档 <em>i</em> 定义如下<strong>损失函数</strong>：</p><script type="math/tex; mode=display">\varepsilon\left(g, \Phi_{j}\right)=\left(r\left(d_{i}, q_{j}\right)-\operatorname{score}\left(d_{i}, q_{j}\right)\right)^{2}</script><p>这里简单的定义 <em>r</em> 函数是关于二者是否相关的布尔函数（0/1），使用平方误差是为了让结果更连续。</p><p>在训练集中，我们标注出所有结果的 $s_t$ 、 $s_b$ 和 <em>r</em> 函数的取值——八种情况，并分别统计其次数。例如，$n_{01r}$ 表示 $s_t=0,s_b=1$ 且相关的例子，$n_{01n}$ 表示 $s_t=0,s_b=1$​ 且不相关的例子，其平方误差之和为：</p><script type="math/tex; mode=display">[1-(1-g)]^{2} n_{01 r}+[0-(1-g)]^{2} n_{01 n}</script><p>同样的，我们对其他三组也进行计算后相加，化简可得：</p><script type="math/tex; mode=display">\left(n_{01 r}+n_{10 n}\right) g^{2}+\left(n_{10 r}+n_{01 n}\right)(1-g)^{2}+n_{00 r}+n_{11 n}</script><p>要求这个函数的极小值，只需用对关于 <em>g</em> 的导数求零点即可。如果考虑更多的变量，则需要求<strong>偏导</strong>，再用拉格朗日常数法等数值分析方法。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
      <tag>NLP</tag>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #9 网页排序</title>
    <link href="/IR-Note-9.html"/>
    <url>/IR-Note-9.html</url>
    
    <content type="html"><![CDATA[<p>当我们在一个小的文档库中查询时，即使 query 很模糊，我们只要返回所有相关文档即可，甚至不需要<strong>猜测</strong>用户的查询需求。</p><p>但如果在一个大的文档集中查询时（比如谷歌），往往可以返回大量的相关文档。如果基于相关度的 ranking，往往无法区分哪些文档该呈现在最前面，甚至可能时一些低质量的网页由于某些词的词频很高，从而排在了前面。</p><p>此时我们就不能只聚焦于「相关度」，PageRank 算法通过计算一个页面的「<strong>重要度</strong>」，从而判别网页质量，得到排序。</p><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>如何衡量「重要度」？用点击率、权威性？然而，这些数据都是爬虫无法爬取到的，同时也难以正确衡量。</p><p>科学家们从 Bibliometrics (文献计量学) 中借鉴了如下观点：</p><ul><li>Bibliographic coupling (引文耦合)：两篇文章具有相近的引用。</li><li>Co-citation (协同引用)：两篇文章被大量其他文章同时引用。</li><li>Impact factor (影响因子)：一个期刊中的文章的年平均被引次数，衡量了一个期刊的「<strong>重要度</strong>」。</li></ul><p>例如，最权威的 SCI 往往只收录其认为重要的期刊，也只记录其中的期刊相互引用的次数。当一篇文章被 SCI 收录的文章引用时，通常也可以说明其有一定的影响力——即重要度的「<strong>传递</strong>」。</p><p>对于文献引用的可视化，我们通常称为 Citation Graph，通常是一个 Directed Acyclic Graph (有向无环图，DAG)，因为较早的文章无法修改而引用后来的文章。</p><p>在网页中，我们可以 Hyperlinks (超链接) 来类比引用，从而形成一个 Hyperlink Graph，区别是这类图中可以有环路。</p><p>从而引出网页排序的基本假设：</p><ul><li>The rank of a web page is higher if many pages link to it.</li><li>Links from highly ranked pages are given greater weight than links from less highly ranked pages. </li></ul><h2 id="PageRank-Algorithm"><a href="#PageRank-Algorithm" class="headerlink" title="PageRank Algorithm"></a>PageRank Algorithm</h2><p>基于上述假设，我们很容易可以得到当前页面的链入、链出数。但是，要怎么知道链入当前页面的<strong>前序页面</strong>，其重要度是多少呢？</p><h3 id="随机游走模型-Random-Walk-Model"><a href="#随机游走模型-Random-Walk-Model" class="headerlink" title="随机游走模型 | Random Walk Model"></a>随机游走模型 | Random Walk Model</h3><p>在一个封闭的 Hyperlink Graph 中，随机选取一个页面作为访问起点，随机选取其链出的页面进行访问，再对下一个页面重复上述操作。</p><p>大量重复后，统计每个结点被访问的频率，用频率近似概率后，我们可以发现访问概率较大者通常有着较多的链入，或者其链入页面也有着较大的访问概率。用公式表示就是：</p><script type="math/tex; mode=display">\mathrm{Pr}\left( P_i \right) =\mathrm{Pr}\left( P_i\mid P_1 \right) \mathrm{Pr}\left( P_1 \right) +\mathrm{Pr}\left( P_i\mid P_2 \right) \mathrm{Pr}\left( P_2 \right) +\cdots +\mathrm{Pr}\left( P_i\mid P_N \right) \mathrm{Pr}\left( P_N \right)</script><p>其中 $\mathrm{Pr}\left( P_i\mid P_1 \right) $​​ 表示从编号为 1 的网页跳转到编号为 <em>i</em> 的网页的概率，其计算方式为：</p><script type="math/tex; mode=display">\mathrm{Pr}\left( P_i\mid P_1 \right) =\begin{cases}    0\text{，如果}P_1\text{到}P_i\text{没有链入}\\    \frac{1}{m}\text{，}m\text{为}P_1\text{的链出数}\\\end{cases}</script><h3 id="矩阵表示-Matrix-Representation"><a href="#矩阵表示-Matrix-Representation" class="headerlink" title="矩阵表示 | Matrix Representation"></a>矩阵表示 | Matrix Representation</h3><p>令 $w_i=\mathrm{Pr}\left( P_i \right) $，则 $\boldsymbol{w}=\left[ \mathrm{Pr}\left( P_1 \right) ,\mathrm{Pr}\left( P_2 \right) ,\cdots ,\mathrm{Pr}\left( P_N \right) \right] ^T$，再令 $\boldsymbol{B}_i=\left[ \mathrm{Pr}\left( P_i\mid P_1 \right) ,\mathrm{Pr}\left( P_i\mid P_2 \right) ,\cdots ,\mathrm{Pr}\left( P_i\mid P_N \right) \right] $，则有：</p><script type="math/tex; mode=display">w_{i}=B_i\cdot \boldsymbol{w}</script><p>特别地，当 <em>i</em> 取遍 1 到 N 的所有值后， 得到矩阵形式：</p><script type="math/tex; mode=display">\boldsymbol{w}=B\cdot \boldsymbol{w}</script><p>其中 <em>B</em> 称作<strong>标准化链接矩阵</strong>，矩阵中的每个元素代表列号对应的 Page 链入行号对应的 Page 的概率，每列之和为 1。当一个页面没有链出时，这一列全为 0。</p><p>于是我们可以用<strong>迭代</strong>方法求解这个方程的稳定解 $\boldsymbol{w}_k$​​​——即我们想求的访问概率向量，也就是<strong>重要度</strong>向量。只需要将 $\boldsymbol{w}_0$​​​ 设为全 1 向量（因为一开始随机访问到每个页面的概率都相同），不断代入即可。</p><h3 id="阻尼迭代-PageRank-with-Damping"><a href="#阻尼迭代-PageRank-with-Damping" class="headerlink" title="阻尼迭代 | PageRank with Damping"></a>阻尼迭代 | PageRank with Damping</h3><p>然而，现在存在的问题是，上面的所有推导都是建立在理想状态下的，即假设所有网页组成的这个有向图是<strong>强连通</strong>的。</p><p>当 Hyperlink Graph 存在 link loops (<strong>循环陷阱</strong>)，即存在一个小的子图，只有链入没有链出，所有随机游走的用户到了这几个网页后，就如同进了黑洞一般，一直在里面“打转”，出不来了。</p><p>这样就使得当游走次数趋于无穷时，最终陷阱中结点的访问次数远大于其他结点。这样会使得计算出的 $\boldsymbol{w}$ 向量中，陷阱外的结点访问概率都为 0。</p><p>PageRank 算法最终采用了<strong>阻尼因子</strong>（damping factor）的修正，使得进入陷阱后仍有机会跳出循环。</p><script type="math/tex; mode=display">\boldsymbol{w}_k=d\boldsymbol{w}_0+\left( 1-d \right) B\cdot \boldsymbol{w}_{k-1}</script><p>其中 $\boldsymbol{w}_0$​ 为全 1 向量，<em>d</em> 是实验确定的常数，通常取 0.15。</p><h3 id="结合相关度-Combined-Method"><a href="#结合相关度-Combined-Method" class="headerlink" title="结合相关度 | Combined Method"></a>结合相关度 | Combined Method</h3><p>有了重要度向量后，当有查询时，我们只需要先确定<strong>命中文档</strong>（至少有一个 term 与 query 相同的文档），再将其用重要度排序即可。</p><p>然而，这样做的缺点是，没有考虑到查询和文档的相关性——即，有可能一篇文档虽然有相同的 term，但主题却相去甚远。</p><p>于是，有人提出了结合 Term Weighting 和 PageRank 的方法，在确定命中文档后，利用传统的权重计算方法，计算出 query 和每个 doc 的相似度 $s_j$。再和重要度 $p_j$​ 线性加权算出排序指标：</p><script type="math/tex; mode=display">c_j=\lambda s_j+\left( 1-\lambda \right) p_j</script><p>其中 $\lambda$​ 为实验确定的常数。</p><h3 id="PageRank-算法缺点"><a href="#PageRank-算法缺点" class="headerlink" title="PageRank 算法缺点"></a>PageRank 算法缺点</h3><ol><li><p>忽略了查询，则忽略了 query 和 doc 主题相关性，导致结果的相关性降低。</p></li><li><p>没有过滤广告链接和功能链接（例如常见的分享链接）。这些链接通常没有什么实际价值，前者链接到广告页面，后者常常链接到某个社交网站首页。</p></li><li><p>对新网页不友好。因为即使是非常好的新页面也不会有很多链入，要成为一个高重要度的页面仍需要很长时间的推广。</p></li></ol><h2 id="主题敏感-PR-Topic-Sensitive-PageRank"><a href="#主题敏感-PR-Topic-Sensitive-PageRank" class="headerlink" title="主题敏感 PR | Topic-Sensitive PageRank"></a>主题敏感 PR | Topic-Sensitive PageRank</h2><p>在实际的网络中，PageRank 算法还存在「<strong>主题漂移</strong>」问题，特别对于大量随意交互外链的站点，会导致搜索引擎返回主题无关结果。</p><p>同时，前面的讨论提到，PageRank 忽略了 query 的主题相关性，也导致了结果的相关性降低。同一查询词在<strong>不同语境</strong>下，语义上指向的可能是不同的主题，但 PageRank 无论如何都是返回「重要度」最高的页面。</p><p>理想情况下，应为每个用户的偏好维护一套专用的「主题重要度」向量，但面对海量用户这种方法显然不可行。所以搜索引擎一般会选择一种称为主题敏感的折中方案。</p><h3 id="基本思想-Basic-Idea"><a href="#基本思想-Basic-Idea" class="headerlink" title="基本思想 | Basic Idea"></a>基本思想 | Basic Idea</h3><p><strong>基本假设</strong>：在 PageRank 的随机游走模型中，用户倾向于选择具有<strong>同一个主题</strong>的链出网页。</p><p>基于这个假设，可以预定义几个话题类别，例如体育、娱乐、科技等等，对于某个网页来说，对应某个主题类型都有相应的 PageRank 分值，然后想办法关联用户的话题倾向，根据用户的话题倾向排序结果。</p><h3 id="矩阵形式-Matrix-Form"><a href="#矩阵形式-Matrix-Form" class="headerlink" title="矩阵形式 | Matrix Form"></a>矩阵形式 | Matrix Form</h3><p>与原始的 PageRank 不同，新的算法对出度为 0 的网站加以处理以保证<strong>收敛性</strong>。引入了向量 $\boldsymbol{d}$​​​ 来指示某一个网页是否出度为 0，若为 0 则对应项为 1。</p><script type="math/tex; mode=display">d_{i}= \begin{cases}1 & \text { if } \operatorname{deg}(j)=0 \\ 0 & \text { otherwise }\end{cases}</script><p>向量 $\boldsymbol{p}$ 来表示访问各个网页的概率均等，代替 $\boldsymbol{w}_0$​ 的写法：</p><script type="math/tex; mode=display">\boldsymbol{p}=\left[\frac{1}{n}\right]_{n \times 1}</script><p>两个矩阵的乘积所得的矩阵 <em>D</em> 表示出度为 0 的网页将以均等概率访问其他网页。与前述提到的矩阵 $B$​​ 具有互补的特性，补充了在随机游走模型中，一个网页出度为 0 时的访问页面的情况。这样做使得最终矩阵的每一列之和都为 1。</p><script type="math/tex; mode=display">D=\boldsymbol{p} \times \boldsymbol{d}^{T}</script><p>则最终排名的计算方法为：</p><script type="math/tex; mode=display">\boldsymbol{Rank} =d \boldsymbol{p} + (1-d)(B+D) \cdot  \boldsymbol{Rank}</script><h3 id="偏置向量-ODP-Biasing"><a href="#偏置向量-ODP-Biasing" class="headerlink" title="偏置向量 | ODP-Biasing"></a>偏置向量 | ODP-Biasing</h3><p>主题的预定义参考了 <a href="www.dmoz.org">ODP</a> (Open Directory Project) 网站，利用 ODP 中 16 个顶级分类下的 URLs 生成了 16 组偏置 PageRank 向量 (biased PageRank vectors)。</p><p>为了实现这一点，算法中采用了新的向量 $\boldsymbol{v_j}=\boldsymbol{p}$，针对每个主题有：</p><script type="math/tex; mode=display">v_{j i}=\left\{\begin{array}{cl}\frac{1}{\left|T_{j}\right|} & i \in T_{j} \\0 & i \notin T_{j}\end{array}\right.</script><p>其中 $T_{j}$​ 表示在契合第 <em>j</em> 个主题的网页集合。包含在这些网页中的页面被赋予较大的跳转概率值，而其他网站则相对减少。</p><h3 id="查询打分-Query-Time-Importance-Score"><a href="#查询打分-Query-Time-Importance-Score" class="headerlink" title="查询打分 | Query-Time Importance Score"></a>查询打分 | Query-Time Importance Score</h3><p>此外，还需要在给定一个查询 <em>q</em> 的时候，估算出该查询落在某个主题 $c_j$ 的概率。文章使用了<strong>朴素贝叶斯分类器</strong>（naive-Bayes classifier），将查询 <em>q</em> 中的每个 term 分词记作 $q_i$，利用贝叶斯公式：</p><script type="math/tex; mode=display">P\left(c_{j} \mid q\right)=\frac{p\left(c_{j}\right) \cdot P\left(q \mid c_{j}\right)}{P\left(q\right)} \propto P\left(c_{j}\right) \cdot \prod_{i} P\left(q_{i} \mid c_{j}\right)</script><p>而 $P\left(q_{i} \mid c_{j}\right)$ 则容易用统计的方法估计出来，对于 $P\left(c_{j}\right)$​ 则采用<strong>先验概率</strong>的方法，根据用户的查询历史（上下文）进行动态调整。</p><p>计算出了查询落在各个主题的概率后，再用这个概率对各个主题下的 <strong><em>Rank</em></strong> 向量进行线性加权，即可得到最终排序用的评分：</p><script type="math/tex; mode=display">s_{q d}=\sum_{j} P\left(c_{j} \mid q^{\prime}\right) \cdot r_{j d}</script><h2 id="HITS-Hyperlink-Induced-Topic-Search"><a href="#HITS-Hyperlink-Induced-Topic-Search" class="headerlink" title="HITS: Hyperlink-Induced Topic Search"></a>HITS: Hyperlink-Induced Topic Search</h2><p>这里再介绍一种基础的网页排序算法——基于超链接追敏的主题排序，对于一个查询，不再返回单一的网页排名，而是同时返回两个列表：</p><ul><li>包含链接的 Hub 网页，收录了主题相关的权威网页链接。</li><li>包含内容的 Authority 网页，有着与主题相关的高质量内容。</li></ul><p>那么，如何排序这两个列表呢？</p><p><strong>基本假设</strong>：</p><ul><li>一个好的 Hub 网页指向该主题的许多 Authority 网页。</li><li>一个好的 Authority 网页被许多好的 Hub 网页指向。</li></ul><p>基于这两个假设，我们可以提出两个指标来衡量每个页面：枢纽值（Hub Scores）和权威值（Authority Scores），这两种值是互相依存、互相影响的。</p><ul><li>枢纽值，指的是页面上所有出链指向页面的权威值之和。</li><li>权威值，指的是页面的所有入链所在的原页面的枢纽值之和。</li></ul><h3 id="算法步骤-HITS-Algorithm"><a href="#算法步骤-HITS-Algorithm" class="headerlink" title="算法步骤 | HITS Algorithm"></a>算法步骤 | HITS Algorithm</h3><ol><li><p>找出 root set：根据用户 query 中的 term，在文档集中找出包含至少一个 term 的的文档，使他们构成 root set。</p></li><li><p>找出 <strong>base set</strong>：在 root set 的基础上，找出集合中网页链入或链出并且不在 root set 中的网页，并把他们加入到集合中，从而构成 base set。</p></li><li>计算每一个网页的枢纽值 h(x) 和权威值 a(x)，初始时，所有 h 值和 a 值均为 1。</li><li><strong>迭代</strong>更新两个值直至收敛。为了防止两个值太大，可以在每次迭代后归一化。归一化的指标不重要，因为我们只关注相对排名。</li><li>返回两个值分别排序的列表。</li></ol><h3 id="HITS-算法缺点"><a href="#HITS-算法缺点" class="headerlink" title="HITS 算法缺点"></a>HITS 算法缺点</h3><ol><li>尽管限制了计算对象在 base set 中，但在线计算效率还是太低，不如 PR 快。</li><li>主题漂移现象仍未解决。如果在集合里包含与查询主题无关的页面，且含有大量相互链接，可能会排到前列。这种现象被称为<strong>紧密链接社区</strong>现象。</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #8 倒排索引模型</title>
    <link href="/IR-Note-8.html"/>
    <url>/IR-Note-8.html</url>
    
    <content type="html"><![CDATA[<p>文件组织架构，也称 index (索引)，常用于提升一个检索系统的性能。</p><p>回顾向量空间模型，我们知道在查询时，命中的 doc 应该是与 query 最为相近的几个向量。当查询时，若只在所有<strong>可能相似的文档</strong>（至少含有一个 query 中的关键词）中查找，可以大大减少资源浪费。</p><p>那么就需要先得到 query 中各个 term 出现过的文档，再取<strong>并集</strong>，最后在并集中进行相似度的计算——「<strong>过滤</strong>」思想。</p><p>此时用特殊的索引方式，就可以更快地实现文档的过滤。有人提出 Hash 的设想，但是 Hash 的缺点在于不能模糊匹配，当用户的 Query 和词典中的 term 略有差距时，可能在 hash table 中会相距十分遥远。</p><h2 id="倒排文件-Inverted-Files"><a href="#倒排文件-Inverted-Files" class="headerlink" title="倒排文件 | Inverted Files"></a>倒排文件 | Inverted Files</h2><p>我们通过一组对比，引入「<strong>倒排</strong>」的概念：</p><ul><li>正排索引：已知文档 doc，得到 doc 的 所有 term 的位置序列，实现方式是「文档编号 + term 数组」</li><li>倒排索引：已知 term，找到包含 term 的文档 d1, d2, d3… 实现方式是「term做键的字典，值是文档编号数组」</li></ul><p>由此我们可以得到倒排文件组织架构的<strong>构成</strong>：</p><ul><li>Index file：索引文件，以<strong>词典</strong>（Lexicon）的形式存储词项，链接到 Posting file 的空间。</li><li>Postings file：记录文件，以倒排表的形式存储每个 term 对应在 Doc file 中的df、tf、DocID、pos 等相关信息。 </li><li>Document file：文档文件，存储所有文档。</li></ul><p>有了上述的架构，当用户输入 query 时，我们可以提取出 term，直接访问对应的 Index file，再根据链接来到 Posting file。对于多个 term，可以先完成交、并等逻辑运算，得到结果后，再去访问过滤后的文档集。</p><h2 id="构建倒排文件"><a href="#构建倒排文件" class="headerlink" title="构建倒排文件"></a>构建倒排文件</h2><p>由此，我们可以知道当爬取到新的文档时，构建索引的步骤：</p><ol><li>Tokenizer：提取 token 流。</li><li>Linguistic modules：规范化，得到 term 集合。</li><li>Indexer：在对应的 term 键值下新增该文档的编号。</li></ol><h3 id="文档解析-Document-Parsing"><a href="#文档解析-Document-Parsing" class="headerlink" title="文档解析 | Document Parsing"></a>文档解析 | Document Parsing</h3><p>接下来介绍搜索引擎如何解析一个新爬取到的文档，这个过程往往是离线进行的（在线进行的是用户查询过程）。</p><p>而由于文档的多样性，往往解析过程中会面临各式各样的问题：文件格式、各国语言、字符编码、停用词等。这些问题往往用<strong>启发式</strong>（heuristically）的方法解决。</p><ul><li>断词、标记化 | Tokenization</li></ul><p>Token 来自文档的原始字符串，是根据空格划分提取出的原始单词。在实际中，要考虑：是否保留 \’s 、是否保留连字符、专有名词是否拆开、数字嵌入等子问题。</p><p>而针对不同语言，也有更多新的问题：法语中大量的 \’ 使用、德语中名词复合现象、中文日文不适用空格分词、日语的平假片假、阿拉伯语的书写次序等。</p><ul><li>停用词 | Stop words</li></ul><p>在文本中，往往还需要把最频繁出现的无意义词停用。在文档解析中，如何利用停用词进行压缩空间？在查询优化中，如何判别停用词？当停用词有意义时，如何识别？这些都是需要考虑的问题。</p><ul><li>标准化词项 | Normalization</li></ul><p>在英语中，通常时以定义「<strong>等价集</strong>」（equivalence classing）来归并词项。通常将单词归并到其原型，而对于特殊的单词有特殊的规则，例如规定 “U.S.A.” 归并于 “USA”，规定 “anti-discriminatory” 归并于 “antidiscriminatory”。</p><p>对于有的单词，不同形式可能含有不同语义，例如 window/windows/Windows。此时在查询时可以先做<strong>不对称展开</strong>（asymmetric expansion），对展开项搜索后取并集。</p><ul><li>辞典和探测法纠错 | Thesauri &amp; Soundex</li></ul><p>主要针对 Synonyms (同义词)、Homonyms (同形同音异义词)，这种情况下也可以利用等价集和不对称展开解决。</p><p>此外，当用户查询中有英文拼写错误时，常用的方法是 Soundex (探测法)，返回同音字串。Soundex 是基于语音启发式方法生成的<strong>语音等价集</strong>。这种方法在汉语拼音中同样有很大应用。</p><ul><li>词干分析与词形还原 | Stemming &amp; Lemmatization</li></ul><p>将单词的名词、动词、形容词等形式统一归并到<strong>词根</strong>，将单复数、人称所有格、时态等统一归并到<strong>原型</strong>。</p><h3 id="文档文件-Document-file"><a href="#文档文件-Document-file" class="headerlink" title="文档文件 | Document file"></a>文档文件 | Document file</h3><p>解析完文档后，我们可以将新的文档直接存入文档集，也可以利用<strong>摘要生成</strong>技术生成 Surrogates (文档替代品)，减少存储空间。</p><p>此外，当我们搜索到页面文档时，其文件格式可能各不相同，如 HTML、XML 等，故检索到网页后还需要进行 Page Purifing (文档净化)，从而获得便于识别的文本文档和内部链接。</p><h3 id="记录文件-Posting-File"><a href="#记录文件-Posting-File" class="headerlink" title="记录文件 | Posting File"></a>记录文件 | Posting File</h3><p>之前的文章介绍过，用于连接 term 和 doc 的词典表往往是个稀疏矩阵。而倒排文件用<strong>链表</strong>的形式存储每一行的内容，即包含此 term 的所有 doc 及其基本信息，串接而成。链表中的每个元素称为一个 posting (记录)。</p><p>其中，基本信息可以包含：Document ID (文档的唯一标识)、Location Pointer (该文档在 Doc file 中的位置)、原始的权重因子。</p><p>存储原始的权重因子，是为了在查找的时候更方便的计算词项权重。可以包括 df、tf、最大频度、总文档数等等。</p><p>此外，链表中的元素以 Doc ID 排序，这样存储有利于多页倒排表的<strong>合并</strong>匹配。</p><h3 id="索引文件-Index-File"><a href="#索引文件-Index-File" class="headerlink" title="索引文件 | Index File"></a>索引文件 | Index File</h3><p>索引文件通常以词典的形式存储 term ID、含有该 term 的文档数以及该 term 在记录文件中的位置（指针）。</p><p>以下列出几种常用的索引文件组织形式：</p><ul><li><p>Linear Index | 线性索引</p></li><li><p>Binary Tree | 二叉树</p></li><li><p>Right Threaded Binary Tree | 右索二叉树</p></li><li><p>B-trees | B树</p></li><li><p>B+-tree | B+树</p></li><li>Tries | 搜索树</li></ul><h2 id="特征选取-Feature-Selection"><a href="#特征选取-Feature-Selection" class="headerlink" title="特征选取 | Feature Selection"></a>特征选取 | Feature Selection</h2><p>前文提到，在解析一篇文档获得索引时，最简单的方法就是先提取 token，再获得 term 作为索引。而在真正高效的索引模型（Index Model）中，往往要先对文档进行<strong>特征选取</strong>，从而构成索引。</p><p>而特征选择问题，可以转化为词项权重（term weighting）计算，一篇文档中权重较大的 term 往往更能表示这篇文档。</p><h3 id="词项频率-TF"><a href="#词项频率-TF" class="headerlink" title="词项频率 | TF"></a>词项频率 | TF</h3><p>在前面的文章中有提到，tf 及其衍生的权重计算方法，是 IR 模型中最常用的权重计算方法。这里就不再重复介绍，仅提及一个有趣的定理 <code>Zipf&#39;s Law</code>。</p><p>该定理描述了如下现象：在一个大的文档集中，统计出各个词项的 tf 排名后，记排名为 <em>r</em>，频率为 <em>f</em>，则有</p><script type="math/tex; mode=display">f\cdot r\approx \mathrm{const}</script><p>而在实际中，排名最高的词项通常都是停用词，最「<strong>重要</strong>」的词往往词频不是很高，而最罕见的词往往没有普遍价值。这也与 <em>tf·idf</em> 的思想契合，下图说明了这一点。</p><p>在倒排文档中，移除停用词和罕见词、保留重要词，可以节约大量的记录空间。</p><p><img src="/img/blog/IR-Note-8-images/index_tf.png" alt="词项频率与重要度的关系" style="zoom:67%;" /></p><h3 id="索引规模-Index-Scale"><a href="#索引规模-Index-Scale" class="headerlink" title="索引规模 | Index Scale"></a>索引规模 | Index Scale</h3><p>对于一个确定大小的文档集，需要多少词项才能很好的索引全部文档呢？这便是根据文档集大小确定词典大小（Lexicon Size）的问题。<code>Heap&#39;s Law</code> 对此进行了估算：</p><script type="math/tex; mode=display">n=|V|=K \cdot N^{\beta} \text { with constants } K, 0<\beta<1</script><p>其中，<em>K</em> 通常取 10 到 100 间的整数，$\beta$​​​ 通常取 0.4 到 0.6 之间的小数。绘制出的图如下：</p><p><img src="/img/blog/IR-Note-8-images/index_scale.png" alt="索引规模的变化曲线" style="zoom:50%;" /></p><h3 id="词项判别模型-Term-Discrimination-Model"><a href="#词项判别模型-Term-Discrimination-Model" class="headerlink" title="词项判别模型 | Term Discrimination Model"></a>词项判别模型 | Term Discrimination Model</h3><p>在一个向量空间中，文档由<strong>基向量</strong>加权构成的向量表示。</p><p>我们可以计算文档之间的相似度，相似度越高，代表空间越紧凑，反之则越松散。计算文档集两两之间的相似度需要 $O(n^2)$ 的复杂度。</p><p>当然，如果先计算出一个「<strong>平均文档</strong>」，再计算其他文档与其的相似度，则只需要 $O(n)$​ 的复杂度。</p><p>词项判别模型则是通过<strong>引入</strong>一个新的 term 作为基向量，观察相似度的变化分析该 term 的重要性。大致的思想是：</p><ul><li>如果一个 term 引入后，向量空间变松散了，则说明这个 term 有效的区分了不同文档，这个词通常是<strong>中频词</strong>（重要词）。</li><li>如果一个 term 引入后，向量空间没有变化，则说明这个 term 没有太大价值，这个词通常是<strong>低频词</strong>（罕见词）。</li><li>如果一个 term 引入后，向量空间变紧凑了，则说明这个 term 将文档同一化了，这个词通常是<strong>高频词</strong>（停用词）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #7 IRLbot</title>
    <link href="/IR-Note-7.html"/>
    <url>/IR-Note-7.html</url>
    
    <content type="html"><![CDATA[<p>本文是 WWW2008 最佳论文「IRLbot: Scaling to 6 Billion Pages and Beyond」的阅读报告。相关领域：网络信息检索。</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>随着验证 URL 唯一性的复杂度平方增长、BFS 爬行顺序和固定的每主机速率限制，现有的爬虫算法不能有效地应对在大型爬虫中产生的大量 URL、高度分枝的垃圾页面（highly-branching spam）、数百万页博客站点以及服务器端脚本（server-side scripts）产生的无限循环。作者提供了一组处理这些问题的技术，并在称为 IRLbot 的实现中测试它们的性能。</p><p><strong>关键词</strong>：IRLbot, large-scale, crawling</p><h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>作者称本文不是针对数据挖掘器，而是致力于设计能够适应<strong>当前和未来网络规模</strong>的网络爬虫：从一个给定的 seed URL 集合开始，递归地访问集合中的页面，并在这个过程中动态地改变下载顺序，最终可以下载到所有有用的网页；同时，在下载的过程中，无论规模多大，都应当保持一定的速度。</p><p>当然，还有以下考虑：爬虫需要限制对于单一网站、单一服务器的访问频率（礼貌策略），避免陷入垃圾网站和服务器端脚本产生的无限循环。</p><p>具体而言，作者提出了三类问题：</p><h3 id="规模扩展问题-Scalability"><a href="#规模扩展问题-Scalability" class="headerlink" title="规模扩展问题 | Scalability"></a>规模扩展问题 | Scalability</h3><p>每个爬虫系统都必须面对一个固有的取舍：在处理规模（<strong>scalability</strong>）、性能（performance）和硬件资源使用（resource usage）三者中做出权衡。</p><p>一般来说，较大的规模将导致较低的性能与较高的资源使用，较高的性能需要降低规模与增加资源使用。因而，大多数爬虫只能兼顾三者之二（大型慢速爬虫、小型快速爬虫，大型快速却需要占用大量资源的爬虫）。</p><p>本文希望在给定性能标准和硬件资源的情况下，研究规模的扩展问题。</p><h3 id="网站信誉与垃圾网站问题-Reputation-and-Spam"><a href="#网站信誉与垃圾网站问题-Reputation-and-Spam" class="headerlink" title="网站信誉与垃圾网站问题 | Reputation and Spam"></a>网站信誉与垃圾网站问题 | Reputation and Spam</h3><p>与早期的网络相比，如今的网络已发生了很大变化，主要是在服务器端脚本生成的动态网站和垃圾网站两个方面。二者性质不同，却都给爬虫带来了一个新的挑战：必须要有一种在爬虫爬取网页的过程中实时决定<strong>哪些站点包含有用信息</strong>、实时<strong>决定爬取优先级</strong>的方法。</p><p>因为，传统的广度优先搜索往往会由于以下原因而降低效率：</p><ul><li>来自垃圾网站 URL 分支过多，甚至可能取代合法的 URL；</li><li>单个域名中动态创建新主机名，DNS 解析不及；</li><li>来自网页的延迟攻击，故意在来自爬虫程序 IP 地址的所有请求中引入 HTTP 和 DNS 延迟。</li></ul><h3 id="礼貌问题-Politeness"><a href="#礼貌问题-Politeness" class="headerlink" title="礼貌问题 | Politeness"></a>礼貌问题 | Politeness</h3><p>网络爬虫对某一服务器的频繁访问，往往会对服务器的正常性能造成影响，因而也容易招致服务器的拒绝访问或是举报、诉讼，因而需要对爬虫设置一定速度的限制。</p><p>直接给爬虫设置这种对单一服务器、单一 IP 地址的访问速度限制并不复杂，却容易导致爬虫的效率在特定情况下（待爬取的 URL 只来自于极少的几个服务器或 IP，由于限制不得不减慢速度）极大地降低效率。</p><p>因而需要设计一种可以避免这种情况的发生的爬虫。 </p><h2 id="解决规模扩展问题"><a href="#解决规模扩展问题" class="headerlink" title="解决规模扩展问题"></a>解决规模扩展问题</h2><h3 id="磁盘检查算法-Disk-check-Algorithms"><a href="#磁盘检查算法-Disk-check-Algorithms" class="headerlink" title="磁盘检查算法 | Disk-check Algorithms"></a>磁盘检查算法 | Disk-check Algorithms</h3><p>规模问题最终体现在使用 <code>URLseen</code> 确认 URL 的唯一性和使用 <code>RobotsCache</code> 检查 robot.txt 的符合上。此外，还要将新的 URL 再传递给 <code>URLseen</code> ，以及在必要时更新 <code>RobotsCache</code>。主要牵涉到磁盘与存储器的交互。</p><p>在先前的方法中，无论是使用 RAM 散列存储的 <strong>Mrcator-B</strong>，还是使用内存中二叉搜索树的 <strong>Ploybot</strong>，随着爬取规模的增大，执行这一步骤的开销都会快速增长。为了降低这一开销，需要一种更有效的数据存储结构。 </p><h3 id="DRUM-Disk-Repository-with-Update-Management"><a href="#DRUM-Disk-Repository-with-Update-Management" class="headerlink" title="DRUM - Disk Repository with Update Management"></a>DRUM - Disk Repository with Update Management</h3><p>论文中提出了 DRUM 技术，这个技术结合了桶排序和哈希算法。</p><p>DRUM 的目的是允许高效地存储大量 <key, value> 对的集合，其中 key 是某些数据的唯一标识符（hash），value 是附加到密钥的任意信息。通过这样的设计，可以实现对大规模键值对数据的存储，并实现快速的检查（check）、更新（update）、检查＋更新（check+update）的操作。 </p><p>下图展示了 DRUM 的操作流程：</p><p><img src="/img/blog/IR-Note-7-images/DRUM.png" alt="DRUM" style="zoom:50%;" /></p><p>在该图中，一个连续的元组 <key, value, aux> 流到达了 DRUM，其中 aux 是与每个键相关联的一些辅助数据。随后被分割为 <key, value> 与 aux 两个部分，分入内存中的各桶，并在一次操作中将所有的桶中的 <key, value> 与磁盘存储阵列中的数据进行合并。此外，通过读取 cache <em>Z</em> 中的 $\varDelta$ 字块，并与桶中的 key 比较，可以确定其唯一性。</p><p>利用这一技术，在论文中的爬虫系统创建了多个存储模块，包括 <code>URLseen</code> 模块、<code>RobotsCache</code> 模块、<code>RobotsRequested</code> 模块、<code>PLDindegree</code> 模块，分别赋予元组一定的意义，赋予各模块特定的操作，以此大大提高系统规模化的效率。 </p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>论文中主要通过给定一系列参数来推导 <code>URLseen</code> 的开销，从而比较各种数据结构的优劣。参数定义及推导过程详见论文。</p><p>Mrcator-B：</p><script type="math/tex; mode=display">\omega(n, R)=\frac{2(H+P) p H}{R} n^{2}</script><p>Ploybot：</p><script type="math/tex; mode=display">\omega(n, R)=\frac{2(b+4 P) p b q}{R} n^{2}</script><p>DRUM：（论文中公式有两种情况）</p><script type="math/tex; mode=display">\omega(n, R)=n b\left(\frac{(H+b)(2 U H+p H n)}{b D}+2+p+\frac{2 H}{b}\right)</script><p>并做出了如下比较：</p><p><img src="/img/blog/IR-Note-7-images/DRUM2.png" alt="DRUM和其他模型的比较" style="zoom:67%;" /></p><p>可以看出 DRUM 模型的效率远超过原来两个模型。此外论文中还针对磁盘性能和平均爬虫效率（下载速率）做出了比较，这里不再赘述。</p><h2 id="解决垃圾网站问题"><a href="#解决垃圾网站问题" class="headerlink" title="解决垃圾网站问题"></a>解决垃圾网站问题</h2><h3 id="计算站点信誉-Computing-Domain-Reputation"><a href="#计算站点信誉-Computing-Domain-Reputation" class="headerlink" title="计算站点信誉 | Computing Domain Reputation"></a>计算站点信誉 | Computing Domain Reputation</h3><p>拥有大量动态网页的合法网站与制造大量垃圾网页的恶意网站（quickly branching site），都使得爬虫在礼貌性原则、DNS 查找以及爬取本身的限制下变得低效，也会浪费带宽下载许多无用的内容。</p><p>然而，由于互联网规模不断扩大，拥有同样有用大量网页的合法网站与恶意网站相互混杂，使得简单的<strong>限制分支因子</strong>或限制<strong>每个域名的最大 pages/hosts 数量</strong>，并不能合理的解决这个问题。而在之前的研究中，无论是 BFS 的爬取策略，还是 PageRank、BlockRank、SiteRank 算法，也极易使爬虫陷入到这种海量网站中。</p><p>事实上，严格的<strong>页面级排名</strong>对于控制大量分支垃圾网站并不是绝对必要的。作者发现可以通过根据<strong>域名信誉</strong>来判断网页类型、决定对某一域名的网站搜索的深度，域名信誉是根据垃圾网站必须付费的域名资源程度来确定的。</p><h3 id="STAR-Spam-Tracking-and-Avoidance-through-Reputation"><a href="#STAR-Spam-Tracking-and-Avoidance-through-Reputation" class="headerlink" title="STAR - Spam Tracking and Avoidance through Reputation"></a>STAR - Spam Tracking and Avoidance through Reputation</h3><p>论文指出，只要在「域名信誉」的基础上给每个 PLD (Pay-Level Domain) 分配「<strong>预算</strong>」，即可侦测出垃圾网站。论文在 PLD 这个较粗的粒度上进行“预算”的计算，流程如下图：</p><p><img src="/img/blog/IR-Note-7-images/STAR.png" alt="STAR" style="zoom:50%;" /></p><p>利用 DRUM 的存储结构，存储爬虫在爬去过程中得到的 PLD 网络图的信息，构造 <code>PLDindegree</code> 模块。通过模块中考察域名的链入数，为各个域名动态地分配“预算”，并按照“预算”指示单位时间内爬虫能够从该域名爬取多少新的链接，最终避免垃圾网站的困扰。</p><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>从理论上说，从其他 PLD 获得链入需要付出（金钱）代价，一般的垃圾网站在代价面前很可能不会获得高的“预算”，故使用这一方法来鉴别网站的质量。 </p><h2 id="解决礼貌问题"><a href="#解决礼貌问题" class="headerlink" title="解决礼貌问题"></a>解决礼貌问题</h2><h3 id="速率限制-Rate-Limiting"><a href="#速率限制-Rate-Limiting" class="headerlink" title="速率限制 | Rate Limiting"></a>速率限制 | Rate Limiting</h3><p>IRLbot 从一开始的主要目标之一就是在访问配置不佳（就带宽或服务器负载而言）的站点时遵守严格的速率限制策略。尽管较大的站点更难崩溃，但不受限制的访问频率往往也会被视为 DOS 攻击。</p><p>而在之前的研究中，简单地设置单个主机的访问延迟，可能会导致“多主机共用”的<strong>托管服务器</strong>崩溃，若设置单个服务器的访问延迟，又将大大降低效率，甚至可能在大规模的网页中最终无法正常工作。</p><p>另一方面，在已经得到各网站“预算”的情况下，若仅仅只是重复地扫描未爬取的链接队列并从中选取需要爬取的链接，只能在高昂的花费下得到极少的有用链接。因而需要想办法更有效地利用“预算”的结果给出爬取各网页的延迟，才能实现高效的爬虫。 </p><h3 id="BEAST-Budget-Enforcement-with-Anti-Spam-Tactics"><a href="#BEAST-Budget-Enforcement-with-Anti-Spam-Tactics" class="headerlink" title="BEAST - Budget Enforcement with Anti-Spam Tactics"></a>BEAST - Budget Enforcement with Anti-Spam Tactics</h3><p>此方法的目标不是丢弃 URL，而是<strong>延迟</strong>它们的下载，直到更多地了解它们的<strong>合法性</strong>。</p><p>大多数网站的排名较低是因为它们没有权重高的链入，这并不一定意味着它们的内容是无用的，或者它们属于垃圾网站。在所有其他条件相同的情况下，排名较低的域名应该以某种近似循环（round-robin）的方式爬取，并谨慎控制它们的分支。</p><p>此外，随着爬取的进行，域名会改变它们的声誉，而先前未通过预算检查的 URL 需要重新计算预算，并且以不同的速率爬取。</p><p><img src="/img/blog/IR-Note-7-images/BEAST.png" alt="BEAST" style="zoom:50%;" /></p><p>如图所示，在经过修正之后，论文给出了一种不需要依赖数据规模增大硬盘读写能力的实现方式: </p><p>将通过 STAR 赋予了一定预算的成批链接进行检查，将通过检查的、有较高预算的链接按照预算排名高低分到 <em>j</em> 个队列中，将暂时未通过检查的、只有排名的链接分到一个单独的队列 $Q_F$ 中；当前 <em>j</em> 个队列中的链接全部爬取完成后，重新检查队列 $Q_F$，并将其中通过检查的链接分到已有队列的两倍数量的队列中。</p><p>不断重复上述过程，不断动态地增加队列的数量，直至达到某些停止条件。用这种办法可以合理地决定网页的爬取顺序。 </p><h3 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h3><p>采取 BEATS 的办法，一方面保留了队列的不同优先级，使得队列 $Q_F$ 中具有较高预算的链接可以尽快地得到爬取；另一方面利用不断增长的 <em>j</em> 使得预算较低的链接不断地推迟被爬取的时机，实现爬取的延迟。 </p><h2 id="实验验证"><a href="#实验验证" class="headerlink" title="实验验证"></a>实验验证</h2><h3 id="模型构建"><a href="#模型构建" class="headerlink" title="模型构建"></a>模型构建</h3><p>在充分整合 DRUM, STAR, BEAST 技术之后，论文搭建形成了如图所示的爬虫系统 IRLbot。</p><p><img src="/img/blog/IR-Note-7-images/IRLbot.png" alt="IRLbot" style="zoom:50%;" /></p><p>并从 crawling threads 得到新链接开始，涉及到 URL 唯一性确认，“预算”的确认，robot.txt 的确认，“预算”的检查以及最终页面的下载，形成了一个完整的处理流程。 </p><h3 id="效率验证"><a href="#效率验证" class="headerlink" title="效率验证"></a>效率验证</h3><p>论文中提到，在 2007 年 6 月 9 日至 8 月 3 日的这段时间，IRLbot 运行在单一服务器上，并以 1GB/s 的速度连接互联网。最终在 41 天的运行过程中，爬取了 63 亿的页面。</p><p>此外，通过分析排名最高的 1000 个网站，发现其中的大部分网站都非常权威知名，这也说明了 STAR 信誉计算的有效性。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #6 网络信息检索</title>
    <link href="/IR-Note-6.html"/>
    <url>/IR-Note-6.html</url>
    
    <content type="html"><![CDATA[<p>随着互联网的兴起，Web 的增多，网络信息检索成为 IR 中的一大主题。</p><p>简要介绍以下几个相关概念：</p><ul><li>最广的是 Network ，一个物理层面的<strong>广义网络</strong>。</li><li>其次，是互联网。因特网和其他类似的由计算机相互连接而成的<strong>大型网络系统</strong>都可算是互联网，Internet 是互联网中最大的一个。</li><li>再者，是 Internet，即因特网。由许多小的<strong>子网</strong>互联而成的一个逻辑网，每个子网中连接着若干台计算机（主机）。</li><li>最后，是 Web，也称 World Wide Web，即万维网。它使用超文本技术将遍布全球的各种信息资源链接起来，以便于用户访问。Web 只是 Internet 上的一个<strong>应用层服务</strong>。</li></ul><h2 id="网络信息检索-Web-Search"><a href="#网络信息检索-Web-Search" class="headerlink" title="网络信息检索 | Web Search"></a>网络信息检索 | Web Search</h2><p><strong>Goal</strong> | 目标</p><p>Provide information discovery for large amounts of open access material on the web.</p><p><strong>Challenges</strong> | 挑战</p><ul><li><p>Volume of material — several billion items, growing steadily</p></li><li><p>Items created dynamically or in databases (deep web, about 150 times of web pages of surface web) </p></li><li><p>Great variety — length, formats, quality control, purpose, etc.</p></li><li><p>Inexperience of users — range of needs</p></li><li><p>Economic models to pay for the service — 订阅、广告、许可</p></li></ul><p><strong>Strategies</strong> | 策略</p><ul><li>Subject hierarchies (<strong>分类目录</strong>) + human indexing — 1st Generation</li><li>Web crawling (<strong>网页爬取</strong>) + automatic indexing — 2nd Generation</li><li>Human directed web crawling and automatic indexing — Mixed models</li></ul><p><strong>Components</strong> | 组成</p><ul><li>Web crawler: URL Server + <strong>Crawler</strong> + Store Server</li><li>Indexing system: URL Resolver + Indexer + <strong>Pagerank</strong> (离线网页排名算法)</li><li>Search system: Sorter + Searcher (在线检索服务)</li></ul><h2 id="网络爬虫-Web-crawler"><a href="#网络爬虫-Web-crawler" class="headerlink" title="网络爬虫 | Web crawler"></a>网络爬虫 | Web crawler</h2><p>Web crawler，也称 Web spider，用于下载网页的一种程序。只要给出 seed URLs (Uniform Resource Locator) 的初始集，就可以<strong>递归地</strong>（recursively）根据集合中的链接下载更多的页面。有两种特殊的爬虫：</p><ul><li><p>Focused web crawler，针对特定类别的网站的专业爬虫，需要分类方法支持。</p></li><li><p>Deep web crawler，针对动态网页的深网爬虫，需要脚本模拟动作支持。</p></li></ul><p>对于所有的爬虫，最重要的是抓取一个页面中的链接，扩充初始集。</p><p>此外，一个爬虫，还要考虑性能（爬取大量页面）、礼貌性（避免过载服务器、违法操作）、应对故障（破损链接、超时、爬虫陷阱）、搜索策略（DFS/BFS），存储网页（并行文件系统）等。</p><h3 id="礼貌性-Politeness"><a href="#礼貌性-Politeness" class="headerlink" title="礼貌性 | Politeness"></a>礼貌性 | Politeness</h3><p>「恶意爬虫」往往会在短时间内大量访问同一个站点，造成 DDoS 攻击（Distributed denial of service attack，分布式拒绝服务攻击），进而导致网站的瘫痪。此外，还存在非法爬取私人信息、非法收集数据等行为。</p><p>为了在法律上限制爬虫，有以下的协议：</p><p><strong>Robots Exclusion Protocol</strong>：网站管理者可以注明该网站的哪些路径是不可被爬虫访问的，这些协议会体现在 <a href="http://.../robots.txt">http://.../robots.txt</a> 中。</p><p><strong>Robots META tag</strong>：HTML 作者可以注明该页面中的文件不可被索引，或该页面不可被用于解析以获得更多链接。只需要在 HTML 文本中添加以下命令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robots&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;noindex, nofollow&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="爬虫性能-Performance"><a href="#爬虫性能-Performance" class="headerlink" title="爬虫性能 | Performance"></a>爬虫性能 | Performance</h3><p>爬虫面向的信息往往是极庞大的，超过了一台机器的性能范围。现实中，通常采用<strong>并行分布式</strong>爬虫，将任务量划分到各台机器。那么如何分配任务才能使得各台机器承受的压力均匀呢？</p><h4 id="Distributing-the-Workload"><a href="#Distributing-the-Workload" class="headerlink" title="Distributing the Workload"></a>Distributing the Workload</h4><p>首先可以将机器编号 0 至 N-1，再对一个 URL 的主域名（Domain name）做<strong>哈希</strong>，得到一个 0 至 N-1 的值，并分配到对应机器。这样做的好处有：</p><ul><li>同一域名只在一台机器上访问，这样就可以防止多台机器<strong>同时访问</strong>了同一域名（避免对其造成 DoS 攻击）。</li><li>不需要主服务器的分配，减少了机器间的沟通，主域名下的子域名全在同一台机器中。</li><li>每台机器有独立的 DNS cache (域名缓存)，可以提高查询效率。</li></ul><h4 id="Software-Hazards"><a href="#Software-Hazards" class="headerlink" title="Software Hazards"></a>Software Hazards</h4><p>此外，要提高爬虫的性能，还要实现软件故障的处理：</p><ul><li>过慢、无应答的 DNS/HTTP 服务器</li><li>过大、无限大的页面（自动填充型）</li><li>无限的链接（随时间变化的路径）</li><li>破损的 HTML 页面</li></ul><h4 id="Extract-Links"><a href="#Extract-Links" class="headerlink" title="Extract Links"></a>Extract Links</h4><p>抓取页面中的链接、解析页面中的链接也会遇到许多难题：</p><ul><li>相对路径、绝对路径</li><li>CGI (Common Gateway Interface, 公共网关接口) 动态生成的页面</li><li>Server-side 服务端脚本</li><li>隐藏在 JavaScript 代码中的链接</li></ul><h2 id="爬虫架构-Crawler-Architecture"><a href="#爬虫架构-Crawler-Architecture" class="headerlink" title="爬虫架构 | Crawler Architecture"></a>爬虫架构 | Crawler Architecture</h2><p>接下来介绍一种经典的<strong>分布式</strong>爬虫架构 <code>High performance large scale web spider architecture</code>。</p><p><img src="/img/blog/IR-Note-6-images/WebCrawler1.png" alt="爬虫架构" style="zoom:67%;" /></p><ul><li><strong>URL Manager</strong></li></ul><p>存放所有访问过的 URL 记录，以及待访问队列。</p><ul><li><strong>Pool of data collector</strong></li></ul><p>数据收集池，按照 URL Manager 分配的序列访问网页，内部通常由多台机器多线程地收集网页数据。</p><ul><li><strong>Set of filters</strong></li></ul><p>实现数据统计、页面索引、链接提取的功能，并返回新的连接到 URL Manager。</p><ul><li><strong>Storage manager</strong></li></ul><p>负责压缩、解压缩、存储、检索数据。</p><ul><li><strong>Communicator</strong></li></ul><p>通信器，将新找到的页面和找到它的页面连接，完成 URL 去重等任务。</p><p><img src="/img/blog/IR-Note-6-images/WebCrawler2.png" alt="工作流程"></p><h3 id="URL-队列-URL-Frontier"><a href="#URL-队列-URL-Frontier" class="headerlink" title="URL 队列 | URL Frontier"></a>URL 队列 | URL Frontier</h3><p>URL Frontier 维护了一个包含大量 URL 的队列，并且每当有爬虫线程寻找 URL 的时候，它都会按照某种顺序重新排序。以何种顺序返回队列中的 URL，需要有两个方面的考虑：</p><ul><li>第一个要考虑的是具有很高更新频率的高质量页面，即<strong>页面的优先级</strong>。一个页面的优先级权值应该是由它的改变频率和它本身网页质量（使用一些恰当的质量评估方法）共同决定的。</li><li>第二个要考虑的就是<strong>礼貌策略</strong>：我们必须避免在很短的时间间隔内重复抓取同一个主机。因此，如果URL队列被设计成简单的优先级队列的话，可能会造成对某一主机的大量的访问请求。</li></ul><p><img src="/img/blog/IR-Note-6-images/URL_Frontier.png" alt="URL队列工作流程"></p><p>上图展示了一个基于<strong>礼貌性和权值策略</strong>的URL队列的实现。它的目标是确保：</p><ul><li>每次只有一个连接去访问一台主机；</li><li>连续对同一个主机的访问请求之间存在几秒钟的等待时间；</li><li>具有高优先级的页面将会被优先爬取。</li></ul><p>其中有两个重要的子模块，前部分的 Front 队列集合 F，以及后部分的 Back 队列集合 B。这两种队列均是 FIFO 队列。</p><p>Front 队列实现了对权值相关处理，而 Back 队列实现了对礼貌策略的相关处理。在一条 URL 被添加到队列的过程中，它将会先后穿越 Front 和 Back 队列。</p><p>首先，权值计算器会给该 URL 分配一个介于 1 和 F 之间的整数权值，再进入相应的 Front 队列，具有<strong>很高更新频率</strong>的文档（如新闻页面）将会被赋予一个很高的权值（通过启发式方法）。而后高权值对应的 Front 队列也会更高频率的吞吐 URL。</p><p>此外，我们需要维护一个<strong>堆</strong>，堆里存放着的条目对应每一个 Back 队列，该条目记录着该队列所对应的主机可以再次被连接的最早时间。注意：每个队列仅对应一个主机，即满足分布式的要求。</p><p>请求获取 URL 的爬虫线程会抽取出<strong>堆顶元素</strong>（时间最早者），然后一直等到相应时间后访问之。从而避免访问频率过高。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #5 检索系统评价</title>
    <link href="/IR-Note-5.html"/>
    <url>/IR-Note-5.html</url>
    
    <content type="html"><![CDATA[<p>前述文章介绍了几种基本信息检索模型，本文将介绍如何评价一个现有的文档检索系统。</p><h2 id="Evaluation-in-Document-Retrieval"><a href="#Evaluation-in-Document-Retrieval" class="headerlink" title="Evaluation in Document Retrieval"></a>Evaluation in Document Retrieval</h2><p>一个检索系统的好坏，通常取决于其检索结果与用户查询的相关性，此外还有检索用时、检索范围等等。这里仅针对评价相关性展开讨论。</p><h3 id="相关性-Relevance"><a href="#相关性-Relevance" class="headerlink" title="相关性 | Relevance"></a>相关性 | Relevance</h3><p>如何度量相关性？考虑如下三个待实现的要素：</p><ul><li><p>A <strong>benchmark</strong> document collection (基准文档集)</p></li><li><p>A <strong>benchmark</strong> suite of queries (基准查询集)</p></li><li><p>A <strong>usually binary assessment</strong> of either Relevant or Nonrelevant for each query and each document (对基准查询结果打分)</p></li></ul><p>当然，这个「打分标准」可能会随每个人的<strong>信息需求</strong>而变化（the information need is <strong>translated</strong> into a query），因此这个指标不是确定的（more than binary）。</p><p>有了以上三个基本要素，我们就可以构造出一个合理的<strong>测试集</strong>：包含文档集、查询集和有关评价机制。</p><h3 id="测试集-Test-collections"><a href="#测试集-Test-collections" class="headerlink" title="测试集 | Test collections"></a>测试集 | Test collections</h3><p>在制定测试集的时候，往往要先标注好相关的「查询-文档」对。对于小的测试，可以采用人工标注（遍历文档集和查询集）。</p><p>但对于较大的测试集则不行（如 TREC 测试集）。此时，可以采用如下方法：</p><ul><li>Pooling | <strong>池化</strong></li></ul><p>直接用已有的几个检索系统在「总的基准文档集」中检索，取出每个检索的前 n 个结果，取<strong>并集</strong>，用这个「新的集合」作为「模拟基准文档集」进行标注，这样就可以大大减少范围。</p><ul><li>Sampling | 抽样</li></ul><p>可以通过随机抽样估计真实相关集的大小。</p><ul><li>Search-based</li></ul><p>与其阅读所有的文档，不如人工用较宽泛的 Query 先得到一些检索结果，再在这些结果中标记。</p><h2 id="有效性度量-Effectiveness-measures"><a href="#有效性度量-Effectiveness-measures" class="headerlink" title="有效性度量 | Effectiveness measures"></a>有效性度量 | Effectiveness measures</h2><p>有了合理的测试集，只需要用待测试 IR 查询「基准查询集」的内容，对查询结果与「查询-文档」对比较，即可得到有效性度量。</p><p>以下介绍两个在度量有效性过程中常用的变量。</p><h3 id="精度和召回率-Precision-and-Recall"><a href="#精度和召回率-Precision-and-Recall" class="headerlink" title="精度和召回率 | Precision and Recall"></a>精度和召回率 | Precision and Recall</h3><p>在检索结果的 Top n 中，我们定义如下变量：</p><p>Precision (精度): Proportion of a retrieved set that is relevant.</p><p>Recall (召回率): Proportion of all relevant documents in the collection included in the retrieved set.</p><p>与这两个概念相关的还有 Miss (漏识率) 和 Fallout (误报率)。</p><p>对应的混淆矩阵（Confusion Matrix）如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:center">/</th><th style="text-align:center">相关</th><th style="text-align:center">不相关</th></tr></thead><tbody><tr><td style="text-align:center">检索到</td><td style="text-align:center">A</td><td style="text-align:center">B</td></tr><tr><td style="text-align:center">未检索到</td><td style="text-align:center">C</td><td style="text-align:center">D</td></tr></tbody></table></div><script type="math/tex; mode=display">\text{精度}=\frac{A}{A+B}, \text{召回率}=\frac{A}{A+C}, \text{漏识率}=\frac{C}{A+C}, \text{误报率}=\frac{B}{B+D}</script><p>这样的计算过程没有考虑到检索结果的顺序，事实上相关文档排在前列的搜索引擎才是我们最需要的。</p><h4 id="有序检索-Ranked-retrieval"><a href="#有序检索-Ranked-retrieval" class="headerlink" title="有序检索 | Ranked retrieval"></a>有序检索 | Ranked retrieval</h4><p>考虑搜索引擎返回的结果是有序的，取 Top n，则计算 P/R 的方法可以加以修正：</p><p>对检索到的文档按照 ranking 排列，顺次计算 P/R，每次计算时考虑前 k 个文档。最后会得到一组 n 个 P/R 值，再对 Top n 中的「相关文档」对应的 Precision 取平均。</p><p><img src="/img/blog/IR-Note-5-images/PR_ranking1.png" alt="同一关键词的查询结果" style="zoom:67%;" /></p><p><img src="/img/blog/IR-Note-5-images/PR_ranking2.png" alt="平均值计算" style="zoom:50%;" /></p><p>上图中，我们对搜索引擎 A 和搜索引擎 B 查询了同一关键词，并取了 Top 10 的查询结果，其中各有 5 篇相关文档，经过计算可发现，A 的检索结果更优。</p><p>但是，如果我们要对同一个搜索引擎 A 用不同的关键词来查询呢？</p><p><img src="/img/blog/IR-Note-5-images/PR_ranking3.png" alt="不同关键词的查询结果" style="zoom:67%;" /></p><p>对于不同的 query 可能 Top n 中有数量不同的相关文档，此时的 Recall 就会不一致。如果我们要计算同一 Recall 值处的精度，则需要用到插值方法。</p><h4 id="跨查询平均-Averaging-across-queries"><a href="#跨查询平均-Averaging-across-queries" class="headerlink" title="跨查询平均 | Averaging across queries"></a>跨查询平均 | Averaging across queries</h4><p>仅用个别的 query 难以在数据巨大的文档集中得到准确的 P/R 值。因此需要考虑更多的 query，并对结果再次平均。</p><p>由此，引出两种平均的思想：</p><ul><li>Micro-average (<strong>微平均</strong>): each relevant document is a point in the average. 只针对该搜索引擎下一个 query 的命中结果，求出平均精度。</li><li>Macro-average (<strong>宏平均</strong>): each query is a point in the average (Most Common). 针对该搜索引擎下的许多 query 的微平均精度，再求总的平均精度。</li></ul><p>做宏平均的过程中，最重要的是将所有 query 视作平等的点。因为在微平均的过程中，我们往往只关注一些大样本、常见样本，而这些样本并不能完全体现搜索引擎的性能。而宏平均关注其他小样本、偏僻样本，这些样本的检索结果体现了搜索引擎内部的类别分布是否均匀。</p><p>这种方法也称作 MAP (<strong>Mean Average Precision</strong>)，平均之上的平均。</p><h4 id="绘图-Recall-Precision-graphs"><a href="#绘图-Recall-Precision-graphs" class="headerlink" title="绘图 | Recall/Precision graphs"></a>绘图 | Recall/Precision graphs</h4><p>如果只关注平均精度，则会隐藏检索结果的一些有效信息。如果用图表的形式呈现，则更能观察到趋势。</p><p>如果直接把 ranked retrieval 的结果画在图中，会得到一条「<strong>锯齿状</strong>」的曲线。因为在同一个召回率下，随着结果数的增长，精度是垂直向下的。</p><p><img src="/img/blog/IR-Note-5-images/PR_graph1.png" alt="锯齿状的PR图" style="zoom: 80%;" /></p><p>此时，如果我们想要关注曲线中的：</p><ul><li>特定召回率（10%、20%等）下的精度</li><li>零召回率（系统尚未返回结果）下的精度</li></ul><p>由于各个 query 对应的相关文档总数不同，观测到的召回率点也不同。此时就需要对离散的点用 interpolate (插值)，做出连续的曲线，才能确定这些点的精度。接下来讨论如何选取适合的插值方法。</p><blockquote><p>直接连接各点？连接最大值？连接最小值？连接平均值？</p><p>零召回率时假设为零？假设为最大精度？假设为平均精度？与起始点相等？</p></blockquote><p><strong>基本原则</strong>：从<strong>平均</strong>来看，随着召回率的增加，精度应该是单调递减的。</p><p>基于这个原则，可以得到</p><script type="math/tex; mode=display">P(R)=\max \left\{P^{\prime}: \quad R^{\prime} \geq R \wedge\left(R^{\prime}, P^{\prime}\right) \in S\right\}</script><p>即：选取「当前区间」最大的精度点，再以「召回率大于该点的区间」为「新区间」，选取最大的精度点，迭代至 100%。</p><p>最后用「<strong>阶梯状</strong>」曲线连接以上各点，可以得到单调递减的曲线。</p><p><img src="/img/blog/IR-Note-5-images/PR_graph2.png" alt="阶梯状的PR图" style="zoom:67%;" /></p><h3 id="E-and-F"><a href="#E-and-F" class="headerlink" title="E and F"></a>E and F</h3><p>综合考虑 P/R 值，可以计算出如下<strong>单值评价指标</strong>。</p><h4 id="E-Measure"><a href="#E-Measure" class="headerlink" title="E Measure"></a>E Measure</h4><p>用于强调精度或召回率中的某一个指标，同时兼顾另一个指标。</p><script type="math/tex; mode=display">E=1-\frac{1}{\alpha \frac{1}{P}+(1-\alpha) \frac{1}{R}}</script><p>根据 $\alpha$ 的取值，增大 $\alpha$ 代表强调精度的重要性，反之强调召回率。</p><p>令 $\alpha =\frac{1}{\beta ^2+1}$ ，可以得到</p><script type="math/tex; mode=display">E=1-\frac{\left(\beta^{2}+1\right) P R}{\beta^{2} P+R}</script><p>当 $\beta = 1$ 时可得到二者相同重要性的效果，此时的 $E$ 具有的<strong>物理意义</strong>是所有相关文档 $A+C$ 和所有检索到文档 $A+B$ 的集合的<strong>对称差</strong>的基数除以两个集合的基数。</p><h4 id="F-Measure"><a href="#F-Measure" class="headerlink" title="F Measure"></a>F Measure</h4><p>将 $E$ 取补，可以得到</p><script type="math/tex; mode=display">F_{\beta}=1-E=\frac{\left(\beta^{2}+1\right) P R}{\beta^{2} P+R}</script><p>其中 $F_1$ 分数则是 P/R 值的调和平均，较为平均的兼顾了二者。这是分类与信息检索中最常用的指标之一。</p><script type="math/tex; mode=display">F_{1}=\frac{2 P R}{P+R}=\frac{1}{\frac{1}{2}\left(\frac{1}{R}+\frac{1}{P}\right)}</script><p>之所以使用<strong>调和平均</strong>而不是算术平均，是因为在<strong>算术平均</strong>中，任何一方对数值增长的贡献相当，任何一方对数值下降的责任也相当；而<strong>调和平均</strong>在增长的时候会偏袒较小值，也会惩罚精确率和召回率相差巨大的极端情况，很好地兼顾了精确率和召回率。</p><h3 id="单值评价指标-Other-Single-Valued-Measures"><a href="#单值评价指标-Other-Single-Valued-Measures" class="headerlink" title="单值评价指标 | Other Single-Valued Measures"></a>单值评价指标 | Other Single-Valued Measures</h3><p>类似 $E$ 和 $F$ 这样的单值评价指标之所以重要，是因为这样能够更好的优化度量。此外，在文档评价中，我们还有如下指标：</p><ul><li>期望搜索长度 | Expected search length</li></ul><p>定义在弱顺序文档，量化的用户查找 K 个相关文档所需工作量。这项指标计算预期用户在找到第 K 个相关文档之前，按顺序浏览搜索结果列表将要看到的非相关文档的数量。</p><ul><li>损益平衡点 | Breakeven point</li></ul><p>寻找 Precision 等于 Recall 的点，通常在分类任务中用到。</p><ul><li><strong>平均排序倒数</strong> | <strong>MRR</strong> (Mean Reciprocal Rank)</li></ul><p>对于某些 IR 系统（如问答系统或主页发现系统），只关心第一个标准答案返回的 rank，越前越好，这个位置的倒数称为 Reciprocal Rank (RR) ，对问题集合求平均，则得到 MRR。即，把标准答案在被评价系统给出结果中的排序取倒数作为它的准确度，再对所有的问题取平均。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #4 概率模型</title>
    <link href="/IR-Note-4.html"/>
    <url>/IR-Note-4.html</url>
    
    <content type="html"><![CDATA[<p>前面介绍的模型，都是通过对<strong>相似性</strong>的计算，得出最佳匹配的模型。而概率检索模型，则是基于概率原理，越过相似性，直接对<strong>相关性</strong>进行计算的一种检索模型。</p><p>利用相关性有一个好处，就是对于两个不相似的词，如果它们因为某些因素联系起来了，那么也会出现在检索结果中。</p><h2 id="朴素贝叶斯分类-Naive-Bayes"><a href="#朴素贝叶斯分类-Naive-Bayes" class="headerlink" title="朴素贝叶斯分类 | Naive Bayes"></a>朴素贝叶斯分类 | Naive Bayes</h2><p>贝叶斯公式是概率论中非常基础的公式，其解决的核心点在于根据已有信息，对未知事物发生结果的概率计算。这里简单介绍一下作为模型的引入。</p><p>如果我们有文档 <em>D</em>，可以记 $P(R=1|D)$ 为文档和查询相关的概率（这里的 <em>R</em> 只有 0 和 1 两种取值），这表示在文档确定的情况下，发生 $R=1$ 假设的<strong>后验概率</strong>。</p><p>与此同时，$P(R=1)$ 可以表示该假设的<strong>先验概率</strong>，意思是在完全对文档无所知的情况下，这个文档的<strong>分类</strong>情况满足假设的概率。</p><p>以下我们将 $R=1$ 简写为 <em>R</em>，$R=0$ 简写为 <em>NR</em>，表示一下贝叶斯公式：</p><script type="math/tex; mode=display">P(R|D) = \frac{P(RD)}{P(D)} = \frac{P(D|R)P(R)}{P(D)}</script><p>实际上，贝叶斯公式是做了一个转换，将复杂的概率式转化为三个更好计算的概率式。</p><ul><li>$P(D)$ 表示随机选取一篇文档，恰好是特定的 <em>D</em> 的概率，这个概率对于所有文档都是一致的，如果只是作比较，就不需要考虑。</li><li>$P(R)$ 表示假设 <em>R</em> 成立的先验概率，如果有已知的数据集，我们可以用相似文档的频率近似概率；如果没有，也可以先设为 0.5。但应用在比较中，也是不需要考虑的。</li><li>$P(D|R)$ 表示任意一篇文档被归类为相似后，恰好是特定的 <em>D</em> 的概率，需要所用特殊的方法来估计。</li></ul><p>所以，<strong>判断</strong>一篇文档是否相似，只需要比较 $P(R|D)$ 和 $P(NR|D)$ 两个值的大小，就是比较 $P(D|R)P(R)$ 和 $P(D|NR)P(NR)$。</p><h2 id="概率检索-Probabilistic-Retrieval"><a href="#概率检索-Probabilistic-Retrieval" class="headerlink" title="概率检索 | Probabilistic Retrieval"></a>概率检索 | Probabilistic Retrieval</h2><p>概率检索模型与贝叶斯分类的思想非常接近，但还是有本质区别的。概率检索模型的根本目的不是<strong>分类</strong>，它不需要根据查询判断一个文档属于“相关”或者“不相关”，而是计算这个文档属于属于“相关”或者“不相关”的<strong>概率大小</strong>为文档<strong>排序</strong>。</p><p>因此，在概率检索模型中，我们首先要定义一个<strong>相关度指标</strong>，考虑前文中提到的 $P(D|R)P(R)$ 和 $P(D|NR)P(NR)$，由于 $P(R)$ 和 $P(NR)$ 在同一个查询下对所有文档都是一致的，因此只要关注剩余部分之比（也称为<strong>优势率</strong>）：</p><script type="math/tex; mode=display">\alpha = \frac{P(D|R)}{P(D|NR)}</script><p>显然，这个比值越大，代表该文档与查询的相关度越大，因此我们最后就通过 $\alpha$ 将文档排序。</p><h3 id="风险最小化-Risk-Minimization"><a href="#风险最小化-Risk-Minimization" class="headerlink" title="风险最小化 | Risk Minimization"></a>风险最小化 | Risk Minimization</h3><p>此外，在检索过程中，我们还要决定一篇文档是否被召回，即设定一个<strong>召回阈值</strong>。一般我们会选择<strong>贝叶斯最优决策定理</strong>（Bayes’ Optimal Decision Rule）来决定一个文档是否相关，进而确定是否将其返回。</p><p>所谓的贝叶斯最优决策定理其实很简单，当 $P\left( R|D \right) &gt;P\left( NR|D \right) $ 时，我们认定该文档是相关文档，将其返回。</p><p>但在实际中，我们还要考虑<strong>最小化期望损失</strong>（<strong>也称为贝叶斯风险</strong>，Bayes Risk），即「返回一篇不相关文档」或「没有返回一篇相关文档」的损失。</p><p>举个例子，在就诊看病的过程中，将患病者诊断为「健康」而错失治疗时机，远比健康者诊断为「患病」代价大得多。因此我们也认为「没有返回一篇相关文档」的代价要大于「返回一篇不相关文档」。</p><p>如果记 $c_{rr}$ 为 cost of deciding <strong>relevant when relevant</strong>， $c_{rn}$ 为 cost of deciding <strong>relevant when not relevant</strong>，$c_{nn}$ 和 $c_{nr}$ 同理。那么就有：</p><script type="math/tex; mode=display">c_{nr}P\left( R|D \right) +c_{nn}P\left( NR|D \right) >c_{rn}P\left( NR|D \right) +c_{rr}P\left( R|D \right)</script><p>移项，并引入贝叶斯公式后：</p><script type="math/tex; mode=display">\left( c_{nr}-c_{rr} \right) P\left( D|R \right) P\left( R \right) >\left( c_{rn}-c_{nn} \right) P\left( D|NR \right) P\left( NR \right)</script><p>结合相关度指标，可以等到新的阈值：</p><script type="math/tex; mode=display">\alpha =\frac{P(D|R)}{P(D|NR)}>\frac{\left( c_{rn}-c_{nn} \right)P\left( NR \right)}{\left( c_{nr}-c_{rr} \right)P\left( R \right)}</script><h2 id="二值独立检索-Binary-Independence-Retrieval"><a href="#二值独立检索-Binary-Independence-Retrieval" class="headerlink" title="二值独立检索 | Binary Independence Retrieval"></a>二值独立检索 | Binary Independence Retrieval</h2><p>前面提到，$P(D|R)$ 表示任意一篇文档被归类为相似后，恰好是特定的 <em>D</em> 的概率，在通常的<strong>朴素贝叶斯分类</strong>中，通常有两种方法来估计：</p><ul><li>用 <em>D</em> 在类别 <em>R</em> 中的比例来估计，显然，这个方法在检索中不适用，因为同一文档 <em>D</em> 几乎不可能在 <em>R</em> 中出现过。</li><li>将 <em>D</em> 看作由 0 和 1 <strong>二值</strong>组成的向量，每个维度代表了一种词项是否包含在该文档中，默认词项之间是相互<strong>独立</strong>的，然后用下面的公式计算：</li></ul><script type="math/tex; mode=display">P(D|R) = \prod_{T_i \in D}{P(T_i=1|R)}\prod_{T_j \notin D}{P(T_j=0|R)}</script><p>其中，<em>T</em> 就代表文档中的词项 term，$P(T|R)$ 就是该词项在归类为相似的文档集中<strong>出现或不出现</strong>的概率。</p><h3 id="公式推演"><a href="#公式推演" class="headerlink" title="公式推演"></a>公式推演</h3><p>在以上的概念下，不妨记：</p><ul><li>相似文档集中 $P(T_k=1|R)$ 为 $p_k$，$P(T_k=0|R)$ 为 $1-p_k$。</li><li>不相似文档集中 $P(T_k=1|NR)$ 为 $q_k$，$P(T_k=0|NR)$ 为 $1-q_k$。</li></ul><p>则相关度指标可表示为：</p><script type="math/tex; mode=display">\alpha = \frac{\prod_{T_k \in D}p_k \prod_{T_k \notin D} 1 - p_k}{\prod_{T_k \in D}q_k \prod_{T_k \notin D}1 - q_k}</script><p>再做一个数学上的等价变换，如下：</p><script type="math/tex; mode=display">\begin{aligned}\alpha &= \frac{\prod_{T_k \in D}p_k \prod_{T_k \notin D}1 - p_k}{\prod_{T_k \in D}q_k \prod_{T_k \notin D}1 - q_k} = \frac{\prod_{T_k \in D}p_k}{\prod_{T_k \in D}q_k} \cdot \frac{\prod_{T_k \notin D}1 - p_k}{\prod_{T_k \notin D}1 - q_k}\\&= (\frac{\prod_{T_k \in D}p_k}{\prod_{T_k \in D}q_k} \cdot \frac{\prod_{T_k \in D}1 - q_k}{\prod_{T_k \in D}1 - p_k}) \cdot (\frac{\prod_{T_k \in D}1 - p_k}{\prod_{T_k \in D}1 - q_k} \frac{\prod_{T_k \notin D}1 - p_k}{\prod_{T_k \notin D}1 - q_k})\\&= \frac{\prod_{T_k \in D}p_k(1 - q_k)}{\prod_{T_k \in D}q_k(1 - p_k)} \cdot \frac{\prod 1 - p_k}{\prod 1 - q_k} \end{aligned}</script><p>在同一查询下，相似文档集和不相似文档集是固定的，也就是说 $p_k$ 和 $q_k$ 的值也是相同的。故公式的第二部分（与文档 <em>D</em> 无关）可以忽略，简化成</p><script type="math/tex; mode=display">\alpha=\prod_{T_k \in D}\frac{p_k(1 - q_k)}{q_k(1 - p_k)}</script><p>取对数将乘积转化为求和得到用于排序的两，称为 RSV (Retrieval Status Value，<strong>检索状态值</strong>)：</p><script type="math/tex; mode=display">RSV_D=\sum_{T_k \in D} \left(\log \frac{p_k}{1 - p_k} + \log \frac{1 - q_k}{q_k} \right)</script><h3 id="Estimation-using-training-data"><a href="#Estimation-using-training-data" class="headerlink" title="Estimation using training data"></a>Estimation using training data</h3><p>现在我们只要计算出 $p_k$ 和 $q_k$ 的值就成功了。在计算之前，我们先写出下面的索引项出现列联表：</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">相关文档</th><th style="text-align:center">不相关文档</th><th style="text-align:center">总数</th></tr></thead><tbody><tr><td style="text-align:center"><strong>包含</strong>词项 $T_k$</td><td style="text-align:center">r</td><td style="text-align:center">n-r</td><td style="text-align:center">n</td></tr><tr><td style="text-align:center"><strong>不包含</strong>词项 $T_k$</td><td style="text-align:center">R-r</td><td style="text-align:center">N-n-R+r</td><td style="text-align:center">N-n</td></tr><tr><td style="text-align:center"><strong>总数</strong></td><td style="text-align:center">R</td><td style="text-align:center">N-R</td><td style="text-align:center">N</td></tr></tbody></table></div><p>则可以得到估算式：</p><script type="math/tex; mode=display">p_k=\frac{r}{R}, q_k=\frac{n-r}{N-R}</script><p>同时，为了避免可能出现的<strong>零频问题</strong>（比如所有的相关文档都包含或不包含某个特定的词项），一种很常规的做法是在之前的表格中的每个量的基础上都加上 0.5 来<strong>平滑处理</strong>，因此总数也做相应改变：</p><script type="math/tex; mode=display">p_k=\frac{r+0.5}{R+1}, q_k=\frac{n-r+0.5}{N-R+1}</script><h3 id="Estimation-without-training-data"><a href="#Estimation-without-training-data" class="headerlink" title="Estimation without training data"></a>Estimation without training data</h3><p>用上式代入得到的计算式也称作 <code>Robertson-Sparck Jones</code> 等式，这个式子的计算条件是知道相关文档总数 R，但实际上大多数时候我们都是不知道的。</p><p>一种可行的方案是，初始时令相关文档数为 0，这是因为在实际检索情景下，文档库中往往只有少部分是和查询词相关的内容：</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">相关文档</th><th style="text-align:center">不相关文档</th><th style="text-align:center">总数</th></tr></thead><tbody><tr><td style="text-align:center"><strong>包含</strong>词项 $T_k$</td><td style="text-align:center">0</td><td style="text-align:center">n</td><td style="text-align:center">n</td></tr><tr><td style="text-align:center"><strong>不包含</strong>词项 $T_k$</td><td style="text-align:center">0</td><td style="text-align:center">N-n</td><td style="text-align:center">N-n</td></tr><tr><td style="text-align:center"><strong>总数</strong></td><td style="text-align:center">0</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr></tbody></table></div><p>此时的 $p_k$ 值可以用常数来代替，如 0.3。</p><h2 id="修正公式"><a href="#修正公式" class="headerlink" title="修正公式"></a>修正公式</h2><p>在本文的最后，我们再来讨论一个问题，在前面讲到的 $p_k$ 和  $q_k$的值估算过程中，我们其实是用到了之前提过的<strong>文档频率</strong> <em>df</em>。</p><p>而在之前的文章中，还有词频、逆文档频率、文档长度等等多种因素未被考虑到。因此，基于最初的原理和假设，可以对原来的 RSV 公式增加修正因子，使得模型更加精确。</p><h3 id="BM25-Weighting"><a href="#BM25-Weighting" class="headerlink" title="BM25 Weighting"></a>BM25 Weighting</h3><p>这是一种最常用的加权方法，考虑了<strong>词频</strong>和<strong>文档长度</strong>。BM25 模型为文档 $D_i$ 每个词项项 $T_j$ 分配了一个系数 $B_{i,j}$ ，由下计算生成：</p><script type="math/tex; mode=display">B_{i,j}=\frac{\left( K_1+1 \right) f_{i,j}}{K_1\left[ (1-b)+b\frac{\mathrm{len}\left( D_i \right)}{\,\,\mathrm{avg}\_\mathrm{doclen}} \right] +f_{i,j}}</script><p>其中，$K_1$ 和 <em>b</em> 为经验参数，用于调节词频和文档长度在权重计算中起到的作用，一般来讲， $K_1$ 取 1，<em>b</em> 取 0.75 已经被证明是合理的假设。而 $f_{i,j}$ 则为词项 $T_j$ 在文档 $D_i$ 中的词频，avg_doclen 为平均文档长度。</p><h3 id="Multiple-Fields"><a href="#Multiple-Fields" class="headerlink" title="Multiple Fields"></a>Multiple Fields</h3><p>在 BM25 的之后，还有一种针对其提出的修正方法。将文档划分成不同的<strong>域</strong>，如：title/abstract/body，并对不同域赋予不同的权重（每个 term 出现的<strong>当量</strong>不同）。例如，term 在标题出现 1 次相当于在 abstract 出现 1.5 次。</p><p>同理，文档长度也相应的进行加权调整，最后可以计算出新的修正因子：</p><script type="math/tex; mode=display">\begin{aligned}\widetilde{t f}_{i} &=\sum_{s=1}^{S} w_{s} t f_{s i} \\\widetilde{d l} &=\sum_{s=1}^{S} w_{s} s l_{s}\end{aligned}</script><p>最后计算出的频度替换原始的频度，代入 BM25 Weighting 公式。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #3 向量空间模型</title>
    <link href="/IR-Note-3.html"/>
    <url>/IR-Note-3.html</url>
    
    <content type="html"><![CDATA[<p>回忆前两个模型，我们发现统计语言模型在布尔模型上，做出了最佳匹配和排序结果的改进。但是，仍然没有考虑到「<strong>词项的权重</strong>」。</p><p>在向量空间模型中，我们容易联想到用向量来表示文档和查询，再通过计算余弦来得到两个向量的距离，从而得到相似性度量。</p><p>那么，如何选取向量空间 basis vector (基向量)？如何将目标转化为向量？如何为各个维度选取 magnitide (幅值)，从而考虑权重？如何在高维空间计算向量距离？</p><h2 id="向量空间模型-Vector-Space-Model"><a href="#向量空间模型-Vector-Space-Model" class="headerlink" title="向量空间模型 | Vector Space Model"></a>向量空间模型 | Vector Space Model</h2><p>通常地，我们选择用 linearly independent (线性独立) 或 orthogonal (正交) 的基向量来张成<strong>向量空间</strong>，这样可以使得维度最少。那么，如何选取基向量？</p><p>这是一个特征选择问题，在 IR 中，通常有两种方式：</p><ol><li><p>Core concept (核心概念) 的思想：把词语的类型分类，按照其在不同分类上的「倾斜程度」决定向量的值，可以使维度尽量少。但是，由于语义上的多样性，很难实现。目前有 WordNet, HowNet, HNC 等模型。</p></li><li><p>把出现过的 term 都当作是一个基向量，并<strong>假设</strong>所有的基向量都是相互正交、相互独立的。这样将会得到一个维度不断增长的向量空间（随着词典表扩大）。</p></li></ol><p>以下我们采用第二种方式。一个 Doc 或 Query 的向量表示就是：所有出现在文档中的 term 的向量之和。</p><h3 id="词项权重-Term-Weighting"><a href="#词项权重-Term-Weighting" class="headerlink" title="词项权重 | Term Weighting"></a>词项权重 | Term Weighting</h3><p>当一个 term 在文档中不断出现时，在这个方向上的向量幅值就会很大。这样比起布尔模型的 0/1 二值，更能反映了这个 term 的重要性。这便是决定权重的 <em>tf</em> (<strong>term frequency</strong>，词项频率) 方法。</p><p>然而，原始的 <em>tf</em> 值会面临这样一个严重的问题：即在和查询进行相关度计算时，所有 term 都被认为是同等重要的。</p><p>实际上，某些 term 对于相关度计算来说几乎没有或很少有区分能力。一个很直接的想法就是给包含在较多文档中的词项赋予较低的权重。为此，引入变量 <em>df</em> (<strong>document frequency</strong>，文档集频率)，即有多少文档包含了该 term。df 值越大，说明该 term 越不重要。</p><p>为了计算的方便，将其标准化得到 <em>idf</em> (<strong>inverse document frequency</strong>，逆文档频率)：</p><script type="math/tex; mode=display">idf_t=\log \left( \frac{N}{df_t} \right)</script><p>观察该式发现，<em>idf</em> 虽然可以使得在较多文档中的词项权值降低，但与 <em>tf</em> 相反的是，这样做的缺点是：对那些极少出现的词极度敏感。</p><p>为此，我们将二者结合在一起，诞生了 <strong><em>tf·idf</em></strong> 方法——在文本处理领域中使用最广泛的数值权重计算方法。方法基于的思想和构造的统计量都很简单，但是在实际中却表现了很好的性能。</p><p>在 VSM 中，我们会将词项的 <em>tf·idf</em> 存储在词典表（词项-文档）矩阵中，作为向量的幅值，用于后续的计算。</p><h3 id="相似度计算-Similarity"><a href="#相似度计算-Similarity" class="headerlink" title="相似度计算 | Similarity"></a>相似度计算 | Similarity</h3><p>当我们已经把文档表示成 $R^{v}$ 上的向量，从而可以计算文档与文档之间的相似度（根据向量内积或者<strong>余弦夹角</strong>）。</p><p>设 $D_1$ 和 $D_2$ 表示 VSM 中的两个向量：</p><script type="math/tex; mode=display">\begin{aligned}&D_{1}=D_{1}\left(w_{11}, w_{12}, \ldots, w_{1 n}\right) \\&D_{2}=D_{2}\left(w_{21}, w_{22}, \ldots, w_{2 n}\right)\end{aligned}</script><p>可以借助于 N 维空间中两个向量之间的某种距离来表示文档之间的相似度，常用的方法是使用向量之间的內积来计算：</p><script type="math/tex; mode=display">\operatorname{Sim}\left(D_{1}, D_{2}\right)=\sum_{k=1}^{n} w_{1 k} \times w_{2 k}</script><p>考虑到向量的<strong>归一化</strong>，则可以使用两个向量的余弦值来表示相似系数：</p><script type="math/tex; mode=display">\operatorname{Sim}\left(D_{1}, D_{2}\right)=\cos \theta=\frac{\sum_{k=1}^{n} w_{1 k} \times w_{2 k}}{\sqrt{\sum_{k=1}^{n} w_{1 k}^{2} \sum_{k=1}^{n} w_{2 k}^{2}}}</script><p>要注意，这里使用向量内积，是基于对所有向量相互独立、相互正交的假设，否则计算内积也就失去了意义。对于相关的基向量，应该评估 Term 之间的相关度 $T_{i,j}$，再把向量当成多项式计算，最后代入 $T_{i,j}$。</p><p>此外，在其他的考虑权重的模型中，如 Lucene，在计算相似度时引入了更多的因子，如 <em>tf·idf</em>，$boost_t$，<em>overlap(q,d)</em> 等，对应用情形、平滑度加以考量。</p><h3 id="VSM-实际应用"><a href="#VSM-实际应用" class="headerlink" title="VSM 实际应用"></a>VSM 实际应用</h3><p>在 IR 中应用 VSM 模型时，相似度在检索结果中有两种体现：</p><ol><li><strong>Threshold</strong> (阈值)：对于每个查询，只在相似度大于一定阈值的文档中检索，如 Sim &gt; 0.50 的文档中，减少查询范围。</li><li><strong>Ranking</strong>：对于每个查询，返回相似度排名 Top n 的文档，以相似度排序。</li></ol><p>而 VSM 模型也有着致命的<strong>缺点</strong>：</p><ul><li><p>对于大的文档集（10w+ term），向量维度太多导致难以存储和计算。</p></li><li><p>一篇文档的词数（1k+ term）远低于总的词数——高维稀疏矩阵。</p></li><li>词项之间的相关性，导致了大量冗余的基向量。</li></ul><h2 id="潜层语义索引-Latent-Semantic-Indexing"><a href="#潜层语义索引-Latent-Semantic-Indexing" class="headerlink" title="潜层语义索引 | Latent Semantic Indexing"></a>潜层语义索引 | Latent Semantic Indexing</h2><p>潜层语义索引，也被称为 LSA (Latent Semantic Analysis，潜在语义分析)，是针对向量空间的「<strong>高维稀疏</strong>」问题提出的解决方法，利用线性代数中的<strong>奇异值分解</strong>降低维度（去除噪音），同时尽量减少信息的损失。</p><h3 id="奇异值分解-Singular-Value-Decomposition"><a href="#奇异值分解-Singular-Value-Decomposition" class="headerlink" title="奇异值分解 | Singular Value Decomposition"></a>奇异值分解 | Singular Value Decomposition</h3><p>参考：<a href="https://www.cnblogs.com/pinard/p/6251584.html">https://www.cnblogs.com/pinard/p/6251584.html</a></p><p>对于一个 $t\times d$​​ 矩阵 $A$​​​，可以分解为下面三个矩阵：</p><script type="math/tex; mode=display">A_{t\times d}=U_{t\times t}\varSigma _{t\times d}V^T_{d\times d}</script><p>其中 $U$​ 和 $V$​ 都是<strong>酉矩阵</strong>，即满足 $U^TU=I, V^TV=I$​。$\varSigma$​ 一个 $t\times d$​ 矩阵，除了主对角线上的元素以外全为 0，主对角线上的每个元素都称为<strong>奇异值</strong>。</p><p>利用酉矩阵性质得：</p><script type="math/tex; mode=display">A=U\Sigma V^T \Rightarrow A^T=V\Sigma^T U^T \Rightarrow A^TA = V\Sigma^T U^TU\Sigma V^T = V\Sigma^2V^T</script><p>可以看出 $A^TA$ 的特征向量组成的矩阵，就是我们 SVD 中的 $V^T_{d\times d}$​ 矩阵。进一步我们还可以看出我们的特征值矩阵等于奇异值矩阵的平方。</p><p>利用以上原理，我们可以得出 SVD <strong>分解步骤</strong>：</p><ol><li>假设词典矩阵为 $A$，首先求出 $AA^T$，会得到一个 $t\times t$ 的方阵。</li><li>既然是方阵，就可以进行特征值分解，得到 <em>t</em> 个特征值和对应的特征向量。</li><li>将特征值按方差大小排序，用所有的列向量张成一个 $t\times t$ 的矩阵 $U_{t\times t}$。</li><li>同理可以用 $A^TA$ 求出 $d\times d$ 的矩阵 $V^T_{d\times d}$。</li><li>利用前面求出的特征值，开方后得到 $\varSigma _{t\times d}$。​</li></ol><h3 id="利用-SVD-降维"><a href="#利用-SVD-降维" class="headerlink" title="利用 SVD 降维"></a>利用 SVD 降维</h3><p>对于奇异值，它跟我们特征分解中的特征值类似，在奇异值矩阵中也是按照从大到小排列。通常，奇异值的<strong>衰减</strong>得特别快，在很多情况下，前 10% 甚至 1% 的奇异值之和就占了全部的奇异值之和的 99% 以上的比例。</p><p>也就是说，我们也可以用最大的 k 个的奇异值和对应的左右奇异向量来近似描述矩阵。也就是说：</p><script type="math/tex; mode=display">A_{t\times d}=U_{t\times t}\varSigma _{t\times d}V^T_{d\times d}\approx U_{t\times k}\varSigma _{k\times k}V^T_{k\times d}</script><p>其中 <em>k</em> 要比 <em>t</em> 小很多，也就是一个大的矩阵可以用三个小的矩阵，此时存储空间可以大量节省。通常 <em>k</em> 的值即为我们假设的<strong>主题数</strong>。</p><p>SVD 分解后，$U_{il}$ 对应第 <em>i</em> 个词和第 <em>l</em> 个词义的相关度。$V_{jm}$ 对应第 <em>j</em> 个文档和第 <em>m</em> 个主题的相关度。$\Sigma_{lm}$ 对应第 <em>l</em> 个词义和第 <em>m</em> 个主题的相关度。</p><p>这样我们通过一次 SVD，就可以得到词和词义的相关度，词义和主题的相关度，以及文档和主题的相关度。</p><h3 id="LSI-的使用"><a href="#LSI-的使用" class="headerlink" title="LSI 的使用"></a>LSI 的使用</h3><p>通过计算后，我们关注新的矩阵 $V^T_{k\times d}$​ ，所有的文档已经简化成了和 k 个主题的相关度。假设此时的查询为 $Q=q_1q_2\cdots q_t$​​​​，​其中 <em>q</em> 取 0 或 1，则</p><script type="math/tex; mode=display">Q_{1\times k}=Q_{1\times t}U_{t\times k}\varSigma _{k\times k}</script><p>可将 <em>t</em> 维的查询转化成 <em>k</em> 维的「<strong>与主题的相关度</strong>」，此时就可以与文档进行相似度计算了。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #2 统计语言模型</title>
    <link href="/IR-Note-2.html"/>
    <url>/IR-Note-2.html</url>
    
    <content type="html"><![CDATA[<p>基于对布尔模型的改进，提出一种新的最佳匹配模型。</p><h2 id="统计语言模型-Statistical-Language-Models"><a href="#统计语言模型-Statistical-Language-Models" class="headerlink" title="统计语言模型 | Statistical Language Models"></a>统计语言模型 | Statistical Language Models</h2><p>首先探讨的是 Doc (文档) 的呈现形式，引入 Topic (<strong>主题</strong>) 来表述一个文档的隐含语义，起到索引作用。基于以下两个假设：</p><ul><li>Words common in document are common in topic.</li><li>Words not in document much less likely.</li></ul><p>可以得出，Topic 是由 Doc 中的一些关键词勾勒出来的。于是引入 $P(w|Doc)$ 概率分布表：统计每个词在文档中出现频度（频率）——基于大数定律。</p><p>但 Topic 的难确定性（语义理解不同、可能有多个主题）导致其难以直接计算，因此可以用近似估算。</p><script type="math/tex; mode=display">P\left( w|Topic_D \right) \approx P\left( w|D \right) =tf\left( w,D \right) /len\left( D \right)</script><p>事实上，我们可以认为 Topic 是一种「<strong>语言模型</strong>」，$P\left( w|Topic_D \right)$ 可以认为是在 Topic 下生成该 word 的概率，即该 word 在这个「语言模型」中被生成的概率，故 word 可以不在 Topic 中出现，但也有概率生成。</p><h3 id="语言模型化-Language-Modeling"><a href="#语言模型化-Language-Modeling" class="headerlink" title="语言模型化 | Language Modeling"></a>语言模型化 | Language Modeling</h3><p>定义 <em>M</em> 为我们试图描述的 language (语言)，<em>s</em> 为该语言下观测到的文本串（由许多词条构成）。</p><ul><li><p><em>M</em> can be thought of as a “source” or a generator - a <strong>mechanism</strong> that can spit out strings that are legal in the language.</p></li><li><p>$P(s|M)$ is the probability of getting “<em>s</em>” during random sampling from <em>M</em>.</p></li></ul><p>语言的规模可大可小，把每种语言的规模缩小为一个 Topic（对应着语料库中的一个文档）；这个 Topic 就决定了任意一个字符串在这个 Topic 所对应的「语言模型」中出现的概率：比如，在一个描述信息检索发展历史的文档中，“Washington” 出现的概率就会远远小于 “Robertson”。</p><p>那么，一旦我们确定了这个 Doc 所对应的「语言模型」$M_D$ ，而 <em>Q</em> 是用户的 Query，我们是不是可以求出这个「语言模型」下<strong>生成</strong> <em>Q</em> 的概率？概率最大者就是与查询最相关的文档。那么，我们就可以根据 $P(Q|M_D) $ 给所有的 Doc 排序，得到我们的查询结果。</p><h2 id="多元语言模型-N-gram-Language-Models"><a href="#多元语言模型-N-gram-Language-Models" class="headerlink" title="多元语言模型 | N-gram Language Models"></a>多元语言模型 | N-gram Language Models</h2><p>对于一个较长的 Query，我们采用<strong>分词</strong>的方法来计算它的生成概率。为此，首先通过几个例子明确语言模型中 N-gram 的概念：</p><ul><li>Unigram 一元分词，把句子分成一个一个的汉字，如：哈/工/大/深/圳</li><li>Bigram 二元分词，每两个字组成一个词语，如：哈工/工大/大深/深圳</li><li>Trigram 三元分词，每三个字组成一个词语，如：哈工大/工大深/大深圳</li></ul><p>在以上例子中，我们可以知道一个文本串在一元语言中生成的概率将这样计算：</p><script type="math/tex; mode=display">P\left( w_1w_2w_3 \right) =P\left( w_1 \right) \cdot P\left( w_2 \right) \cdot P\left( w_3 \right)</script><p>在二元语言中将这样计算：</p><script type="math/tex; mode=display">P\left( w_1w_2w_3 \right) =P\left( w_1 \right) \cdot P\left( w_2|w_1 \right) \cdot P\left( w_3|w_2 \right)</script><p>可以发现，在 Unigram 中我们假设了单词之间的<strong>独立性</strong>，这就意味着它的本质是词的多项分布，而一个文本串可以看作是这个分布的一个实例。</p><p>对于更多元的分词 N-gram，我们是假设每个单词出现的概率只与它之前的 n-1 个单词<strong>相关</strong>，因此采用了条件概率。事实上，这是一种基于马尔可夫假设的模型，此时的文本串应是有序相关的，这就不属于 BoW 的范畴。</p><p>一般情况下，N 的取值都很小，实际<strong>自然语言处理</strong>应用中最多的是将 N = 3 的三元分词模型。原因如下：</p><ul><li>N 元模型的空间复杂度，是 N 的指数函数，即 $O\left( \left| V \right|^N \right) $，<em>V</em> 是一种语言的词汇量，一般在几万到几十万个。时间复杂度也是一个指数函数$O\left( \left| V \right|^{N-1} \right) $。</li><li>即使使用 N = 4 、N = 5 也不可能覆盖所有词与词之间的相关性。某两个词可能是一段话和一段话之间才会出现的。</li></ul><h3 id="多元语言模型的参数估计"><a href="#多元语言模型的参数估计" class="headerlink" title="多元语言模型的参数估计"></a>多元语言模型的参数估计</h3><p>针对一元模型，只需要统计该「语言模型」生成的文档中，出现该 term 的频率，用频率近似概率即可——<strong>大数定律</strong>。</p><p>这里对二元模型展开探讨：估计 $P\left( w_i|w_{i-1} \right)$，利用条件概率：</p><script type="math/tex; mode=display">P\left(w_{i} \mid w_{i-1}\right)=\frac{P\left(w_{i-1}, w_{i}\right)}{P\left(w_{i-1}\right)}</script><p>于是，我们只需要统计 $\left(w_{i-1}, w_{i}\right)$ 的有序词对在文档中的出现次数，再统计 $w_{i-1}$ 的出现次数，即可估计其概率。</p><p>然而，存在这样一个问题：在文本中，两个词没有连续出现过，即频度为 0，那么它的概率就是 0 吗？如果词对 $\left(w_{i-1}, w_{i}\right)$ 和 $w_{i-1}$ 的出现次数相同，其概率就是 1 吗？这就涉及到了统计的可靠性问题，也称「<strong>不平滑问题</strong>」。</p><p>解决这些问题的主要方法是<strong>古德-图灵估计</strong>（Good-Turing Estimate）和<strong>卡茨退避法</strong>（Katz backoff）。</p><ul><li><p>对出现次数大于某个阈值的词，频率不下调，即用频率代替概率；</p></li><li><p>对出现次数小于这个阈值的词，频率才下调，利用古德-图灵估计的相对频度来调整；</p></li><li><p>对出现次数等于 0 的词，利用卡茨退避法给予一个比较小的概率值。</p></li></ul><p>这部分的内容属于语料库的自然语言处理，本文中不赘述，仅在后文针对零频问题介绍几种方法。</p><h2 id="查询排序问题-Ranking"><a href="#查询排序问题-Ranking" class="headerlink" title="查询排序问题 | Ranking"></a>查询排序问题 | Ranking</h2><p>当给定查询 <em>Q</em> 时，怎么根据统计语言模型进行排序呢？有三种排序方法，分别是：</p><ol><li><strong>查询似然排序</strong> | Query-likelihood</li></ol><p>为每个 Doc 确定其所对应的 $M_D$，而用户的 Query 记为 $q=(q_1,q_2,\cdots,q_k)$ 。则该查询在每个文档的「语言模型」下生成的概率可如下计算：</p><script type="math/tex; mode=display">P\left(q_{1} \ldots q_{k} \mid M_{D}\right)=\prod_{i=1}^{k} P\left(q_{i} \mid M_{D}\right)</script><p>将所有计算结果排序，即可得到检索结果。要注意，这种方法对每个 Doc 计算出的概率都独立于其他 Doc，相关文档没有被利用到。</p><ol><li><strong>文档似然排序</strong> | Document-likelihood</li></ol><p>查询似然的翻转版本，为每个 Query 确定其所对应的 $M_Q$，计算任意一个文档在该查询的「语言模型」下生成的概率：</p><script type="math/tex; mode=display">P\left(D \mid M_{Q}\right)=\prod_{w \in D} P\left(w \mid M_{Q}\right)</script><p>但是，这种方法存在如下问题：</p><ul><li>文档的长度相差很大，很难比较。</li><li>由于文档中出现的词很多没有出现在查询中，将会出现零频问题。</li><li>将会出现无意义的作弊网页，如将 Query 中的关键词无限重复。</li></ul><p>要解决这些问题，需要引入 Likelihood Ratio (似然比)，对文档长度加以归一。</p><script type="math/tex; mode=display">P\left(M_{Q} \mid D\right)=\frac{P\left(M_{Q}\right) P\left(D \mid M_{Q}\right)}{P(D)} \approx \frac{c \prod_{w \in D} P\left(w \mid M_{Q}\right)}{\prod_{w \in D} P(w \mid G E)}</script><p>其中，对每个文档计算其可能 「生成 $M_Q$」的概率，在用贝叶斯公式展开，其中的 $P\left(M_{Q}\right)$ 对于每个文档可视作常数，再由分母的约束，对文档加以限制。</p><ol><li>Ranking by <strong>Model Comparison</strong></li></ol><p>结合前两种方法，提出了<strong>交叉熵</strong>（cross-entropy）的概念：</p><script type="math/tex; mode=display">H\left(M_{Q} \| M_{D}\right)=-\sum_{w} P\left(w \mid M_{Q}\right) \log P\left(w \mid M_{D}\right)</script><p>这种方法同时考虑了查询 $M_Q$ 和文档 $M_D$，直接比较两种模型的相似度。要注意，$M_Q$ 和 $M_D$ 在公式中的顺序不能调换。</p><h3 id="零频问题-Zero-frequency-problem"><a href="#零频问题-Zero-frequency-problem" class="headerlink" title="零频问题 | Zero frequency problem"></a>零频问题 | Zero frequency problem</h3><p>有了上述排序模型，现在我们只需要从查询和文档中估算出 $M_Q$ 和 $M_D$。</p><p>在本文的「语言模型」中，我们只需采用<strong>一元分词模型</strong>，独立性和独立分布可以简化许多问题。然而，在<strong>极大似然估计</strong>下，还是有个问题急需解决——零频问题，即有的 term 根本不出现在观测集中，我们该如何估算其概率？</p><p>这里介绍三种 Discounting Methods (折扣法) 来 Smoothing (平滑) ：</p><ol><li><p>Laplace correction：把每个词的词频都加 1，分母的总频数加上词项数 N。但是这种方法不适合较大的词典表。</p></li><li><p>Lindstone correction：把每个词都加一个很小的值 ε，分母的总频数加上 Nε。</p></li><li><p>Absolute Discounting：把词频不等于 0 的词减去一个很小的值 ε，再把减去的总值平均分配到词频为 0 的词上去，不改变分母。</p></li></ol><p>除了折扣法，还有诸如插值法、退避法等方法也可以用于平滑。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IR学习笔记 #1 概论&amp;布尔模型</title>
    <link href="/IR-Note-1.html"/>
    <url>/IR-Note-1.html</url>
    
    <content type="html"><![CDATA[<p>该笔记是本人于哈尔滨工业大学（深圳）2021 年夏季学期「信息检索」课程的笔记，授课教师为 <a href="https://scholar.google.com/citations?hl=zh-CN&amp;user=7aR5D4sAAAAJ">陈清财</a> 教授。姑且算是一门 NLP 入门课程。</p><h2 id="概论-Overview"><a href="#概论-Overview" class="headerlink" title="概论 | Overview"></a>概论 | Overview</h2><h3 id="What’s-Information-Retrieval"><a href="#What’s-Information-Retrieval" class="headerlink" title="What’s Information Retrieval?"></a>What’s Information Retrieval?</h3><p>Indexing, retrieving, and organizing text by probabilistic or statistical.</p><p><strong>Comparing IR to Databases</strong>:</p><div class="table-container"><table><thead><tr><th></th><th>Databases</th><th>IR</th></tr></thead><tbody><tr><td>Data</td><td>Structured</td><td>Unstructured</td></tr><tr><td>Fields</td><td>Clear semantics</td><td>No fields</td></tr><tr><td>Queries</td><td>Defined(SQL)</td><td>Free text (自然语言) + Boolean</td></tr><tr><td>Recoverability</td><td>Critical</td><td>Downplayed</td></tr><tr><td>Matching</td><td>Exact</td><td>Imprecise (need to measure)</td></tr></tbody></table></div><h3 id="信息检索的基本方法-Basic-Approach-to-IR"><a href="#信息检索的基本方法-Basic-Approach-to-IR" class="headerlink" title="信息检索的基本方法 | Basic Approach to IR"></a>信息检索的基本方法 | Basic Approach to IR</h3><p>大多数成功的方法都是基于概论统计，而不是自然语言理解。因为自然语言在缺少约束的状态（unrestricted domains）下具有极大不确定性，而人工标注又十分昂贵。</p><p><strong>统计方法的核心思想</strong>：Relevant (相关) Items are Similar (相似). Usually look for documents matching query words.</p><p>The similarity can be measured by: </p><ul><li>String matching/comparison (字符串匹配)</li><li>Same vocabulary (词汇) </li><li>Probability that documents arise from same model (文档出现概率)</li><li>Same meaning of text (语义) — Hard to achieve</li></ul><h4 id="词袋-“Bag-of-Words”"><a href="#词袋-“Bag-of-Words”" class="headerlink" title="词袋 | “Bag of Words”"></a>词袋 | “Bag of Words”</h4><p>Compares words <strong>without regard to order</strong>.</p><p><strong>Stop word (停用词)</strong>：屏蔽对文章分类无效的高频词。</p><h3 id="基础检索模型-Retrieval-Models"><a href="#基础检索模型-Retrieval-Models" class="headerlink" title="基础检索模型 | Retrieval Models"></a>基础检索模型 | Retrieval Models</h3><p>检索模型：建立在 Doc 和 Query 之间的模型，用于描述相似性、排序相似性。</p><p>检索变量：queries (查询), documents (文档), terms (术语), relevance<br>judgments (相关性判别)。</p><h4 id="Exact-vs-Best-Match"><a href="#Exact-vs-Best-Match" class="headerlink" title="Exact vs. Best Match"></a>Exact vs. Best Match</h4><p>精确匹配：二值 (0/1) 匹配，检索结果无序，可以用 boolean queries (布尔查询)、proximity operators (邻接算子)、simple regular expressions (正则表达式)。对文档量级有限制。</p><p>最佳匹配：相似度 (0~1) 匹配，检索结果按照相似度排序。</p><h2 id="布尔模型-Boolean-Retrieval"><a href="#布尔模型-Boolean-Retrieval" class="headerlink" title="布尔模型 | Boolean Retrieval"></a>布尔模型 | Boolean Retrieval</h2><p>一种最常见的精确匹配模型，通常结果是无序呈现（unranked），有的模型会增加简单的排序。</p><p>精确匹配模型最直接的想法：<strong>线性扫描</strong>，从头到尾扫描文档集，对每个文档都查看是否包含关键词。在 Unix/Linux 系统中的文本扫描命令 grep 做的就是这种工作。然而，当需要检索的文档规模非常大时，这种线性扫描的方式的效率会变得非常低下。</p><h3 id="如何实现-Boolean-Retrieval"><a href="#如何实现-Boolean-Retrieval" class="headerlink" title="如何实现 Boolean Retrieval"></a>如何实现 Boolean Retrieval</h3><p>需要实现如下的模块：</p><ul><li>Term-document incidence (<strong>词典表</strong>): 类似 index (索引) 的文档呈现的形式，一个矩阵中，用 0 和 1 标记文档中出现的 term (词项)。</li><li><p>Boolean queries (布尔查询): AND, OR, AND-NOT.</p></li><li><p>Incidence vector (关联向量): 0/1 vector, bitwise AND。</p></li><li><p>Proximity operators (邻接算子): phrases - “”、same sentence - “ /s ”、same paragraph - “/p” 等等。</p></li></ul><h3 id="实现中的要点"><a href="#实现中的要点" class="headerlink" title="实现中的要点"></a>实现中的要点</h3><p>在词典表实现中，为了避免矩阵过大，还可以引入 inverted index (<strong>倒排索引</strong>) 存储矩阵，这里不再赘述。下面介绍两个实现步骤中的概念。</p><p><strong>token (词条) vs. term (词项)</strong>：</p><p>对于英文文本而言，词条就是根据空格把单词一个一个地提取出来，把原始文本分割开。词项则是更加统一规范的的词条。</p><p>例如在文本中可能出现 “apple”、“apples”、“Apple” 这类 token，但我们知道这几个 token 都是表达苹果（apple）的意思，因此，在构建索引的时候通常会把这几个 token 统一还原为 “apple”，只为 “apple” 建立索引项，那么 “apple” 就是一个 term 了。</p><h3 id="Features-to-Note-about-Queries"><a href="#Features-to-Note-about-Queries" class="headerlink" title="Features to Note about Queries"></a>Features to Note about Queries</h3><ul><li>Queries are developed incrementally. 查询表达式是可增长的，往往一直增加直到查询出正确结果。</li><li>Queries are complex. 用到了一定公式，对初学者不友好。</li><li>Queries are long (av. 9-10 words). 不同于通常的自然语言询问，只需要 1-2 个单词。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信息检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IR</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo配置与扩展</title>
    <link href="/Hexo-Configuration.html"/>
    <url>/Hexo-Configuration.html</url>
    
    <content type="html"><![CDATA[<p>Hello My World 的姊妹篇。</p><p>本站基于 Hexo + GitHub 搭建，采用 Fluid 主题。</p><p>这篇文章记录了博客的配置历程，包括：主题配置、域名配置、功能扩展。</p><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>本站采用的是 Fluid 主题，以下的配置在路径 <code>hewei2001/_config.fluid.yml</code> 中可以实现。该文件的介绍参见 <a href="https://hexo.fluid-dev.com/docs/guide/">主题配置指南</a>。以下仅介绍部分较为特殊的配置，其他内容可在指南中找到。</p><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p><code>lib</code>: 选择生成高亮的库，可选项有 highlightjs 和 prismjs，对应下面两组配置。</p><p>这里选择 <code>highlightjs</code>，将 <code>style</code> 修改为 <code>Night Owl</code> 风格，将 <code>bg_color</code> 修改为 <code>true</code> 以适配暗色代码框。</p><p>其他尝试过的主题还有 <code>Atom One Dark Reasonable</code>、<code>Vs 2015</code>、<code>Github Dark Dimmed</code>，都是不错的暗色风格。</p><h3 id="Mac-风格代码块"><a href="#Mac-风格代码块" class="headerlink" title="Mac 风格代码块"></a>Mac 风格代码块</h3><p>在 GitHub 的 Issue 发现有人提供了自定义样式实现 Mac 风格代码块的方法，遂尝试之。首先在路径 <code>hewei2001/themes/fluid/source/css</code> 下新建文件 <code>mac.styl</code>，复制以下代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.highlight</span><br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#011627</span><br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span><br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">30px</span> <span class="hljs-number">0</span> rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, .<span class="hljs-number">4</span>)<br>    <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">30px</span><br><br>    <span class="hljs-selector-pseudo">&amp;::before</span><br>      <span class="hljs-attribute">background</span>: <span class="hljs-number">#fc625d</span><br>      <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span><br>      <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">20px</span> <span class="hljs-number">0</span> <span class="hljs-number">#fdbc40</span>, <span class="hljs-number">40px</span> <span class="hljs-number">0</span> <span class="hljs-number">#35cd4b</span><br>      <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27; &#x27;</span><br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">12px</span><br>      <span class="hljs-attribute">left</span>: <span class="hljs-number">12px</span><br>      <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">20px</span><br>      <span class="hljs-attribute">position</span>: absolute<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">12px</span><br></code></pre></td></tr></table></figure><p>然后在路径 <code>hewei2001/_config.fluid.yml</code> 中找到 <code>custom_css</code> 选项，加入 <code>/css/mac.css</code> 代码，注意这里后缀名依然使用 <code>.css</code>，不然无法识别！</p><h3 id="行内代码颜色"><a href="#行内代码颜色" class="headerlink" title="行内代码颜色"></a>行内代码颜色</h3><p>默认的行内代码颜色和正文颜色是继承关系，且行内代码背景色也不明显，因此视觉上难以区分。但是配置文件中又没有对应选项可以修改，查阅 GitHub 的 Issue 发现，有人曾提供过一个解决方案。</p><p>打开路径 <code>hewei2001/themes/fluid/source/css/_pages/_base</code> 下的 <code>base.styl</code> 文件，找到 <code>code</code> 配置项，修改颜色为 <code>#E05B35</code>。</p><h3 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h3><p>Valine 是国内的一款极简风格的评论软件，也是 Fluid 支持的评论软件之一。在 <code>comment</code> 中选择 <code>valine</code>，之后找到相应的配置区域进行如下操作：</p><p>进入官网 <a href="https://leancloud.cn/">LeanCloud</a> 完成注册，然后在控制台创建一个项目 <code>Blog.Comments</code> 后，获取密钥（App ID 和 App Key），在对应位置填入。其他内容选项可以在官网找到说明。</p><h3 id="访问人数统计"><a href="#访问人数统计" class="headerlink" title="访问人数统计"></a>访问人数统计</h3><p>Fluid 主题提供两种网站的 PV、UV 统计数来源：<a href="https://www.leancloud.cn/">LeanCloud</a> 与 <a href="http://busuanzi.ibruce.info/">不蒜子</a>。不蒜子不需要申请账号，直接开启即可，但有时候会响应缓慢拖慢整个页面加载。LeanCloud 使用前需要申请账号，由于前面使用评论功能时已经注册，我们这边直接使用就行。</p><p>在控制台创建一个项目 <code>Blog.Counter</code> 后，获取密钥（App ID 和 App Key）和大陆服务器地址，填入 <code>web_analytics</code> 配置项中 <code>leancloud</code> API 相关参数。</p><h3 id="内置-Tag-插件"><a href="#内置-Tag-插件" class="headerlink" title="内置 Tag 插件"></a>内置 Tag 插件</h3><p>Fluid 内置了一些 Tag 插件，用于实现 Markdown 不容易生成的样式，以下仅列出两种常用的使用语法，添加在 md 文件中：</p><ul><li>脚注</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">正文[^1]<br><br><span class="hljs-section">## 参考</span><br>[<span class="hljs-symbol">^1</span>]: <span class="hljs-link">参考资料1</span><br>[<span class="hljs-symbol">^2</span>]: <span class="hljs-link">参考资料2</span><br></code></pre></td></tr></table></figure><ul><li>Tag 便签</li></ul><p>在 markdown 中加入如下的代码来使用便签：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% note success %&#125;<br>文字 或者 <span class="hljs-code">`Markdown`</span> 均可<br>可选便签：primary/secondary/success/danger/warning/info/light<br>&#123;% endnote %&#125;<br></code></pre></td></tr></table></figure><p>或者使用 HTML 形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-primary&quot;</span>&gt;</span>标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Latex-数学公式"><a href="#Latex-数学公式" class="headerlink" title="Latex 数学公式"></a>Latex 数学公式</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">math:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span> <span class="hljs-string">或</span> <span class="hljs-string">katex</span><br></code></pre></td></tr></table></figure><p>其中 <code>specific</code> 建议开启：当为 true 时，只有在文章 Front-matter 里指定 <code>math: true</code> 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度。</p><p>由于 Hexo 默认的 Markdown 渲染器不支持复杂公式，所以必须更换渲染器为 MathJax + Kramed。新版的 Fluid 建议使用 MathJax + Pandoc 渲染器，这样就可以避免一系列字符错乱。下面仅介绍 Kramed 的配置方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm uninstall hexo-renderer-marked --save  <span class="hljs-comment"># 卸载原渲染器</span><br>$ npm install hexo-renderer-kramed --save    <span class="hljs-comment"># mathjax + kramed</span><br>$ npm install hexo-renderer-pandoc --save<span class="hljs-comment"># mathjax + pandoc</span><br>$ npm install @upupming/hexo-renderer-markdown-it-plus --save  <span class="hljs-comment"># katex</span><br></code></pre></td></tr></table></figure><p>这里选择 MathJax 而不是 Katex，是因为其对 LaTeX 语法支持全面，且右键点击公式有扩展功能菜单。</p><p>但是 Hexo 中会对一些字符转义，使得用 MathJax 渲染公式有时会出错，根据 GitHub 上的 Issue，需要找到路径 <code>node_modules\kramed\lib\rules\inline.js</code>，修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//第11行：取消对 \ 和 &#123;&#125; 的转义 escape</span><br><span class="hljs-attr">escape</span>: <span class="hljs-regexp">/^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/</span>,<br><span class="hljs-built_in">escape</span>: <span class="hljs-regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,<br><span class="hljs-comment">//第20行：避免下划线 _ 被转义为斜体，而非 LaTeX 下标</span><br>em: <span class="hljs-regexp">/^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,<br>em: <span class="hljs-regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,<br><span class="hljs-comment">//第64行：避免反斜杠加竖线 \| 被转义为 |，而非 LaTeX 双竖线</span><br><span class="hljs-built_in">escape</span>: replace(inline.escape)(<span class="hljs-string">&#x27;])&#x27;</span>, <span class="hljs-string">&#x27;~|])&#x27;</span>)(),<br><span class="hljs-attr">escape</span>: replace(inline.escape)(<span class="hljs-string">&#x27;])&#x27;</span>, <span class="hljs-string">&#x27;~])&#x27;</span>)(),<br></code></pre></td></tr></table></figure><p>如果发现 MathJax 公式虽然能显示，但字体异常，右键点击公式，检查是否默认设置了 <code>Math Settings &gt; Math Renderer &gt; CHTML</code>，将其改为 <code>SVG</code> 可以恢复正常。打开博客主题路径 <code>hewei2001\themes\fluid\layout\_partials\plugins\math.ejs</code>，修改如下内容即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// import_js(theme.static_prefix.mathjax.replace(&#x27;es5/&#x27;, &#x27;&#x27;), &#x27;es5/tex-mml-chtml.js&#x27;)</span><br>import_js(theme.static_prefix.mathjax.replace(<span class="hljs-string">&#x27;es5/&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>), <span class="hljs-string">&#x27;es5/tex-svg-full.js&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>Tips1：在使用数学公式时，应当避免使用两个连续的 <code>&#123;&#125;</code>，否则会被 Hexo 解释为特殊标签，从而报错。</p><p>Tips2：Hexo 对公式的支持不如 Typora 好，譬如<strong>多行公式</strong>需要用 <code>\begin&#123;aligned&#125; ... \end&#123;aligned&#125;</code>，换行符 <code>\\</code> 和定位符 <code>&amp;</code>。</p><p>Tips3：Hexo 中变量的<strong>上下标</strong>只能用 LaTeX 实现而不能用 Enhanced Markdown 语法。</p><p>Tips4：行内公式、公式块里的联立公式，如果含有<strong>分数</strong>或者<strong>大运算符</strong>（如求和），需要用 <code>\begin&#123;aligned&#125; ... \end&#123;aligned&#125;</code> 夹住，否则会被渲染器压扁。</p><p>Tips5：公式块内如果一行有多个式子，间隙可能会被压缩，需要用 <code>\quad</code> 分隔。</p></blockquote><h2 id="域名配置"><a href="#域名配置" class="headerlink" title="域名配置"></a>域名配置</h2><h3 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h3><p>有了 GitHub Pages 服务器自带的域名后，还可以到阿里云再购买一个自定义域名，然后将域名解析到博客的域名，具体过程如下：</p><ol><li>注册阿里云，实名认证后在购买下 hwcoder.top 域名。</li><li>打开域名控制台，进入<strong>域名解析</strong>列表，进入新买的域名，添加两条记录：<ul><li>主机记录：@；记录类型：A；记录值为 GitHub Pages 域名的 IP。</li><li>主机记录：www；记录类型：CNAME；记录值为 GitHub Pages 域名。</li></ul></li><li>在路径 <code>hewei2001/source</code> 下新建一个 <code>CNAME</code> 文件，里面填写我们买的域名，注意文件不需要任何后缀。</li><li>GitHub 中打开对应仓库，在 Setting 中找到 Pages，添加 Custom Domain 为新买的域名，旁边的一个 <code>Enforce HTTPS</code> 勾选后我们的网站就变为 <a href="https://hwcoder.top。">https://hwcoder.top。</a></li><li>路径 <code>hewei2001/_config.yml</code> 的<code>#URL</code> 部分，更改为新域名。</li></ol><p>以上操作后就可以在自定义的域名访问博客站点了，如果显示的内容与本地服务器查看内容不同，<strong>清除浏览器缓存</strong>后即可解决。如果不能解决，检查是否以上步骤有错。</p><h3 id="部署到-Coding-Pages"><a href="#部署到-Coding-Pages" class="headerlink" title="部署到 Coding Pages"></a>部署到 Coding Pages</h3><p>Coding 可以算是国内的 GitHub，尽管并不是特别流行，但部署到上面可以使国内访问速度更快，还可以提交百度收录（GitHub 禁止了百度的爬取）。</p><p>注意：由于 Coding 在前段时间改版后，原有的个人版 Pages 下架，以企业版的形式重新开放，新版的静态网站服务需调用腾讯云对象存储 COS、内容分发网络 CDN、SSL 证书产品等资源，其中 COS 和 CDN 采用<strong>用量计费模式</strong>。故本博客暂不采用 Coding 部署。</p><h3 id="部署到-Cloudflare-Pages"><a href="#部署到-Cloudflare-Pages" class="headerlink" title="部署到 Cloudflare Pages"></a>部署到 Cloudflare Pages</h3><p>无意中发现了 Cloudflare 这个平台在 2021 年初开始提供了静态网页托管的服务，且对免费用户也比较友好。</p><p>下面是部署的过程：</p><ol><li>注册 Cloudflare 账户，注册后与 GitHub 绑定。</li><li>绑定账户后可以直接 clone 博客仓库，按照引导选择 Build，等待若干分钟即可，部署后访问 <a href="https://hewei2001.pages.dev/">https://hewei2001.pages.dev/</a> 可以看到博客页面。</li><li><strong>自定义域名设置</strong>：输入 <code>hwcoder.top</code>，提示需要进行将 DNS <strong>转移</strong>到 Cloudflare 服务器，选择 Free 免费版本。</li><li><strong>更改名称服务器</strong>：打开之前购买域名的阿里云，进入域名控制台，选择 DNS 修改，按照 Cloudflare 的提示将原 DNS 服务器修改为指定的内容。</li><li>等待 DNS 转移成功后，重复第 4 步操作，此时 Cloudflare 会<strong>自动</strong>将 DNS 记录为 A 的那条修改为如下内容：<ul><li>主机记录：hwcoder；记录类型：CNAME；记录值为 Cloudflare Pages 域名。</li></ul></li></ol><p>通过 Cloudflare 双线部署后，不需要在 <code>_config.yml</code> 文件中加入新的部署仓库，因为自带的 Hook 会在每次部署到 GitHub 后拉取更新。</p><h3 id="搜索路径优化"><a href="#搜索路径优化" class="headerlink" title="搜索路径优化"></a>搜索路径优化</h3><p>Hexo 博客默认的文章路径是 <code>域名/年/月/日/文章标题</code>，这样的多层目录搜索引擎爬虫爬起来非常费力，平时查阅也很困难，因此需要优化文章的 URL 路径。</p><p>打开 <code>hewei2001/_config.yml</code>，找到 <code>permalink</code> 项，将 <code>:year/:month/:day/:title/</code> 修改为 <code>:name.html</code>，就可以用 <code>域名/文章标题</code> 访问了。</p><blockquote><p><code>:title</code> 和 <code>:name</code> 的区别是：前者访问时会保留相对于 <code>_post</code> 目录的路径，改成后者后就是纯粹的文章标题。</p></blockquote><p>此外，还可以将下方的 <code>pretty_url</code> 项中的两个 <code>true</code> 改为 <code>false</code> 用于美化 URL，两项分别是去除连接中的后缀 <code>index.html</code> 和 <code>.html</code> 的。</p><h3 id="添加百度谷歌收录"><a href="#添加百度谷歌收录" class="headerlink" title="添加百度谷歌收录"></a>添加百度谷歌收录</h3><p>如果仅部署在 GitHub Pages，是无法被百度收录的，因为 GitHub 禁止了百度爬虫，最常见的解决办法是进行双线部署。</p><p>下面介绍如何提交百度和谷歌搜索：</p><ol><li><p>进入<a href="https://link.jianshu.com?t=http://zhanzhang.baidu.com/linksubmit/url">百度搜索提交入口</a> 或 <a href="https://link.jianshu.com?t=https://www.google.com/webmasters/tools/home?hl=zh-CN">Google搜索提交入口</a>，登录。百度的提交入口比较隐蔽，需要进入 <code>用户中心 &gt; 站点管理</code>。</p></li><li><p>输入网站后，需要验证对网站的所有权，有三种验证方式，这里选择「HTML <strong>标签验证</strong>」，打开 <code>hewei2001/themes/fluid/layout/_partial/head.ejs</code> 文件，将验证标签放入 <code>&lt;head&gt;...&lt;/head&gt;</code> 中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;baidu-site-verification&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;code-J3wrn8WJYJ&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;google-site-verification&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;0p_KJKTfB8EcahVDp0vYRjVRhHFw1SBWHi15OakKHY0&quot;</span> /&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 注意每个站点的验证标签都不一样，请勿复制！ --&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>重新 <code>hexo d</code> 后，等待数分钟，点击完成验证，就会出现成功提示。</p></li></ol><p>提交搜索后，可以选择添加<strong>站点地图</strong>使搜索引擎更智能地抓取内容：</p><ol><li><p>在博客目录下打开 Git Bash，输入如下命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-generator-sitemap --save<br>$ npm install hexo-generator-baidu-sitemap --save<br></code></pre></td></tr></table></figure></li><li><p>打开 <code>hewei2001/_config.yml</code>，在最下方添加如下字段：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 自动生成sitemap</span><br><span class="hljs-attr">sitemap:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">sitemap.xml</span><br><span class="hljs-attr">baidusitemap:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">baidusitemap.xml</span><br></code></pre></td></tr></table></figure></li><li><p>重新 <code>hexo d</code> 后，等待数分钟。</p></li><li><p>打开刚才验证网站的页面，找到 <code>sitemap</code> 相关字样，输入：</p><ul><li>百度：<a href="https://hwcoder.top/baidusitemap.xml">https://hwcoder.top/baidusitemap.xml</a></li><li>谷歌：<a href="https://hwcoder.top/sitemap.xml">https://hwcoder.top/sitemap.xml</a></li></ul></li></ol><p>完成以上内容后，就可以静待两个搜索引擎的收录啦，其他搜索引擎也同理，在搜索引擎中输入 <code>site:hwcoder.top</code> 就可以实时查看收录结果。</p><h2 id="其他功能扩展"><a href="#其他功能扩展" class="headerlink" title="其他功能扩展"></a>其他功能扩展</h2><p>以下配置是在 Fluid 主题中不具有的功能，通过各种插件实现。</p><h3 id="备份博客到-GitHub"><a href="#备份博客到-GitHub" class="headerlink" title="备份博客到 GitHub"></a>备份博客到 GitHub</h3><p>由于 Hexo 博客是静态托管的，所有的原始数据都保存在本地，如果哪一天电脑坏了，或者是误删了本地数据就很危险了。</p><p>GitHub 上可以找到一个 <code>hexo-git-backup</code> 插件，但似乎已经不再更新了，仅支持 Hexo 3.x.x 版本，尝试后放弃。</p><h3 id="压缩静态资源"><a href="#压缩静态资源" class="headerlink" title="压缩静态资源"></a>压缩静态资源</h3><p>博客中有大量 HTML、CSS、JS 文件，这些文件为了阅读方便会加入许多回车和空行，但在页面解析时其实会浪费部分时间，此外如果有许多插图，也会拖慢网页加载，并占据 GitHub 仓库的存储空间。</p><p>目前有关插件有 <code>gulp</code>、<code>hexo-neat</code>、<code>hexo-all-minifier</code>。推荐采用集成度比较高的 <code>hexo-all-minifier</code> 来实现，由于在安装依赖包过程报错，本站最终采用了 <code>hexo-neat</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-all-minifier --save  <span class="hljs-comment"># 出现 npm ERR! code ELIFECYCLE 错误</span><br>$ npm install hexo-neat --save <span class="hljs-comment"># 换成这个后成功安装</span><br></code></pre></td></tr></table></figure><p>之后在配置文件 <code>hewei2001/_config.yml</code> 中增加如下内容就行：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># hexo-neat</span><br><span class="hljs-comment">## Docs: https://github.com/rozbo/hexo-neat</span><br><span class="hljs-attr">neat_enable:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 压缩 html</span><br><span class="hljs-attr">neat_html:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">exclude:</span><br><span class="hljs-comment"># 压缩 css  </span><br><span class="hljs-attr">neat_css:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">exclude:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;**/*.min.css&#x27;</span><br><span class="hljs-comment"># 压缩 js</span><br><span class="hljs-attr">neat_js:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">mangle:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">output:</span><br>  <span class="hljs-attr">compress:</span><br>  <span class="hljs-attr">exclude:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;**/*.min.js&#x27;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;**/jquery.fancybox.pack.js&#x27;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;**/index.js&#x27;</span> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello My World</title>
    <link href="/Hello-My-World.html"/>
    <url>/Hello-My-World.html</url>
    
    <content type="html"><![CDATA[<p>谨以此文纪念该个人网站的诞生。</p><p>本站基于 Hexo + GitHub 搭建，采用 Fluid 主题。</p><p>这篇文章记录了博客的搭建历程，以及 Hexo 的使用指南。</p><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>早在大学入学时，夏老师就告知了个人博客的重要性。</p><p>期间也看过许多漂亮的个人网站，也看到很多大神的技术博客，偶尔会心动一下。</p><p>于是乎，咕到了大二快结束时，打开了这个新世界的大门。</p><h2 id="搭建历程"><a href="#搭建历程" class="headerlink" title="搭建历程"></a>搭建历程</h2><h3 id="1-安装-Node-js"><a href="#1-安装-Node-js" class="headerlink" title="1. 安装 Node.js"></a>1. 安装 Node.js</h3><p>官网：<a href="https://nodejs.org/en/">nodejs.org</a></p><p>安装后在 cmd 命令行输入 <code>node -v</code> 即可查看版本。</p><h3 id="2-注册-GitHub"><a href="#2-注册-GitHub" class="headerlink" title="2. 注册 GitHub"></a>2. 注册 GitHub</h3><p>注册后，创建仓库：<a href="https://github.com/hewei2001/hewei2001.github.io">https://github.com/hewei2001/hewei2001.github.io</a></p><p>此时在浏览器中已经可以访问域名：<a href="https://hewei2001.github.io">https://hewei2001.github.io</a></p><p>注意，仓库名必须取 <code>&lt;username&gt;.github.io</code>，如果仓库取了其他名字，最后访问的域名会是：<a href="https://用户名.github.io/仓库名/">https://用户名.github.io/仓库名/</a></p><h3 id="3-下载-Git"><a href="#3-下载-Git" class="headerlink" title="3. 下载 Git"></a>3. 下载 Git</h3><p>官网：<a href="https://gitforwindows.org/">gitforwindows.org</a></p><p>安装时按照默认配置即可，其中有个 MinTTY 终端模拟器的选项会默认选上，如果不选则会使用 Windows 自带的终端 cmd 显示 Git Bash。</p><p>安装后在 cmd 命令行输入 <code>git</code> 即可调出功能目录。</p><p>此后就在 cmd 中配置 Git 个人基本信息（绑定 GitHub）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global user.name <span class="hljs-string">&quot;hewei2001&quot;</span><br>$ git config --global user.email <span class="hljs-string">&quot;631670924@qq.com&quot;</span><br></code></pre></td></tr></table></figure><p>配置完才后续才可以正常提交远程仓库（详见博客 Git 分类下其他文章）。</p><h3 id="4-配置-GitHub-SSH"><a href="#4-配置-GitHub-SSH" class="headerlink" title="4. 配置 GitHub SSH"></a>4. 配置 GitHub SSH</h3><p>该步骤旨在建立当前主机与 GitHub 的安全连接，以后提交/拉取仓库才不需要重复输入密码。如果你这台主机已经建立过 SSH 连接，那么可以跳过这一步。</p><p>打开 Git Bash 输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;631670924@qq.com&quot;</span> <span class="hljs-comment"># 获取 SSH Key</span><br></code></pre></td></tr></table></figure><p>完成后，在提示路径下找到 .ssh 文件夹中的 id_rsa.pub 公钥文件，用记事本打开拷贝。</p><p>在 GitHub 个人设置中找到 SSH，新建，输入 Key。</p><p>配置后可以用如下命令测试是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh -T git@github.com<br><span class="hljs-comment"># 运行结果出现类似如下即表示成功</span><br><span class="hljs-comment"># Hi hewei2001! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></code></pre></td></tr></table></figure><h3 id="5-安装-Hexo"><a href="#5-安装-Hexo" class="headerlink" title="5. 安装 Hexo"></a>5. 安装 Hexo</h3><p>官网：<a href="https://hexo.io/zh-cn/">hexo.io</a>，有中文官网。</p><p>在电脑中新建 Blog 文件夹，如 <code>D:\Blog</code>。</p><p>在 cmd 命令行打开 D 盘，用 <code>cd Blog</code>命令进入 Blog 子目录。或者在文件夹路径栏直接输入 <code>cmd</code>。</p><p>输入 Hexo 官网上的全局安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-cli -g<br></code></pre></td></tr></table></figure><p>输入初始化部署命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init hewei2001<br></code></pre></td></tr></table></figure><p>即可在 Blog 目录下新建<strong>博客文件夹</strong> hewei2001。用 <code>cd hewei2001</code>命令进入博客子目录。</p><p>输入安装 Node.js 包管理器命令，安装所有的依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install<br></code></pre></td></tr></table></figure><p>输入生成本地预览命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo s<br></code></pre></td></tr></table></figure><p>默认会生成 <code>localhost:4000</code> 端口的网址，在浏览器中可以访问。</p><h3 id="6-安装编辑器"><a href="#6-安装编辑器" class="headerlink" title="6. 安装编辑器"></a>6. 安装编辑器</h3><p>主要用于编写文档和修改配置，这里选择 VsCode 即可，打开路径 <code>hewei2001/source/_posts/hello-world.md</code>，随便修改内容后保存。</p><p>在 hewei2001 目录中运行 Git Bash。</p><p>依次输入清理缓存、生成博客文件（静态页面）、<strong>生成本地预览</strong>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo cl <span class="hljs-comment"># 表示 clean</span><br>$ hexo g  <span class="hljs-comment"># 表示 generate</span><br>$ hexo s  <span class="hljs-comment"># 表示 server</span><br></code></pre></td></tr></table></figure><p>在浏览器中访问即可查看更改。之后按下 Ctrl + C 即可退出预览进程。</p><h3 id="7-将-Hexo-发布至-GitHub"><a href="#7-将-Hexo-发布至-GitHub" class="headerlink" title="7. 将 Hexo 发布至 GitHub"></a>7. 将 Hexo 发布至 GitHub</h3><p>打开路径 <code>hewei2001/_config.yml</code>，更改基础参数。</p><ul><li><code>#Site</code> 部分的站点描述自行修改</li><li><code>#URL</code> 部分，将链接改为 <a href="https://hewei2001.github.io">https://hewei2001.github.io</a> </li><li><code>#Deployment</code> 部分<ul><li><code>type</code> 改为 git</li><li><code>repo</code> 改为 <a href="https://github.com/hewei2001/hewei2001.github.io.git">https://github.com/hewei2001/hewei2001.github.io.git</a></li><li><code>branch</code> 改为 main（旧版本默认分支叫 master）</li></ul></li></ul><p>进入 Hexo 官网，复制 hexo-deployer-git 的安装命令，在 Git Bash 中安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>依次输入清理缓存、生成博客文件（静态页面）、<strong>提交远程仓库</strong>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo cl<br>$ hexo g<br>$ hexo d  <span class="hljs-comment"># 表示 deploy，安装了上面的 hexo-deployer-git 才可用</span><br></code></pre></td></tr></table></figure><p>初次使用该操作可能会弹出一个 GitHub 登录界面，用于当前主机的身份验证。</p><p>在浏览器中访问 <a href="https://hewei2001.github.io">https://hewei2001.github.io</a>  即可查看站点。</p><h2 id="Hexo-使用"><a href="#Hexo-使用" class="headerlink" title="Hexo 使用"></a>Hexo 使用</h2><p>以下介绍其他常用的 Hexo 操作命令，需要在博客文件夹下打开 Git Bash 使用。</p><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo n <span class="hljs-string">&quot;文章名&quot;</span> <span class="hljs-comment"># 代表 new</span><br></code></pre></td></tr></table></figure><p>文章名不需要文件后缀，会自动生成 Markdown 文件，且带有预先定义的参数（在 Front-matter 中），如标题、日期、标签等。</p><p>以下是一些常用的参数及默认设置：</p><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>title</code></td><td>标题，最好用<strong>引号</strong>括起来</td><td>文章的文件名</td></tr><tr><td><code>date</code></td><td>建立日期</td><td>文件建立日期</td></tr><tr><td><code>updated</code></td><td>更新日期</td><td>文件更新日期</td></tr><tr><td><code>comments</code></td><td>开启文章的评论功能</td><td>true</td></tr><tr><td><code>categories</code></td><td>分类（不适用于分页）</td><td>无</td></tr><tr><td><code>tags</code></td><td>标签（不适用于分页）</td><td>无</td></tr><tr><td><code>excerpt</code></td><td>摘要，优先于 <code>&lt;!-- more --&gt;</code></td><td>无</td></tr><tr><td><code>index_img</code></td><td>文章封面图，用 /img/ 相对路径</td><td>无</td></tr><tr><td><code>math</code></td><td>公式转换，关闭时加速加载</td><td>true</td></tr><tr><td><code>sticky</code></td><td>文章置顶，数值越大越靠前</td><td>无</td></tr></tbody></table></div><p>注意 Hexo 采用的是 GitHub Favored Markdown，书写规范与标准 Markdown 有微小区别，可以查阅 GitHub 上的说明。</p><h3 id="布局管理"><a href="#布局管理" class="headerlink" title="布局管理"></a>布局管理</h3><p>在上面新建文章时，我们还可以制定布局：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo n [layout] <span class="hljs-string">&quot;文章名&quot;</span> <br></code></pre></td></tr></table></figure><p>其中，<code>layout</code> 可替换为 post（文章，默认）、draft（草稿）、page（页面）。默认值可以在配置文件中修改 <code>default_layout</code> 来改动。不同布局的文件会存储在不同位置。</p><p>对于 page 布局，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件，页面布局顾名思义就是用来 DIY 我们博客页面的，不会被渲染。 </p><p>对于 draft 布局，在建立时会被保存到 <code>source/drafts</code> 文件夹中，但不会显示在页面上，如果我们不想某一篇文章显示在页面上，也可以把它移动到该文件夹中。</p><p>此外，还有关于 draft 的一些操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo s --draft  <span class="hljs-comment"># 在服务器预览时加入草稿文件</span><br>$ hexo publish [layout] <span class="hljs-string">&quot;文章名&quot;</span>  <span class="hljs-comment"># 将草稿发布为 post 或 page</span><br></code></pre></td></tr></table></figure><h3 id="修改默认布局"><a href="#修改默认布局" class="headerlink" title="修改默认布局"></a>修改默认布局</h3><p>上述布局管理中的三种布局，还对应这三种模板，这些模板可以在 <code>hewei2001/scaffolds</code> 路径下找到，我们可以提前修改 post 模板，这样每次新建文章时就不需要自己添加 Front-matter 了。</p><p>以下是我修改后的 Front-matter 布局：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> &#123;&#123; <span class="hljs-string">title</span> &#125;&#125;<br><span class="hljs-attr">excerpt:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/home/</span><br><span class="hljs-attr">math:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">date:</span> &#123;&#123; <span class="hljs-string">date</span> &#125;&#125;<br><span class="hljs-attr">updated:</span><br><span class="hljs-attr">category_bar:</span> [<span class="hljs-string">&quot;分类&quot;</span>]<br><span class="hljs-attr">categories:</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-attr">sticky:</span> <br></code></pre></td></tr></table></figure><h3 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h3><p>在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p><p>首先要创建「分类」和「标签」本身所在的<strong>页面</strong>，打开博客文件夹，执行 <code>hexo new page xxx</code> 命令。Fluid 主题不需要，已经自带「分类」、「标签」和「归档」页面了，故这里不展开介绍。</p><p>此后就可以 post 布局的文章指定分类和标签了，也需要在对应文章的 Front-matter 中设置。Hexo 不鼓励给一篇文章指定<strong>多个同级分类</strong>，因此需要规划好。下面是指定方法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">categories:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">技术经验</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">博客</span>  <span class="hljs-comment"># 「博客」会作为「技术经验」的子类</span><br><span class="hljs-attr">tags:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">Hexo</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">Git</span>  <span class="hljs-comment"># 「Hexo」与「Git」是同级标签</span><br></code></pre></td></tr></table></figure><p>当然，Hexo 还提供了一种类 WordPress 的分类方式，用于指定多个同级分类：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">categories:</span><br><span class="hljs-bullet">-</span> [<span class="hljs-string">Diary</span>, <span class="hljs-string">PlayStation</span>]<br><span class="hljs-bullet">-</span> [<span class="hljs-string">Diary</span>, <span class="hljs-string">Games</span>]<br><span class="hljs-bullet">-</span> [<span class="hljs-string">Life</span>]  <span class="hljs-comment"># 文章会同时出现在三个类别中</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术经验</category>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
