<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg"><link rel="icon" href="/img/logo.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#01213a"><meta name="author" content="He Wei"><meta name="keywords" content="Computer Science and Technology, Machine Learning, Deep Learning, Computer Vision, Natural Language Processing"><meta name="baidu-site-verification" content="code-J3wrn8WJYJ"><meta name="google-site-verification" content="0p_KJKTfB8EcahVDp0vYRjVRhHFw1SBWHi15OakKHY0"><meta name="description" content="算法入门学习过程中的笔记，本文零碎地记录了一系列算法竞赛技巧、调试技巧、实用代码、C++ 特性、IDE 代码模板，以及在刷题时根据不同数据范围选择算法的技巧。"><meta property="og:type" content="article"><meta property="og:title" content="算法入门笔记 #1 杂记"><meta property="og:url" content="https://hwcoder.top/Algo-Note-1"><meta property="og:site_name" content="Hwcoder - Life Oriented Programming"><meta property="og:description" content="算法入门学习过程中的笔记，本文零碎地记录了一系列算法竞赛技巧、调试技巧、实用代码、C++ 特性、IDE 代码模板，以及在刷题时根据不同数据范围选择算法的技巧。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hwcoder.top/img/home/coding.png"><meta property="article:published_time" content="2022-08-27T08:23:05.000Z"><meta property="article:modified_time" content="2022-11-23T14:42:25.169Z"><meta property="article:author" content="He Wei"><meta property="article:tag" content="Algorithm"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://hwcoder.top/img/home/coding.png"><title>算法入门笔记 #1 杂记 | Hwcoder - Life Oriented Programming</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/mac.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"hwcoder.top",root:"/",version:"1.9.0",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h2, h3",placement:"left",visible:"always",icon:"§"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4",collapseDepth:3},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"XGNf4GEnaFLiUijMUvz8HSBF-gzGzoHsz",app_key:"JPeVLcug6EcWdBTpGrDJSdKi",server_url:"https://xgnf4gen.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Hwcoder</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于我</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/bg/other.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="算法入门笔记 #1 杂记"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-08-27 16:23" pubdate>2022年8月27日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 7.7k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 43 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="算法笔记" id="heading-6caacb5aaee15525d7a2b4768aa79852" role="tab" data-toggle="collapse" href="#collapse-6caacb5aaee15525d7a2b4768aa79852" aria-expanded="true">算法笔记 <span class="list-group-count">(17)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-6caacb5aaee15525d7a2b4768aa79852" role="tabpanel" aria-labelledby="heading-6caacb5aaee15525d7a2b4768aa79852"><div class="category-post-list"></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="力扣刷题" id="heading-9ca088cdf0fdc34dd48290c9d13c88b1" role="tab" data-toggle="collapse" href="#collapse-9ca088cdf0fdc34dd48290c9d13c88b1" aria-expanded="false">力扣刷题 <span class="list-group-count">(15)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-9ca088cdf0fdc34dd48290c9d13c88b1" role="tabpanel" aria-labelledby="heading-9ca088cdf0fdc34dd48290c9d13c88b1"><div class="category-post-list"><a href="/LeetCode-Array" title="力扣刷题笔记 #01 数组" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #01 数组</span> </a><a href="/LeetCode-Bitwise" title="力扣刷题笔记 #02 数位&amp;二进制" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #02 数位&amp;二进制</span> </a><a href="/LeetCode-Data-Structure" title="力扣刷题笔记 #03 数据结构" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #03 数据结构</span> </a><a href="/LeetCode-Divide-Conquer" title="力扣刷题笔记 #04 二分&amp;分治" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #04 二分&amp;分治</span> </a><a href="/LeetCode-DP-1" title="力扣刷题笔记 #05.1 一维动态规划" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #05.1 一维动态规划</span> </a><a href="/LeetCode-DP-2" title="力扣刷题笔记 #05.2 二维动态规划" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #05.2 二维动态规划</span> </a><a href="/LeetCode-DP-3" title="力扣刷题笔记 #05.3 复杂动态规划" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #05.3 复杂动态规划</span> </a><a href="/LeetCode-Graph" title="力扣刷题笔记 #06 图论" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #06 图论</span> </a><a href="/LeetCode-Greedy" title="力扣刷题笔记 #07 贪心算法" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #07 贪心算法</span> </a><a href="/LeetCode-LinkList" title="力扣刷题笔记 #08 链表" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #08 链表</span> </a><a href="/LeetCode-Math" title="力扣刷题笔记 #09 数学" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #09 数学</span> </a><a href="/LeetCode-Search" title="力扣刷题笔记 #10 搜索&amp;剪枝" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #10 搜索&amp;剪枝</span> </a><a href="/LeetCode-Stack-Queue" title="力扣刷题笔记 #11 栈&amp;队列" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #11 栈&amp;队列</span> </a><a href="/LeetCode-String" title="力扣刷题笔记 #12 字符串" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #12 字符串</span> </a><a href="/LeetCode-Tree" title="力扣刷题笔记 #13 树" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #13 树</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem list-group-item category-item-action col-10 col-md-11 col-xm-11" title="算法入门" id="heading-cbb23c60a3cdd7188054b6ba4efbf423" role="tab" data-toggle="collapse" href="#collapse-cbb23c60a3cdd7188054b6ba4efbf423" aria-expanded="true">算法入门 <span class="list-group-count">(2)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-cbb23c60a3cdd7188054b6ba4efbf423" role="tabpanel" aria-labelledby="heading-cbb23c60a3cdd7188054b6ba4efbf423"><div class="category-post-list"><a href="/Algo-Note-1" title="算法入门笔记 #1 杂记" class="list-group-item list-group-item-action active"><span class="category-post">算法入门笔记 #1 杂记</span> </a><a href="/Algo-Note-2" title="算法入门笔记 #2 STL标准库" class="list-group-item list-group-item-action"><span class="category-post">算法入门笔记 #2 STL标准库</span></a></div></div></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">算法入门笔记 #1 杂记</h1><p class="note note-info">本文最后更新于：2022年11月23日 晚上</p><div class="markdown-body"><p>该笔记是去年尝试入坑 ACM 竞赛的遗留物，为作机试的准备，重新整理一遍以加深印象。以下部分内容出自<strong>刘汝佳</strong>的《算法计算入门经典》，也就是俗称的「<strong>紫书</strong>」，部分内容参考了网上流传甚广的博客。</p><h2 id="算法竞赛技巧"><a href="#算法竞赛技巧" class="headerlink" title="算法竞赛技巧"></a>算法竞赛技巧</h2><ol><li>数组在 <code>main</code> 外面定义可以开得更大：避免<strong>爆栈</strong>，在全局区申请分担压力；<code>main</code> 函数返回 0，是为了告诉操作系统、IDE、调试器、OJ，程序正常结束。</li><li>对复杂的表达式化简不仅可以减少计算量，还能减少<strong>中间结果溢出</strong>的可能，尤其是带除法运算的浮点数，绝对会爆 double，必须把表达式通分后除最大公约数。</li><li><p>使用 <code>while(scanf(&quot;%d&quot;, &amp;x) == 1)</code>读入<strong>未知量</strong>数据：<code>scanf</code> 会成功返回读入变量的个数，如果有多个变量，则用 <code>== 2</code>。否则即使只成功一个，返回 <code>1</code>，循环还是会执行。如果发生错误输入/中止符，中止前输入的数也会被保存。</p><ul><li><p>此时运行代码时如果用键盘输入，则最后一个 Enter 无法中止程序，因为函数默认略过换行。</p></li><li><p>在 Windows 下，输入完毕后先按 Enter 再按 <code>Ctrl+Z</code> 再按 Enter 可以结束输入，相当于人工输入一个 EOF，换成 <code>while(scanf() != EOF)</code> 也行。</p></li><li><p>在 Linux 下，输入完毕后按 <code>Ctrl+D</code> 即可。</p></li></ul></li><li>使用 <code>while(cin&gt;&gt;x)</code> 读入<strong>未知量</strong>数据：正常输入，直到遇到文件结束符 EOF 或人工输入 <code>Ctrl+Z</code>，istream 返回无效假条件；错误输入，如用字符输入整型变量，也会返回假条件，强制结束循环；如果有多个读入 <code>&gt;&gt;x&gt;&gt;y</code>，只要发生上面任意一种，都会中止，但在中止前输入的数会保存；<ul><li>证明了 <code>&gt;&gt;</code> 运算符返回值是同样的 istream。</li></ul></li><li>打表法：对于输入范围在 1e3 以内，暴力复杂度较高的情况，使用一个 <code>freopen(&quot;ans.txt&quot;,&quot;w&quot;,stdout);</code> 即可将输出重定向到文本，再<strong>造好数组格式的输出</strong>，手动复制到代码里提交即可；<ul><li>一维数组：造输出时用 <code>printf(&quot;%d,&quot;,num);</code> 不要忘记输出逗号，复制到 <code>int ans[]=&#123;这里&#125;;</code> 。</li><li>二维数组：造输出时用 <code>printf(f[%d][%d]=%d&quot;,i,j,d[n][m]);</code>，复制到一个 <code>void get_ans()&#123;这里&#125;</code>。</li><li>如果有 <code>long long</code> 输出，必须带上 <code>LL</code>，用 <code>printf(&quot;f[%d][%d]=%lldLL&quot;,i,j,d[n][m]);</code>。</li></ul></li><li>O3 优化：如果代码里有 STL 的话，请一定加上这句话 <code>#pragma GCC optimize(3)</code>，一般的 OJ 都是默认开启的，洛谷需要手动点一下。<ul><li>开启 O3 后编译器会自动 <code>inline/register</code> 加速，节省时间（代价是汇编代码变多，可能编译失败）。</li><li>开启 O3 后编译器会自动 <code>const</code> 所有不修改的常量，加速取模等复杂运算。</li><li>开启 O3 后编译器会自动将乘法变成移位运算。</li></ul></li><li><code>cin/cout</code> 解绑：原生的 <code>cin/cout</code> 的速度非常慢，因为要和 <code>scanf/printf</code> 进行同步，所以需要加上 <code>ios::sync_with_stdio(false); cin.tie(0);</code><ul><li>注意解绑后，不能使用 <code>scanf/printf</code> 了，快读也是不可以的。解绑后的 <code>cin/cout</code> 的速度是比 <code>scanf</code> 要快的，因为不用类型判断。</li><li>解绑后可以 <code>#define endl &quot;\n&quot;</code>，因为 <code>endl</code> 在使用的时候不仅仅是换行，还会清空缓冲区。速度上可能比 <code>&quot;\n&quot;</code> 换行慢了 10 倍。</li></ul></li></ol><h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><ol><li>最常用的方法：<strong>输出中间结果</strong>，提交代码时记得注释掉；</li><li>使用 <code>exit(0);</code> 中断程序，如果没有问题，则往下继续中断，也可以用来定位 bug；</li><li>编译时加入以下参数 <code>-Wall -Wshadow</code>：增强警告信息，列举所有有遮盖关系的变量（覆盖）；</li><li>调试时不想反复输入数据，可用<strong>重定向输入输出</strong>，这样就会把文件作为流：<ul><li><code>freopen(&quot;input.in&quot;, &quot;r&quot;, stdin);</code></li><li><code>freopen(&quot;output.out&quot;, &quot;w&quot;, stdout);</code></li><li>如果懒得注释可以用 <code>#define LOCAL</code>，再在 <code>#ifdef LOCAL</code> 和 <code>#endif</code> 两句中重定向，提交代码时删除定义语句 <code>#define LOCAL</code>。</li></ul></li><li><strong>断言</strong>表达式 <code>assert(判断语句)</code>：当判断语句为真时无变化，当表达式为假时中止程序，并给出错误提示。</li></ol><h2 id="实用代码"><a href="#实用代码" class="headerlink" title="实用代码"></a>实用代码</h2><ol><li>如果题目要求文件提交，但禁止重定向：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">FILE *fin, *fout;	<span class="hljs-comment">// c</span><br>fin=<span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;data.in&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br>fout=<span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;data.out&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>);<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">fscanf</span>(fin, <span class="hljs-string">&quot;%d&quot;</span>, &amp;x) != EOF)<br>	<span class="hljs-built_in">fprintf</span>(fout, <span class="hljs-string">&quot;%d&quot;</span>, x);<br><span class="hljs-built_in">fclose</span>(fin);<br><span class="hljs-built_in">fclose</span>(fout);<br></code></pre></td></tr></table></figure><blockquote><p>在比赛前先了解是使用标准输入输出（即标准I/O，用键盘读写）还是文件输入输出。如果是文件输入输出，是否禁止用重定向的方式访问文件</p></blockquote><ol><li>如果允许重定向：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x) != EOF) 	<span class="hljs-comment">// 这里也可以换成 cin &gt;&gt; x</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, x);			<span class="hljs-comment">// 这里也可以换成 cout &lt;&lt; x</span><br><span class="hljs-built_in">fclose</span>(stdin);<br><span class="hljs-built_in">fclose</span>(stdout);<br></code></pre></td></tr></table></figure><ol><li><p>交换两数：<code>a^=b^=a^=b;</code></p></li><li><p>三整数排序：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(a&gt;b) <span class="hljs-built_in">swap</span>(a,b); <span class="hljs-comment">// 执行完a≤b</span><br><span class="hljs-keyword">if</span>(a&gt;c) <span class="hljs-built_in">swap</span>(a,c); <span class="hljs-comment">// 执行完a≤c，且a≤b依然成立</span><br><span class="hljs-keyword">if</span>(b&gt;c) <span class="hljs-built_in">swap</span>(b,c); <span class="hljs-comment">// 执行完a≤b≤c</span><br></code></pre></td></tr></table></figure><ol><li><p>四舍五入：<code>floor(x+0.5)</code>，此时等于 1 的区间为 <code>[0.5, 1.5)</code></p><ul><li><p>注意，小数部分为 0.5 数可能受到浮点误差的影响，因为计算机中可能存了 0.49999。</p></li><li><p>并且 <code>floor</code> 函数返回值是 double 型，要强转或赋值给 int 型。</p></li></ul></li><li>简单求无理数：<code>const double pi = acos(-1.0)</code>，注意三角函数使用弧度制。类似的还有 <code>const double e = exp(1.0)</code>。</li><li>交错输出：<code>printf(&quot;%d&quot;, q?a:b); q=!q;</code></li><li>更新最值：<code>ans=max(ans,dfs(i,j));</code></li><li>初始化某个<strong>数组</strong>为正无穷：<code>memset(a,0x3f,sizeof(a));</code>，比直接用 <code>0x7fffffff</code> 好，不容易加法溢出。同理初始化为负无穷用 <code>memset(a,0xcf,sizeof(a));</code><ul><li>在 LeetCode 中如果用 vector 初始化，可以用 <code>vector&lt;int&gt; a(n, INT_MAX)</code>，同理还有 <code>INT_MIN</code> 常量，这是在 limits.h 头文件中定义的最大最小值，分别是 2147483647 和 -2147483648（<code>-INT_MAX-1</code>）。</li></ul></li><li>求数组实际长度：<code>sizeof(a)/sizeof(单位)</code>，前者仅仅是整个数组占内存大小，必须除以单位才能得到数组的实际长度。<ul><li>注意这里的 <code>a</code> 是数组名，但如果用指针指向数组，<code>sizeof(指针)</code> 得到的却是指针的长度，这是数组名和指针的一大区别。</li><li>在 32 位 (x86) 系统中，指针长度为 4，在 64 位 (x64) 系统中，指针长度为 8。</li></ul></li><li>两个整数相除并<strong>向上取整</strong>：<code>(x + y - 1) / y</code>，比 <code>ceil((double x / y))</code> 更快。</li></ol><h2 id="C-vs-C"><a href="#C-vs-C" class="headerlink" title="C vs. C++"></a>C vs. C++</h2><h3 id="版本比较"><a href="#版本比较" class="headerlink" title="版本比较"></a>版本比较</h3><ul><li>在 C89 中不允许在 <code>for</code> 循环中 <code>int i=0</code>，但 C99 后和 C++ 都可以。</li><li>在 C99 中，<strong>double 的输出</strong>必须用 <code>%f</code>，输入要用 <code>%lf</code>，但 C89 和 C++ 中都可以全用 <code>%lf</code>，所以尽量用 C++。</li><li>C99 中只规定了 int 至少是 16 位，但没规定具体值，好在比赛平台几乎都是 32 位，即上限 <code>2147483647</code>，这里有 10 位数，long long 最大值有 19 位数。</li><li><p>C99 用 <strong>long long</strong> 可以解决<strong>部分溢出</strong>，但是输入时要改成 <code>%lld</code>。</p><ul><li>但是在 MinGW 的 gcc 中，要把 <code>%lld</code> 改成 <code>%I64d</code>，在 VC2008 中又得改回 <code>%lld</code>。</li><li>因此如果涉及 long long 的输入输出，常用 C++ 的<strong>输入输出流</strong> <code>cin/cout</code> 或<strong>自定义</strong>的输入输出方法。</li></ul></li><li>C 中的 <code>gets(s)</code> 存在缓冲区溢出漏洞，不推荐使用，在 C11 标准中，已经被正式删除。<ul><li>使用 <code>fgets(buf, maxn, fin);</code> 替代，或者直接用 C++ 的 <code>cin&gt;&gt;s;</code>。</li><li>但是 C++ 直接流读取 string 类型会在<strong>遇到空格时停止</strong>，如果想要读取一整行包含空格的字符串，可以用 <code>getline(cin,str);</code>。</li></ul></li><li>C++ 声明数组时，可以用 const 声明的<strong>常数数组</strong>，在 C99 中是不允许的，推荐用 C++。</li></ul><h3 id="新增工具"><a href="#新增工具" class="headerlink" title="新增工具"></a>新增工具</h3><ul><li>C++ 中特有的 bool 型变量，只有 0 或 1 两种取值，用 true 和 false 表示真和假。</li><li>C 中的空指针 NULL 定义为 <code>((void *)0)</code>，使用时可以强转赋值给任意类型指针，而 C++ 不能隐式强转，因此 NULL 被定义为 <code>0</code>，引入了新的关键字 <code>nullptr</code> 来表示空指针。</li></ul><ul><li><p>C 中的 <code>qsort</code> 需要强转万能指针 <code>void*</code>，并且让 cmp 函数在 <code>a&lt;b,a=b,a&gt;b</code> 时分别返回负数、零、正数。注意 cmp 是被函数指针 <code>int (*comparator)</code> 指向的函数。一般在算法竞赛中使用 C++ STL 中的 sort 函数。</p><ul><li><p>sort 通常配合自定义 cmp 函数实现复杂排序 <code>bool cmp(T &amp;a,T &amp;b)&#123;return a&lt;b;&#125;</code>，在力扣刷题时要在函数前加上 <code>static</code>。</p></li><li><p>对于比较简短的比较函数，也可以用 <strong>Lambda 表达式</strong>直接塞进 sort 里面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 完全闭包，无外部变量</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-keyword">auto</span> &amp;a, <span class="hljs-keyword">auto</span> &amp;b)&#123;<br>    <span class="hljs-keyword">return</span> a &lt; b;<br>&#125;);<br><span class="hljs-comment">// 捕捉闭包外的变量，&amp;hash 表示引用捕捉指定变量，也可以只用 &amp; 表示全部变量</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [&amp;hash](<span class="hljs-keyword">auto</span> &amp;a, <span class="hljs-keyword">auto</span> &amp;b)&#123;<br>    <span class="hljs-keyword">if</span>(hash[a] == hash[b]) <span class="hljs-keyword">return</span> a &gt; b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> hash[a] &lt; hash[b];<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>C++ 中可以用 C 的类型强转：<code>(ll)a</code> 或 <code>ll(a)</code>，此外还新增了四种强转方法，用于类、结构体的强转。最基本的用法是 <code>static_cast&lt;long long&gt;</code>，效果和 C 的类似。</p></li><li><p>C++ 中除了有 Lambda 表达式，还可以封装可调用的 Lambda <strong>仿函数</strong>（函数内嵌函数），可以<strong>避免用到全局变量、或传入冗长的参数</strong>，在 LeetCode 中较为使用，具体用法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 使用 &amp; 表示捕获全部变量</span><br>	function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; dfs = [&amp;](<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) &#123;<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;; <span class="hljs-comment">// 注意这里必须要有分号</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="全新特性"><a href="#全新特性" class="headerlink" title="全新特性"></a>全新特性</h3><ul><li>C++ 中最重要的特点就是「<strong>函数传引用调用</strong>」，例如 <code>void swap2(int&amp;a, int&amp;b)</code>，不必再传指针调用，更方便快捷。对于字符串、长数组可以<strong>节省大量时间</strong>，且可以直接在函数内修改原参数。<ul><li>不过一旦使用 <code>&amp;</code> 入参就<strong>不能为常量</strong>，如 <code>func(1)</code>。此时只能使用 <code>const auto&amp; a</code> 传参，这样<strong>速度更快</strong>，但是<strong>限制了函数内修改参数</strong>。</li></ul></li><li>C++ 中除了 struct 还有 class，工程中，一般用 struct 定义纯数据的类型，用 class 定义复杂行为的类型，二者最主要的区别是<strong>访问权限和继承方式</strong>不同。但算法竞赛中还是常用 struct 来定义结构体，因为 C++ 的结构体还可以定义<strong>成员函数</strong>、<strong>构造函数</strong>等。<ul><li>拥有构造函数的结构体，可以通过 <code>T *a = new T(10);</code> 调用，得到一个指向结构体的指针，在力扣刷题用。</li><li>此外也可以直接调用 <code>T a(10);</code> 或 <code>T a = T(10);</code> 或 <code>T b = a;</code>，在洛谷刷题比较常用。</li></ul></li><li>C++ 中可以重载运算符，实现结构体之间的四则运算和输入输出。例如：<ul><li><code>T operator +(const T &amp;A) const&#123; return ...;&#125;</code> 在结构体内重载加法运算；</li><li><code>T operator +(const T &amp;A, const T &amp;B)&#123; return ...;&#125;</code> 在结构体外重载加法运算；</li><li><code>ostream&amp; operator &lt;&lt; (ostream &amp;out, const T&amp; p)&#123; out &lt;&lt; ...; return out;&#125;</code> 在结构体外重载输出流；</li></ul></li><li>C++ 中具有<strong>泛型、模板</strong>的概念，即 <code>template&lt;typename T&gt;</code>，可以实现<strong>函数端口参数的自适应</strong>，如各种类型数组的求和，甚至结构体数组的求和（需要重载加法）。</li></ul><h2 id="算法时间复杂度选择"><a href="#算法时间复杂度选择" class="headerlink" title="算法时间复杂度选择"></a>算法时间复杂度选择</h2><p>一般 ACM 或者笔试题的时间限制是 1 秒或 2 秒。在这种情况下，C++ 代码中的操作次数控制在 $10^7 \sim 10^8$ 为最佳。</p><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p><div class="table-container"><table><thead><tr><th style="text-align:center">数据范围</th><th style="text-align:center">时间复杂度</th><th style="text-align:center">算法</th></tr></thead><tbody><tr><td style="text-align:center">$n \leq 30$</td><td style="text-align:center">$O(n!) \;\; O\left(2^{n}\right)$</td><td style="text-align:center">DFS+剪枝、状态压缩 DP</td></tr><tr><td style="text-align:center">$n \leq 100$</td><td style="text-align:center">$O\left(n^{3}\right)$</td><td style="text-align:center">Floyd、DP、高斯消元</td></tr><tr><td style="text-align:center">$n \leq 1000$</td><td style="text-align:center">$O\left(n^{2}\right) \;\; O\left(n^{2} \log n\right)$</td><td style="text-align:center">DP、二分、朴素版 Dijkstra、朴素版 Prim、Bellman-Ford</td></tr><tr><td style="text-align:center">$n \leq 10000$</td><td style="text-align:center">$O(n\sqrt{n})$</td><td style="text-align:center">块状链表、分块</td></tr><tr><td style="text-align:center">$n \leq 100000$</td><td style="text-align:center">$O(n \log n)$</td><td style="text-align:center">各种 sort、线段树、树状数组、set/map、heap、拓扑排序、Dijkstra+heap、Prim+heap、Kruskal、二分、树链剖分</td></tr><tr><td style="text-align:center">$n \leq 10^{6}$</td><td style="text-align:center">$O(n)$，常数较小的 $O(n \log n)$ 算法</td><td style="text-align:center">单调队列、hash、双指针、并查集、KMP<br>常数比较小的 $O(n \log n)$ 做法：sort、树状数组、heap、Dijkstra</td></tr><tr><td style="text-align:center">$n \leq 10^{7}$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">双指针扫描、KMP、差分、前缀和、离散化</td></tr><tr><td style="text-align:center">$n \leq 10^{9}$</td><td style="text-align:center">$O(\sqrt{n})$</td><td style="text-align:center">判断质数</td></tr><tr><td style="text-align:center">$n \leq 10^{18}$</td><td style="text-align:center">$O(\log n)$</td><td style="text-align:center">最大公约数、快速幂</td></tr><tr><td style="text-align:center">$n \leq 10^{1000}$</td><td style="text-align:center">$O\left((\log n)^{2}\right)$</td><td style="text-align:center">高精度加减乘除</td></tr><tr><td style="text-align:center">$n \leq 10^{100000}$</td><td style="text-align:center">$O(\log k \times \log \log k)$，$k$ 表示位数</td><td style="text-align:center">高精度加减、FFT/NTT</td></tr></tbody></table></div><h2 id="IDE-代码模板"><a href="#IDE-代码模板" class="headerlink" title="IDE 代码模板"></a>IDE 代码模板</h2><p>ACM 模式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X first</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Y second</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lb(x) ((x) &amp; (-x))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem(a,b) memset(a,b,sizeof(a))</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> db;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-keyword">int</span>&gt; vi;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">int</span> n,m,k;<br><span class="hljs-keyword">int</span> dp[maxn][maxn], a[maxn][maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>力扣人工补全：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// int long double bool char string void auto </span><br><span class="hljs-comment">// vector stack queue deque pair map set </span><br><span class="hljs-comment">// unordered_map unordered_set priority_queue</span><br><span class="hljs-comment">// multimap multiset hash seen clear</span><br><span class="hljs-comment">// front back push_back insert erase</span><br><span class="hljs-comment">// make_pair first second push pop top</span><br><span class="hljs-comment">// lower_bound upper_bound sort find count</span><br><span class="hljs-comment">// reverse swap substr cout endl max min</span><br><span class="hljs-comment">// for while if else continue break return </span><br><span class="hljs-comment">// size const operator begin end iterator</span><br><span class="hljs-comment">// nullptr sizeof new INT_MAX INT_MIN ch str</span><br><span class="hljs-comment">// idx col row left right ans res flag len</span><br></code></pre></td></tr></table></figure><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>与<strong>取值范围</strong>有关：</p><ol><li>根据<strong>取值范围</strong>判断类型，注意 $10^5$ 个 $10^5$ 相加有 11 位数会爆 int，要用 <code>long long</code>。</li><li>当题目明确说「对 $1e9 + 7$ 取模」时，一定要用 <code>long long</code>，可以确保一次相乘后还不会溢出，但是<strong>可能溢出的地方</strong>都要尽量取模。</li><li>当题目明确说「保证 XXX 在<strong>不取余</strong>的情况下可以用 <strong>64 位有符号整数</strong>保存」时，此时不仅要开 <code>long long</code>，还不能先取模，因为可能需要 <code>max</code> 操作（<strong>不满足模不变性</strong>），必须在最后返回时才取模。</li><li>给 <code>long long</code> 变量赋值（<code>+=</code>）时，等号右边也可能溢出，最好先进行转换 <code>1LL *</code>。</li></ol><p>与<strong>边界条件</strong>有关：</p><ol><li>使用 stack、queue 等容器时，要注意<strong>容器可能为空</strong>，直接访问元素会报 heap 溢出编译错误。</li><li>使用 $i+1$、$i-1$ 等方式访问容器 vector 的时候，要注意可能<strong>容器越界</strong>，会报 vector 编译错误。</li><li>记得测试 $n$ 等于 $0$ 或 $1$ 等边界情形时，答案是否需要<strong>特判</strong>。</li></ol><p>与<strong>题目的坑</strong>有关：</p><ol><li>有的坑题故意给排好序的样例，但实际上要<strong>先自己排序</strong>。</li><li>有的题目要统计满足某条件的 XX 个数，还告诉你答案可能很大，但只要题目没说，一定要<strong>特判个数为</strong> $0$ 的情况。</li></ol><p>与<strong>复杂度</strong>有关：</p><ol><li>当题目出现树结构时（无论是题目给的或是自己用的），都要防止<strong>树退化成链表</strong>，卡复杂度 $O(n^2)$。</li><li>搜索题如果用到 DFS，要根据参数看是否需要<strong>记忆化</strong>，如果会重复访问同一个状态则需要。</li></ol></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" class="category-chain-item">算法笔记</a> <span>></span> <a href="/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/" class="category-chain-item">算法入门</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Algorithm/">#Algorithm</a></div></div><div class="license-box my-3"><div class="license-title"><div>算法入门笔记 #1 杂记</div><div>https://hwcoder.top/Algo-Note-1</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>He Wei</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年8月27日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/Algo-Note-2" title="算法入门笔记 #2 STL标准库"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">算法入门笔记 #2 STL标准库</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/Uplift-2" title="Uplift Recommendation 论文汇总"><span class="hidden-mobile">Uplift Recommendation 论文汇总</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.16/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"jdbBr3BddTiqSCPnXw6sXFv7-gzGzoHsz","appKey":"2bjgwDr2opjVCwhgjDMpk53c","path":"window.location.pathname","placeholder":"说点什么吧( •̀ ω •́ )✧","avatar":"retro","meta":["nick","mail","link"],"requiredFields":["nick"],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-t}),0<o.find(".toc-list-item").length&&o.css("visibility","visible"))})</script><script>!function(){var i,t=CONFIG.code_language.enable&&CONFIG.code_language.default,c=CONFIG.copy_btn;(t||c)&&(i="",i+='<div class="code-widget">',i+="LANG",i+="</div>",jQuery(".markdown-body pre").each(function(){var e,a,n=jQuery(this);0<n.find("code.mermaid").length||0<n.find("span.line").length||(e="",t&&(e=CONFIG.code_language.default,0<n[0].children.length&&2<=n[0].children[0].classList.length&&n.children().hasClass("hljs")?e=n[0].children[0].classList[1]:n[0].getAttribute("data-language")?e=n[0].getAttribute("data-language"):n.parent().hasClass("sourceCode")&&0<n[0].children.length&&2<=n[0].children[0].classList.length?(e=n[0].children[0].classList[1],n.parent().addClass("code-wrapper")):n.parent().hasClass("markdown-body")&&0===n[0].classList.length&&n.wrap('<div class="code-wrapper"></div>'),e=e.toUpperCase().replace("NONE",CONFIG.code_language.default)),n.append(i.replace("LANG",e).replace('code-widget">',(a=n[0],(0<=Fluid.utils.getBackgroundLightness(a)?"code-widget-light":"code-widget-dark")+(c?' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>':' code-widget">')))),c&&Fluid.utils.createScript("https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js",function(){new window.ClipboardJS(".copy-btn",{target:function(e){for(var a=e.parentNode.childNodes,n=0;n<a.length;n++)if("CODE"===a[n].tagName)return a[n]}}).on("success",function(e){e.clearSelection(),e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-copy","icon-success"),setTimeout(function(){e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-success","icon-copy")},2e3)})}))}))}()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script>MathJax = {
          tex    : {
            inlineMath: { '[+]': [['$', '$']] }
          },
          loader : {
            load: ['ui/lazy']
          },
          options: {
            renderActions: {
              findScript    : [10, doc => {
                document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                  const display = !!node.type.match(/; *mode=display/);
                  const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                  const text = document.createTextNode('');
                  node.parentNode.replaceChild(text, node);
                  math.start = { node: text, delim: '', n: 0 };
                  math.end = { node: text, delim: '', n: 0 };
                  doc.math.push(math);
                });
              }, '', false],
              insertedScript: [200, () => {
                document.querySelectorAll('mjx-container').forEach(node => {
                  let target = node.parentNode;
                  if (target.nodeName.toLowerCase() === 'li') {
                    target.parentNode.classList.add('has-jax');
                  }
                });
              }, '', false]
            }
          }
        };</script><script src="https://lib.baomitu.com/mathjax/3.2.0/es5/tex-svg-full.js"></script><script src="/js/local-search.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>