<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg"><link rel="icon" href="/img/logo.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#01213a"><meta name="author" content="Wei He"><meta name="keywords" content="Computer Science and Technology, Machine Learning, Deep Learning, Computer Vision, Natural Language Processing"><meta name="description" content="算法入门学习过程中的笔记，本文零碎地记录了一系列算法竞赛技巧、调试技巧、实用代码、C++ 特性、IDE 代码模板，以及在刷题时根据不同数据范围选择算法的技巧。"><meta property="og:type" content="article"><meta property="og:title" content="算法入门笔记 #1 杂记"><meta property="og:url" content="https://hwcoder.top/Algo-Note-1"><meta property="og:site_name" content="Hwcoder - Life Oriented Programming"><meta property="og:description" content="算法入门学习过程中的笔记，本文零碎地记录了一系列算法竞赛技巧、调试技巧、实用代码、C++ 特性、IDE 代码模板，以及在刷题时根据不同数据范围选择算法的技巧。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hwcoder.top/img/home/coding.png"><meta property="article:published_time" content="2022-08-27T08:23:05.000Z"><meta property="article:modified_time" content="2025-03-22T12:21:53.311Z"><meta property="article:author" content="Wei He"><meta property="article:tag" content="Algorithm"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://hwcoder.top/img/home/coding.png"><title>算法入门笔记 #1 杂记 | Hwcoder - Life Oriented Programming</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/mac.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"hwcoder.top",root:"/",version:"1.9.5",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h2, h3",placement:"left",visible:"always",icon:"§"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4",collapseDepth:3},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"XGNf4GEnaFLiUijMUvz8HSBF-gzGzoHsz",app_key:"JPeVLcug6EcWdBTpGrDJSdKi",server_url:"https://xgnf4gen.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")})</script><meta name="generator" content="Hexo 5.4.2"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Hwcoder</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/bg/other.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="算法入门笔记 #1 杂记"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-08-27 16:23" pubdate>2022年8月27日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 8.5k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 48 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="算法笔记" id="heading-6caacb5aaee15525d7a2b4768aa79852" role="tab" data-toggle="collapse" href="#collapse-6caacb5aaee15525d7a2b4768aa79852" aria-expanded="true">算法笔记 <span class="list-group-count">(21)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-6caacb5aaee15525d7a2b4768aa79852" role="tabpanel" aria-labelledby="heading-6caacb5aaee15525d7a2b4768aa79852"><div class="category-post-list"></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="力扣刷题" id="heading-9ca088cdf0fdc34dd48290c9d13c88b1" role="tab" data-toggle="collapse" href="#collapse-9ca088cdf0fdc34dd48290c9d13c88b1" aria-expanded="false">力扣刷题 <span class="list-group-count">(15)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-9ca088cdf0fdc34dd48290c9d13c88b1" role="tabpanel" aria-labelledby="heading-9ca088cdf0fdc34dd48290c9d13c88b1"><div class="category-post-list"><a href="/LeetCode-Array" title="力扣刷题笔记 #01 数组" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #01 数组</span> </a><a href="/LeetCode-Bitwise" title="力扣刷题笔记 #02 数位&amp;二进制" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #02 数位&amp;二进制</span> </a><a href="/LeetCode-Data-Structure" title="力扣刷题笔记 #03 数据结构" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #03 数据结构</span> </a><a href="/LeetCode-Divide-Conquer" title="力扣刷题笔记 #04 二分&amp;分治" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #04 二分&amp;分治</span> </a><a href="/LeetCode-DP-1" title="力扣刷题笔记 #05-1 一维动态规划" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #05-1 一维动态规划</span> </a><a href="/LeetCode-DP-2" title="力扣刷题笔记 #05-2 二维动态规划" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #05-2 二维动态规划</span> </a><a href="/LeetCode-DP-3" title="力扣刷题笔记 #05-3 复杂动态规划" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #05-3 复杂动态规划</span> </a><a href="/LeetCode-Graph" title="力扣刷题笔记 #06 图论" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #06 图论</span> </a><a href="/LeetCode-Greedy" title="力扣刷题笔记 #07 贪心算法" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #07 贪心算法</span> </a><a href="/LeetCode-LinkList" title="力扣刷题笔记 #08 链表" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #08 链表</span> </a><a href="/LeetCode-Math" title="力扣刷题笔记 #09 数学" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #09 数学</span> </a><a href="/LeetCode-Search" title="力扣刷题笔记 #10 搜索&amp;剪枝" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #10 搜索&amp;剪枝</span> </a><a href="/LeetCode-Stack-Queue" title="力扣刷题笔记 #11 栈&amp;队列" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #11 栈&amp;队列</span> </a><a href="/LeetCode-String" title="力扣刷题笔记 #12 字符串" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #12 字符串</span> </a><a href="/LeetCode-Tree" title="力扣刷题笔记 #13 树" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #13 树</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="手撕经典算法" id="heading-67ebbc1a1af276ea349725e619870fea" role="tab" data-toggle="collapse" href="#collapse-67ebbc1a1af276ea349725e619870fea" aria-expanded="false">手撕经典算法 <span class="list-group-count">(4)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-67ebbc1a1af276ea349725e619870fea" role="tabpanel" aria-labelledby="heading-67ebbc1a1af276ea349725e619870fea"><div class="category-post-list"><a href="/Manual-Coding-1" title="手撕经典算法 #1 Attention篇" class="list-group-item list-group-item-action"><span class="category-post">手撕经典算法 #1 Attention篇</span> </a><a href="/Manual-Coding-2" title="手撕经典算法 #2 神经网络篇" class="list-group-item list-group-item-action"><span class="category-post">手撕经典算法 #2 神经网络篇</span> </a><a href="/Manual-Coding-3" title="手撕经典算法 #3 Transformer篇" class="list-group-item list-group-item-action"><span class="category-post">手撕经典算法 #3 Transformer篇</span> </a><a href="/Manual-Coding-4" title="手撕经典算法 #4 经典函数篇" class="list-group-item list-group-item-action"><span class="category-post">手撕经典算法 #4 经典函数篇</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem list-group-item category-item-action col-10 col-md-11 col-xm-11" title="算法入门" id="heading-cbb23c60a3cdd7188054b6ba4efbf423" role="tab" data-toggle="collapse" href="#collapse-cbb23c60a3cdd7188054b6ba4efbf423" aria-expanded="true">算法入门 <span class="list-group-count">(2)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-cbb23c60a3cdd7188054b6ba4efbf423" role="tabpanel" aria-labelledby="heading-cbb23c60a3cdd7188054b6ba4efbf423"><div class="category-post-list"><a href="/Algo-Note-1" title="算法入门笔记 #1 杂记" class="list-group-item list-group-item-action active"><span class="category-post">算法入门笔记 #1 杂记</span> </a><a href="/Algo-Note-2" title="算法入门笔记 #2 STL标准库" class="list-group-item list-group-item-action"><span class="category-post">算法入门笔记 #2 STL标准库</span></a></div></div></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">算法入门笔记 #1 杂记</h1><p class="note note-info">本文最后更新于：2025年3月22日 晚上</p><div class="markdown-body"><p>该笔记是去年尝试入坑 ACM 竞赛的遗留物，为作机试的准备，重新整理一遍以加深印象。以下部分内容出自<strong>刘汝佳</strong>的《算法计算入门经典》，也就是俗称的「<strong>紫书</strong>」，部分内容参考了网上流传甚广的博客。</p><h2 id="算法竞赛技巧">算法竞赛技巧</h2><ol type="1"><li><p>数组在 <code>main</code> 外面定义可以开得更大：避免<strong>爆栈</strong>，在全局区申请分担压力；<code>main</code> 函数返回 0，是为了告诉操作系统、IDE、调试器、OJ，程序正常结束。</p></li><li><p>对复杂的表达式化简不仅可以减少计算量，还能减少<strong>中间结果溢出</strong>的可能，尤其是带除法运算的浮点数，绝对会爆 double，必须把表达式通分后除最大公约数。</p></li><li><p>使用 <code>while(scanf("%d", &amp;x) == 1)</code>读入<strong>未知量</strong>数据：<code>scanf</code> 会成功返回读入变量的个数，如果有多个变量，则用 <code>== 2</code>。否则即使只成功一个，返回 <code>1</code>，循环还是会执行。如果发生错误输入/中止符，中止前输入的数也会被保存。</p><ul><li><p>此时运行代码时如果用键盘输入，则最后一个 Enter 无法中止程序，因为函数默认略过换行。</p></li><li><p>在 Windows 下，输入完毕后先按 Enter 再按 <code>Ctrl+Z</code> 再按 Enter 可以结束输入，相当于人工输入一个 EOF，换成 <code>while(scanf() != EOF)</code> 也行。</p></li><li><p>在 Linux 下，输入完毕后按 <code>Ctrl+D</code> 即可。</p></li></ul></li><li><p>使用 <code>while(cin&gt;&gt;x)</code> 读入<strong>未知量</strong>数据：正常输入，直到遇到文件结束符 EOF 或人工输入 <code>Ctrl+Z</code>，istream 返回无效假条件；错误输入，如用字符输入整型变量，也会返回假条件，强制结束循环；如果有多个读入 <code>&gt;&gt;x&gt;&gt;y</code>，只要发生上面任意一种，都会中止，但在中止前输入的数会保存；</p><ul><li>证明了 <code>&gt;&gt;</code> 运算符返回值是同样的 istream。</li></ul></li><li><p>字符串读入：常规方法 <code>cin&gt;&gt;s</code> 可以满足大部分条件，但有时候需要<strong>整行读入</strong>的时候，直接 <code>cin&gt;&gt;s</code> 遇到空格会停止。此时可以用 <code>getline(cin, s)</code>，但要注意先清空输入缓冲区前缀的换行符 <code>cin.ignore()</code>。</p></li><li><p>打表法：对于输入范围在 1e3 以内，暴力复杂度较高的情况，使用一个 <code>freopen("ans.txt","w",stdout);</code> 即可将输出重定向到文本，再<strong>造好数组格式的输出</strong>，手动复制到代码里提交即可；</p><ul><li>一维数组：造输出时用 <code>printf("%d,",num);</code> 不要忘记输出逗号，复制到 <code>int ans[]=&#123;这里&#125;;</code> 。</li><li>二维数组：造输出时用 <code>printf(f[%d][%d]=%d",i,j,d[n][m]);</code>，复制到一个 <code>void get_ans()&#123;这里&#125;</code>。</li><li>如果有 <code>long long</code> 输出，必须带上 <code>LL</code>，用 <code>printf("f[%d][%d]=%lldLL",i,j,d[n][m]);</code>。</li></ul></li><li><p>O3 优化：如果代码里有 STL 的话，请一定加上这句话 <code>#pragma GCC optimize(3)</code>，一般的 OJ 都是默认开启的，洛谷需要手动点一下。</p><ul><li>开启 O3 后编译器会自动 <code>inline/register</code> 加速，节省时间（代价是汇编代码变多，可能编译失败）。</li><li>开启 O3 后编译器会自动 <code>const</code> 所有不修改的常量，加速取模等复杂运算。</li><li>开启 O3 后编译器会自动将乘法变成移位运算。</li></ul></li><li><p><code>cin/cout</code> 解绑：原生的 <code>cin/cout</code> 的速度非常慢，因为要和 <code>scanf/printf</code> 进行同步，所以需要加上 <code>ios::sync_with_stdio(false); cin.tie(0);</code></p><ul><li>注意解绑后，不能使用 <code>scanf/printf</code> 了，快读也是不可以的。解绑后的 <code>cin/cout</code> 的速度是比 <code>scanf</code> 要快的，因为不用类型判断。</li><li>解绑后可以 <code>#define endl "\n"</code>，因为 <code>endl</code> 在使用的时候不仅仅是换行，还会清空缓冲区。速度上可能比 <code>"\n"</code> 换行慢了 10 倍。</li></ul></li></ol><h2 id="调试技巧">调试技巧</h2><ol type="1"><li>最常用的方法：<strong>输出中间结果</strong>，提交代码时记得注释掉；</li><li>使用 <code>exit(0);</code> 中断程序，如果没有问题，则往下继续中断，也可以用来定位 bug；</li><li>编译时加入以下参数 <code>-Wall -Wshadow</code>：增强警告信息，列举所有有遮盖关系的变量（覆盖）；</li><li>调试时不想反复输入数据，可用<strong>重定向输入输出</strong>，这样就会把文件作为流：<ul><li><code>freopen("input.in", "r", stdin);</code></li><li><code>freopen("output.out", "w", stdout);</code></li><li>如果懒得注释可以用 <code>#define LOCAL</code>，再在 <code>#ifdef LOCAL</code> 和 <code>#endif</code> 两句中重定向，提交代码时删除定义语句 <code>#define LOCAL</code>。</li></ul></li><li><strong>断言</strong>表达式 <code>assert(判断语句)</code>：当判断语句为真时无变化，当表达式为假时中止程序，并给出错误提示。</li></ol><h2 id="实用代码">实用代码</h2><ol type="1"><li>如果题目要求文件提交，但禁止重定向：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">FILE *fin, *fout;	<span class="hljs-comment">// c</span><br>fin=<span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;data.in&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br>fout=<span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;data.out&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>);<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">fscanf</span>(fin, <span class="hljs-string">&quot;%d&quot;</span>, &amp;x) != EOF)<br>	<span class="hljs-built_in">fprintf</span>(fout, <span class="hljs-string">&quot;%d&quot;</span>, x);<br><span class="hljs-built_in">fclose</span>(fin);<br><span class="hljs-built_in">fclose</span>(fout);<br></code></pre></td></tr></table></figure><blockquote><p>在比赛前先了解是使用标准输入输出（即标准I/O，用键盘读写）还是文件输入输出。如果是文件输入输出，是否禁止用重定向的方式访问文件</p></blockquote><ol start="2" type="1"><li>如果允许重定向：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x) != EOF) 	<span class="hljs-comment">// 这里也可以换成 cin &gt;&gt; x</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, x);			<span class="hljs-comment">// 这里也可以换成 cout &lt;&lt; x</span><br><span class="hljs-built_in">fclose</span>(stdin);<br><span class="hljs-built_in">fclose</span>(stdout);<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><p>交换两数：<code>a^=b^=a^=b;</code></p></li><li><p>三整数排序：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(a&gt;b) <span class="hljs-built_in">swap</span>(a,b); <span class="hljs-comment">// 执行完a≤b</span><br><span class="hljs-keyword">if</span>(a&gt;c) <span class="hljs-built_in">swap</span>(a,c); <span class="hljs-comment">// 执行完a≤c，且a≤b依然成立</span><br><span class="hljs-keyword">if</span>(b&gt;c) <span class="hljs-built_in">swap</span>(b,c); <span class="hljs-comment">// 执行完a≤b≤c</span><br></code></pre></td></tr></table></figure><ol start="4" type="1"><li><p>四舍五入：<code>floor(x+0.5)</code>，此时等于 1 的区间为 <code>[0.5, 1.5)</code></p><ul><li><p>注意，小数部分为 0.5 数可能受到浮点误差的影响，因为计算机中可能存了 0.49999。</p></li><li><p>并且 <code>floor</code> 函数返回值是 double 型，要强转或赋值给 int 型。</p></li></ul></li><li><p>简单求无理数：<code>const double pi = acos(-1.0)</code>，注意三角函数使用弧度制。类似的还有 <code>const double e = exp(1.0)</code>。</p></li><li><p>交错输出：<code>printf("%d", q?a:b); q=!q;</code></p></li><li><p>更新最值：<code>ans=max(ans,dfs(i,j));</code></p></li><li><p>初始化某个<strong>数组</strong>为正无穷：<code>memset(a,0x3f,sizeof(a));</code>，比直接用 <code>0x7fffffff</code> 好，不容易加法溢出。同理初始化为负无穷用 <code>memset(a,0xcf,sizeof(a));</code></p><ul><li>在 LeetCode 中如果用 vector 初始化，可以用 <code>vector&lt;int&gt; a(n, INT_MAX)</code>，同理还有 <code>INT_MIN</code> 常量，这是在 limits.h 头文件中定义的最大最小值，分别是 2147483647 和 -2147483648（<code>-INT_MAX-1</code>）。</li></ul></li><li><p>求数组实际长度：<code>sizeof(a)/sizeof(单位)</code>，前者仅仅是整个数组占内存大小，必须除以单位才能得到数组的实际长度。</p><ul><li>注意这里的 <code>a</code> 是数组名，但如果用指针指向数组，<code>sizeof(指针)</code> 得到的却是指针的长度，这是数组名和指针的一大区别。</li><li>在 32 位 (x86) 系统中，指针长度为 4，在 64 位 (x64) 系统中，指针长度为 8。</li></ul></li><li><p>两个整数相除并<strong>向上取整</strong>：<code>(x + y - 1) / y</code>，比 <code>ceil((double x / y))</code> 更快。</p></li></ol><h2 id="c-vs.-c">C vs. C++</h2><h3 id="版本比较">版本比较</h3><ul><li><p>在 C89 中不允许在 <code>for</code> 循环中 <code>int i=0</code>，但 C99 后和 C++ 都可以。</p></li><li><p>在 C99 中，<strong>double 的输出</strong>必须用 <code>%f</code>，输入要用 <code>%lf</code>，但 C89 和 C++ 中都可以全用 <code>%lf</code>，所以尽量用 C++。</p></li><li><p>C99 中只规定了 int 至少是 16 位，但没规定具体值，好在比赛平台几乎都是 32 位，即上限 <code>2147483647</code>，这里有 10 位数，long long 最大值有 19 位数。</p></li><li><p>C99 用 <strong>long long</strong> 可以解决<strong>部分溢出</strong>，但是输入时要改成 <code>%lld</code>。</p><ul><li>但是在 MinGW 的 gcc 中，要把 <code>%lld</code> 改成 <code>%I64d</code>，在 VC2008 中又得改回 <code>%lld</code>。</li><li>因此如果涉及 long long 的输入输出，常用 C++ 的<strong>输入输出流</strong> <code>cin/cout</code> 或<strong>自定义</strong>的输入输出方法。</li></ul></li><li><p>C 中的 <code>gets(s)</code> 存在缓冲区溢出漏洞，不推荐使用，在 C11 标准中，已经被正式删除。</p><ul><li>使用 <code>fgets(buf, maxn, fin);</code> 替代，或者直接用 C++ 的 <code>cin&gt;&gt;s;</code>。</li><li>但是 C++ 直接流读取 string 类型会在<strong>遇到空格时停止</strong>，如果想要读取一整行包含空格的字符串，可以用 <code>getline(cin,str);</code>。</li></ul></li><li><p>C++ 声明数组时，可以用 const 声明的<strong>常数数组</strong>，在 C99 中是不允许的，推荐用 C++。</p></li></ul><h3 id="新增工具">新增工具</h3><ul><li><p>C++ 中特有的 bool 型变量，只有 0 或 1 两种取值，用 true 和 false 表示真和假。</p></li><li><p>C 中的空指针 NULL 定义为 <code>((void *)0)</code>，使用时可以强转赋值给任意类型指针，而 C++ 不能隐式强转，因此 NULL 被定义为 <code>0</code>，引入了新的关键字 <code>nullptr</code> 来表示空指针。</p></li><li><p>C 中的 <code>qsort</code> 需要强转万能指针 <code>void*</code>，并且让 cmp 函数在 <code>a&lt;b,a=b,a&gt;b</code> 时分别返回负数、零、正数。注意 cmp 是被函数指针 <code>int (*comparator)</code> 指向的函数。一般在算法竞赛中使用 C++ STL 中的 sort 函数。</p><ul><li><p>sort 通常配合自定义 cmp 函数实现复杂排序 <code>bool cmp(T &amp;a,T &amp;b)&#123;return a&lt;b;&#125;</code>，在力扣刷题时要在函数前加上 <code>static</code>。</p></li><li><p>对于比较简短的比较函数，也可以用 <strong>Lambda 表达式</strong>直接塞进 sort 里面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 完全闭包，无外部变量</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-keyword">auto</span> &amp;a, <span class="hljs-keyword">auto</span> &amp;b)&#123;<br>    <span class="hljs-keyword">return</span> a &lt; b;<br>&#125;);<br><span class="hljs-comment">// 捕捉闭包外的变量，&amp;hash 表示引用捕捉指定变量，也可以只用 &amp; 表示全部变量</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [&amp;hash](<span class="hljs-keyword">auto</span> &amp;a, <span class="hljs-keyword">auto</span> &amp;b)&#123;<br>    <span class="hljs-keyword">if</span>(hash[a] == hash[b]) <span class="hljs-keyword">return</span> a &gt; b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> hash[a] &lt; hash[b];<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>C++ 中可以用 C 的类型强转：<code>(ll)a</code> 或 <code>ll(a)</code>，此外还新增了四种强转方法，用于类、结构体的强转。最基本的用法是 <code>static_cast&lt;long long&gt;</code>，效果和 C 的类似。</p></li><li><p>C++ 中除了有 Lambda 表达式，还可以封装可调用的 Lambda <strong>仿函数</strong>（函数内嵌函数），可以<strong>避免用到全局变量、或传入冗长的参数</strong>，在 LeetCode 中较为使用，具体用法如下：</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 使用 &amp; 表示捕获全部变量</span><br>	function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; dfs = [&amp;](<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) &#123;<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;; <span class="hljs-comment">// 注意这里必须要有分号</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p></p></li></ul><h3 id="全新特性">全新特性</h3><ul><li>C++ 中最重要的特点就是「<strong>函数传引用调用</strong>」，例如 <code>void swap(int &amp;a, int &amp;b)</code>，不必再传指针调用，更方便快捷。对于字符串、长数组可以<strong>节省大量时间</strong>，且可以直接在函数内修改原参数。<ul><li>不过一旦使用 <code>&amp;</code> 入参就<strong>不能为常量</strong>，如 <code>func(1)</code>。此时只能使用 <code>const auto&amp; a</code> 传参，这样<strong>速度更快</strong>，但是<strong>限制了函数内修改参数</strong>。</li></ul></li><li>C++ 中除了 struct 还有 class，工程中，一般用 struct 定义纯数据的类型，用 class 定义复杂行为的类型，二者最主要的区别是<strong>访问权限和继承方式</strong>不同。但算法竞赛中还是常用 struct 来定义结构体，因为 C++ 的结构体还可以定义<strong>成员函数</strong>、<strong>构造函数</strong>等。<ul><li>拥有构造函数的结构体，可以通过 <code>T *a = new T(10);</code> 调用，得到一个指向结构体的指针，在力扣刷题用。</li><li>此外也可以直接调用 <code>T a(10);</code> 或 <code>T a = T(10);</code> 或 <code>T b = a;</code>，在洛谷刷题比较常用。</li><li>下面给出一个经典的类模板：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 成员变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">6</span>;<br>	<span class="hljs-keyword">int</span> nums[N], param;<br>	<br>    <span class="hljs-comment">// 构造函数</span><br>	<span class="hljs-built_in">MyClass</span>(<span class="hljs-keyword">int</span> param_in) : <span class="hljs-built_in">param</span>(param_in)) &#123;<br>        <span class="hljs-built_in">memset</span>(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(nums));<br>	&#125;<br>	<br>    <span class="hljs-comment">// 成员函数</span><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>		<span class="hljs-comment">// TODO</span><br>	&#125;<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO</span><br>        <span class="hljs-keyword">return</span> res_vec;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/** 使用方法</span><br><span class="hljs-comment"> * MyClass* obj = new MyClass(param_in);</span><br><span class="hljs-comment"> * obj-&gt;func1(num);</span><br><span class="hljs-comment"> * vector&lt;int&gt; res_vec = obj-&gt;func2();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure></li><li>C++ 中可以重载运算符，实现结构体之间的四则运算和输入输出。例如：<ul><li><code>T operator +(const T &amp;A) const&#123; return ...;&#125;</code> 在结构体内重载加法运算；</li><li><code>T operator +(const T &amp;A, const T &amp;B)&#123; return ...;&#125;</code> 在结构体外重载加法运算；</li><li><code>ostream&amp; operator &lt;&lt; (ostream &amp;out, const T&amp; p)&#123; out &lt;&lt; ...; return out;&#125;</code> 在结构体外重载输出流；</li></ul></li><li>C++ 中具有<strong>泛型、模板</strong>的概念，即 <code>template&lt;typename T&gt;</code>，可以实现<strong>函数端口参数的自适应</strong>，如各种类型数组的求和，甚至结构体数组的求和（需要重载加法）。</li></ul><h2 id="python">Python</h2><p>在算法竞赛中，Python 有时会更有优势：高精度运算、字符串处理、记忆化搜索等，因此有必要掌握 Python 的简单技巧。Python 的基础知识可以参考 <a href="https://hwcoder.top/Python-Note-1">Python笔记 #1 基础语法</a>，下面介绍算法竞赛中会用到的内容：</p><ul><li>类的模板</li><li>高精度运算</li><li>常用容器</li><li>常用函数</li><li>记忆化搜索（函数修饰符）</li></ul><h2 id="算法时间复杂度选择">算法时间复杂度选择</h2><p>一般 ACM 或者笔试题的时间限制是 1 秒或 2 秒。在这种情况下，C++ 代码中的操作次数控制在 <span class="math inline">\(10^7 \sim 10^8\)</span> 为最佳。</p><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p><table><thead><tr class="header"><th style="text-align:center">数据范围</th><th style="text-align:center">时间复杂度</th><th style="text-align:center">算法</th></tr></thead><tbody><tr class="odd"><td style="text-align:center"><span class="math inline">\(n \leq 30\)</span></td><td style="text-align:center"><span class="math inline">\(O(n!) \;\; O\left(2^{n}\right)\)</span></td><td style="text-align:center">DFS+剪枝、状态压缩 DP</td></tr><tr class="even"><td style="text-align:center"><span class="math inline">\(n \leq 100\)</span></td><td style="text-align:center"><span class="math inline">\(O\left(n^{3}\right)\)</span></td><td style="text-align:center">Floyd、三维 DP、区间 DP、高斯消元</td></tr><tr class="odd"><td style="text-align:center"><span class="math inline">\(n \leq 1000\)</span></td><td style="text-align:center"><span class="math inline">\(O\left(n^{2}\right) \;\; O\left(n^{2} \log n\right)\)</span></td><td style="text-align:center">DP、二分、朴素版 Dijkstra、朴素版 Prim、Bellman-Ford</td></tr><tr class="even"><td style="text-align:center"><span class="math inline">\(n \leq 10^{4}\)</span></td><td style="text-align:center"><span class="math inline">\(O(n\sqrt{n})\)</span></td><td style="text-align:center">块状链表、分块</td></tr><tr class="odd"><td style="text-align:center"><span class="math inline">\(n \leq 10^{5}\)</span></td><td style="text-align:center"><span class="math inline">\(O(n \log n)\)</span></td><td style="text-align:center">各种 sort、线段树、树状数组、set/map、heap、拓扑排序、Dijkstra+heap、Prim+heap、Kruskal、二分、树链剖分</td></tr><tr class="even"><td style="text-align:center"><span class="math inline">\(n \leq 10^{6}\)</span></td><td style="text-align:center"><span class="math inline">\(O(n)\)</span>，常数较小的 <span class="math inline">\(O(n \log n)\)</span> 算法</td><td style="text-align:center">单调队列、hash、双指针、并查集、KMP<br>常数比较小的 <span class="math inline">\(O(n \log n)\)</span> 做法：sort、树状数组、heap、Dijkstra</td></tr><tr class="odd"><td style="text-align:center"><span class="math inline">\(n \leq 10^{7}\)</span></td><td style="text-align:center"><span class="math inline">\(O(n)\)</span></td><td style="text-align:center">双指针扫描、KMP、差分、前缀和、离散化</td></tr><tr class="even"><td style="text-align:center"><span class="math inline">\(n \leq 10^{9}\)</span></td><td style="text-align:center"><span class="math inline">\(O(\sqrt{n})\)</span></td><td style="text-align:center">判断质数</td></tr><tr class="odd"><td style="text-align:center"><span class="math inline">\(n \leq 10^{18}\)</span></td><td style="text-align:center"><span class="math inline">\(O(\log n)\)</span></td><td style="text-align:center">最大公约数、快速幂</td></tr><tr class="even"><td style="text-align:center"><span class="math inline">\(n \leq 10^{1000}\)</span></td><td style="text-align:center"><span class="math inline">\(O\left((\log n)^{2}\right)\)</span></td><td style="text-align:center">高精度加减乘除</td></tr><tr class="odd"><td style="text-align:center"><span class="math inline">\(n \leq 10^{100000}\)</span></td><td style="text-align:center"><span class="math inline">\(O(\log k \times \log \log k)\)</span>，<span class="math inline">\(k\)</span> 表示位数</td><td style="text-align:center">高精度加减、FFT/NTT</td></tr></tbody></table><h2 id="ide-代码模板">IDE 代码模板</h2><p>ACM 模式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X first</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Y second</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lb(x) ((x) &amp; (-x))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mem(a,b) memset(a,b,sizeof(a))</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> db;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-keyword">int</span>&gt; vi;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pii;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">int</span> n,m,k;<br><span class="hljs-keyword">int</span> dp[maxn][maxn], a[maxn][maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常见错误">常见错误</h2><p>与<strong>取值范围</strong>有关：</p><ol type="1"><li>根据<strong>取值范围</strong>判断类型，注意 <span class="math inline">\(10^5\)</span> 个 <span class="math inline">\(10^5\)</span> 相加有 11 位数会爆 int，要用 <code>long long</code>。</li><li>当题目明确说「对 <span class="math inline">\(1e9 + 7\)</span> 取模」时，一定要用 <code>long long</code>，可以确保一次相乘后还不会溢出，但是<strong>可能溢出的地方</strong>都要尽量取模。</li><li>当题目明确说「保证 XXX 在<strong>不取余</strong>的情况下可以用 <strong>64 位有符号整数</strong>保存」时，此时不仅要开 <code>long long</code>，还不能先取模，因为可能需要 <code>max</code> 操作（<strong>不满足模不变性</strong>），必须在最后返回时才取模。</li><li>如果题目要求取余，则应当<strong>在所有运算之后都取余</strong>。避免最后<strong>减法导致负数</strong>，<strong>加法导致上溢</strong>等不易察觉的错误。</li><li>给 <code>long long</code> 变量赋值（<code>+=</code>）时，<strong>等号右边</strong>也可能溢出，最好先进行转换 <code>1LL *</code>。</li><li><code>nums.size() - 1</code> 不能乱用，因为 <code>.size()</code> 返回 <code>unsigned long</code>，如果 0 - 1 答案不是 -1，而是越界。</li><li>使用 STL 中的 <code>accumulate</code> 时，可能会因为最后一个参数 <code>0</code> 而爆 int，所有 STL 算法都可能<strong>潜在溢出</strong>。</li></ol><p>与<strong>边界条件</strong>有关：</p><ol type="1"><li>使用 stack、queue 等容器时，要注意<strong>容器可能为空</strong>，直接访问元素会报 heap 溢出编译错误。</li><li>使用 <span class="math inline">\(i+1\)</span>、<span class="math inline">\(i-1\)</span> 等方式访问容器 vector 的时候，要注意可能<strong>容器越界</strong>，会报 vector 编译错误。</li><li>DP 初始化 DP 数组时，考虑到初始状态 <code>dp[0]</code>，通常会将数组<strong>扩大一些</strong>，防止越界报错。</li><li>DP <strong>访问历史值</strong>时，如果会跨很长距离，也要注意可能<strong>容器越界</strong>，会报 vector 编译错误。</li><li>for <strong>循环的起始条件</strong>如果是 <span class="math inline">\(x-y\)</span> 的形式，可能会是负数，导致<strong>容器越界</strong>，应该套上 <code>max(0, x - y)</code>。</li><li>在链表操作中，如果代码本身能顺利执行，但是最后依旧报 heap-use-after-free 错误，则说明链表最后出现环，而 LeetCode 框架在执行完代码后释放链表空间时会重复访问已经被释放的节点。</li></ol><p>与<strong>题目的坑</strong>有关：</p><ol type="1"><li>有的坑题故意给排好序的样例，但实际上要<strong>先自己排序</strong>。</li><li>有的题目要统计满足某条件的 XX 个数，还告诉你答案可能很大，但只要题目没说，一定要<strong>特判个数为</strong> <span class="math inline">\(0\)</span> 的情况。</li><li>记得测试 <span class="math inline">\(n\)</span> 等于 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(1\)</span> 等边界情形时，答案是否需要<strong>特判</strong>。</li></ol><p>与<strong>复杂度</strong>有关：</p><ol type="1"><li>当题目出现树结构时（无论是题目给的或是自己用的），都要防止<strong>树退化成链表</strong>，卡复杂度 <span class="math inline">\(O(n^2)\)</span>。</li><li>搜索题如果用到 DFS，要根据参数看是否需要<strong>记忆化</strong>，如果会重复访问同一个状态则需要。</li><li>小技巧：如果力扣周赛平台的<strong>错误用例被隐藏</strong>，大概率是卡最坏复杂度、或整数溢出，数据过多而不显示。</li></ol><p>与<strong>代码实现</strong>有关：</p><ol type="1"><li><code>&amp;&amp;</code> 和 <code>||</code> 运算符有<strong>短路机制</strong>，可能会漏执行后面的条件，而 <code>&amp;</code> 和 <code>|</code> 位运算符则都会执行。</li><li><code>&gt;&gt;</code> 等位运算的<strong>优先级最低</strong>，实现二分等操作时容易出错，建议全加上括号！</li><li>表达式的<strong>运算顺序</strong>可能会关系到是否溢出，如果有大数相乘、相加，尽量先处理缩小运算符。</li></ol></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" class="category-chain-item">算法笔记</a> <span>></span> <a href="/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/" class="category-chain-item">算法入门</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Algorithm/" class="print-no-link">#Algorithm</a></div></div><div class="license-box my-3"><div class="license-title"><div>算法入门笔记 #1 杂记</div><div>https://hwcoder.top/Algo-Note-1</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Wei He</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年8月27日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/Algo-Note-2" title="算法入门笔记 #2 STL标准库"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">算法入门笔记 #2 STL标准库</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/Uplift-Paper-Collection" title="Uplift Recommendation 论文汇总"><span class="hidden-mobile">Uplift Recommendation 论文汇总</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"jdbBr3BddTiqSCPnXw6sXFv7-gzGzoHsz","appKey":"2bjgwDr2opjVCwhgjDMpk53c","path":"window.location.pathname","placeholder":"说点什么吧( •̀ ω •́ )✧","avatar":"retro","meta":["nick","mail","link"],"requiredFields":["nick"],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script>if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-svg-full.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>