<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg"><link rel="icon" href="/img/logo.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#01213a"><meta name="author" content="Wei He"><meta name="keywords" content="Computer Science and Technology, Machine Learning, Deep Learning, Computer Vision, Natural Language Processing"><meta name="description" content="在 LeetCode 等平台上刷题的笔记，循序渐进，一题多解。本文包含「链表」类型题中的：扫描链表、链表模拟等。持续更新中。"><meta property="og:type" content="article"><meta property="og:title" content="力扣刷题笔记 #08 链表"><meta property="og:url" content="https://hwcoder.top/LeetCode-LinkList"><meta property="og:site_name" content="Hwcoder - Life Oriented Programming"><meta property="og:description" content="在 LeetCode 等平台上刷题的笔记，循序渐进，一题多解。本文包含「链表」类型题中的：扫描链表、链表模拟等。持续更新中。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hwcoder.top/img/home/LeetCode.jpg"><meta property="article:published_time" content="2022-10-02T09:07:36.000Z"><meta property="article:modified_time" content="2025-03-11T09:31:45.281Z"><meta property="article:author" content="Wei He"><meta property="article:tag" content="Algorithm"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://hwcoder.top/img/home/LeetCode.jpg"><title>力扣刷题笔记 #08 链表 | Hwcoder - Life Oriented Programming</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/mac.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"hwcoder.top",root:"/",version:"1.9.5",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h2, h3",placement:"left",visible:"always",icon:"§"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4",collapseDepth:3},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"XGNf4GEnaFLiUijMUvz8HSBF-gzGzoHsz",app_key:"JPeVLcug6EcWdBTpGrDJSdKi",server_url:"https://xgnf4gen.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!0}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")})</script><meta name="generator" content="Hexo 5.4.2"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Hwcoder</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/bg/other.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="力扣刷题笔记 #08 链表"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-10-02 17:07" pubdate>2022年10月2日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 5.7k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 32 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="算法笔记" id="heading-6caacb5aaee15525d7a2b4768aa79852" role="tab" data-toggle="collapse" href="#collapse-6caacb5aaee15525d7a2b4768aa79852" aria-expanded="true">算法笔记 <span class="list-group-count">(23)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-6caacb5aaee15525d7a2b4768aa79852" role="tabpanel" aria-labelledby="heading-6caacb5aaee15525d7a2b4768aa79852"><div class="category-post-list"></div><div class="category-sub row nomargin-x"><a class="category-subitem list-group-item category-item-action col-10 col-md-11 col-xm-11" title="力扣刷题" id="heading-9ca088cdf0fdc34dd48290c9d13c88b1" role="tab" data-toggle="collapse" href="#collapse-9ca088cdf0fdc34dd48290c9d13c88b1" aria-expanded="true">力扣刷题 <span class="list-group-count">(15)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-9ca088cdf0fdc34dd48290c9d13c88b1" role="tabpanel" aria-labelledby="heading-9ca088cdf0fdc34dd48290c9d13c88b1"><div class="category-post-list"><a href="/LeetCode-Array" title="力扣刷题笔记 #01 数组" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #01 数组</span> </a><a href="/LeetCode-Bitwise" title="力扣刷题笔记 #02 数位&amp;二进制" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #02 数位&amp;二进制</span> </a><a href="/LeetCode-Data-Structure" title="力扣刷题笔记 #03 数据结构" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #03 数据结构</span> </a><a href="/LeetCode-Divide-Conquer" title="力扣刷题笔记 #04 二分&amp;分治" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #04 二分&amp;分治</span> </a><a href="/LeetCode-DP-1" title="力扣刷题笔记 #05-1 一维动态规划" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #05-1 一维动态规划</span> </a><a href="/LeetCode-DP-2" title="力扣刷题笔记 #05-2 二维动态规划" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #05-2 二维动态规划</span> </a><a href="/LeetCode-DP-3" title="力扣刷题笔记 #05-3 复杂动态规划" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #05-3 复杂动态规划</span> </a><a href="/LeetCode-Graph" title="力扣刷题笔记 #06 图论" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #06 图论</span> </a><a href="/LeetCode-Greedy" title="力扣刷题笔记 #07 贪心算法" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #07 贪心算法</span> </a><a href="/LeetCode-LinkList" title="力扣刷题笔记 #08 链表" class="list-group-item list-group-item-action active"><span class="category-post">力扣刷题笔记 #08 链表</span> </a><a href="/LeetCode-Math" title="力扣刷题笔记 #09 数学" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #09 数学</span> </a><a href="/LeetCode-Search" title="力扣刷题笔记 #10 搜索&amp;剪枝" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #10 搜索&amp;剪枝</span> </a><a href="/LeetCode-Stack-Queue" title="力扣刷题笔记 #11 栈&amp;队列" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #11 栈&amp;队列</span> </a><a href="/LeetCode-String" title="力扣刷题笔记 #12 字符串" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #12 字符串</span> </a><a href="/LeetCode-Tree" title="力扣刷题笔记 #13 树" class="list-group-item list-group-item-action"><span class="category-post">力扣刷题笔记 #13 树</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="手撕经典算法" id="heading-67ebbc1a1af276ea349725e619870fea" role="tab" data-toggle="collapse" href="#collapse-67ebbc1a1af276ea349725e619870fea" aria-expanded="false">手撕经典算法 <span class="list-group-count">(6)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-67ebbc1a1af276ea349725e619870fea" role="tabpanel" aria-labelledby="heading-67ebbc1a1af276ea349725e619870fea"><div class="category-post-list"><a href="/Manual-Coding-1" title="手撕经典算法 #1 Attention篇" class="list-group-item list-group-item-action"><span class="category-post">手撕经典算法 #1 Attention篇</span> </a><a href="/Manual-Coding-2" title="手撕经典算法 #2 神经网络篇" class="list-group-item list-group-item-action"><span class="category-post">手撕经典算法 #2 神经网络篇</span> </a><a href="/Manual-Coding-3" title="手撕经典算法 #3 Transformer篇" class="list-group-item list-group-item-action"><span class="category-post">手撕经典算法 #3 Transformer篇</span> </a><a href="/Manual-Coding-4" title="手撕经典算法 #4 经典函数篇" class="list-group-item list-group-item-action"><span class="category-post">手撕经典算法 #4 经典函数篇</span> </a><a href="/Manual-Coding-5" title="手撕经典算法 #5 机器学习篇" class="list-group-item list-group-item-action"><span class="category-post">手撕经典算法 #5 机器学习篇</span> </a><a href="/Manual-Coding-6" title="手撕经典算法 #6 RLHF篇" class="list-group-item list-group-item-action"><span class="category-post">手撕经典算法 #6 RLHF篇</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="算法入门" id="heading-cbb23c60a3cdd7188054b6ba4efbf423" role="tab" data-toggle="collapse" href="#collapse-cbb23c60a3cdd7188054b6ba4efbf423" aria-expanded="false">算法入门 <span class="list-group-count">(2)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-cbb23c60a3cdd7188054b6ba4efbf423" role="tabpanel" aria-labelledby="heading-cbb23c60a3cdd7188054b6ba4efbf423"><div class="category-post-list"><a href="/Algo-Note-1" title="算法入门笔记 #1 杂记" class="list-group-item list-group-item-action"><span class="category-post">算法入门笔记 #1 杂记</span> </a><a href="/Algo-Note-2" title="算法入门笔记 #2 STL标准库" class="list-group-item list-group-item-action"><span class="category-post">算法入门笔记 #2 STL标准库</span></a></div></div></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">力扣刷题笔记 #08 链表</h1><p class="note note-info">本文最后更新于：2025年3月11日 下午</p><div class="markdown-body"><p>本文包含「链表」类型题中的：扫描链表、链表模拟等。持续更新中。</p><blockquote><p><a href="">题目描述</a>：</p><p><strong>方法1</strong>：</p><p><strong>方法2</strong>：</p><p><strong>方法3</strong>：</p><p><strong>坑点</strong>：</p></blockquote><h2 id="扫描链表">扫描链表</h2><p>链表的特点是只能<strong>正向遍历</strong>，通常由<strong>指针</strong>来扫描，个别题目可以用<strong>递归法</strong>解决（逆向思维）。</p><blockquote><p><strong>小技巧</strong>：链表问题通常没有空间复杂度的限制，因为其本身的存储也需要 <span class="math inline">\(O(n)\)</span>，因此面试题通常要求「<strong>原地操作</strong>」。如果只追求解题，完全可以将链表 <span class="math inline">\(O(n)\)</span> 转为数组后再操作，最后再 <span class="math inline">\(O(n)\)</span> 转回链表。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    ListNode *next;<br>    <span class="hljs-built_in">ListNode</span>() : <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-keyword">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-keyword">int</span> x, ListNode *next) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(next) &#123;&#125; <br>&#125;;<br><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">to_vector</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; ret;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = head; it; it = it-&gt;next)<br>        ret.<span class="hljs-built_in">push_back</span>(it-&gt;val);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function">ListNode *<span class="hljs-title">to_list</span><span class="hljs-params">(<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (v.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    ListNode *ret = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(v[<span class="hljs-number">0</span>]);<br>    ListNode *it = ret;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; v.<span class="hljs-built_in">size</span>(); ++ i)&#123;<br>        it-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(v[i]);<br>        it = it-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两数相加-e">2. 两数相加 (E)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers/">题目描述</a>：两个非空链表，每个结点代表十进制的一位（表头代表最低位），将其相加，并以相同形式返回一个新链表。</p><p><strong>方法</strong>：直接遍历两个链表，存储进位，复杂度 <span class="math inline">\(O(n)\)</span>。</p><p><strong>坑点</strong>：并不是两个链表都遍历完就结束，还要考虑最后的<strong>进位</strong>。</p><h3 id="回文链表-e">234. 回文链表 (E)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/">题目描述</a>：给定一个链表，判断链表节点的值是否构成回文序列。</p><p><strong>方法1</strong>：暴力，将链表转为数组，再用对撞双指针遍历，时空复杂度均为 <span class="math inline">\(O(n)\)</span>。</p><p><strong>方法2</strong>：栈，第一次遍历链表将元素<strong>压入栈</strong>中，第二次遍历时逐个<strong>弹出匹配</strong>，可以实现逆向遍历。同理，也可以用递<strong>归反向迭代</strong>，同时用递归<strong>函数外的变量正向迭代</strong>，原理相同。时空复杂度均为 <span class="math inline">\(O(n)\)</span>。</p><p><strong>方法3</strong>：修改原链表，使用快慢指针获得链表中点后，将<strong>后半部分反转</strong>，再用双指针进行配对。空间复杂度 <span class="math inline">\(O(1)\)</span>。</p><p><strong>方法4</strong>：字符串哈希，将链表当成数字字符串，计算<strong>正向哈希值和反向哈希值</strong>，如果两个值相等则可以认为构成回文。无需修改原链表，时间复杂度 <span class="math inline">\(O(n)\)</span>，空间复杂度 <span class="math inline">\(O(1)\)</span>。</p><blockquote><p>正向值和反向值可以一次遍历算出，二者的方法不一样。需要定义 <span class="math inline">\(base\)</span>，<span class="math inline">\(mod\)</span>，以及递增的<strong>乘子</strong> <span class="math inline">\(mul\)</span>。</p><ul><li>正向哈希值：<span class="math inline">\(pos=(pos*base+val)\% mod\)</span></li><li>反向哈希值：<span class="math inline">\(neg=(neg+mul*val)\%mod\)</span>，<span class="math inline">\(mul=mul*base \% mod\)</span></li></ul></blockquote><h3 id="合并两个有序链表-e">21. 合并两个有序链表 (E)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">题目描述</a>：将两个升序链表合并为一个新的<strong>升序</strong>链表并返回。</p><p><strong>方法1</strong>：正向扫描，当两个链表都不为空时取较小者；当<strong>一个为空</strong>时，将<strong>链表末尾指向另一个</strong>即可。在实现时可以用一个虚拟 head 作为头，复杂度 <span class="math inline">\(O(n+m)\)</span>。</p><p><strong>方法2</strong>：递归，边界条件是一个为空时，返回另一个。都不为空时，取出较小者，指向「<strong>剩下的两条链表递归合并的结果</strong>」，并返回较小者所在的链表头。</p><h3 id="合并-k-个升序链表-h">23. 合并 k 个升序链表 (H)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/">题目描述</a>：一个链表数组，里面有 <span class="math inline">\(k\)</span> 个长为 <span class="math inline">\(n\)</span> 的链表，每个链表都按升序排列，将所有链表合并成一个升序链表。</p><p><strong>方法1</strong>：顺序合并，每次合并的复杂度是两个链表长度之和，第一次是 <span class="math inline">\(2n\)</span>，第二次是 <span class="math inline">\(3n\)</span>，以此类推到 <span class="math inline">\(k-1\)</span> 次，累加得到总复杂度为 <span class="math inline">\(O(k^2 n)\)</span>，空间复杂度 <span class="math inline">\(O(1)\)</span>。</p><p><strong>方法2</strong>：<strong>优先队列</strong>，维护每个链表未被合并的<strong>首个元素</strong>，每次取出最小者，再将其下一个元素放入队列。时间复杂度 <span class="math inline">\(O(kn\log k)\)</span>，维护队列需要 <span class="math inline">\(O(k)\)</span> 的空间。</p><p><strong>方法3</strong>：分治归并，将长度相等的链表<strong>两两归并</strong>，第一轮 <span class="math inline">\(k\)</span> 个链表合并为 <span class="math inline">\(k/2\)</span> 个，总长度 <span class="math inline">\(kn\)</span>；第二轮合并为 <span class="math inline">\(k/4\)</span> 个，总长度还是 <span class="math inline">\(kn\)</span>，以此类推到 <span class="math inline">\(\log k\)</span> 次，时间复杂度 <span class="math inline">\(O(kn\log k)\)</span>，递归需要 <span class="math inline">\(O(\log k)\)</span> 的栈空间。</p><h3 id="反转链表-e">206. 反转链表 (E)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">题目描述</a>：给定单链表的头节点 <code>head</code>（有值），返回<strong>原地反转</strong>后的链表（不能使用新链表、临时栈）。</p><p><strong>方法1</strong>：迭代（三指针），<code>prev</code> 指向 〇，<code>curr</code> 指向 ①，<code>temp</code> 指向 ②。每次将 ①-&gt;② 反转，再依次前移 <code>prev</code> 和 <code>curr</code>，结束条件为 <code>curr</code> 指向空。复杂度 <span class="math inline">\(O(n)\)</span>。</p><p><strong>方法2</strong>：头插法，虚拟一个<strong>哑结点</strong>（Dummy Node）指向第一个节点，每次将下一个点插到哑结点之后，复杂度 <span class="math inline">\(O(n)\)</span>。</p><p><strong>方法3</strong>：递归，边界条件是<strong>单结点</strong>时，无需反转。子问题是「<code>head</code> 后面所有结点已经反转，只需再反转 <code>head</code> 和 <code>head-&gt;next</code> 中间的指针，并将 <code>head</code> 指向空」。复杂度 <span class="math inline">\(O(n)\)</span>，只用到了单指针。</p><h3 id="反转链表-ii-m">92. 反转链表 II (M)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/">题目描述</a>：给定单链表的头节点 <code>head</code>（有值）和两个整数 <code>left</code> 和 <code>right</code>，反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点。</p><p><strong>方法1</strong>：头插法，在上一题的基础上，除了 <code>dummy</code> 节点，还需要用四个指针分别指向 <code>left</code> 及其前序节点、<code>right</code> 及其后继节点。复杂度 <span class="math inline">\(O(n)\)</span>。</p><p><strong>坑点</strong>：当 <code>left</code> 取 <span class="math inline">\(1\)</span> 的时候，前序节点就是 <code>dummy</code>。此外，如果使用头插法，本题还可能导致 <code>left</code> 节点自身成环（在 <code>cur-&gt;next = pre-&gt;next;</code> 操作时，不像上一题那样会指向 nullptr），这会导致 heap-use-after-free 错误，需要注意在最后将其指向 <code>right</code> 的后继节点。</p><h3 id="k-个一组翻转链表-h">25. K 个一组翻转链表 (H)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">题目描述</a>：给定单链表的头节点 <code>head</code>（有值），每 K 个节点一组<strong>原地反转</strong>，不足 K 个<strong>不反转</strong>。</p><p><strong>方法1</strong>：两次遍历，第一次遍历计数链表长度 <span class="math inline">\(Len\)</span>，第二次遍历翻转 <span class="math inline">\(Len/K\)</span> 次子链表，时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><p><strong>方法2</strong>：递归，边界条件是不足 K 个时，无需反转。通过循环找到第 <span class="math inline">\(K\)</span> 个节点 <code>tail</code>，子问题是「<code>tail</code> 后面所有结点已经反转，只需再反转 <code>head</code> 到 <code>tail-&gt;next</code> 的指针，并将 <code>head</code> 指向 <code>tail</code>」。复杂度 <span class="math inline">\(O(n)\)</span>。</p><p><strong>坑点</strong>：注意<strong>子问题处理完</strong>后 <code>head</code> 会变成第 <span class="math inline">\(K\)</span> 个节点，<strong>不能直接返回</strong>。</p><h2 id="双指针定位">双指针定位</h2><h3 id="删除链表的倒数第-n-个结点-m">19. 删除链表的倒数第 N 个结点 (M)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">题目描述</a>：一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>方法1</strong>：强行计算链表长度，至少需要遍历两次。</p><p><strong>方法2</strong>：借助栈，将所有结点依次入栈再弹出，第 <code>n</code> 个弹出的结点就是要删除的结点，此时栈顶结点就是其前驱结点。</p><p><strong>方法3</strong>：<strong>快慢指针</strong>，快指针先走 <code>n</code> 步，随后快慢指针同步前进。遍历一次且空间复杂度 <span class="math inline">\(O(1)\)</span>。</p><p><strong>坑点</strong>：链表的倒数第 <code>n</code> 个结点可能就是头结点，此时快指针已经指向 nullptr，慢指针是不需要继续前进的，直接返回 <code>head-&gt;next</code> 即可。</p><p><strong>拓展</strong>：如果要删除链表<strong>正中间结点</strong>，只需用步长为 2 的快指针和步长为 1 的慢指针遍历即可。</p><h3 id="环形链表-e">141. 环形链表 (E)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">题目描述</a>：给一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p><strong>方法1</strong>：哈希集合，将便利到的结点的指针存储到集合中，每次先 <code>count</code> 判断。时空复杂度均 <span class="math inline">\(O(n)\)</span>。</p><p><strong>方法2</strong>：<strong>快慢指针</strong>，用步长为 2 的快指针和步长为 1 的慢指针遍历，如果两指针相遇，则一定有环。空间复杂度 <span class="math inline">\(O(1)\)</span>。</p><p><strong>坑点</strong>：快慢指针的初值不应该都设置为 <code>head</code>，否则可能会直接退出循环，可以将快指针设为 <code>head-&gt;next</code>，或者直接先让两个指针各前进一步再判断。</p><p><strong>扩展</strong>：如何统计环的长度？快慢指针<strong>相遇后继续移动</strong>，直到第二次相遇。<strong>两次相遇间的移动次数</strong>即为环的长度。</p><h3 id="环形链表-ii-m">142. 环形链表 II (M)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">题目描述</a>：给一个链表的头节点 <code>head</code> ，返回链表<strong>环的入口</strong>（开始入环的第一个节点）。</p><p><strong>方法1</strong>：哈希集合，同上题，当 <code>count()!=0</code> 时即找到入口，返回即可。时空复杂度均 <span class="math inline">\(O(n)\)</span>。</p><p><strong>方法2</strong>：快慢指针，用步长为 2 的 <span class="math inline">\(fast\)</span> 和步长为 1 的 <span class="math inline">\(slow\)</span> 遍历，两指针相遇后，用一个步长为 1 的 <span class="math inline">\(pos\)</span> 从 <code>head</code> 出发，且 <span class="math inline">\(slow\)</span> 继续以步长 1 前进。当 <span class="math inline">\(slow\)</span> 和 <span class="math inline">\(pos\)</span> 第一次相遇时，相遇处即为环的入口。空间复杂度 <span class="math inline">\(O(1)\)</span>。</p><blockquote><p>快慢指针第一次相遇时，设慢指针路程 <span class="math inline">\(s\)</span>，快指针路程 <span class="math inline">\(f=2s\)</span>，环的长度为 <span class="math inline">\(r\)</span>。显然 <span class="math inline">\(f=s+nr\)</span>，<span class="math inline">\(n\)</span> 为套圈数。联立两式可知 <span class="math inline">\(s=nr\)</span>。</p><p>记 <code>head</code> 到环的入口需要走的路程为 <span class="math inline">\(p\)</span>，显然 <span class="math inline">\(p+nr\)</span> 也是环的入口，所以 <span class="math inline">\(p+s\)</span> 也是环的入口。令一个定位指针从 <code>head</code> 出发走 <span class="math inline">\(p\)</span>，同时慢指针继续走 <span class="math inline">\(p\)</span>，二者就会在环的入口相遇。</p></blockquote><h3 id="寻找重复数-m">287. 寻找重复数 (M)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-duplicate-number/">题目描述</a>：给定一个包含 <span class="math inline">\(n + 1\)</span> 个整数的数组，其数字都在 <span class="math inline">\([1, n]\)</span> 范围内，假设数组中<strong>有且仅有一个重复的整数</strong>，找出数组中重复的数字，要求空间复杂度 <span class="math inline">\(O(1)\)</span>。</p><p><strong>方法1</strong>：二分答案，定义 <span class="math inline">\(cnt[i]\)</span> 表示数组中<strong>小于等于</strong> <span class="math inline">\(i\)</span> 的数的个数，假设重复数是 <span class="math inline">\(x\)</span>，则 <span class="math inline">\([1,x-1]\)</span> 里所有数都满足 <span class="math inline">\(cnt[i] \leq i\)</span>；而 <span class="math inline">\([x,n]\)</span> 里的所有数满足 <span class="math inline">\(cnt[i]&gt;i\)</span>。因此可以二分枚举 <span class="math inline">\(x\)</span> 直到找到。时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><p><strong>方法2</strong>：二进制，预处理 <span class="math inline">\([1,n]\)</span> 这 <span class="math inline">\(n\)</span> 个数「<strong>每一位</strong>为 <span class="math inline">\(1\)</span> 的<strong>个数之和</strong>」，如果当前数组的「<strong>每一位</strong>为 <span class="math inline">\(1\)</span> 的<strong>个数之和</strong>」大于期望值，则说明<strong>重复数的这一位</strong>为 <span class="math inline">\(1\)</span>。遍历每一位即可，时间复杂度 <span class="math inline">\(O(n \log n)\)</span>。</p><p><strong>方法3</strong>：抽象成环形链表寻找入口，快慢指针，先用 <span class="math inline">\(fast\)</span> 和 <span class="math inline">\(slow\)</span> 相遇，再用 <span class="math inline">\(pos\)</span> 和 <span class="math inline">\(slow\)</span> 相遇，时间复杂度 <span class="math inline">\(O(n)\)</span>。</p><blockquote><p>将数组和下标抽象为链表，数组的值代表链表下一个节点的下标。由于不存在数字 0，可下标为 0 的元素作为<strong>链表头节点</strong>。由于数组中存在重复数字，对应链表中有多个指针指向同一个顶点，则链表中<strong>必有环</strong>。找出重复数等价于找出链表<strong>环的入口</strong>。</p></blockquote><h3 id="相交链表-e">160. 相交链表 (E)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">题目描述</a>：给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code>，请你找出并返回两个单链表相交的<strong>起始节点</strong>。</p><p><strong>方法1</strong>：哈希集合，遍历 <code>headA</code> 并将每个节点加入集合，然后遍历 <code>headB</code>，对每个结点检查是否在集合中。时间复杂度为 <span class="math inline">\(O(m+n)\)</span>，空间复杂度为 <span class="math inline">\(O(m)\)</span>。</p><p><strong>方法2</strong>：暴力，<strong>消除两个链表的长度差</strong>，遍历两个链表并计数得到长度，长的先走几步，然后一起走并判断两指针是否相等。时间复杂度为 <span class="math inline">\(O(m+n)\)</span>，空间复杂度 <span class="math inline">\(O(1)\)</span>。</p><p><strong>方法3</strong>：双指针，<strong>消除两个链表的长度差</strong>，将两个链表拼接到一起就是等长。具体实现：当指针遍历完一个链表时，<strong>再次指向另一个链表</strong>的头节点继续遍历。时间复杂度 <span class="math inline">\(O(m+n)\)</span>，空间复杂度 <span class="math inline">\(O(1)\)</span>。</p><h2 id="链表模拟">链表模拟</h2><h3 id="todo-707.-设计链表">Todo 707. 设计链表</h3><h3 id="lru-缓存-m">146. LRU 缓存 (M)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/">题目描述</a>：设计一个 <code>LRUCache</code> 类，实现以下功能：</p><ul><li><code>LRUCache(int capacity)</code>：以<strong>正整数</strong>作为容量 <code>capacity</code> 初始化 LRU 缓存；</li><li><code>int get(int key)</code>：如果 <code>key</code> 存在于缓存中，则返回其值，否则返回 <code>-1</code>，要求 <span class="math inline">\(O(1)\)</span>；</li><li><code>void put(int key, int value)</code>：如果 <code>key</code> 存在，则变更其值为 <code>value</code>；如果不存在，则向缓存中插入键值对。如果插入操作导致数量溢出 ，则应该<strong>逐出</strong>最久未使用（LRU）的关键字，要求 <span class="math inline">\(O(1)\)</span>。</li></ul><p><strong>方法</strong>：双向链表 + 哈希表。链表用来存放<strong>关键字序列</strong>，首部表示 MRU，尾部表示 LRU，<code>put</code> 关键字默认放在首部，<code>get</code> 关键字默认移到首部，溢出时首先移除尾部。时间复杂度 <span class="math inline">\(O(1)\)</span>。</p><blockquote><p>使用两个哈希表存储<strong>关键字到链表节点</strong>、<strong>关键字到值</strong>的映射：前者用来 <span class="math inline">\(O(1)\)</span> 找到关键字在链表中的位置，方便移动；后者用来存值，也可以省略并在链表中存 pair。</p><p>使用双向链表的原因：<code>get</code> 或 <code>put</code> 需要将已有关键字移到首部，从链表中间删除一个节点需要<strong>知道其前序节点的指针</strong>，双向链表可以 <span class="math inline">\(O(1)\)</span> 获取。</p><p>注意：移除尾部时<strong>并非</strong>利用了双向链表的特性，维护一个 <span class="math inline">\(tail\)</span> 指针同样可以 <span class="math inline">\(O(1)\)</span> 移除尾部。</p></blockquote><h3 id="lfu-缓存-h">460. LFU 缓存 (H)</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lfu-cache/">题目描述</a>：设计一个 <code>LFUCache</code> 类，实现以下功能：</p><ul><li><code>LFUCache(int capacity)</code> 和 <code>int get(int key)</code> 同上；</li><li><code>void put(int key, int value)</code>：如果插入操作导致数量溢出 ，则应该<strong>逐出</strong>最不经常使用（LFU）的关键字。当存在<strong>平局</strong>（即两个或更多个键具有相同使用频率）时，应该去除<strong>最近最久未使用</strong>的键。</li></ul><p><strong>方法1</strong>：哈希表 + 集合。用集合存储 <span class="math inline">\(Node\)</span> 结构体，<span class="math inline">\(Node\)</span> 中包含键值对和<strong>使用频率、最近使用时间</strong>，并且<strong>自定义结构体比较函数</strong>。每次更新需要把元素从 set 取出、修改、再重新插入，时间复杂度 <span class="math inline">\(O(\log n)\)</span>。</p><p><strong>方法2</strong>：十字链表 + 双哈希表。一个哈希表用<strong>频率为索引</strong>， 每个索引存放一个双向链表；另一个哈希表以<strong>关键字为索引</strong>，存放链表节点的指针。维护一个 <span class="math inline">\(minFreq\)</span>，每次删除操作直接从对应的链表中删，时间复杂度 <span class="math inline">\(O(1)\)</span>。</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" class="category-chain-item">算法笔记</a> <span>></span> <a href="/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/" class="category-chain-item">力扣刷题</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Algorithm/" class="print-no-link">#Algorithm</a></div></div><div class="license-box my-3"><div class="license-title"><div>力扣刷题笔记 #08 链表</div><div>https://hwcoder.top/LeetCode-LinkList</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Wei He</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年10月2日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/LeetCode-Math" title="力扣刷题笔记 #09 数学"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">力扣刷题笔记 #09 数学</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/LeetCode-Greedy" title="力扣刷题笔记 #07 贪心算法"><span class="hidden-mobile">力扣刷题笔记 #07 贪心算法</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"jdbBr3BddTiqSCPnXw6sXFv7-gzGzoHsz","appKey":"2bjgwDr2opjVCwhgjDMpk53c","path":"window.location.pathname","placeholder":"说点什么吧( •̀ ω •́ )✧","avatar":"retro","meta":["nick","mail","link"],"requiredFields":["nick"],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script>if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-svg-full.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>